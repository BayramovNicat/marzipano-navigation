(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Marzipano = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)(o|0)s/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr\/|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/Whale/i.test(ua)) {
      result = {
        name: 'NAVER Whale browser'
        , whale: t
        , version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/MZBrowser/i.test(ua)) {
      result = {
        name: 'MZ Browser'
        , mzbrowser: t
        , version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/focus/i.test(ua)) {
      result = {
        name: 'Focus'
        , focus: t
        , version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , osname: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , osname: 'Chrome OS'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/edg([ea]|ios)/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , osname: 'Sailfish OS'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
        result.osname = 'Firefox OS'
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , osname: 'BlackBerry OS'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , osname: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , osname: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , osname: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && (android || result.silk)) {
      result.android = t
      result.osname = 'Android'
    } else if (!result.windowsphone && iosdevice) {
      result[iosdevice] = t
      result.ios = t
      result.osname = 'iOS'
    } else if (mac) {
      result.mac = t
      result.osname = 'macOS'
    } else if (xbox) {
      result.xbox = t
      result.osname = 'Xbox'
    } else if (windows) {
      result.windows = t
      result.osname = 'Windows'
    } else if (linux) {
      result.linux = t
      result.osname = 'Linux'
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }

    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.whale && compareVersions([result.version, '1.0']) === 1) ||
        (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||
        (result.focus && compareVersions([result.version, '1.0']) === 1) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  /*
   * Set our detect public method to the main bowser object
   * This is needed to implement bowser in server side
   */
  bowser.detect = detect;
  return bowser
});

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],3:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

exports.glMatrix = glMatrix;

var mat2 = _interopRequireWildcard(require("./mat2.js"));

exports.mat2 = mat2;

var mat2d = _interopRequireWildcard(require("./mat2d.js"));

exports.mat2d = mat2d;

var mat3 = _interopRequireWildcard(require("./mat3.js"));

exports.mat3 = mat3;

var mat4 = _interopRequireWildcard(require("./mat4.js"));

exports.mat4 = mat4;

var quat = _interopRequireWildcard(require("./quat.js"));

exports.quat = quat;

var quat2 = _interopRequireWildcard(require("./quat2.js"));

exports.quat2 = quat2;

var vec2 = _interopRequireWildcard(require("./vec2.js"));

exports.vec2 = vec2;

var vec3 = _interopRequireWildcard(require("./vec3.js"));

exports.vec3 = vec3;

var vec4 = _interopRequireWildcard(require("./vec4.js"));

exports.vec4 = vec4;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./common.js":2,"./mat2.js":4,"./mat2d.js":5,"./mat3.js":6,"./mat4.js":7,"./quat.js":8,"./quat2.js":9,"./vec2.js":10,"./vec3.js":11,"./vec4.js":12}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */


function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */


function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */


function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],5:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */


function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */


function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/


function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],6:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],7:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],8:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.getAngle = getAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.exp = exp;
exports.ln = ln;
exports.pow = pow;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":2,"./mat3.js":6,"./vec3.js":11,"./vec4.js":12}],9:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromMat4 = fromMat4;
exports.copy = copy;
exports.identity = identity;
exports.set = set;
exports.getDual = getDual;
exports.setDual = setDual;
exports.getTranslation = getTranslation;
exports.translate = translate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateAroundAxis = rotateAroundAxis;
exports.add = add;
exports.multiply = multiply;
exports.scale = scale;
exports.lerp = lerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.normalize = normalize;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var quat = _interopRequireWildcard(require("./quat.js"));

var mat4 = _interopRequireWildcard(require("./mat4.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */


function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */


function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */


function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */


var getReal = quat.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

exports.getReal = getReal;

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */


var setReal = quat.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

exports.setReal = setReal;

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */


function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */


function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */


function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */


function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */


function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */


function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

exports.mul = mul;

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */


var dot = quat.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

exports.dot = dot;

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */


function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */


var length = quat.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = quat.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

exports.sqrLen = sqrLen;

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */


function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}
},{"./common.js":2,"./mat4.js":7,"./quat.js":8}],10:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],11:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],12:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],13:[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @class
 * @classdesc Minimalistic event emitter mixin.
 */
function EventEmitter() {}

/**
 * Registers an event listener for the specified event. If the listener has
 * already been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.addEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name] = eventMap[name] || [];
  if (handlerList.indexOf(fn) < 0) {
    handlerList.push(fn);
  }
};

/**
 * Unregisters an event listener from the specified event. If the listener
 * hasn't been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.removeEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  if (handlerList) {
    var index = handlerList.indexOf(fn);
    if (index >= 0) {
      handlerList.splice(index, 1);
    }
  }
};

/**
 * Emits an event, causing all registered event listeners for that event to be
 * called in registration order.
 *
 * @param {string} name The event name.
 * @param {...*} var_args Arguments to call listeners with.
 */
EventEmitter.prototype.emit = function(name, var_args) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  var args = Array.prototype.slice.call(arguments, 1);
  if (handlerList) {
    for (var i = 0; i < handlerList.length; i++) {
      var fn = handlerList[i];
      fn.apply(this, args);
    }
  }
};

/**
 * Mixes in {@link EventEmitter} into a constructor function.
 *
 * @param {function} ctor The constructor function.
 */
function eventEmitter(ctor) {
  for (var prop in EventEmitter.prototype) {
    if (EventEmitter.prototype.hasOwnProperty(prop)) {
      ctor.prototype[prop] = EventEmitter.prototype[prop];
    }
  }
}

module.exports = eventEmitter;

},{}],15:[function(require,module,exports){
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * @class DepthmapStore
 * @classdesc
 *
 * A DepthmapStore maintains a cache of depthmap data used to render a {@link Layer}.
 *
 * Multiple layers belonging to the same underlying {@link WebGlStage} may
 * share the same DepthmapStore. Layers belonging to distinct {@link WebGlStage}
 * instances may not do so due to restrictions on the use of textures across
 * stages.
 *
 * @param {string} source The underlying source url.
 * @param {Stage} stage The underlying stage.
 * @param {Object} opts Options.
 */
function DepthmapStore(source, stage, opts) {

  var self = this;

  opts = opts || {};

  self._source = source;
  self._stage = stage;

  self._asset = null;
  self._texture = null;

  // TODO Other types of depthmap.
  stage.loadImage(source, null, function (err, asset) {
    
    // TODO error.
    if (err) {
      return;
    }

    stage.createTexture(null, asset, function (err, _tile, asset, texture) {

      // TODO error.
      if (err) {
        return;
      }

      self._asset = asset;
      self._texture = texture;
    });
  });
}

eventEmitter(DepthmapStore);


/**
 * Destructor.
 */
DepthmapStore.prototype.destroy = function () {

  var asset = this._asset;
  var texture = this._texture;

  // Destroy asset.
  if (asset) {
    asset.destroy();
  }

  // Destroy texture.
  if (texture) {
    texture.destroy();
  }

  clearOwnProperties(this);
};


/**
 * Return the underlying {@link Stage}.
 * @return {Stage}
 */
DepthmapStore.prototype.stage = function () {
  return this._stage;
};


/**
 * Return the underlying source.
 * @return {string}
 */
DepthmapStore.prototype.source = function () {
  return this._source;
};


/**
 * Return the depthmap texture {@link Source}.
 * @return {WTexture}
 */
DepthmapStore.prototype.asset = function () {
  return this._asset;
};


/**
 * Return the depthmap texture {@link WebGlTexture}.
 * @return {WebGlTexture}
 */
DepthmapStore.prototype.texture = function () {
  return this._texture;
};


module.exports = DepthmapStore;

},{"./util/clearOwnProperties":80,"minimal-event-emitter":14}],16:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var positionAbsolutely = require('./util/positionAbsolutely');
var setTransform = require('./util/dom').setTransform;
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * @class Hotspot
 * @classdesc
 *
 * A Hotspot allows a DOM element to be placed at a fixed position in the
 * image. The position is updated automatically when the {@link View view}
 * changes.
 *
 * Positioning is performed with the `transform` CSS property when available,
 * falling back to the `position`, `left` and `top` properties when not.
 * In both cases, the top left corner of the element is placed in the requested
 * position; clients are expected to use additional children elements or other
 * CSS properties to achieve more sophisticated layouts.
 *
 * There are two kinds of hotspots: regular and embedded. A regular hotspot
 * does not change size depending on the zoom level. An embedded hotspot is
 * displayed at a fixed size relative to the panorama, always covering the
 * same portion of the image.
 *
 * Clients should call {@link HotspotContainer#createHotspot} instead of
 * invoking the constructor directly.
 *
 * @param {Element} domElement The DOM element.
 * @param {View} view The view.
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords} for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Additional options.
 * @param {Object} opts.perspective Perspective options for embedded hotspots.
 * @param {number} [opts.perspective.radius=null] If set, embed the hotspot
 *     into the image by transforming it into the surface of a sphere with this
 *     radius.
 * @param {string} [opts.perspective.extraTransforms=null] If set, append this
 *     value to the CSS `transform` property used to position the hotspot. This
 *     may be used to rotate an embedded hotspot.
 */
function Hotspot(domElement, parentDomElement, view, coords, opts) {

  opts = opts || {};
  opts.perspective = opts.perspective || {};
  opts.perspective.extraTransforms =
      opts.perspective.extraTransforms != null ? opts.perspective.extraTransforms : "";

  this._domElement = domElement;
  this._parentDomElement = parentDomElement;
  this._view = view;
  this._coords = {};
  this._perspective = {};

  this.setPosition(coords);

  // Add hotspot into the DOM.
  this._parentDomElement.appendChild(this._domElement);

  this.setPerspective(opts.perspective);

  // Whether the hotspot is visible.
  // The hotspot may still be hidden if it's inside a hidden HotspotContainer.
  this._visible = true;

  // The current calculated screen position.
  this._position = { x: 0, y: 0 };
}

eventEmitter(Hotspot);


/**
 * Destructor.
 * Clients should call {@link HotspotContainer#destroyHotspot} instead.
 */
Hotspot.prototype.destroy = function() {
  this._parentDomElement.removeChild(this._domElement);
  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
Hotspot.prototype.domElement = function() {
  return this._domElement;
};


/**
 * @return {Object}
 */
Hotspot.prototype.position = function() {
  return this._coords;
};


/**
 * @param {Object} coords
 */
Hotspot.prototype.setPosition = function(coords) {
  for (var key in coords) {
    this._coords[key] = coords[key];
  }
  this._update();
  // TODO: We should probably emit a hotspotsChange event on the parent
  // HotspotContainer. What's the best way to do so?
};


/**
 * @return {Object}
 */
Hotspot.prototype.perspective = function() {
  return this._perspective;
};


/**
 * @param {Object}
 */
Hotspot.prototype.setPerspective = function(perspective) {
  for (var key in perspective) {
    this._perspective[key] = perspective[key];
  }
  this._update();
};


/**
 * Show the hotspot
 */
Hotspot.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._update();
  }
};


/**
 * Hide the hotspot
 */
Hotspot.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._update();
  }
};


Hotspot.prototype._update = function() {
  var element = this._domElement;

  var params = this._coords;
  var position = this._position;
  var x, y;

  var isVisible = false;

  if (this._visible) {
    var view = this._view;

    if (this._perspective.radius) {
      // Hotspots that are embedded in the panorama may be visible even when
      // positioned behind the camera.
      isVisible = true;
      this._setEmbeddedPosition(view, params);
    } else {
      // Regular hotspots are only visible when positioned in front of the
      // camera. Note that they may be partially visible when positioned outside
      // the viewport.
      view.coordinatesToScreen(params, position);
      x = position.x;
      y = position.y;

      if (x != null && y != null) {
        isVisible = true;
        this._setPosition(x, y);
      }
    }
  }

  // Show if visible, hide if not.
  if (isVisible) {
    element.style.display = 'block';
    element.style.position = 'absolute';
  }
  else {
    element.style.display = 'none';
    element.style.position = '';
  }

};


Hotspot.prototype._setEmbeddedPosition = function(view, params) {
  var transform = view.coordinatesToPerspectiveTransform(
      params, this._perspective.radius, this._perspective.extraTransforms);
  setTransform(this._domElement, transform);
};


Hotspot.prototype._setPosition = function(x, y) {
  positionAbsolutely(this._domElement, x, y, this._perspective.extraTransforms);
};


module.exports = Hotspot;

},{"./util/clearOwnProperties":80,"./util/dom":89,"./util/positionAbsolutely":100,"minimal-event-emitter":14}],17:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Hotspot = require('./Hotspot');
var calcRect = require('./util/calcRect');
var positionAbsolutely = require('./util/positionAbsolutely');
var setAbsolute = require('./util/dom').setAbsolute;
var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setOverflowVisible = require('./util/dom').setOverflowVisible;
var setNullSize = require('./util/dom').setNullSize;
var setPixelSize = require('./util/dom').setPixelSize;
var setPointerEvents = require('./util/dom').setWithVendorPrefix('pointer-events');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that a hotspot has been created or destroyed on the container.
 * @event HotspotContainer#hotspotsChange
 */

/**
 * @class HotspotContainer
 * @classdesc
 *
 * Creates a DOM element to hold {@link Hotspot hotspots} and updates their
 * position when necessary.
 *
 * @param {Element} parentDomElement The DOM element inside which the container
 *     should be created.
 * @param {Stage} stage The underlying stage.
 * @param {View} view The view according to which the hotspots are positioned.
 * @param {RenderLoop} renderLoop The render loop indicating when the hotspots
 *     must be rendered.
 * @param {Object} opts
 * @param {RectSpec} opts.rect Rectangular region covered by the container. See
 *    {@link Effects#rect}.
 */
function HotspotContainer(parentDomElement, stage, view, renderLoop, opts) {
  opts = opts || {};

  this._parentDomElement = parentDomElement;
  this._stage = stage;
  this._view = view;
  this._renderLoop = renderLoop;

  // Hotspot list.
  this._hotspots = [];

  // Whether the hotspot container should be visible.
  this._visible = true;

  // The current rect.
  this._rect = opts.rect;

  // Whether the visibility or the rect have changed since the last DOM update.
  this._visibilityOrRectChanged = true;

  // The last seen stage dimensions.
  this._stageWidth = null;
  this._stageHeight = null;

  // Temporary variable to hold the calculated position and size.
  this._tmpRect = {};

  // Wrapper element. When the rect effect is set, the wrapper will have nonzero
  // dimensions and `pointer-events: none` so that hotspots outside the rect are
  // hidden, but no mouse events are hijacked.
  this._hotspotContainerWrapper = document.createElement('div');
  setAbsolute(this._hotspotContainerWrapper);
  setPointerEvents(this._hotspotContainerWrapper, 'none');
  this._parentDomElement.appendChild(this._hotspotContainerWrapper);

  // Hotspot container element. It has zero dimensions and `pointer-events: all`
  // to override the `pointer-events: none` on the wrapper and allow hotspots to
  // be interacted with.
  this._hotspotContainer = document.createElement('div');
  setAbsolute(this._hotspotContainer);
  setPointerEvents(this._hotspotContainer, 'all');
  this._hotspotContainerWrapper.appendChild(this._hotspotContainer);

  // Update when the hotspots change or scene is re-rendered.
  this._updateHandler = this._update.bind(this);
  this._renderLoop.addEventListener('afterRender', this._updateHandler);
}

eventEmitter(HotspotContainer);


/**
 * Destructor.
 */
HotspotContainer.prototype.destroy = function() {
  while (this._hotspots.length) {
    this.destroyHotspot(this._hotspots[0]);
  }

  this._parentDomElement.removeChild(this._hotspotContainerWrapper);

  this._renderLoop.removeEventListener('afterRender', this._updateHandler);

  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
HotspotContainer.prototype.domElement = function() {
  return this._hotspotContainer;
};


/**
 * @param {Rect} rect
 */
HotspotContainer.prototype.setRect = function(rect) {
  this._rect = rect;
  this._visibilityOrRectChanged = true;
};


/**
 * @return {Rect}
 */
HotspotContainer.prototype.rect = function() {
  return this._rect;
};


/**
 * Creates a new hotspot in this container.
 *
 * @param {Element} domElement DOM element to use for the hotspot
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords}` for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Options in the same format as the `opts` argument to
 *     the {@link Hotspot} constructor.
 * @return {Hotspot}
 */
HotspotContainer.prototype.createHotspot = function(domElement, coords, opts) {
  coords = coords || {};

  var hotspot = new Hotspot(
      domElement, this._hotspotContainer, this._view, coords, opts);
  this._hotspots.push(hotspot);
  hotspot._update();

  this.emit('hotspotsChange');

  return hotspot;
};


/**
 * @param {Hotspot} hotspot
 * @return {boolean}
 */
HotspotContainer.prototype.hasHotspot = function(hotspot) {
  return this._hotspots.indexOf(hotspot) >= 0;
};


/**
 * @return {Hotspot[]}
 */
HotspotContainer.prototype.listHotspots = function() {
  return [].concat(this._hotspots);
};


/**
 * Removes a hotspot from the container.
 *
 * @param {Hotspot} hotspot
 */
HotspotContainer.prototype.destroyHotspot = function(hotspot) {
  var i = this._hotspots.indexOf(hotspot);
  if (i < 0) {
    throw new Error('No such hotspot');
  }
  this._hotspots.splice(i, 1);

  hotspot.destroy();
  this.emit('hotspotsChange');
};


/**
 * Hide the container's DOM element, causing every contained {@link Hotspot} to
 * be hidden.
 */
HotspotContainer.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


/**
 * Show the container's DOM element, causing every contained {@link Hotspot} to
 * be shown.
 */
HotspotContainer.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


HotspotContainer.prototype._update = function() {
  var wrapper = this._hotspotContainerWrapper;
  var width = this._stage.width();
  var height = this._stage.height();
  var tmpRect = this._tmpRect;

  // Avoid updating the wrapper DOM unless necessary.
  if (this._visibilityOrRectChanged ||
      (this._rect && (width !== this._stageWidth || height !== this._stageHeight))) {
    var visible = this._visible;
    wrapper.style.display = visible ? 'block' : 'none';

    if (visible) {
      if (this._rect) {
        calcRect(width, height, this._rect, tmpRect);
        positionAbsolutely(wrapper, width * tmpRect.x, height * tmpRect.y);
        setPixelSize(wrapper, width * tmpRect.width, height * tmpRect.height);
        setOverflowHidden(wrapper);
      } else {
        positionAbsolutely(wrapper, 0, 0);
        setNullSize(wrapper);
        setOverflowVisible(wrapper);
      }
    }

    this._stageWidth = width;
    this._stageHeight = height;
    this._visibilityOrRectChanged = false;
  }

  // Update hotspots unconditionally, as the view parameters may have changed.
  for (var i = 0; i < this._hotspots.length; i++) {
    this._hotspots[i]._update();
  }
};


module.exports = HotspotContainer;

},{"./Hotspot":16,"./util/calcRect":76,"./util/clearOwnProperties":80,"./util/dom":89,"./util/positionAbsolutely":100,"minimal-event-emitter":14}],18:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


var eventEmitter = require('minimal-event-emitter');
var extend = require('./util/extend');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the layer has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Layer#renderComplete
 */

/**
 * @class Layer
 * @classdesc
 *
 * A Layer is a combination of {@link Source}, {@link Geometry}, {@link View}
 * and {@link TextureStore} that may be added into a {@link Stage} and rendered
 * with {@link Effects}.
 *
 * @param {Source} source
 * @param {Geometry} geometry
 * @param {string} depthmap
 * @param {View} view
 * @param {TextureStore} textureStore
 * @param {Object} opts
 * @param {Effects} opts.effects
*/
function Layer(source, geometry, depthmap, view, textureStore, depthmapStore, opts) {
  opts = opts || {};

  var self = this;

  this._source = source;
  this._geometry = geometry;
  this._depthmap = depthmap;
  this._view = view;
  this._textureStore = textureStore;
  this._depthmapStore = depthmapStore;

  this._effects = opts.effects || {};

  this._fixedLevelIndex = null;

  this._viewChangeHandler = function () {
    self.emit('viewChange', self.view());
  };

  this._view.addEventListener('change', this._viewChangeHandler);

  this._textureStoreChangeHandler = function () {
    self.emit('textureStoreChange', self.textureStore());
  };

  this._textureStore.addEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureInvalid',
    this._textureStoreChangeHandler);
}

eventEmitter(Layer);


/**
 * Destructor.
 */
Layer.prototype.destroy = function () {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._textureStore.removeEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureInvalid',
    this._textureStoreChangeHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying {@link Source source}.
 * @return {Source}
 */
Layer.prototype.source = function () {
  return this._source;
};

/**
 * Returns the underlying depthmap.
 * @returns {string}
 */
Layer.prototype.depthmap = function () {
  return this._depthmap;
}

/**
 * Returns the underlying {@link Geometry geometry}.
 * @return {Geometry}
 */
Layer.prototype.geometry = function () {
  return this._geometry;
};


/**
 * Returns the underlying {@link View view}.
 * @return {View}
 */
Layer.prototype.view = function () {
  return this._view;
};


/**
 * Returns the underlying {@link TextureStore texture store}.
 * @return {TextureStore}
 */
Layer.prototype.textureStore = function () {
  return this._textureStore;
};


/**
 * Returns the underlying {@link DepthmapStore date store}.
 * @return {DepthmapStore}
 */
Layer.prototype.depthmapStore = function () {
  return this._depthmapStore;
};


/**
 * Returns the currently set {@link Effects effects}.
 * @return {Effects}
 */
Layer.prototype.effects = function () {
  return this._effects;
};


/**
 * Sets the {@link Effects effects}.
 * @param {Effects} effects
 */
Layer.prototype.setEffects = function (effects) {
  this._effects = effects;
  this.emit('effectsChange', this._effects);
};


/**
 * Merges effects into the currently set ones. The merge is non-recursive; for
 * instance, if current effects are `{ rect: { relativeWidth: 0.5 } }`,
 * calling this method with `{ rect: { relativeX: 0.5 }}` will reset
 * `rect.relativeWidth`.
 *
 * @param {Effects} effects
 */
Layer.prototype.mergeEffects = function (effects) {
  extend(this._effects, effects);
  this.emit('effectsChange', this._effects);
};


/**
 * Returns the fixed level index.
 * @return {(number|null)}
 */
Layer.prototype.fixedLevel = function () {
  return this._fixedLevelIndex;
};


/**
 * Sets the fixed level index. When set, the corresponding level will be
 * used regardless of the view parameters. Unset with a null argument.
 *
 * @param {(number|null)} levelIndex
 * @throws An error if the level index is out of range.
 */
Layer.prototype.setFixedLevel = function (levelIndex) {
  if (levelIndex !== this._fixedLevelIndex) {
    if (levelIndex != null && (levelIndex >= this._geometry.levelList.length ||
      levelIndex < 0)) {
      throw new Error("Level index out of range: " + levelIndex);
    }
    this._fixedLevelIndex = levelIndex;
    this.emit('fixedLevelChange', this._fixedLevelIndex);
  }
};


Layer.prototype._selectLevel = function () {
  var level;
  if (this._fixedLevelIndex != null) {
    level = this._geometry.levelList[this._fixedLevelIndex];
  } else {
    level = this._view.selectLevel(this._geometry.selectableLevelList);
  }
  return level;
};


Layer.prototype.visibleTiles = function (result) {
  var level = this._selectLevel();
  return this._geometry.visibleTiles(this._view, level, result);
};


/**
 * Pin a whole level into the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.pinLevel = function (levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.pin(tiles[i]);
  }
};


/**
 * Unpin a whole level from the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.unpinLevel = function (levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.unpin(tiles[i]);
  }
};


/**
 * Pin the first level. Equivalent to `pinLevel(0)`.
 */
Layer.prototype.pinFirstLevel = function () {
  return this.pinLevel(0);
};


/**
 * Unpin the first level. Equivalent to `unpinLevel(0)`.
 */
Layer.prototype.unpinFirstLevel = function () {
  return this.unpinLevel(0);
};


module.exports = Layer;

},{"./util/clearOwnProperties":80,"./util/extend":90,"minimal-event-emitter":14}],19:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('./util/inherits');

/**
 * @class NetworkError
 * @extends {Error}
 * @classdesc
 *
 * Signals an error that occurred while fetching a URL. This is used by
 * {@link Loader loaders} to distinguish network failures from other errors.
 */
function NetworkError(message) {
  // See: https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript
  this.constructor.super_.apply(this, arguments);
  this.message = message;
}

inherits(NetworkError, Error);

module.exports = NetworkError;

},{"./util/inherits":93}],20:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that {@link Stage#render} is about to be called.
 * @event RenderLoop#beforeRender
 */

/**
 * Signals that {@link Stage#render} has just been called.
 * @event RenderLoop#afterRender
 */

/**
 * @class RenderLoop
 * @classdesc
 *
 * A RenderLoop wraps a {@link Stage} and calls {@link Stage#render} on the next
 * frame whenever it fires {@link Stage#renderInvalid}. It may be started and
 * stopped, and is initially in the stopped state, in which no call to
 * {@link Stage#render} occurs.
 *
 * @listens Stage#renderInvalid
 *
 * @param {Stage} stage
 */
function RenderLoop(stage) {

  var self = this;

  // The stage wrapped by the loop.
  this._stage = stage;

  // Whether the loop is running.
  this._running = false;

  // Whether the loop is currently rendering.
  this._rendering = false;

  // The current requestAnimationFrame handle.
  this._requestHandle = null;

  // The callback passed into requestAnimationFrame.
  this._boundLoop = this._loop.bind(this);

  // Handler for renderInvalid events emitted by the stage.
  this._renderInvalidHandler = function() {
    // If we are already rendering, there's no need to schedule a new render
    // on the next frame.
    if (!self._rendering) {
      self.renderOnNextFrame();
    }
  };

  // Handle renderInvalid events emitted by the stage.
  this._stage.addEventListener('renderInvalid', this._renderInvalidHandler);

}

eventEmitter(RenderLoop);


/**
 * Destructor.
 */
RenderLoop.prototype.destroy = function() {
  this.stop();
  this._stage.removeEventListener('renderInvalid', this._renderInvalidHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying stage.
 * @return {Stage}
 */
RenderLoop.prototype.stage = function() {
  return this._stage;
};


/**
 * Starts the render loop.
 */
RenderLoop.prototype.start = function() {
  this._running = true;
  this.renderOnNextFrame();
};


/**
 * Stops the render loop.
 */
RenderLoop.prototype.stop = function() {
  if (this._requestHandle) {
    window.cancelAnimationFrame(this._requestHandle);
    this._requestHandle = null;
  }
  this._running = false;
};


/**
 * Forces the stage to render on the next frame, even if its contents remain
 * valid. Does nothing if the loop is stopped.
 */
RenderLoop.prototype.renderOnNextFrame = function() {
  if (this._running && !this._requestHandle) {
    this._requestHandle = window.requestAnimationFrame(this._boundLoop);
  }
};


RenderLoop.prototype._loop = function() {
  if (!this._running) {
    throw new Error('Render loop running while in stopped state');
  }
  this._requestHandle = null;
  this._rendering = true;
  this.emit('beforeRender');
  this._rendering = false;
  this._stage.render();
  this.emit('afterRender');
};


module.exports = RenderLoop;

},{"./util/clearOwnProperties":80,"minimal-event-emitter":14}],21:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Layer = require('./Layer');
var TextureStore = require('./TextureStore');
var DepthmapStore = require('./DepthmapStore');
var HotspotContainer = require('./HotspotContainer');
var eventEmitter = require('minimal-event-emitter');
var now = require('./util/now');
var noop = require('./util/noop');
var type = require('./util/type');
var defaults = require('./util/defaults');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the scene's view has changed. See {@link View#event:change}.
 * @event Scene#viewChange
 */

/**
 * Signals that the scene's layers have changed.
 * @event Scene#layerChange
 */

/**
 * @class Scene
 * @classdesc
 *
 * A Scene is a stack of {@link Layer layers} sharing the same {@link View view}
 * and {@link HotspotContainer hotspot container}. It belongs to the
 * {@link Viewer viewer} inside which it is displayed.
 *
 * Clients should call {@link Viewer#createScene} instead of invoking the
 * constructor directly.
 *
 * @param {Viewer} viewer The viewer this scene belongs to.
 * @param {View} view The scene's underlying view.
 */
function Scene(viewer, view) {
  this._viewer = viewer;
  this._view = view;
  this._layers = [];

  // Hotspot container. Assume it occupies a full rect.
  this._hotspotContainer = new HotspotContainer(
    viewer._controlContainer,
    viewer.stage(),
    this._view,
    viewer.renderLoop());

  // The current movement.
  this._movement = null;
  this._movementStartTime = null;
  this._movementStep = null;
  this._movementParams = null;
  this._movementCallback = null;

  // Event listener for updating the view according to the current movement.
  // The listener is set/unset on the render loop when a movement starts/stops.
  this._updateMovementHandler = this._updateMovement.bind(this);

  // Show or hide hotspots when scene changes.
  this._updateHotspotContainerHandler = this._updateHotspotContainer.bind(this);
  this._viewer.addEventListener('sceneChange', this._updateHotspotContainerHandler);

  // Emit event when view changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');
  this._view.addEventListener('change', this._viewChangeHandler);

  // Update the hotspot container.
  this._updateHotspotContainer();
}

eventEmitter(Scene);


/**
 * Destructor. Clients should call {@link Viewer#destroyScene} instead.
 */
Scene.prototype.destroy = function () {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._viewer.removeEventListener('sceneChange', this._updateHotspotContainerHandler);

  if (this._movement) {
    this.stopMovement();
  }

  this._hotspotContainer.destroy();

  this.destroyAllLayers();

  clearOwnProperties(this);
};



/**
 * Returns the {@link HotspotContainer hotspot container} for the scene.
 * @return {Layer}
 */
Scene.prototype.hotspotContainer = function () {
  return this._hotspotContainer;
};

/**
 * Returns the first of the {@link Layer layers} belonging to the scene, or
 * null if the scene has no layers.
 *
 * This method is equivalent to `Scene#listLayers[0]`. It may be removed in the
 * future.
 *
 * @return {Layer}
 */
Scene.prototype.layer = function () {
  return this._layers[0];
};

/**
* Returns a list of all {@link Layer layers} belonging to the scene. The
* returned list is in display order, background to foreground.
* @return {Layer[]}
 */
Scene.prototype.listLayers = function () {
  return [].concat(this._layers);
};


/**
 * Returns the scene's underlying {@link View view}.
 * @return {View}
 */
Scene.prototype.view = function () {
  return this._view;
};


/**
 * Returns the {@link Viewer viewer} the scene belongs to.
 * @return {Viewer}
 */
Scene.prototype.viewer = function () {
  return this._viewer;
};


/**
 * Returns whether the scene is currently visible.
 * @return {boolean}
 */
Scene.prototype.visible = function () {
  return this._viewer.scene() === this;
};


/**
 * Creates a new {@link Layer layer} and adds it into the scene in the
 * foreground position.
 *
 * @param {Object} opts Layer creation options.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.
 * @param {Source} opts.depthmap The layer's underlying depthmap {@link Source}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Layer}
 */
Scene.prototype.createLayer = function (opts) {
  opts = opts || {};

  var textureStoreOpts = opts.textureStoreOpts || {};
  var depthmapStoreOpts = opts.depthmapStoreOpts || {};
  var layerOpts = opts.layerOpts || {};

  var source = opts.source;
  var geometry = opts.geometry;
  var depthmap = opts.depthmap;
  var view = this._view;
  var stage = this._viewer.stage();
  var textureStore = new TextureStore(source, stage, textureStoreOpts);
  var depthmapStore = depthmap && new DepthmapStore(depthmap, stage, depthmapStoreOpts);

  var layer = new Layer(source, geometry, depthmap, view, textureStore, depthmapStore, layerOpts);

  this._layers.push(layer);

  if (opts.pinFirstLevel) {
    layer.pinFirstLevel();
  }

  // Signal that the layers have changed.
  this.emit('layerChange');

  return layer;
};


/**
 * Destroys a {@link Layer layer} and removes it from the scene.
 * @param {Layer} layer
 * @throws An error if the layer does not belong to the scene.
 */
Scene.prototype.destroyLayer = function (layer) {
  var i = this._layers.indexOf(layer);
  if (i < 0) {
    throw new Error('No such layer in scene');
  }

  this._layers.splice(i, 1);

  // Signal that the layers have changed.
  this.emit('layerChange');

  layer.textureStore().destroy();
  layer.destroy();
};


/**
 * Destroys all {@link Layer layers} and removes them from the scene.
 */
Scene.prototype.destroyAllLayers = function () {
  while (this._layers.length > 0) {
    this.destroyLayer(this._layers[0]);
  }
};


/**
 * Switches to the scene.
 *
 * This is equivalent to calling {@link Viewer#switchScene} on this scene.
 *
 * @param {Object} opts Options to pass into {@link Viewer#switchScene}.
 * @param {function} done Function to call when the switch is complete.
 */
Scene.prototype.switchTo = function (opts, done) {
  return this._viewer.switchScene(this, opts, done);
};


/**
 * Tweens the scene's underlying {@link View view}.
 *
 * @param {Object} params Target view parameters.
 * @param {Object} opts Transition options.
 * @param {function} [opts.ease=easeInOutQuad] Tween easing function
 * @param {number} [opts.controlsInterrupt=false] allow controls to interrupt
 *     an ongoing tween.
 * @param {number} [opts.transitionDuration=1000] Tween duration, in
 *     milliseconds.
 * @param {number} [opts.closest=true] Whether to tween through the shortest
 *    path between the initial and final view parameters. This requires
 *    {@link View#normalizeToClosest} to be implemented, and does nothing
 *    otherwise.
 * @param {function} done Function to call when the tween finishes or is
 *    interrupted.
 */
Scene.prototype.lookTo = function (params, opts, done) {
  var self = this;

  opts = opts || {};
  done = done || noop;

  if (type(params) !== 'object') {
    throw new Error("Target view parameters must be an object");
  }

  // Quadratic in/out easing.
  var easeInOutQuad = function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  };

  var ease = opts.ease != null ? opts.ease : easeInOutQuad;
  var controlsInterrupt = opts.controlsInterrupt != null ? opts.controlsInterrupt : false;
  var duration = opts.transitionDuration != null ? opts.transitionDuration : 1000;
  var shortest = opts.shortest != null ? opts.shortest : true;

  var view = this._view;

  var initialParams = view.parameters();

  var finalParams = {};
  defaults(finalParams, params);
  defaults(finalParams, initialParams);

  // Tween through the shortest path if requested.
  // The view must implement the normalizeToClosest() method.
  if (shortest && view.normalizeToClosest) {
    view.normalizeToClosest(finalParams, finalParams);
  }

  var movement = function () {

    var finalUpdate = false;

    return function (params, elapsed) {

      if (elapsed >= duration && finalUpdate) {
        return null;
      }

      var delta = Math.min(elapsed / duration, 1);

      for (var param in params) {
        var start = initialParams[param];
        var end = finalParams[param];
        params[param] = start + ease(delta) * (end - start);
      }

      finalUpdate = elapsed >= duration;

      return params;

    };
  };

  var reenableControls = this._viewer.controls().enabled();

  if (!controlsInterrupt) {
    this._viewer.controls().disable();
  }

  this.startMovement(movement, function () {
    if (reenableControls) {
      self._viewer.controls().enable();
    }
    done();
  });

};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Scene.prototype.startMovement = function (fn, done) {

  var renderLoop = this._viewer.renderLoop();

  if (this._movement) {
    this.stopMovement();
  }

  var step = fn();
  if (typeof step !== 'function') {
    throw new Error('Bad movement');
  }

  this._movement = fn;
  this._movementStep = step;
  this._movementStartTime = now();
  this._movementParams = {};
  this._movementCallback = done;

  renderLoop.addEventListener('beforeRender', this._updateMovementHandler);
  renderLoop.renderOnNextFrame();
};


/**
 * Stops the current movement.
 */
Scene.prototype.stopMovement = function () {

  var done = this._movementCallback;
  var renderLoop = this._viewer.renderLoop();

  if (!this._movement) {
    return;
  }

  // Clear state before calling done, to prevent an infinite loop when the
  // callback starts a new movement.
  this._movement = null;
  this._movementStep = null;
  this._movementStartTime = null;
  this._movementParams = null;
  this._movementCallback = null;

  renderLoop.removeEventListener('beforeRender', this._updateMovementHandler);

  if (done) {
    done();
  }
};


/**
 * Returns the current movement.
 * @return {function}
 */
Scene.prototype.movement = function () {
  return this._movement;
};


Scene.prototype._updateMovement = function () {

  if (!this._movement) {
    throw new Error('Should not call update');
  }

  var renderLoop = this._viewer.renderLoop();
  var view = this._view;

  var elapsed = now() - this._movementStartTime;
  var step = this._movementStep;
  var params = this._movementParams;

  params = view.parameters(params);
  params = step(params, elapsed);
  if (params == null) {
    this.stopMovement();
  } else {
    view.setParameters(params);
    renderLoop.renderOnNextFrame();
  }

};


Scene.prototype._updateHotspotContainer = function () {
  if (this.visible()) {
    this._hotspotContainer.show();
  } else {
    this._hotspotContainer.hide();
  }
};


module.exports = Scene;

},{"./DepthmapStore":15,"./HotspotContainer":17,"./Layer":18,"./TextureStore":22,"./util/clearOwnProperties":80,"./util/defaults":85,"./util/noop":96,"./util/now":97,"./util/type":105,"minimal-event-emitter":14}],22:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Map = require('./collections/Map');
var Set = require('./collections/Set');
var LruSet = require('./collections/LruSet');
var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var retry = require('./util/retry');
var chain = require('./util/chain');
var inherits = require('./util/inherits');
var clearOwnProperties = require('./util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.textureStore;


// A Stage informs the TextureStore about the set of visible tiles during a
// frame by calling startFrame, markTile and endFrame. In a particular frame,
// TextureStore expects one or more calls to startFrame, followed by zero or
// more calls to markTile, followed by one or more calls to endFrame. The
// number of calls to startFrame and endFrame must match. Calls to other
// TextureStore methods may be freely interleaved with this sequence.
//
// At any given time, TextureStore is in one of four states. The START state
// corresponds to the interval between the first startFrame and the first
// markTile of a frame. The MARK state corresponds to the interval between the
// first markTile and the first endFrame. The END state corresponds to the
// interval between the first and the last endFrame. At any other time, the
// TextureStore is in the IDLE state.
var State = {
  IDLE: 0,
  START: 1,
  MARK: 2,
  END: 3
};


var defaultOptions = {
  // Maximum number of cached textures for previously visible tiles.
  previouslyVisibleCacheSize: 512
};


// Assign an id to each operation so we can track its state.
// We actually only need this in debug mode, but the code is less convoluted
// if we track unconditionally, and the performance hit is minimal anyway.
var nextId = 0;


// Distinguishes a cancellation from other kinds of errors.
function CancelError() {}
inherits(CancelError, Error);


/**
 * @class TextureStoreItem
 * @classdesc
 *
 * An item saved in a {@link TextureStore}.
 *
 * Clients do not need to instantiate this. It is automatically instantiated by
 * a {@link TextureStore} to manage the lifetime of a stored item: loading,
 * refreshing, unloading and emitting associated events.
 *
 * @param {TextureStore} store The underlying {@link TextureStore}.
 * @param {Tile} tile The underlying tile.
 */
function TextureStoreItem(store, tile) {

  var self = this;

  var id = nextId++;

  self._id = id;
  self._store = store;
  self._tile = tile;

  self._asset = null;
  self._texture = null;

  self._changeHandler = function() {
    store.emit('textureInvalid', tile);
  };

  var source = store.source();
  var stage = store.stage();

  var loadAsset = source.loadAsset.bind(source);
  var createTexture = stage.createTexture.bind(stage);

  // Retry loading the asset until it succeeds, then create the texture from it.
  // This process may be canceled at any point by calling the destroy() method.
  var fn = chain(retry(loadAsset), createTexture);

  store.emit('textureStartLoad', tile);
  if (debug) {
    console.log('loading', id, tile);
  }

  self._cancel = fn(stage, tile, function(err, _tile, asset, texture) {

    // Make sure we do not call cancel after the operation is complete.
    self._cancel = null;

    if (err) {
      // The loading process was interrupted by an error.
      // This could either be because the texture creation failed, or because
      // the operation was canceled before the loading was complete.

      // Destroy the asset and texture, if they exist.
      if (asset) {
        asset.destroy();
      }
      if (texture) {
        texture.destroy();
      }

      // Emit events.
      if (err instanceof CancelError) {
        store.emit('textureCancel', tile);
        if (debug) {
          console.log('cancel', id, tile);
        }
      } else {
        store.emit('textureError', tile, err);
        if (debug) {
          console.log('error', id, tile);
        }
      }

      return;
    }

    // Save a local reference to the texture.
    self._texture = texture;

    // If the asset is dynamic, save a local reference to it and set up a
    // handler to be called whenever it changes. Otherwise, destroy the asset
    // as we won't be needing it any longer.
    if (asset.isDynamic()) {
      self._asset = asset;
      asset.addEventListener('change', self._changeHandler);
    } else {
      asset.destroy();
    }

    // Emit event.
    store.emit('textureLoad', tile);
    if (debug) {
      console.log('load', id, tile);
    }
  });

}


TextureStoreItem.prototype.asset = function() {
  return this._asset;
};


TextureStoreItem.prototype.texture = function() {
  return this._texture;
};


TextureStoreItem.prototype.destroy = function() {
  var id = this._id;
  var store = this._store;
  var tile = this._tile;
  var asset = this._asset;
  var texture = this._texture;
  var cancel = this._cancel;

  if (cancel) {
    // The texture is still loading, so cancel it.
    cancel(new CancelError('Texture load cancelled'));
    return;
  }

  // Destroy asset.
  if (asset) {
    asset.removeEventListener('change', this._changeHandler);
    asset.destroy();
  }

  // Destroy texture.
  if (texture) {
    texture.destroy();
  }

  // Emit event.
  store.emit('textureUnload', tile);
  if (debug) {
    console.log('unload', id, tile);
  }

  clearOwnProperties(this);
};

eventEmitter(TextureStoreItem);

/**
 * Signals that a texture has started to load.
 *
 * This event is followed by either {@link TextureStore#textureLoad},
 * {@link TextureStore#textureError} or {@link TextureStore#textureCancel}.
 *
 * @event TextureStore#textureStartLoad
 * @param {Tile} tile The tile for which the texture has started to load.
 */

/**
 * Signals that a texture has been loaded.
 *
 * @event TextureStore#textureLoad
 * @param {Tile} tile The tile for which the texture was loaded.
 */

/**
 * Signals that a texture has been unloaded.
 *
 * @event TextureStore#textureUnload
 * @param {Tile} tile The tile for which the texture was unloaded.
 */

/**
 * Signals that a texture has been invalidated.
 *
 * This event may be raised for a texture with an underlying dynamic asset. It
 * may only occur while the texture is loaded, i.e., in between
 * {@link TextureStore#textureLoad} and {@link TextureStore#textureUnload}.
 *
 * @event TextureStore#textureInvalid
 * @param {Tile} tile The tile for which the texture was invalidated.
 */

/**
 * Signals that loading a texture has been cancelled.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * becomes unnecessary before it finishes loading.
 *
 * @event TextureStore#textureCancel
 * @param {Tile} tile The tile for which the texture loading was cancelled.
 */

/**
 * Signals that loading a texture has failed.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * fails to load.
 *
 * @event TextureStore#textureError
 * @param {Tile} tile The tile for which the texture loading has failed.
 */

/**
 * @class TextureStore
 * @classdesc
 *
 * A TextureStore maintains a cache of textures used to render a {@link Layer}.
 *
 * A {@link Stage} communicates with the TextureStore through the startFrame(),
 * markTile() and endFrame() methods, which indicate the tiles that are visible
 * in the current frame. Textures for visible tiles are loaded and retained
 * as long as the tiles remain visible. A limited amount of textures whose
 * tiles were previously visible are cached according to an LRU policy. Tiles
 * may be pinned to keep their respective textures cached even when they are
 * invisible; these textures do not count towards the previously visible limit.
 *
 * Multiple layers belonging to the same underlying {@link WebGlStage} may
 * share the same TextureStore. Layers belonging to distinct {@link WebGlStage}
 * instances may not do so due to restrictions on the use of textures across
 * stages.
 *
 * @param {Source} source The underlying source.
 * @param {Stage} stage The underlying stage.
 * @param {Object} opts Options.
 * @param {Number} [opts.previouslyVisibleCacheSize=32] The maximum number of
 *     previously visible textures to cache according to an LRU policy.
 */
function TextureStore(source, stage, opts) {
  opts = defaults(opts || {}, defaultOptions);

  this._source = source;
  this._stage = stage;

  // The current state.
  this._state = State.IDLE;

  // The number of startFrame calls yet to be matched by endFrame calls during
  // the current frame.
  this._delimCount = 0;

  // The cache proper: map cached tiles to their respective textures/assets.
  this._itemMap = new Map();

  // The subset of cached tiles that are currently visible.
  this._visible = new Set();

  // The subset of cached tiles that were visible recently, but are not
  // visible right now. Newly inserted tiles replace older ones.
  this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);

  // The subset of cached tiles that should never be evicted from the cache.
  // A tile may be pinned more than once; map each tile into a reference count.
  this._pinMap = new Map();

  // Temporary variables.
  this._newVisible = new Set();
  this._noLongerVisible = [];
  this._visibleAgain = [];
  this._evicted = [];
}

eventEmitter(TextureStore);


/**
 * Destructor.
 */
TextureStore.prototype.destroy = function() {
  this.clear();
  clearOwnProperties(this);
};


/**
 * Return the underlying {@link Stage}.
 * @return {Stage}
 */
TextureStore.prototype.stage = function() {
  return this._stage;
};


/**
 * Return the underlying {@link Source}.
 * @return {Source}
 */
TextureStore.prototype.source = function() {
  return this._source;
};


/**
 * Remove all textures from the TextureStore, including pinned textures.
 */
TextureStore.prototype.clear = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    self._evicted.push(tile);
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all internal state.
  self._itemMap.clear();
  self._visible.clear();
  self._previouslyVisible.clear();
  self._pinMap.clear();
  self._newVisible.clear();
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


/**
 * Remove all textures in the TextureStore, excluding unpinned textures.
 */
TextureStore.prototype.clearNotPinned = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._evicted.push(tile);
    }
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all caches except the pinned set.
  self._visible.clear();
  self._previouslyVisible.clear();

  // Clear temporary variables.
  self._evicted.length = 0;
};


/**
 * Signal the beginning of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.startFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.IDLE && this._state !== State.START) {
    throw new Error('TextureStore: startFrame called out of sequence');
  }

  // Enter the START state, if not already there.
  this._state = State.START;

  // Expect one more endFrame call.
  this._delimCount++;
};


/**
 * Mark a tile as visible within the current frame. Called from {@link Stage}.
 * @param {Tile} tile The tile to mark.
 */
TextureStore.prototype.markTile = function(tile) {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK) {
    throw new Error('TextureStore: markTile called out of sequence');
  }

  // Enter the MARK state, if not already there.
  this._state = State.MARK;

  // Refresh texture for dynamic assets.
  var item = this._itemMap.get(tile);
  var texture = item && item.texture();
  var asset = item && item.asset();
  if (texture && asset) {
    texture.refresh(tile, asset);
  }

  // Add tile to the visible set.
  this._newVisible.add(tile);
};


/**
 * Signal the end of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.endFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {
    throw new Error('TextureStore: endFrame called out of sequence');
  }

  // Enter the END state, if not already there.
  this._state = State.END;

  // Expect one less call to endFrame.
  this._delimCount--;

  // If no further calls are expected, process frame and enter the IDLE state.
  if (!this._delimCount) {
    this._update();
    this._state = State.IDLE;
  }
};


TextureStore.prototype._update = function() {
  var self = this;

  // Calculate the set of tiles that used to be visible but no longer are.
  self._noLongerVisible.length = 0;
  self._visible.forEach(function(tile) {
    if (!self._newVisible.has(tile)) {
      self._noLongerVisible.push(tile);
    }
  });

  // Calculate the set of tiles that were visible recently and have become
  // visible again.
  self._visibleAgain.length = 0;
  self._newVisible.forEach(function(tile) {
    if (self._previouslyVisible.has(tile)) {
      self._visibleAgain.push(tile);
    }
  });

  // Remove tiles that have become visible again from the list of previously
  // visible tiles.
  self._visibleAgain.forEach(function(tile) {
    self._previouslyVisible.remove(tile);
  });

  // Cancel loading of tiles that are no longer visible.
  // Move no longer visible tiles with a loaded texture into the previously
  // visible set, and collect the tiles evicted from the latter.
  self._evicted.length = 0;
  self._noLongerVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    var texture = item && item.texture();
    if (texture) {
      var otherTile = self._previouslyVisible.add(tile);
      if (otherTile != null) {
        self._evicted.push(otherTile);
      }
    } else if (item) {
      self._unloadTile(tile);
    }
  });

  // Unload evicted tiles, unless they are pinned.
  self._evicted.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._unloadTile(tile);
    }
  });

  // Load visible tiles that are not already in the store.
  // Refresh texture on visible tiles for dynamic assets.
  self._newVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    if (!item) {
      self._loadTile(tile);
    }
  });

  // Swap the old visible set with the new one.
  var tmp = self._visible;
  self._visible = self._newVisible;
  self._newVisible = tmp;

  // Clear the new visible set.
  self._newVisible.clear();

  // Clear temporary variables.
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


TextureStore.prototype._loadTile = function(tile) {
  if (this._itemMap.has(tile)) {
    throw new Error('TextureStore: loading texture already in cache');
  }
  var item = new TextureStoreItem(this, tile);
  this._itemMap.set(tile, item);
};


TextureStore.prototype._unloadTile = function(tile) {
  var item = this._itemMap.del(tile);
  if (!item) {
    throw new Error('TextureStore: unloading texture not in cache');
  }
  item.destroy();
};


TextureStore.prototype.asset = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.asset();
  }
  return null;
};


TextureStore.prototype.texture = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.texture();
  }
  return null;
};


/**
 * Pin a tile. Textures for pinned tiles are never evicted from the store.
 * Upon pinning, the texture is created if not already present. Pins are
 * reference-counted; a tile may be pinned multiple times and must be unpinned
 * the corresponding number of times. Pinning is useful e.g. to ensure that
 * the lowest-resolution level of an image is always available to fall back
 * onto.
 * @param {Tile} tile the tile to pin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.pin = function(tile) {
  // Increment reference count.
  var count = (this._pinMap.get(tile) || 0) + 1;
  this._pinMap.set(tile, count);
  // If the texture for the tile is not present, load it now.
  if (!this._itemMap.has(tile)) {
    this._loadTile(tile);
  }
  return count;
};


/**
 * Unpin a tile. Pins are reference-counted; a tile may be pinned multiple
 * times and must be unpinned the corresponding number of times.
 * @param {Tile} tile the tile to unpin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.unpin = function(tile) {
  var count = this._pinMap.get(tile);
  // Consistency check.
  if (!count) {
    throw new Error('TextureStore: unpin when not pinned');
  } else {
    // Decrement reference count.
    count--;
    if (count > 0) {
      this._pinMap.set(tile, count);
    } else {
      this._pinMap.del(tile);
      // If the tile does not belong to either the visible or previously
      // visible sets, evict it from the cache.
      if (!this._visible.has(tile) && !this._previouslyVisible.has(tile)) {
        this._unloadTile(tile);
      }
    }
  }
  return count;
};


/**
 * Return type for {@link TextureStore#query}.
 * @typedef {Object} TileState
 * @property {boolean} visible Whether the tile is in the visible set.
 * @property {boolean} previouslyVisible Whether the tile is in the previously
 *     visible set.
 * @property {boolean} hasAsset Whether the asset for the tile is present.
 * @property {boolean} hasTexture Whether the texture for the tile is present.
 * @property {boolean} pinned Whether the tile is in the pinned set.
 * @property {number} pinCount The pin reference count for the tile.
 */


/**
 * Return the state of a tile.
 * @param {Tile} tile The tile to query.
 * @return {TileState}
 */
TextureStore.prototype.query = function(tile) {
  var item = this._itemMap.get(tile);
  var pinCount = this._pinMap.get(tile) || 0;
  return {
    visible: this._visible.has(tile),
    previouslyVisible: this._previouslyVisible.has(tile),
    hasAsset: item != null && item.asset() != null,
    hasTexture: item != null && item.texture() != null,
    pinned: pinCount !== 0,
    pinCount: pinCount
  };
};


module.exports = TextureStore;

},{"./collections/LruSet":30,"./collections/Map":31,"./collections/Set":32,"./util/chain":78,"./util/clearOwnProperties":80,"./util/defaults":85,"./util/inherits":93,"./util/retry":103,"minimal-event-emitter":14}],23:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Set = require('./collections/Set');

/**
 * @class TileSearcher
 * @classdesc
 *
 * A TileSearcher performs searches for visible tiles.
 */
function TileSearcher() {
  // Stack of tiles to be explored.
  this._stack = [];

  // Set of already explored tiles.
  this._visited = new Set();

  // Tile vertices. Allocated by Tile#vertices on first use.
  this._vertices = null;
}

/**
 * Performs a search for visible tiles by starting at a given tile and
 * recursively exploring neighbors until no more visible tiles are found.
 *
 * @param {View} view The view used to deem whether a tile is visible.
 * @param {Tile} tile The starting tile.
 * @param {Tile[]} result An array to append the visible tiles to, including the
 *     starting tile when visible. Existing array members are preserved.
 * @return {number} The number of visible tiles found.
 */
TileSearcher.prototype.search = function(view, startingTile, result) {
  var stack = this._stack;
  var visited = this._visited;
  var vertices = this._vertices;

  var count = 0;

  // Clear internal state.
  this._clear();

  stack.push(startingTile);

  while (stack.length > 0) {
    var tile = stack.pop();

    if (visited.has(tile)) {
      // Skip already visited tile.
      continue;
    }

    if (!view.intersects(tile.vertices(vertices))) {
      // Skip non-visible tile.
      continue;
    }

    // Mark tile as visited.
    visited.add(tile);

    // Add neighbors to the stack of tiles to explore.
    var neighbors = tile.neighbors();
    for (var i = 0; i < neighbors.length; i++) {
      stack.push(neighbors[i]);
    }

    // Add to result.
    result.push(tile);

    count++;
  }

  // Reuse the vertices array in future searches.
  this._vertices = vertices;

  // Clear internal state.
  this._clear();

  return count;
};

TileSearcher.prototype._clear = function() {
  this._stack.length = 0;
  this._visited.clear();
};

module.exports = TileSearcher;

},{"./collections/Set":32}],24:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var now = require('./util/now');

var defaultOptions = {
  duration: Infinity
};


/**
 * Signals a timeout.
 * @event Timer#timeout
 */


/**
 * @class Timer
 * @classdesc
 *
 * A Timer provides a mechanism to receive an event after a timeout.
 *
 * A timer has a set duration, and is either started or stopped at a given time.
 * The timer is initially stopped. When the timer is started, a timeout event is
 * scheduled to fire once the set duration elapses. When the timer is stopped,
 * the scheduled timeout event is cancelled. When a timeout event fires, the
 * timer returns to the stopped state.
 *
 * @param {number} [opts.duration=Infinity] Timeout in milliseconds.
 */
function Timer(opts) {

  opts = defaults(opts || {}, defaultOptions);

  this._duration = opts.duration;

  this._startTime = null;

  this._handle = null;

  this._check = this._check.bind(this);

}

eventEmitter(Timer);


/**
 * Starts the timer. If the timer is already started, this has the effect of
 * stopping and starting again (i.e. resetting the timer).
 */
Timer.prototype.start = function() {
  this._startTime = now();
  if (this._handle == null && this._duration < Infinity) {
    this._setup(this._duration);
  }
};


/**
 * Returns whether the timer is in the started state.
 * @return {boolean}
 */
Timer.prototype.started = function() {
  return this._startTime != null;
};


/**
 * Stops the timer.
 */
Timer.prototype.stop = function() {
  this._startTime = null;
  if (this._handle != null) {
    clearTimeout(this._handle);
    this._handle = null;
  }
};


Timer.prototype._setup = function(interval) {
  this._handle = setTimeout(this._check, interval);
};


Timer.prototype._teardown = function() {
  clearTimeout(this._handle);
  this._handle = null;
};


Timer.prototype._check = function() {
  var currentTime = now();
  var elapsed = currentTime - this._startTime;
  var remaining = this._duration - elapsed;

  this._teardown();

  if (remaining <= 0) {
    this.emit('timeout');
    this._startTime = null;
  } else if (remaining < Infinity) {
    this._setup(remaining);
  }
};


/**
 * Returns the currently set duration.
 */
Timer.prototype.duration = function() {
  return this._duration;
};


/**
 * Sets the duration. If the timer is already started, the timeout event is
 * rescheduled to occur once the new duration has elapsed since the last call
 * to start. In particular, if an amount of time larger than the new duration
 * has already elapsed, the timeout event fires immediately.
 * @param {number}
 */
Timer.prototype.setDuration = function(duration) {
  this._duration = duration;
  if (this._startTime != null) {
    this._check();
  }
};


module.exports = Timer;

},{"./util/defaults":85,"./util/now":97,"minimal-event-emitter":14}],25:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');

var RenderLoop = require('./RenderLoop');
var Controls = require('./controls/Controls');
var Scene = require('./Scene');
var Timer = require('./Timer');

var WebGlStage = require('./stages/WebGl');

var ControlCursor = require('./controls/ControlCursor');
var HammerGestures = require('./controls/HammerGestures');

var registerDefaultControls = require('./controls/registerDefaultControls');
var registerDefaultRenderers = require('./renderers/registerDefaultRenderers');

var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setAbsolute = require('./util/dom').setAbsolute;
var setFullSize = require('./util/dom').setFullSize;

var tween = require('./util/tween');
var noop = require('./util/noop');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the current scene has changed.
 * @event Viewer#sceneChange
 */

/**
 * Signals that the view of the current scene has changed. See
 * {@link View#event:change}.
 * @event Viewer#viewChange
 */

/**
 * @class Viewer
 * @classdesc
 *
 * A Viewer is a container for multiple {@link Scene scenes} to be displayed
 * inside a {@link Stage stage} contained in the DOM.
 *
 * Scenes may be created by calling {@link Viewer#createScene}. Except during a
 * scene switch, a single one of them, called the current scene, is visible.
 * Calling {@link Viewer#switchScene} sets the current scene and switches to it.
 *
 * @param {Element} domElement The DOM element to contain the stage.
 * @param {Object} opts Viewer creation options.
 * @param {Object} opts.controls Options to be passed to
 *     {@link registerDefaultControls}.
 * @param {Object} opts.stage Options to be passed to the {@link Stage}
 *     constructor.
 * @param {Object} opts.cursors Cursor options.
 * @param {Object} opts.cursors.drag Drag cursor options to be passed to the
 *     {@link ControlCursor} constructor.
 */
function Viewer(domElement, opts) {
  opts = opts || {};

  this._domElement = domElement;

  // Add `overflow: hidden` to the domElement.
  setOverflowHidden(domElement);

  // Create stage.
  this._stage = new WebGlStage(opts.stage);

  // Register the default renderers for the selected stage.
  registerDefaultRenderers(this._stage);

  // Add the stage element into the DOM.
  this._domElement.appendChild(this._stage.domElement());

  // Create control container.
  // Controls cannot be placed directly on the root DOM element because
  // Hammer.js will prevent click events from reaching the elements beneath.

  // The hotspot containers will be added inside the controls container.
  this._controlContainer = document.createElement('div');
  setAbsolute(this._controlContainer);
  setFullSize(this._controlContainer);
  domElement.appendChild(this._controlContainer);

  // Respond to window size changes.
  this._size = {};
  this.updateSize();
  this._updateSizeListener = this.updateSize.bind(this);
  window.addEventListener('resize', this._updateSizeListener);

  // Create render loop.
  this._renderLoop = new RenderLoop(this._stage);

  // Create the controls and register them with the render loop.
  this._controls = new Controls();
  this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);
  this._controls.attach(this._renderLoop);

  // Expose HammerJS.
  this._hammerManagerTouch = HammerGestures.get(this._controlContainer, 'touch');
  this._hammerManagerMouse = HammerGestures.get(this._controlContainer, 'mouse');

  // Initialize drag cursor.
  this._dragCursor = new ControlCursor(this._controls, 'mouseViewDrag', domElement, opts.cursors && opts.cursors.drag || {});

  // Start the render loop.
  this._renderLoop.start();

  // Scene list.
  this._scenes = [];

  // The currently visible scene.
  // During a scene transition, this is the scene being switched to.
  this._currentScene = null;

  // The scene being switched from during a scene transition.
  // This is necessary to update the layers correctly when they are added or
  // removed during a transition.
  this._replacedScene = null;

  // The current transition.
  this._cancelCurrentTween = null;

  // The event listener fired when the current scene layers change.
  // This is attached to the correct scene whenever the current scene changes.
  this._layerChangeHandler = this._updateSceneLayers.bind(this);

  // The event listener fired when the current scene view changes.
  // This is attached to the correct scene whenever the current scene changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');

  // Setup the idle timer.
  // By default, the timer has an infinite duration so it does nothing.
  this._idleTimer = new Timer();
  this._idleTimer.start();

  // Reset the timer whenever the view changes.
  this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);
  this.addEventListener('viewChange', this._resetIdleTimerHandler);

  // Start the idle movement when the idle timer fires.
  this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);
  this._idleTimer.addEventListener('timeout', this._triggerIdleTimerHandler);

  // Stop an ongoing movement when the controls are activated or when the
  // scene changes.
  this._stopMovementHandler = this.stopMovement.bind(this);
  this._controls.addEventListener('active', this._stopMovementHandler);
  this.addEventListener('sceneChange', this._stopMovementHandler);

  // The currently programmed idle movement.
  this._idleMovement = null;
}

eventEmitter(Viewer);


/**
 * Destructor.
 */
Viewer.prototype.destroy = function () {

  window.removeEventListener('resize', this._updateSizeListener);

  if (this._currentScene) {
    this._removeSceneEventListeners(this._currentScene);
  }

  if (this._replacedScene) {
    this._removeSceneEventListeners(this._replacedScene);
  }

  this._dragCursor.destroy();

  for (var methodName in this._controlMethods) {
    this._controlMethods[methodName].destroy();
  }

  while (this._scenes.length) {
    this.destroyScene(this._scenes[0]);
  }

  this._domElement.removeChild(this._stage.domElement());

  this._stage.destroy();
  this._renderLoop.destroy();
  this._controls.destroy();
  this._controls = null;

  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
  }

  clearOwnProperties(this);
};


/**
 * Updates the stage size to fill the containing element.
 *
 * This method is automatically called when the browser window is resized.
 * Most clients won't need to explicitly call it to keep the size up to date.
 */
Viewer.prototype.updateSize = function () {
  var size = this._size;
  size.width = this._domElement.clientWidth;
  size.height = this._domElement.clientHeight;
  this._stage.setSize(size);
};


/**
 * Returns the underlying {@link Stage stage}.
 * @return {Stage}
 */
Viewer.prototype.stage = function () {
  return this._stage;
};


/**
 * Returns the underlying {@link RenderLoop render loop}.
 * @return {RenderLoop}
 */
Viewer.prototype.renderLoop = function () {
  return this._renderLoop;
};


/**
 * Returns the underlying {@link Controls controls}.
 * @return {Controls}
 */
Viewer.prototype.controls = function () {
  return this._controls;
};


/**
 * Returns the underlying DOM element.
 * @return {Element}
 */
Viewer.prototype.domElement = function () {
  return this._domElement;
};


/**
 * Creates a new {@link Scene scene} with a single layer and adds it to the
 * viewer.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Scene}
 */
Viewer.prototype.createScene = function (opts) {
  opts = opts || {};

  var scene = this.createEmptyScene({ view: opts.view });

  scene.createLayer({
    source: opts.source,
    geometry: opts.geometry,
    depthmap: opts.depthmap,
    pinFirstLevel: opts.pinFirstLevel,
    textureStoreOpts: opts.textureStoreOpts,
    layerOpts: opts.layerOpts
  });

  return scene;
};


/**
 * Creates a new {@link Scene scene} with no layers and adds it to the viewer.
 *
 * Layers may be added to the scene by calling {@link Scene#createLayer}.
 * However, if the scene has a single layer, it is simpler to call
 * {@link Viewer#createScene} instead of this method.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @return {Scene}
 */
Viewer.prototype.createEmptyScene = function (opts) {
  opts = opts || {};

  var scene = new Scene(this, opts.view);
  this._scenes.push(scene);

  return scene;
};


Viewer.prototype._updateSceneLayers = function () {
  var i;
  var layer;

  var stage = this._stage;
  var currentScene = this._currentScene;
  var replacedScene = this._replacedScene;

  var oldLayers = stage.listLayers();

  // The stage contains layers from at most two scenes: the current one, on top,
  // and the one currently being switched away from, on the bottom.
  var newLayers = [];
  if (replacedScene) {
    newLayers = newLayers.concat(replacedScene.listLayers());
  }
  if (currentScene) {
    newLayers = newLayers.concat(currentScene.listLayers());
  }

  // A single layer can be added or removed from the scene at a time.
  if (Math.abs(oldLayers.length - newLayers.length) !== 1) {
    throw new Error('Stage and scene out of sync');
  }

  if (newLayers.length < oldLayers.length) {
    // A layer was removed.
    for (i = 0; i < oldLayers.length; i++) {
      layer = oldLayers[i];
      if (newLayers.indexOf(layer) < 0) {
        this._removeLayerFromStage(layer);
        break;
      }
    }
  }
  if (newLayers.length > oldLayers.length) {
    // A layer was added.
    for (i = 0; i < newLayers.length; i++) {
      layer = newLayers[i];
      if (oldLayers.indexOf(layer) < 0) {
        this._addLayerToStage(layer, i);
      }
    }
  }

  // TODO: When in the middle of a scene transition, call the transition update
  // function immediately to prevent an added layer from flashing with the wrong
  // opacity.
};


Viewer.prototype._addLayerToStage = function (layer, i) {
  // Pin the first level to ensure a fallback while the layer is visible.
  // Note that this is distinct from the `pinFirstLevel` option passed to
  // createScene(), which pins the layer even when it's not visible.
  layer.pinFirstLevel();
  this._stage.addLayer(layer, i);
};


Viewer.prototype._removeLayerFromStage = function (layer) {
  this._stage.removeLayer(layer);
  layer.unpinFirstLevel();
  layer.textureStore().clearNotPinned();
};


Viewer.prototype._addSceneEventListeners = function (scene) {
  scene.addEventListener('layerChange', this._layerChangeHandler);
  scene.addEventListener('viewChange', this._viewChangeHandler);
};


Viewer.prototype._removeSceneEventListeners = function (scene) {
  scene.removeEventListener('layerChange', this._layerChangeHandler);
  scene.removeEventListener('viewChange', this._viewChangeHandler);
};


/**
 * Destroys a {@link Scene scene} and removes it from the viewer.
 * @param {Scene} scene
 */
Viewer.prototype.destroyScene = function (scene) {
  var i = this._scenes.indexOf(scene);
  if (i < 0) {
    throw new Error('No such scene in viewer');
  }

  var j;
  var layers;

  if (this._currentScene === scene) {
    // The destroyed scene is the current scene.
    // Remove event listeners, remove layers from stage and cancel transition.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    if (this._cancelCurrentTween) {
      this._cancelCurrentTween();
      this._cancelCurrentTween = null;
    }
    this._currentScene = null;
    this.emit('sceneChange');
  }

  if (this._replacedScene === scene) {
    // The destroyed scene is being switched away from.
    // Remove event listeners and remove layers from stage.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    this._replacedScene = null;
  }

  this._scenes.splice(i, 1);

  scene.destroy();
};


/**
 * Destroys all {@link Scene scenes} and removes them from the viewer.
 */
Viewer.prototype.destroyAllScenes = function () {
  while (this._scenes.length > 0) {
    this.destroyScene(this._scenes[0]);
  }
};


/**
 * Returns whether the viewer contains a {@link Scene scene}.
 * @param {Scene} scene
 * @return {boolean}
 */
Viewer.prototype.hasScene = function (scene) {
  return this._scenes.indexOf(scene) >= 0;
};


/**
 * Returns a list of all {@link Scene scenes}.
 * @return {Scene[]}
 */
Viewer.prototype.listScenes = function () {
  return [].concat(this._scenes);
};


/**
 * Returns the current {@link Scene scene}, or null if there isn't one.
 *
 * To change the current scene, call {@link Viewer#switchScene}.
 *
 * @return {Scene}
 */
Viewer.prototype.scene = function () {
  return this._currentScene;
};


/**
 * Returns the {@link View view} for the current {@link Scene scene}, or null
 * if there isn't one.
 * @return {View}
 */
Viewer.prototype.view = function () {
  var scene = this._currentScene;
  if (scene) {
    return scene.view();
  }
  return null;
};


/**
 * Tweens the {@link View view} for the current {@link Scene scene}.
 *
 * This method is equivalent to calling {@link Scene#lookTo} on the current
 * scene.
 *
 * @param {Object} opts Options to pass into {@link Scene#lookTo}.
 * @param {function} done Function to call when the tween is complete.
 */
Viewer.prototype.lookTo = function (params, opts, done) {
  // TODO: is it an error to call lookTo when no scene is displayed?
  var scene = this._currentScene;
  if (scene) {
    scene.lookTo(params, opts, done);
  }
};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * This method is equivalent to calling {@link Scene#startMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Viewer.prototype.startMovement = function (fn, done) {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.startMovement(fn, done);
};


/**
 * Stops the current movement.
 *
 * This method is equivalent to calling {@link Scene#stopMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 */
Viewer.prototype.stopMovement = function () {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.stopMovement();
};


/**
 * Returns the current movement.
 *
 * This method is equivalent to calling {@link Scene#movement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @return {function}
 */
Viewer.prototype.movement = function () {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  return scene.movement();
};


/**
 * Schedules an idle movement to be automatically started when the view remains
 * unchanged for the given timeout period.
 *
 * Changing the view while the idle movement is active stops the movement and
 * schedules it to start again after the same timeout period. To disable it
 * permanently, call with a null movement or an infinite timeout.
 *
 * @param {number} timeout Timeout period in milliseconds.
 * @param {function} movement Automatic movement function, or null to disable.
 */
Viewer.prototype.setIdleMovement = function (timeout, movement) {
  this._idleTimer.setDuration(timeout);
  this._idleMovement = movement;
};


/**
 * Stops the idle movement. It will be started again after the timeout set by
 * {@link Viewer#setIdleMovement}.
 */
Viewer.prototype.breakIdleMovement = function () {
  this.stopMovement();
  this._resetIdleTimer();
};


Viewer.prototype._resetIdleTimer = function () {
  this._idleTimer.start();
};


Viewer.prototype._triggerIdleTimer = function () {
  var idleMovement = this._idleMovement;
  if (!idleMovement) {
    return;
  }
  this.startMovement(idleMovement);
};


var defaultSwitchDuration = 1000;

function defaultTransitionUpdate(val, newScene, oldScene) {
  var layers = newScene.listLayers();
  layers.forEach(function (layer) {
    layer.mergeEffects({ opacity: val });
  });

  newScene._hotspotContainer.domElement().style.opacity = val;
}


/**
 * Switches to another {@link Scene scene} with a fade transition. This scene
 * becomes the current one.
 *
 * If a transition is already taking place, it is interrupted before the new one
 * starts.
 *
 * @param {Scene} newScene The scene to switch to.
 * @param {Object} opts Transition options.
 * @param {number} [opts.transitionDuration=1000] Transition duration, in
 *     milliseconds.
 * @param {number} [opts.transitionUpdate=defaultTransitionUpdate]
 *     Transition update function, with signature `f(t, newScene, oldScene)`.
 *     This function is called on each frame with `t` increasing from 0 to 1.
 *     An initial call with `t=0` and a final call with `t=1` are guaranteed.
 *     The default function sets the opacity of the new scene to `t`.
 * @param {function} done Function to call when the transition finishes or is
 *     interrupted. If the new scene is equal to the old one, no transition
 *     takes place, but this function is still called.
 */
Viewer.prototype.switchScene = function (newScene, opts, done) {
  var self = this;

  opts = opts || {};
  done = done || noop;

  var stage = this._stage;

  var oldScene = this._currentScene;

  // Do nothing if the target scene is the current one.
  if (oldScene === newScene) {
    done();
    return;
  }

  if (this._scenes.indexOf(newScene) < 0) {
    throw new Error('No such scene in viewer');
  }

  // Cancel an already ongoing transition. This ensures that the stage contains
  // layers from exactly one scene before the transition begins.
  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
    this._cancelCurrentTween = null;
  }

  var oldSceneLayers = oldScene ? oldScene.listLayers() : [];
  var newSceneLayers = newScene.listLayers();
  var stageLayers = stage.listLayers();

  // Check that the stage contains exactly as many layers as the current scene,
  // and that the top layer is the right one. If this test fails, either there
  // is a bug or the user tried to modify the stage concurrently.
  if (oldScene && ((stageLayers.length !== oldSceneLayers.length) ||
    (stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0]))) {
    throw new Error('Stage not in sync with viewer');
  }

  // Get the transition parameters.
  var duration = opts.transitionDuration != null ?
    opts.transitionDuration : defaultSwitchDuration;
  var update = opts.transitionUpdate != null ?
    opts.transitionUpdate : defaultTransitionUpdate;

  // Add new scene layers into the stage before starting the transition.
  for (var i = 0; i < newSceneLayers.length; i++) {
    this._addLayerToStage(newSceneLayers[i]);
  }

  // Update function to be called on every frame.
  function tweenUpdate(val) {
    update(val, newScene, oldScene);
  }

  // Once the transition is complete, remove old scene layers from the stage and
  // remove the event listeners. If the old scene was destroyed during the
  // transition, this has already been taken care of. Otherwise, we still need
  // to get a fresh copy of the scene's layers, since they might have changed
  // during the transition.
  function tweenDone() {
    if (self._replacedScene) {
      self._removeSceneEventListeners(self._replacedScene);
      oldSceneLayers = self._replacedScene.listLayers();
      for (var i = 0; i < oldSceneLayers.length; i++) {
        self._removeLayerFromStage(oldSceneLayers[i]);
      }
      self._replacedScene = null;
    }
    self._cancelCurrentTween = null;
    done();
  }

  // Store the cancelable for the transition.
  this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);

  // Update the current and replaced scene.
  this._currentScene = newScene;
  this._replacedScene = oldScene;

  // Emit scene and view change events.
  this.emit('sceneChange');
  this.emit('viewChange');

  // Add event listeners to the new scene.
  // Note that event listeners can only be removed from the old scene once the
  // transition is complete, since layers might get added or removed in the
  // interim.
  this._addSceneEventListeners(newScene);
};


module.exports = Viewer;

},{"./RenderLoop":20,"./Scene":21,"./Timer":24,"./controls/ControlCursor":37,"./controls/Controls":38,"./controls/HammerGestures":42,"./controls/registerDefaultControls":48,"./renderers/registerDefaultRenderers":63,"./stages/WebGl":74,"./util/clearOwnProperties":80,"./util/dom":89,"./util/noop":96,"./util/tween":104,"minimal-event-emitter":14}],26:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('./Static');
var inherits = require('../util/inherits');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class DynamicAsset
 * @implements Asset
 * @extends StaticAsset
 * @classdesc
 *
 * An {@link Asset} whose pixel contents may change.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function DynamicAsset(element) {
  this.constructor.super_.call(this, element);
  this._timestamp = 0;
}

inherits(DynamicAsset, StaticAsset);
eventEmitter(DynamicAsset);

/**
 * Destructor.
 */
DynamicAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

DynamicAsset.prototype.timestamp = function() {
  return this._timestamp;
};

DynamicAsset.prototype.isDynamic = function() {
  return true;
};

/**
 * Marks the asset dirty, signaling that the contents of the underlying pixel
 * source have changed.
 *
 * @throws If the asset is not dynamic.
 */
DynamicAsset.prototype.markDirty = function() {
  this._timestamp++;
  this.emit('change');
};

module.exports = DynamicAsset;

},{"../util/clearOwnProperties":80,"../util/inherits":93,"./Static":27,"minimal-event-emitter":14}],27:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var global = require('../util/global');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

var propertyMap = {
  HTMLImageElement: ['naturalWidth', 'naturalHeight'],
  HTMLCanvasElement: ['width', 'height'],
  ImageBitmap: ['width', 'height']
};

/**
 * @class StaticAsset
 * @implements Asset
 * @classdesc
 *
 * An {@link Asset} whose pixel contents never change.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function StaticAsset(element) {
  var supported = false;
  for (var type in propertyMap) {
    if (global[type] && element instanceof global[type]) {
      supported = true;
      this._widthProp = propertyMap[type][0];
      this._heightProp = propertyMap[type][1];
      break;
    }
  }
  if (!supported) {
    throw new Error('Unsupported pixel source');
  }

  this._element = element;
}

eventEmitter(StaticAsset);

/**
 * Destructor.
 */
StaticAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

StaticAsset.prototype.element = function() {
  return this._element;
};

StaticAsset.prototype.width = function() {
  return this._element[this._widthProp];
};

StaticAsset.prototype.height = function() {
  return this._element[this._heightProp];
};

StaticAsset.prototype.timestamp = function() {
  return 0;
};

StaticAsset.prototype.isDynamic = function() {
  return false;
};

module.exports = StaticAsset;

},{"../util/clearOwnProperties":80,"../util/global":91,"minimal-event-emitter":14}],28:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('./util/defaults');

var defaultSpeed = 0.1;
var defaultAccel = 0.01;

var defaultOptions = {
  yawSpeed: defaultSpeed,
  pitchSpeed: defaultSpeed,
  fovSpeed: defaultSpeed,
  yawAccel: defaultAccel,
  pitchAccel: defaultAccel,
  fovAccel: defaultAccel,
  targetPitch: 0,
  targetFov: null
};

/**
 * @param {Object} opts
 * @param {Number} [opts.yawSpeed=0.1] Yaw maximum speed
 * @param {Number} [opts.pitchSpeed=0.1] Pitch maximum speed
 * @param {Number} [opts.fovSpeed=0.1] Fov maximum speed
 * @param {Number} [opts.yawAccel=0.01] Yaw acceleration
 * @param {Number} [opts.pitchAccel=0.01] Pitch acceleration
 * @param {Number} [opts.fovAccel=0.01] Fov acceleration
 * @param {Number} [opts.targetPitch=0] Value that pitch converges to. `null` means that the pitch will not change.
 * @param {Number} [opts.targetFov=null] Value that fov converges to. `null` means that the fov will not change.
 * @returns Movement function that can be passed to {@link Viewer#setIdleMovement} or {@link Scene#startMovement}
*/
function autorotate(opts) {

  opts = defaults(opts || {}, defaultOptions);

  var yawSpeed = opts.yawSpeed;
  var pitchSpeed = opts.pitchSpeed;
  var fovSpeed = opts.fovSpeed;
  var yawAccel = opts.yawAccel;
  var pitchAccel = opts.pitchAccel;
  var fovAccel = opts.fovAccel;
  var targetPitch = opts.targetPitch;
  var targetFov = opts.targetFov;

  return function start() {

    var lastTime = 0;
    var lastYawSpeed = 0;
    var lastPitchSpeed = 0;
    var lastFovSpeed = 0;

    var currentYawSpeed = 0;
    var currentPitchSpeed = 0;
    var currentFovSpeed = 0;

    var timeDelta;
    var yawDelta;
    var pitchDelta;
    var fovDelta;

    return function step(params, currentTime) {

      timeDelta = (currentTime - lastTime) / 1000;
      currentYawSpeed = Math.min(lastYawSpeed + timeDelta * yawAccel, yawSpeed);
      yawDelta = currentYawSpeed * timeDelta;
      params.yaw = params.yaw + yawDelta;

      if (targetPitch != null && params.pitch !== targetPitch) {
        var pitchThresh = 0.5 * lastPitchSpeed * lastPitchSpeed / pitchAccel;
        if (Math.abs(targetPitch - params.pitch) > pitchThresh) {
          // Acceleration phase
          currentPitchSpeed = Math.min(lastPitchSpeed + timeDelta * pitchAccel, pitchSpeed);
        } else {
          // Deceleration phase
          currentPitchSpeed = Math.max(lastPitchSpeed - timeDelta * pitchAccel, 0);
        }
        // currentPitchSpeed is the absolute value (>= 0)
        pitchDelta = currentPitchSpeed * timeDelta;
        if (targetPitch < params.pitch) {
          params.pitch = Math.max(targetPitch, params.pitch - pitchDelta);
        }
        if (targetPitch > params.pitch) {
          params.pitch = Math.min(targetPitch, params.pitch + pitchDelta);
        }
      }

      if (targetFov != null && params.fov !== targetPitch) {
        var fovThresh = 0.5 * lastFovSpeed * lastFovSpeed / fovAccel;
        if (Math.abs(targetFov - params.fov) > fovThresh) {
          // Acceleration phase
          currentFovSpeed = Math.min(lastFovSpeed + timeDelta * fovAccel, fovSpeed);
        } else {
          // Deceleration phase
          currentFovSpeed = Math.max(lastFovSpeed - timeDelta * fovAccel, 0);
        }
        // currentFovSpeed is the absolute value (>= 0)
        fovDelta = currentFovSpeed * timeDelta;
        if (targetFov < params.fov) {
          params.fov = Math.max(targetFov, params.fov - fovDelta);
        }
        if (targetFov > params.fov) {
          params.fov = Math.min(targetFov, params.fov + fovDelta);
        }
      }

      lastTime = currentTime;
      lastYawSpeed = currentYawSpeed;
      lastPitchSpeed = currentPitchSpeed;
      lastFovSpeed = currentFovSpeed;

      return params;

    };

  };

}

module.exports = autorotate;
},{"./util/defaults":85}],29:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruMap holds up to a maximum number of key-value pairs, ordered by their
// time of insertion. When the addition of a key-value pair would cause the
// capacity to be exceeded, the oldest key-value pair in the set is evicted.
// As a special case, an LruMap with zero capacity always rejects the insertion
// of a key-value pair.
//
// Keys must implement hash() and equals(). Note that the implementation doesn't
// currently use hash(), but a future version might.
function LruMap(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruMap: invalid capacity');
  }
  this._capacity = capacity;

  // Keys and values are stored in circular arrays ordered by decreasing age.
  // Start is the index of the oldest key/value and size is the number of valid
  // key/values; the region containing valid keys/values may wrap around.
  this._keys = new Array(this._capacity);
  this._values = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruMap.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Returns the value associated to the specified key, or null if not found.
LruMap.prototype.get = function(key) {
  for (var i = 0; i < this._size; i++) {
    var existingKey = this._keys[this._index(i)];
    if (key.equals(existingKey)) {
      return this._values[this._index(i)];
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value. The key-value pair becomes the newest. If the map
// is at capacity, the oldest key-value pair is removed. Returns the removed
// key, or null otherwise. If the capacity is zero, does nothing and returns
// the key.
LruMap.prototype.set = function(key, value) {
  if (this._capacity === 0) {
    return key;
  }
  this.del(key);
  var evictedKey =
      this._size === this._capacity ? this._keys[this._index(0)] : null;
  this._keys[this._index(this._size)] = key;
  this._values[this._index(this._size)] = value;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedKey;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
LruMap.prototype.del = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      var existingValue = this._values[this._index(i)];
      for (var j = i; j < this._size - 1; j++) {
        this._keys[this._index(j)] = this._keys[this._index(j + 1)];
        this._values[this._index(j)] = this._values[this._index(j + 1)];
      }
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
LruMap.prototype.has = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
LruMap.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
LruMap.prototype.clear = function() {
  this._keys.length = 0;
  this._values.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(key, value) for each item in the map, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
LruMap.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._keys[this._index(i)], this._values[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruMap;

},{"../util/mod":95}],30:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruSet holds up to a maximum number of elements, ordered by their time of
// insertion. When the addition of an element would cause the capacity to be
// exceeded, the oldest element in the set is evicted. As a special case, an
// LruSet with zero capacity always rejects the insertion of an element.
//
// Elements must implement hash() and equals(). Note that the implementation
// doesn't currently use hash(), but a future version might.
function LruSet(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruSet: invalid capacity');
  }
  this._capacity = capacity;

  // Elements are stored in a circular array ordered by decreasing age.
  // Start is the index of the oldest element and size is the number of valid
  // elements; the region containing valid elements may wrap around.
  this._elements = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruSet.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Adds an element into the set, possibly replacing an equal element already in
// the set. The element becomes the newest. If the set is at capacity, the
// oldest element is removed. Returns the removed element if it does not equal
// the inserted element, or null otherwise. If the capacity is zero, does
// nothing and returns the element.
LruSet.prototype.add = function(element) {
  if (this._capacity === 0) {
    return element;
  }
  this.remove(element);
  var evictedElement =
      this._size === this._capacity ? this._elements[this._index(0)] : null;
  this._elements[this._index(this._size)] = element;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedElement;
};

// Removes an element from the set.
// Returns the removed element, or null if the element was not found.
LruSet.prototype.remove = function(element) {
  for (var i = 0; i < this._size; i++) {
    var existingElement = this._elements[this._index(i)];
    if (element.equals(existingElement)) {
      for (var j = i; j < this._size - 1; j++) {
        this._elements[this._index(j)] = this._elements[this._index(j + 1)];
      }
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
LruSet.prototype.has = function(element) {
  for (var i = 0; i < this._size; i++) {
    if (element.equals(this._elements[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
LruSet.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
LruSet.prototype.clear = function() {
  this._elements.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
LruSet.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._elements[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruSet;

},{"../util/mod":95}],31:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A map data structure for keys implementing hash() and equals() and arbitrary
// values. The capacity, if given, is just a hint; the map is allowed to exceed
// it, but performance may suffer.
function Map(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Map: invalid capacity');
  }
  this._capacity = capacity || defaultCapacity;

  this._keyBuckets = [];
  this._valBuckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets.push([]);
    this._valBuckets.push([]);
  }
  this._size = 0;
}

// Returns the value associated with the specified key, or null if not found.
Map.prototype.get = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var valBucket = this._valBuckets[h];
      var existingValue = valBucket[i];
      return existingValue;
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value.
// Returns the replaced value, or null if no value was replaced.
Map.prototype.set = function(key, val) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      keyBucket[i] = key;
      valBucket[i] = val;
      return existingValue;
    }
  }
  keyBucket.push(key);
  valBucket.push(val);
  this._size++;
  return null;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
Map.prototype.del = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < keyBucket.length - 1; j++) {
        keyBucket[j] = keyBucket[j+1];
        valBucket[j] = valBucket[j+1];
      }
      keyBucket.length = keyBucket.length - 1;
      valBucket.length = valBucket.length - 1;
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
Map.prototype.has = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
Map.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
Map.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets[i].length = 0;
    this._valBuckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(key, value) for each key-value pair in the map, in an unspecified
// order. Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
Map.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var keyBucket = this._keyBuckets[i];
    var valBucket = this._valBuckets[i];
    for (var j = 0; j < keyBucket.length; j++) {
      fn(keyBucket[j], valBucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Map;

},{"../util/mod":95}],32:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A set data structure for elements implementing hash() and equals().
// The capacity, if given, is just a hint; the set is allowed to exceed it, but
// performance may suffer.
function Set(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Set: invalid capacity');
  }
  this._capacity = this._capacity || defaultCapacity;

  this._buckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._buckets.push([]);
  }
  this._size = 0;
}

// Adds an element, replacing an existing element.
// Returns the replaced element, or null if no element was replaced.
Set.prototype.add = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      bucket[i] = element;
      return existingElement;
    }
  }
  bucket.push(element);
  this._size++;
  return null;
};

// Removes an element.
// Returns the removed element, or null if the element was not found.
Set.prototype.remove = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < bucket.length - 1; j++) {
        bucket[j] = bucket[j+1];
      }
      bucket.length = bucket.length - 1;
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
Set.prototype.has = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
Set.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
Set.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._buckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
Set.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var bucket = this._buckets[i];
    for (var j = 0; j < bucket.length; j++) {
      fn(bucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Set;

},{"../util/mod":95}],33:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WorkQueue = require('./WorkQueue');
var mod = require('../util/mod');


function WorkPool(opts) {
  this._concurrency = opts && opts.concurrency || 1;
  this._paused = opts && !!opts.paused || false;

  this._pool = [];
  for (var i = 0; i < this._concurrency; i++) {
    this._pool.push(new WorkQueue(opts));
  }

  this._next = 0;
}


WorkPool.prototype.length = function() {
  var len = 0;
  for (var i = 0; i < this._pool.length; i++) {
    len += this._pool[i].length();
  }
  return len;
};


WorkPool.prototype.push = function(fn, cb) {
  var i = this._next;
  var cancel = this._pool[i].push(fn, cb);
  this._next = mod(this._next + 1, this._concurrency);
  return cancel;
};


WorkPool.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].pause();
    }
  }
};


WorkPool.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].resume();
    }
  }
};


module.exports = WorkPool;

},{"../util/mod":95,"./WorkQueue":34}],34:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('../util/now');


function WorkTask(fn, cb) {
  this.fn = fn;
  this.cb = cb;
  this.cfn = null;
}


function WorkQueue(opts) {
  this._queue = [];
  this._delay = opts && opts.delay || 0;
  this._paused = opts && !!opts.paused || false;
  this._currentTask = null;
  this._lastFinished = null;
}


WorkQueue.prototype.length = function() {
  return this._queue.length;
};


WorkQueue.prototype.push = function(fn, cb) {

  var task = new WorkTask(fn, cb);

  var cancel = this._cancel.bind(this, task);

  // Push the task into the queue.
  this._queue.push(task);

  // Run the task if idle.
  this._next();

  return cancel;

};


WorkQueue.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
  }
};


WorkQueue.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    this._next();
  }
};


WorkQueue.prototype._start = function(task) {

  // Consistency check.
  if (this._currentTask) {
    throw new Error('WorkQueue: called start while running task');
  }

  // Mark queue as busy, so that concurrent tasks wait.
  this._currentTask = task;

  // Execute the task.
  var finish = this._finish.bind(this, task);
  task.cfn = task.fn(finish);

  // Detect when a non-cancellable function has been queued.
  if (typeof task.cfn !== 'function') {
    throw new Error('WorkQueue: function is not cancellable');
  }

};


WorkQueue.prototype._finish = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  // Consistency check.
  if (this._currentTask !== task) {
    throw new Error('WorkQueue: called finish on wrong task');
  }

  // Call the task callback on the return values.
  task.cb.apply(null, args);

  // Mark as not busy and record task finish time, then advance to next task.
  this._currentTask = null;
  this._lastFinished = now();
  this._next();

};


WorkQueue.prototype._cancel = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  if (this._currentTask === task) {

    // Cancel running task. Because cancel passes control to the _finish
    // callback we passed into fn, the cleanup logic will be handled there.
    task.cfn.apply(null, args);

  } else {

    // Remove task from queue.
    var pos = this._queue.indexOf(task);
    if (pos >= 0) {
      this._queue.splice(pos, 1);
      task.cb.apply(null, args);
    }

  }

};


WorkQueue.prototype._next = function() {

  if (this._paused) {
    // Do not start tasks while paused.
    return;
  }

  if (!this._queue.length) {
    // No tasks to run.
    return;
  }

  if (this._currentTask) {
    // Will be called again when the current task finishes.
    return;
  }

  if (this._lastFinished != null) {
    var elapsed = now() - this._lastFinished;
    var remaining = this._delay - elapsed;
    if (remaining > 0) {
      // Too soon. Run again after the inter-task delay.
      setTimeout(this._next.bind(this), remaining);
      return;
    }
  }

  // Run the next task.
  var task = this._queue.shift();
  this._start(task);

};


module.exports = WorkQueue;

},{"../util/now":97}],35:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var vec4 = require('gl-matrix').vec4;
var mat4 = require('gl-matrix').mat4;

/**
 * Helper functions for color transformation {@link Effects}.
 *
 * References:
 *
 *   - [ColorMatrix Guide](http://docs.rainmeter.net/tips/colormatrix-guide)
 *   - [Matrix Operations for Image Processing](http://www.graficaobscura.com/matrix/index.html)
 *   - [WebGLImageFilter](https://github.com/phoboslab/WebGLImageFilter)
 *   - [glfx.js](https://github.com/evanw/glfx.js)
 *
 * @namespace colorEffects
 */

/**
 * A vector and matrix corresponding to an identity transformation.
 *
 * @param {Object} result Object to store result
 * @param {vec4} result.colorOffset Array with zeroes.
 * @param {mat4} result.colorMatrix Identity matrix.
 *
 * @memberof colorEffects
 */
function identity(resultArg) {
  var result = resultArg || {};
  result.colorOffset = result.colorOffset || vec4.create();
  result.colorMatrix = result.colorMatrix || mat4.create();
  return result;
}

/**
 * Apply color effects to a single pixel
 *
 * @param {vec4} pixel Values in range [0,1]
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 * @param {vec4} result Object to store result
 *
 * @memberof colorEffects
 */
function applyToPixel(pixel, effect, result) {
  vec4TransformMat4Transposed(result, pixel, effect.colorMatrix);
  vec4.add(result, result, effect.colorOffset);
}

// Oddly, the colorTransform matrix needs to be transposed to be used with
// vec4.transformMat4. It is strange that transformMat4 dosn't work the same
// way as multiplying on the shader.
// TODO: investigate this further
function vec4TransformMat4Transposed(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
  out[1] = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
  out[2] = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
  out[3] = m[12] * x + m[13] * y + m[14] * z + m[15] * w;
  return out;
}

/**
 * Apply color effects to an ImageData
 *
 * @param {ImageData} imageData This object will be mutated
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 *
 * @memberof colorEffects
 */
var tmpPixel = vec4.create();
function applyToImageData(imageData, effect) {
  var width = imageData.width;
  var height = imageData.height;
  var data = imageData.data;

  for(var i = 0; i < width * height; i++) {
    vec4.set(tmpPixel, data[i*4+0]/255, data[i*4+1]/255, data[i*4+2]/255, data[i*4+3]/255);
    applyToPixel(tmpPixel, effect, tmpPixel);
    data[i*4+0] = tmpPixel[0]*255;
    data[i*4+1] = tmpPixel[1]*255;
    data[i*4+2] = tmpPixel[2]*255;
    data[i*4+3] = tmpPixel[3]*255;
  }
}

module.exports = {
  identity: identity,
  applyToPixel: applyToPixel,
  applyToImageData: applyToImageData
};

},{"gl-matrix":3}],36:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var now = require('../util/now');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ControlComposer
 * @classdesc
 *
 * Combines changes in parameters triggered by multiple {@link ControlMethod}
 * instances.
 *
 * @listens ControlMethod#parameterDynamics
 */
function ControlComposer(opts) {
  opts = opts || {};

  this._methods = [];

  this._parameters = [ 'x' ,'y', 'axisScaledX', 'axisScaledY', 'zoom', 'yaw', 'pitch', 'roll' ];

  this._now = opts.nowForTesting || now;

  this._composedOffsets = { };

  this._composeReturn = { offsets: this._composedOffsets, changing: null };
}

eventEmitter(ControlComposer);


ControlComposer.prototype.add = function(instance) {
  if (this.has(instance)) {
    return;
  }

  var dynamics = {};
  this._parameters.forEach(function(parameter) {
    dynamics[parameter] = {
      dynamics: new Dynamics(),
      time: null
    };
  });

  var parameterDynamicsHandler = this._updateDynamics.bind(this, dynamics);

  var method = {
    instance: instance,
    dynamics: dynamics,
    parameterDynamicsHandler: parameterDynamicsHandler
  };

  instance.addEventListener('parameterDynamics', parameterDynamicsHandler);

  this._methods.push(method);
};


ControlComposer.prototype.remove = function(instance) {
  var index = this._indexOfInstance(instance);
  if (index >= 0) {
    var method = this._methods.splice(index, 1)[0];
    method.instance.removeEventListener('parameterDynamics', method.parameterDynamicsHandler);
  }
};


ControlComposer.prototype.has = function(instance) {
  return this._indexOfInstance(instance) >= 0;
};


ControlComposer.prototype._indexOfInstance = function(instance) {
  for (var i = 0; i < this._methods.length; i++) {
    if (this._methods[i].instance === instance) {
      return i;
    }
  }
  return -1;
};


ControlComposer.prototype.list = function() {
  var instances = [];
  for (var i = 0; i < this._methods.length; i++) {
    instances.push(this._methods[i].instance);
  }
  return instances;
};


ControlComposer.prototype._updateDynamics = function(storedDynamics, parameter, dynamics) {
  var parameterDynamics = storedDynamics[parameter];

  if (!parameterDynamics) {
    throw new Error("Unknown control parameter " + parameter);
  }

  var newTime = this._now();
  parameterDynamics.dynamics.update(dynamics, (newTime - parameterDynamics.time)/1000);
  parameterDynamics.time = newTime;

  this.emit('change');
};


ControlComposer.prototype._resetComposedOffsets = function() {
  for (var i = 0; i < this._parameters.length; i++) {
    this._composedOffsets[this._parameters[i]] = 0;
  }
};


ControlComposer.prototype.offsets = function() {
  var parameter;
  var changing = false;

  var currentTime = this._now();

  this._resetComposedOffsets();

  for (var i = 0; i < this._methods.length; i++) {
    var methodDynamics = this._methods[i].dynamics;

    for (var p = 0; p < this._parameters.length; p++) {
      parameter = this._parameters[p];
      var parameterDynamics = methodDynamics[parameter];
      var dynamics = parameterDynamics.dynamics;


      // Add offset to composed offset
      if (dynamics.offset != null) {
        this._composedOffsets[parameter] += dynamics.offset;
        // Reset offset
        dynamics.offset = null;
      }

      // Calculate offset from velocity and add it
      var elapsed = (currentTime - parameterDynamics.time)/1000;
      var offsetFromVelocity = dynamics.offsetFromVelocity(elapsed);

      if(offsetFromVelocity) {
        this._composedOffsets[parameter] += offsetFromVelocity;
      }

      // Update velocity on dynamics
      var currentVelocity = dynamics.velocityAfter(elapsed);
      dynamics.velocity = currentVelocity;

      // If there is still a velocity, set changing
      if(currentVelocity) {
        changing = true;
      }

      parameterDynamics.time = currentTime;
    }
  }

  this._composeReturn.changing = changing;
  return this._composeReturn;
};


ControlComposer.prototype.destroy = function() {
  var instances = this.list();
  for (var i = 0; i < instances.length; i++) {
    this.remove(instances[i]);
  }

  clearOwnProperties(this);
};


module.exports = ControlComposer;

},{"../util/clearOwnProperties":80,"../util/now":97,"./Dynamics":40,"minimal-event-emitter":14}],37:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOpts = {
  active: 'move',
  inactive: 'default',
  disabled: 'default'
};

/**
 * @class ControlCursor
 * @classdesc
 *
 * Sets the CSS cursor on a DOM element according to the state of a
 * {@link ControlMethod}.
 *
 * @param {Controls} controls Controls instance containing the control method.
 * @param {string} id ID of the control method.
 * @param {Element} element DOM element where the cursor should be set.
 * @param {Object} opts The control cursors. Each field must be a valid value
 *     for the `cursor` CSS property.
 * @param {string} [opts.active='move'] Cursor to set when the control method
 *     is enabled and active.
 * @param {string} [opts.inactive='default'] Cursor to set when the control
 *     method is enabled and inactive.
 * @param {string} [opts.disabled='default'] Cursor to set when the control
 *     method is disabled.
 */
function ControlCursor(controls, id, element, opts) {
  opts = defaults(opts || {}, defaultOpts);

  // TODO: This class may misbehave if the control method is unregistered and a
  // different control method is registered under the same id.

  this._element = element;
  this._controls = controls;
  this._id = id;

  this._attached = false;

  this._setActiveCursor = this._setCursor.bind(this, opts.active);
  this._setInactiveCursor = this._setCursor.bind(this, opts.inactive);
  this._setDisabledCursor = this._setCursor.bind(this, opts.disabled);
  this._setOriginalCursor = this._setCursor.bind(this, this._element.style.cursor);

  this._updateAttachmentHandler = this._updateAttachment.bind(this);

  controls.addEventListener('methodEnabled', this._updateAttachmentHandler);
  controls.addEventListener('methodDisabled', this._updateAttachmentHandler);
  controls.addEventListener('enabled', this._updateAttachmentHandler);
  controls.addEventListener('disabled', this._updateAttachmentHandler);

  this._updateAttachment();
}

/**
 * Destructor.
 */
ControlCursor.prototype.destroy = function() {
  this._detachFromControlMethod(this._controls.method(this._id));
  this._setOriginalCursor();

  this._controls.removeEventListener('methodEnabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('methodDisabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('enabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('disabled',
      this._updateAttachmentHandler);

  clearOwnProperties(this);
};

ControlCursor.prototype._updateAttachment = function() {
  var controls = this._controls;
  var id = this._id;
  if (controls.enabled() && controls.method(id).enabled) {
    this._attachToControlMethod(controls.method(id));
  } else {
    this._detachFromControlMethod(controls.method(id));
  }
};

ControlCursor.prototype._attachToControlMethod = function(controlMethod) {
  if (!this._attached) {
    controlMethod.instance.addEventListener('active', this._setActiveCursor);
    controlMethod.instance.addEventListener('inactive', this._setInactiveCursor);

    if (controlMethod.active) {
      this._setActiveCursor();
    } else {
      this._setInactiveCursor();
    }

    this._attached = true;
  }
};

ControlCursor.prototype._detachFromControlMethod = function(controlMethod) {
  if (this._attached) {
    controlMethod.instance.removeEventListener('active', this._setActiveCursor);
    controlMethod.instance.removeEventListener('inactive', this._setInactiveCursor);

    this._setDisabledCursor();

    this._attached = false;
  }
};

ControlCursor.prototype._setCursor = function(cursor) {
  this._element.style.cursor = cursor;
}

module.exports = ControlCursor;

},{"../util/clearOwnProperties":80,"../util/defaults":85}],38:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Composer = require('./Composer');
var clearOwnProperties = require('../util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class Controls
 * @classdesc
 *
 * Set of controls which affect a view (e.g. keyboard, touch)
 *
 * {@link ControlMethod} instances can be registered on this class. The methods
 * are then combined to calculate the final parameters to change the {@link View}.
 *
 * Controls is attached to a {@link RenderLoop}. Currently it affects the
 * {@link view} of all {@link Layer} on the {@link Stage} of the
 * {@link RenderLoop} it is attached to. A more flexible API may be provided
 * in the future.
 *
 * The ControlMethod instances are registered with an id and may be enabled,
 * disabled and unregistered using that id. The whole Control can also be
 * enabled or disabled.
 *
 */
function Controls(opts) {
  opts = opts || {};

  this._methods = {};
  this._methodGroups = {};
  this._composer = new Composer();

  // Whether the controls are enabled.
  this._enabled = (opts && opts.enabled) ? !!opts.enabled : true;

  // How many control methods are enabled and in the active state.
  this._activeCount = 0;

  this.updatedViews_ = [];

  this._attachedRenderLoop = null;
}

eventEmitter(Controls);

/**
 * Destructor.
 */
Controls.prototype.destroy = function() {
  this.detach();
  this._composer.destroy();
  clearOwnProperties(this);
};


/**
 * @return {ControlMethod[]} List of registered @{link ControlMethod instances}
 */
Controls.prototype.methods = function() {
  var obj = {};
  for (var id in this._methods) {
    obj[id] = this._methods[id];
  }
  return obj;
};

/**
 * @param {String} id
 * @return {ControlMethod}
 */
Controls.prototype.method = function(id) {
  return this._methods[id];
};

/**
 * @param {String} id
 * @param {ControlMethod} instance
 * @param {Boolean} [enable=false]
 */
Controls.prototype.registerMethod = function(id, instance, enable) {
  if (this._methods[id]) {
    throw new Error('Control method already registered with id ' + id);
  }

  this._methods[id] = {
    instance: instance,
    enabled: false,
    active: false,
    activeHandler: this._handleActive.bind(this, id),
    inactiveHandler: this._handleInactive.bind(this, id)
  };

  if(enable) {
    this.enableMethod(id, instance);
  }
};


/**
 * @param {String} id
 */
Controls.prototype.unregisterMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    this.disableMethod(id);
  }
  delete this._methods[id];
};

/**
 * @param {String} id
 */
Controls.prototype.enableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    return;
  }
  method.enabled = true;
  if (method.active) {
    this._incrementActiveCount();
  }
  this._listen(id);
  this._updateComposer();
  this.emit('methodEnabled', id);
};


/**
 * @param {String} id
 */
Controls.prototype.disableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (!method.enabled) {
    return;
  }
  method.enabled = false;
  if (method.active) {
    this._decrementActiveCount();
  }
  this._unlisten(id);
  this._updateComposer();
  this.emit('methodDisabled', id);
};


/**
 * Create a method group, which can be used to more conveniently enable or
 * disable several control methods at once
 * @param {String} groupId
 * @param {String[]} methodIds
 */
Controls.prototype.addMethodGroup = function(groupId, methodIds) {
  this._methodGroups[groupId] = methodIds;
}

/**
 * @param {String} groupId
 */
Controls.prototype.removeMethodGroup = function(id) {
  delete this._methodGroups[id];
}

/**
 * @return {ControlMethodGroup[]} List of control method groups
 */
Controls.prototype.methodGroups = function() {
  var obj = {};
  for (var id in this._methodGroups) {
    obj[id] = this._methodGroups[id];
  }
  return obj;
}

/**
 * Enables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.enableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.enableMethod(methodId);
  });
}

/**
 * Disables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.disableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.disableMethod(methodId);
  });
}

/**
 * @returns {Boolean}
 */
Controls.prototype.enabled = function() {
  return this._enabled;
};

/**
 * Enables the controls
 */
Controls.prototype.enable = function() {
  if (this._enabled) {
    return;
  }
  this._enabled = true;
  if (this._activeCount > 0) {
    this.emit('active');
  }
  this.emit('enabled');
  this._updateComposer();
};


/**
 * Disables the controls
 */
Controls.prototype.disable = function() {
  if (!this._enabled) {
    return;
  }
  this._enabled = false;
  if (this._activeCount > 0) {
    this.emit('inactive');
  }
  this.emit('disabled');
  this._updateComposer();
};



/**
 * Attaches the controls to a {@link RenderLoop}. The RenderLoop will be woken
 * up when the controls are activated
 *
 * @param {RenderLoop}
 */
Controls.prototype.attach = function(renderLoop) {
  if (this._attachedRenderLoop) {
    this.detach();
  }

  this._attachedRenderLoop = renderLoop;
  this._beforeRenderHandler = this._updateViewsWithControls.bind(this);
  this._changeHandler = renderLoop.renderOnNextFrame.bind(renderLoop);

  this._attachedRenderLoop.addEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.addEventListener('change', this._changeHandler);
};

/**
 * Detaches the controls
 */
Controls.prototype.detach = function() {
  if (!this._attachedRenderLoop) {
    return;
  }

  this._attachedRenderLoop.removeEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.removeEventListener('change', this._changeHandler);

  this._beforeRenderHandler = null;
  this._changeHandler = null;
  this._attachedRenderLoop = null;
};

/**
 * @param {Boolean}
 */
Controls.prototype.attached = function() {
  return this._attachedRenderLoop != null;
};


Controls.prototype._listen = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.addEventListener('active', method.activeHandler);
  method.instance.addEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._unlisten = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.removeEventListener('active', method.activeHandler);
  method.instance.removeEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._handleActive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (!method.active) {
    method.active = true;
    this._incrementActiveCount();
  }
};


Controls.prototype._handleInactive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (method.active) {
    method.active = false;
    this._decrementActiveCount();
  }
};


Controls.prototype._incrementActiveCount = function() {
  this._activeCount++;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 1) {
    this.emit('active');
  }
};


Controls.prototype._decrementActiveCount = function() {
  this._activeCount--;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 0) {
    this.emit('inactive');
  }
};


Controls.prototype._checkActiveCount = function() {
  var count = 0;
  for (var id in this._methods) {
    var method = this._methods[id];
    if (method.enabled && method.active) {
      count++;
    }
  }
  if (count != this._activeCount) {
    throw new Error('Bad control state');
  }
};


Controls.prototype._updateComposer = function() {
  var composer = this._composer;

  for (var id in this._methods) {
    var method = this._methods[id];
    var enabled = this._enabled && method.enabled;

    if (enabled && !composer.has(method.instance)) {
      composer.add(method.instance);
    }
    if (!enabled && composer.has(method.instance)) {
      composer.remove(method.instance);
    }
  }
};


Controls.prototype._updateViewsWithControls = function() {
  var controlData = this._composer.offsets();
  if (controlData.changing) {
    this._attachedRenderLoop.renderOnNextFrame();
  }

  // Update each view at most once, even when shared by multiple layers.
  // The number of views is expected to be small, so use an array to keep track.
  this.updatedViews_.length = 0;

  var layers = this._attachedRenderLoop.stage().listLayers();
  for (var i = 0; i < layers.length; i++) {
    var view = layers[i].view();
    if (this.updatedViews_.indexOf(view) < 0) {
      layers[i].view().updateWithControlParameters(controlData.offsets);
      this.updatedViews_.push(view);
    }
  }
};


module.exports = Controls;

},{"../util/clearOwnProperties":80,"./Composer":36,"minimal-event-emitter":14}],39:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  friction: 6,
  maxFrictionTime: 0.3,
  hammerEvent: 'pan'
};

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class DragControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by clicking/tapping and dragging.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 * @param {'pan'|'pinch'} opts.hammerEvent
 */
function DragControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._startEvent = null;
  this._lastEvent = null;

  this._active = false;

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer = HammerGestures.get(element, pointerType);

  this._hammer.on("hammer.input", this._handleHammerEvent.bind(this));

  if (this._opts.hammerEvent != 'pan' && this._opts.hammerEvent != 'pinch') {
    throw new Error(this._opts.hammerEvent + ' is not a hammerEvent managed in DragControlMethod');
  }

  this._hammer.on(this._opts.hammerEvent + 'start', this._handleStart.bind(this));
  this._hammer.on(this._opts.hammerEvent + 'move', this._handleMove.bind(this));
  this._hammer.on(this._opts.hammerEvent + 'end', this._handleEnd.bind(this));
  this._hammer.on(this._opts.hammerEvent + 'cancel', this._handleEnd.bind(this));
}

eventEmitter(DragControlMethod);

/**
 * Destructor.
 */
DragControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};

DragControlMethod.prototype._handleHammerEvent = function(e) {
  if (e.isFirst) {
    if (debug && this._active) {
      throw new Error('DragControlMethod active detected when already active');
    }
    this._active = true;
    this.emit('active');
  }
  if (e.isFinal) {
    if (debug && !this._active) {
      throw new Error('DragControlMethod inactive detected when already inactive');
    }
    this._active = false;
    this.emit('inactive');
  }
};

DragControlMethod.prototype._handleStart = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  this._startEvent = e;
};


DragControlMethod.prototype._handleMove = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsMove(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }
};


DragControlMethod.prototype._handleEnd = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsRelease(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }

  this._startEvent = false;
  this._lastEvent = false;
};


DragControlMethod.prototype._updateDynamicsMove = function(e) {
  var x = e.deltaX;
  var y = e.deltaY;

  // When a second finger touches the screen, panstart sometimes has a large
  // offset at start; subtract that offset to prevent a sudden jump.
  var eventToSubtract = this._lastEvent || this._startEvent;

  if (eventToSubtract) {
    x -= eventToSubtract.deltaX;
    y -= eventToSubtract.deltaY;
  }

  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  x /= width;
  y /= height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.offset = -x;
  this._dynamics.y.offset = -y;

  this._lastEvent = e;
};


var tmpReleaseFriction = [ null, null ];
DragControlMethod.prototype._updateDynamicsRelease = function(e) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  var x = 1000 * e.velocityX / width;
  var y = 1000 * e.velocityY / height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
  this._dynamics.x.friction = tmpReleaseFriction[0];
  this._dynamics.y.friction = tmpReleaseFriction[1];
};


module.exports = DragControlMethod;

},{"../util/clearOwnProperties":80,"../util/defaults":85,"./Dynamics":40,"./HammerGestures":42,"./util":49,"minimal-event-emitter":14}],40:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class Dynamics
 * @classdesc
 *
 * Represents how a control parameter changes. Used in the events emitted by
 * {@link ControlMethod}.
 *
 * @property {number} offset Parameter changed by a fixed value
 * @property {number} velocity Parameter is changing at this velocity
 * @property {number} friction The velocity will decrease at this rate
 */
function Dynamics() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
}

Dynamics.equals = function(d1, d2) {
  return d1.velocity === d2.velocity && d1.friction === d2.friction && d1.offset === d2.offset;
};

Dynamics.prototype.equals = function(other) {
  return Dynamics.equals(this, other);
};

Dynamics.prototype.update = function(other, elapsed) {
  if (other.offset) {
    // If other has an offset, make this.offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += other.offset;
  }

  var offsetFromVelocity = this.offsetFromVelocity(elapsed);
  if (offsetFromVelocity) {
    // If there is an offset to add from the velocity, make this offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += offsetFromVelocity;
  }

  this.velocity = other.velocity;
  this.friction = other.friction;
};

Dynamics.prototype.reset = function() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
};


Dynamics.prototype.velocityAfter = function(elapsed) {
  if (!this.velocity) {
    return null;
  }
  if (this.friction) {
    return decreaseAbs(this.velocity, this.friction *elapsed);
  }
  return this.velocity;
};

Dynamics.prototype.offsetFromVelocity = function(elapsed) {
  elapsed = Math.min(elapsed, this.nullVelocityTime());

  var velocityEnd = this.velocityAfter(elapsed);
  var averageVelocity = (this.velocity + velocityEnd) / 2;

  return averageVelocity * elapsed;
};


Dynamics.prototype.nullVelocityTime = function() {
  if (this.velocity == null) {
    return 0;
  }
  if (this.velocity && !this.friction) {
    return Infinity;
  }
  return Math.abs(this.velocity / this.friction);
};

function decreaseAbs(num, dec) {
  if (num < 0) {
    return Math.min(0, num + dec);
  }
  if (num > 0) {
    return Math.max(0, num - dec);
  }
  return 0;
}

module.exports = Dynamics;

},{}],41:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ElementPressControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a DOM element.
 *
 * @param {Element} element Element which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
*/
function ElementPressControlMethod(element, parameter, velocity, friction) {
  if(!element) {
    throw new Error("ElementPressControlMethod: element must be defined");
  }
  if(!parameter) {
    throw new Error("ElementPressControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("ElementPressControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("ElementPressControlMethod: friction must be defined");
  }

  this._element = element;

  this._pressHandler = this._handlePress.bind(this);
  this._releaseHandler = this._handleRelease.bind(this);

  element.addEventListener('mousedown', this._pressHandler);
  element.addEventListener('mouseup', this._releaseHandler);
  element.addEventListener('mouseleave', this._releaseHandler);
  element.addEventListener('touchstart', this._pressHandler);
  element.addEventListener('touchmove', this._releaseHandler);
  element.addEventListener('touchend', this._releaseHandler);

  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._dynamics = new Dynamics();

  this._pressing = false;
}
eventEmitter(ElementPressControlMethod);

/**
 * Destructor.
 */
ElementPressControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('mousedown', this._pressHandler);
  this._element.removeEventListener('mouseup', this._releaseHandler);
  this._element.removeEventListener('mouseleave', this._releaseHandler);
  this._element.removeEventListener('touchstart', this._pressHandler);
  this._element.removeEventListener('touchmove', this._releaseHandler);
  this._element.removeEventListener('touchend', this._releaseHandler);
  clearOwnProperties(this);
};

ElementPressControlMethod.prototype._handlePress = function() {
  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

ElementPressControlMethod.prototype._handleRelease = function() {
  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

module.exports = ElementPressControlMethod;

},{"../util/clearOwnProperties":80,"./Dynamics":40,"minimal-event-emitter":14}],42:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Hammer = require('hammerjs');

var nextId = 1;
var idProperty = 'MarzipanoHammerElementId';
function getKeyForElementAndType(element, type) {
  if (!element[idProperty]) {
    element[idProperty] = nextId++;
  }
  return type + element[idProperty];
}


/**
 * @class HammerGestures
 * @classdesc
 *
 * Manages Hammer.js instances. One instance is created for each combination of
 * DOM element and pointer type.
 */
function HammerGestures() {
  this._managers = {};
  this._refCount = {};
}


HammerGestures.prototype.get = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (!this._managers[key]) {
    this._managers[key] = this._createManager(element, type);
    this._refCount[key] = 0;
  }
  this._refCount[key]++;
  return new HammerGesturesHandle(this, this._managers[key], element, type);
};


HammerGestures.prototype._createManager = function(element, type) {
  var manager = new Hammer.Manager(element);

  // Managers are created with different parameters for different pointer
  // types.
  if (type === 'mouse') {
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 0 }));
  }
  else if (type === 'touch' || type === 'pen' || type === 'kinect') {
    // On touch one wants to have both panning and pinching. The panning
    // recognizer needs a threshold to allow the pinch to be recognized.
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 20, pointers: 1 }));
    manager.add(new Hammer.Pinch());
  }

  return manager;
};


HammerGestures.prototype._releaseHandle = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (this._refCount[key]) {
    this._refCount[key]--;
    if (!this._refCount[key]) {
      this._managers[key].destroy();
      delete this._managers[key];
      delete this._refCount[key];
    }
  }
};


function HammerGesturesHandle(hammerGestures, manager, element, type) {
  this._manager = manager;
  this._element = element;
  this._type = type;
  this._hammerGestures = hammerGestures;
  this._eventHandlers = [];
}


HammerGesturesHandle.prototype.on = function(events, handler) {
  var type = this._type;
  var handlerFilteredEvents = function(e) {
    if (type === e.pointerType) {
      handler(e);
    }
  };

  this._eventHandlers.push({ events: events, handler: handlerFilteredEvents });
  this._manager.on(events, handlerFilteredEvents);
};


HammerGesturesHandle.prototype.release = function() {
  for (var i = 0; i < this._eventHandlers.length; i++) {
    var eventHandler = this._eventHandlers[i];
    this._manager.off(eventHandler.events, eventHandler.handler);
  }

  this._hammerGestures._releaseHandle(this._element, this._type);
  this._manager = null;
  this._element = null;
  this._type = null;
  this._hammerGestures = null;
};


HammerGesturesHandle.prototype.manager = function() {
  return this._manager;
};


module.exports = new HammerGestures();

},{"hammerjs":13}],43:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class KeyControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a key.
 *
 * @param {number} keyCode Key which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
 * @param {Element} [element=document] DOM element where the key events are listened to
 */
function KeyControlMethod(keyCode, parameter, velocity, friction, element) {
  if(!keyCode) {
    throw new Error("KeyControlMethod: keyCode must be defined");
  }
  if(!parameter) {
    throw new Error("KeyControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("KeyControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("KeyControlMethod: friction must be defined");
  }

  element = element || document;

  this._keyCode = keyCode;
  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._element = element;

  this._keydownHandler = this._handlePress.bind(this);
  this._keyupHandler = this._handleRelease.bind(this);
  this._blurHandler = this._handleBlur.bind(this);

  this._element.addEventListener('keydown', this._keydownHandler);
  this._element.addEventListener('keyup', this._keyupHandler);
  window.addEventListener('blur', this._blurHandler);

  this._dynamics = new Dynamics();
  this._pressing = false;
}
eventEmitter(KeyControlMethod);

/**
 * Destructor.
 */
KeyControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('keydown', this._keydownHandler);
  this._element.removeEventListener('keyup', this._keyupHandler);
  window.removeEventListener('blur', this._blurHandler);
  clearOwnProperties(this);
};

KeyControlMethod.prototype._handlePress = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

KeyControlMethod.prototype._handleRelease = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

KeyControlMethod.prototype._handleBlur = function() {
  this._dynamics.velocity = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('inactive');

  this._pressing = false;
};

module.exports = KeyControlMethod;

},{"../util/clearOwnProperties":80,"./Dynamics":40,"minimal-event-emitter":14}],44:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class PinchZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Control the view fov/zoom by pinching with two fingers.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use
 * @param {Object} opts
 */
function PinchZoomControlMethod(element, pointerType, opts) {
  this._hammer = HammerGestures.get(element, pointerType);

  this._lastEvent = null;

  this._active = false;

  this._dynamics = new Dynamics();

  this._hammer.on('pinchstart', this._handleStart.bind(this));
  this._hammer.on('pinch', this._handleEvent.bind(this));
  this._hammer.on('pinchend', this._handleEnd.bind(this));
  this._hammer.on('pinchcancel', this._handleEnd.bind(this));
}

eventEmitter(PinchZoomControlMethod);

/**
 * Destructor.
 */
PinchZoomControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


PinchZoomControlMethod.prototype._handleStart = function() {
  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


PinchZoomControlMethod.prototype._handleEnd = function() {
  this._lastEvent = null;

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


PinchZoomControlMethod.prototype._handleEvent = function(e) {
  var scale = e.scale;

  if (this._lastEvent) {
    scale /= this._lastEvent.scale;
  }

  this._dynamics.offset = (scale - 1) * -1;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  this._lastEvent = e;
};


module.exports = PinchZoomControlMethod;

},{"../util/clearOwnProperties":80,"./Dynamics":40,"./HammerGestures":42,"minimal-event-emitter":14}],45:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');


var defaultOptions = {
  speed: 8,
  friction: 6,
  maxFrictionTime: 0.3
};


/**
 * @class QtvrControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by holding the mouse button down and moving it.
 * Also known as "QTVR" control mode.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.speed
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 */
// TODO: allow speed not change linearly with distance to click spot.
// Quadratic or other would allow a larger speed range.
function QtvrControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._active = false;

  this._hammer = HammerGestures.get(element, pointerType);

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer.on('panstart', this._handleStart.bind(this));
  this._hammer.on('panmove', this._handleMove.bind(this));
  this._hammer.on('panend', this._handleRelease.bind(this));
  this._hammer.on('pancancel', this._handleRelease.bind(this));
}

eventEmitter(QtvrControlMethod);

/**
 * Destructor.
 */
QtvrControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


QtvrControlMethod.prototype._handleStart = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


QtvrControlMethod.prototype._handleMove = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, false);
};


QtvrControlMethod.prototype._handleRelease = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, true);

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


var tmpReleaseFriction = [ null, null ];
QtvrControlMethod.prototype._updateDynamics = function(e, release) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;
  var maxDim = Math.max(width, height);

  var x = e.deltaX / maxDim * this._opts.speed;
  var y = e.deltaY / maxDim * this._opts.speed;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  if (release) {
    maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
    this._dynamics.x.friction = tmpReleaseFriction[0];
    this._dynamics.y.friction = tmpReleaseFriction[1];
  }

  this.emit('parameterDynamics', 'x', this._dynamics.x);
  this.emit('parameterDynamics', 'y', this._dynamics.y);
};


module.exports = QtvrControlMethod;

},{"../util/clearOwnProperties":80,"../util/defaults":85,"./Dynamics":40,"./HammerGestures":42,"./util":49,"minimal-event-emitter":14}],46:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  frictionTime: 0.2,
  zoomDelta: 0.001
};

/**
 * @class ScrollZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the fov/zoom through the mouse wheel.
 *
 * @param {Element} element Element to listen for events.
 * @param {Object} opts
 * @param {number} [opts.frictionTime=0.2]
 * @param {number} [opts.zoomDelta=0.001]
 */
function ScrollZoomControlMethod(element, opts) {
  this._element = element;
  this._opts = defaults(opts || {}, defaultOptions);
  this._dynamics = new Dynamics();
  this._eventList = [];

  var fn = this._opts.frictionTime ? this.withSmoothing : this.withoutSmoothing;
  this._wheelListener = fn.bind(this);
  
  element.addEventListener('wheel', this._wheelListener);
}

eventEmitter(ScrollZoomControlMethod);

/**
 * Destructor.
 */
ScrollZoomControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('wheel', this._wheelListener);
  clearOwnProperties(this);
};


ScrollZoomControlMethod.prototype.withoutSmoothing = function(e) {
  this._dynamics.offset = wheelEventDelta(e) * this._opts.zoomDelta;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


ScrollZoomControlMethod.prototype.withSmoothing = function(e) {
  var currentTime = e.timeStamp;

  // Record event.
  this._eventList.push(e);

  // Remove events whose smoothing has already expired.
  while (this._eventList[0].timeStamp < currentTime - this._opts.frictionTime*1000) {
    this._eventList.shift(0);
  }

  // Get the current velocity from the recorded events.
  // Each wheel movement causes a velocity of change/frictionTime during frictionTime.
  var velocity = 0;
  for (var i = 0; i < this._eventList.length; i++) {
    var zoomChangeFromEvent = wheelEventDelta(this._eventList[i]) * this._opts.zoomDelta;
    velocity += zoomChangeFromEvent / this._opts.frictionTime;
  }

  this._dynamics.velocity = velocity;
  this._dynamics.friction = Math.abs(velocity) / this._opts.frictionTime;

  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


function wheelEventDelta(e) {
  var multiplier = e.deltaMode == 1 ? 20 : 1;
  return e.deltaY * multiplier;
}


module.exports = ScrollZoomControlMethod;

},{"../util/clearOwnProperties":80,"../util/defaults":85,"./Dynamics":40,"minimal-event-emitter":14}],47:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class VelocityControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter.
 *
 * The user should emit 'active' and 'inactive' events if required.
 *
 * @param {String} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
*/
function VelocityControlMethod(parameter) {
  if(!parameter) {
    throw new Error("VelocityControlMethod: parameter must be defined");
  }

  this._parameter = parameter;
  this._dynamics = new Dynamics();
}
eventEmitter(VelocityControlMethod);

/**
 * Destructor.
 */
VelocityControlMethod.prototype.destroy = function() {
  clearOwnProperties(this);
};

/**
 * Set the parameter's velocity.
 * @param {Number} velocity
 */
VelocityControlMethod.prototype.setVelocity = function(velocity) {
  this._dynamics.velocity = velocity;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

/**
 * Set the parameter's friction.
 * @param {Number} friction
 */
VelocityControlMethod.prototype.setFriction = function(friction) {
  this._dynamics.friction = friction;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

module.exports = VelocityControlMethod;

},{"../util/clearOwnProperties":80,"./Dynamics":40,"minimal-event-emitter":14}],48:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var DragControlMethod = require('./Drag');
var QtvrControlMethod = require('./Qtvr');
var ScrollZoomControlMethod = require('./ScrollZoom');
var PinchZoomControlMethod = require('./PinchZoom');
var KeyControlMethod = require('./Key');

var defaultOptions = {
  mouseViewMode: 'drag',
  dragMode: 'pan'
};

/**
 * Instantiate and register some commonly used {@link ControlMethod} instances.
 *
 * The following instances are registered:
 *   - mouseViewDrag
 *   - mouseViewQtvr
 *   - touchView
 *   - pinch
 *   - arrowKeys
 *   - plusMinusKeys
 *   - wasdKeys
 *   - qeKeys
 *
 * @param {Controls} controls Where to register the instances.
 * @param {Element} element Element to listen for events.
 * @param {'drag'|'qtvr'} opts.mouseViewMode
 * @param {'pan'|'pinch'} opts.dragMode
 * @param {boolean} opts.scrollZoom
 */
function registerDefaultControls(controls, element, opts) {
  opts = defaults(opts || {}, defaultOptions);

  var controlMethods = {
    mouseViewDrag: new DragControlMethod(element, 'mouse'),
    mouseViewQtvr: new QtvrControlMethod(element, 'mouse'),

    leftArrowKey: new KeyControlMethod(37, 'x', -0.7, 3),
    rightArrowKey: new KeyControlMethod(39, 'x', 0.7, 3),
    upArrowKey: new KeyControlMethod(38, 'y', -0.7, 3),
    downArrowKey: new KeyControlMethod(40, 'y', 0.7, 3),
    plusKey: new KeyControlMethod(107, 'zoom', -0.7, 3),
    minusKey: new KeyControlMethod(109, 'zoom', 0.7, 3),

    wKey: new KeyControlMethod(87, 'y', -0.7, 3),
    aKey: new KeyControlMethod(65, 'x', -0.7, 3),
    sKey: new KeyControlMethod(83, 'y', 0.7, 3),
    dKey: new KeyControlMethod(68, 'x', 0.7, 3),
    qKey: new KeyControlMethod(81, 'roll', 0.7, 3),
    eKey: new KeyControlMethod(69, 'roll', -0.7, 3)
  };

  var enabledControls = ['scrollZoom', 'touchView', 'pinch' ];

  if (opts.scrollZoom !== false) {
    controlMethods.scrollZoom = new ScrollZoomControlMethod(element); //{ frictionTime: 0 }
  }

  var controlMethodGroups = {
    arrowKeys: [ 'leftArrowKey', 'rightArrowKey', 'upArrowKey', 'downArrowKey' ],
    plusMinusKeys: [ 'plusKey', 'minusKey' ],
    wasdKeys: [ 'wKey', 'aKey', 'sKey', 'dKey' ],
    qeKeys: [ 'qKey', 'eKey' ]
  };


  switch (opts.dragMode) {
    case 'pinch':
       controlMethods.pinch = new DragControlMethod(element, 'touch', { hammerEvent: 'pinch' });
      break;
    case 'pan':
      controlMethods.touchView = new DragControlMethod(element, 'touch');
      controlMethods.pinch = new PinchZoomControlMethod(element, 'touch');
      break;
    default:
      throw new Error("Unknown drag mode: " + opts.dragMode);
  }

  switch (opts.mouseViewMode) {
    case 'drag':
      enabledControls.push('mouseViewDrag');
      break;
    case 'qtvr':
      enabledControls.push('mouseViewQtvr');
      break;
    default:
      throw new Error("Unknown mouse view mode: " + opts.mouseViewMode);
  }

  for (var id in controlMethods) {
    var method = controlMethods[id];
    controls.registerMethod(id, method);
    if (enabledControls.indexOf(id) >= 0) {
      controls.enableMethod(id);
    }
  }

  for (var groupId in controlMethodGroups) {
    var methodGroup = controlMethodGroups[groupId];
    controls.addMethodGroup(groupId, methodGroup);
  }

  return controlMethods;
}

module.exports = registerDefaultControls;

},{"../util/defaults":85,"./Drag":39,"./Key":43,"./PinchZoom":44,"./Qtvr":45,"./ScrollZoom":46}],49:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function maxFriction(friction, velocityX, velocityY, maxFrictionTime, result) {
  var velocity = Math.sqrt(Math.pow(velocityX,2) + Math.pow(velocityY,2));
  friction = Math.max(friction, velocity/maxFrictionTime);
  changeVectorNorm(velocityX, velocityY, friction, result);
  result[0] = Math.abs(result[0]);
  result[1] = Math.abs(result[1]);
}

function changeVectorNorm(x, y, n, result) {
  var theta = Math.atan(y/x);
  result[0] = n * Math.cos(theta);
  result[1] = n * Math.sin(theta);
}

module.exports = {
  maxFriction: maxFriction,
  changeVectorNorm: changeVectorNorm
};
},{}],50:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec3 = require('gl-matrix').vec3;
var vec4 = require('gl-matrix').vec4;
var mat4 = require('gl-matrix').mat4;

var neighborsCacheSize = 64;

// Initials for cube faces.
var faceList = 'fudlrb';

// Rotation of each face, relative to the front face.
var faceRotation = {
  f: { x: 0, y: 0 },
  b: { x: 0, y: Math.PI },
  l: { x: 0, y: Math.PI/2 },
  r: { x: 0, y: -Math.PI/2 },
  u: { x: Math.PI/2, y: 0 },
  d: { x: -Math.PI/2, y: 0 }
};

// Zero vector.
var origin = vec3.create();

// Rotate a vector in ZXY order.
function rotateVector(vec, z, x, y) {
  if (z) {
    vec3.rotateZ(vec, vec, origin, z);
  }
  if (x) {
    vec3.rotateX(vec, vec, origin, x);
  }
  if (y) {
    vec3.rotateY(vec, vec, origin, y);
  }
}

// Normalized vectors pointing to the center of each face.
var faceVectors = {};
for (var i = 0; i < faceList.length; i++) {
  var face = faceList[i];
  var rotation = faceRotation[face];
  var v = vec3.fromValues(0,  0, -1);
  rotateVector(v, 0, rotation.x, rotation.y);
  faceVectors[face] = v;
}

// Map each face to its adjacent faces.
// The order is as suggested by the front face.
var adjacentFace = {
  f: [ 'l', 'r', 'u', 'd' ],
  b: [ 'r', 'l', 'u', 'd' ],
  l: [ 'b', 'f', 'u', 'd' ],
  r: [ 'f', 'b', 'u', 'd' ],
  u: [ 'l', 'r', 'b', 'f' ],
  d: [ 'l', 'r', 'f', 'b' ]
};

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class CubeTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a @{CubeGeometry}.
 */
function CubeTile(face, x, y, z, geometry) {
  this.face = face;
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


CubeTile.prototype.rotX = function() {
  return faceRotation[this.face].x;
};


CubeTile.prototype.rotY = function() {
  return faceRotation[this.face].y;
};


CubeTile.prototype.centerX = function() {
  return (this.x + 0.5) / this._level.numHorizontalTiles() - 0.5;
};


CubeTile.prototype.centerY = function() {
  return 0.5 - (this.y + 0.5) / this._level.numVerticalTiles();
};


CubeTile.prototype.scaleX = function() {
  return 1 / this._level.numHorizontalTiles();
};


CubeTile.prototype.scaleY = function() {
  return 1 / this._level.numVerticalTiles();
};


CubeTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
  }

  var rot = faceRotation[this.face];

  function makeVertex(vec, x, y) {
    vec3.set(vec, x, y, -0.5);
    rotateVector(vec, 0, rot.x, rot.y);
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  makeVertex(result[0], left, top);
  makeVertex(result[1], right, top);
  makeVertex(result[2], right, bottom);
  makeVertex(result[3], left, bottom);

  return result;
};


CubeTile.prototype.parent = function() {

  if (this.z === 0) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var parentLevel = geometry.levelList[z-1];

  var tileX = Math.floor(x / level.numHorizontalTiles() * parentLevel.numHorizontalTiles());
  var tileY = Math.floor(y / level.numVerticalTiles() * parentLevel.numVerticalTiles());
  var tileZ = z-1;

  return new CubeTile(face, tileX, tileY, tileZ, geometry);

};


CubeTile.prototype.children = function(result) {

  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var childLevel = geometry.levelList[z+1];

  var nHoriz = childLevel.numHorizontalTiles() / level.numHorizontalTiles();
  var nVert = childLevel.numVerticalTiles() / level.numVerticalTiles();

  result = result || [];

  for (var h = 0; h < nHoriz; h++) {
    for (var v = 0; v < nVert; v++) {
      var tileX = nHoriz * x + h;
      var tileY = nVert * y + v;
      var tileZ = z+1;
      result.push(new CubeTile(face, tileX, tileY, tileZ, geometry));
    }
  }

  return result;

};


CubeTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var vec = geometry._vec;

  var face = this.face;
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;
    var newFace = face;

    if (newX < 0 || newX >= numX || newY < 0 || newY >= numY) {

      // If the neighboring tile belongs to a different face, calculate a
      // vector pointing to the edge between the two faces at the point the
      // tile and its neighbor meet, and convert it into tile coordinates for
      // the neighboring face.

      var xCoord = this.centerX();
      var yCoord = this.centerY();

      // First, calculate the vector as if the initial tile belongs to the
      // front face, so that the tile x,y coordinates map directly into the
      // x,y axes.

      if (newX < 0) {
        vec3.set(vec, -0.5, yCoord, -0.5);
        newFace = adjacentFace[face][0];
      } else if (newX >= numX) {
        vec3.set(vec, 0.5, yCoord, -0.5);
        newFace = adjacentFace[face][1];
      } else if (newY < 0) {
        vec3.set(vec, xCoord, 0.5, -0.5);
        newFace = adjacentFace[face][2];
      } else if (newY >= numY) {
        vec3.set(vec, xCoord, -0.5, -0.5);
        newFace = adjacentFace[face][3];
      }

      var rot;

      // Then, rotate the vector into the actual face the initial tile
      // belongs to.

      rot = faceRotation[face];
      rotateVector(vec, 0, rot.x, rot.y);

      // Finally, rotate the vector from the neighboring face into the front
      // face. Again, this is so that the neighboring tile x,y coordinates
      // map directly into the x,y axes.

      rot = faceRotation[newFace];
      rotateVector(vec, 0, -rot.x, -rot.y);

      // Calculate the neighboring tile coordinates.

      newX = clamp(Math.floor((0.5 + vec[0]) * numX), 0, numX - 1);
      newY = clamp(Math.floor((0.5 - vec[1]) * numY), 0, numY - 1);
    }

    result.push(new CubeTile(newFace, newX, newY, newZ, geometry));
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


CubeTile.prototype.hash = function() {
  return hash(faceList.indexOf(this.face), this.z, this.y, this.x);
};


CubeTile.prototype.equals = function(that) {
  return (this._geometry === that._geometry &&
      this.face === that.face &&
      this.z === that.z &&
      this.y === that.y &&
      this.x === that.x);
};


CubeTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) ||
  cmp(faceList.indexOf(this.face), faceList.indexOf(that.face)) ||
  cmp(this.y, that.y) || cmp(this.x, that.x));
};


CubeTile.prototype.str = function() {
  return 'CubeTile(' + tile.face + ', ' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function CubeLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._size = levelProperties.size;
  this._tileSize = levelProperties.tileSize;

  if (this._size % this._tileSize !== 0) {
    throw new Error('Level size is not multiple of tile size: ' +
                    this._size + ' ' + this._tileSize);
  }
}

inherits(CubeLevel, Level);


CubeLevel.prototype.width = function() {
  return this._size;
};


CubeLevel.prototype.height = function() {
  return this._size;
};


CubeLevel.prototype.tileWidth = function() {
  return this._tileSize;
};


CubeLevel.prototype.tileHeight = function() {
  return this._tileSize;
};


CubeLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();
  var numHorizontal = this.numHorizontalTiles();
  var numVertical = this.numVerticalTiles();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();
  var parentNumHorizontal = parentLevel.numHorizontalTiles();
  var parentNumVertical = parentLevel.numVerticalTiles();

  if (width % parentWidth !== 0) {
    throw new Error('Level width must be multiple of parent level: ' +
                    width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    throw new Error('Level height must be multiple of parent level: ' +
                    height + ' vs. ' + parentHeight);
  }

  if (numHorizontal % parentNumHorizontal !== 0) {
    throw new Error('Number of horizontal tiles must be multiple of parent level: ' +
      numHorizontal + " (" + width + '/' + tileWidth + ')' + " vs. " +
      parentNumHorizontal + " (" + parentWidth + '/' + parentTileWidth + ')');
  }

  if (numVertical % parentNumVertical !== 0) {
    throw new Error('Number of vertical tiles must be multiple of parent level: ' +
      numVertical + " (" + height + '/' + tileHeight + ')' + " vs. " +
      parentNumVertical + " (" + parentHeight + '/' + parentTileHeight + ')');
  }

};


/**
 * @class CubeGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled cube images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles in a level must be square and form a rectangular grid;
 *   - The size of a level must be a multiple of the tile size;
 *   - The size of a level must be a multiple of the parent level size;
 *   - The number of tiles in a level must be a multiple of the number of tiles
 *     in the parent level.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].size Cube face size in pixels
 * @param {number} levelPropertiesList[].tileSize Tile size in pixels
 */
function CubeGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, CubeLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


CubeGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


CubeGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  result = result || [];

  for (var f = 0; f < faceList.length; f++) {
    var face = faceList[f];
    for (var x = 0; x <= maxX; x++) {
      for (var y = 0; y <= maxY; y++) {
        result.push(new CubeTile(face, x, y, levelIndex, this));
      }
    }
  }

  return result;

};


CubeGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 0, 1);
  var matrix = mat4.create()
  mat4.multiply(matrix, view.inverseViewMatrix(), view.inverseProjection());
  vec4.transformMat4(ray, ray, matrix);

  var minAngle = Infinity;
  var closestFace = null;

  // Find the face whose vector makes a minimal angle with the view ray.
  // This is the face into which the view ray points.
  for (var face in faceVectors) {
    var vector = faceVectors[face];
    // For a small angle between two normalized vectors, angle ~ 1-cos(angle).
    var angle = 1 - vec3.dot(vector, ray);
    if (angle < minAngle) {
      minAngle = angle;
      closestFace = face;
    }
  }

  // Project view ray onto cube, i.e., normalize the coordinate with
  // largest absolute value to ±0.5.
  var max = Math.max(Math.abs(ray[0]), Math.abs(ray[1]), Math.abs(ray[2])) / 0.5;
  for (var i = 0; i < 3; i++) {
    ray[i] = ray[i] / max;
  }

  // Rotate view ray into front face.
  var rot = faceRotation[closestFace];
  rotateVector(ray, 0, -rot.x, -rot.y);

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor((0.5 + ray[0]) * numX), 0, numX - 1);
  var tileY = clamp(Math.floor((0.5 - ray[1]) * numY), 0, numY - 1);

  return new CubeTile(closestFace, tileX, tileY, tileZ, this);
};


CubeGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    //throw new Error('Starting tile is not visible');
  }

  return result;
};


CubeGeometry.Tile = CubeGeometry.prototype.Tile = CubeTile;
CubeGeometry.type = CubeGeometry.prototype.type = 'cube';
CubeTile.type = CubeTile.prototype.type = 'cube';


module.exports = CubeGeometry;

},{"../TileSearcher":23,"../collections/LruMap":29,"../util/clamp":79,"../util/cmp":81,"../util/hash":92,"../util/inherits":93,"../util/type":105,"./Level":53,"./common":54,"gl-matrix":3}],51:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var cmp = require('../util/cmp');
var common = require('./common');
var Level = require('./Level');
var type = require('../util/type');


/**
 * @class EquirectTile
 * @implements Tile
 * @classdesc
 *
 * A tile in an @{EquirectGeometry}.
 */
function EquirectTile(z, geometry) {
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


EquirectTile.prototype.rotX = function() {
  return 0;
};


EquirectTile.prototype.rotY = function() {
  return 0;
};


EquirectTile.prototype.centerX = function() {
  return 0.5;
};


EquirectTile.prototype.centerY = function() {
  return 0.5;
};


EquirectTile.prototype.scaleX = function() {
  return 1;
};


EquirectTile.prototype.scaleY = function() {
  return 1;
};


EquirectTile.prototype.parent = function() {
  if (this.z === 0) {
    return null;
  }
  return new EquirectTile(this.z - 1, this._geometry);
};


EquirectTile.prototype.children = function(result) {
  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }
  result = result || [];
  result.push(new EquirectTile(this.z + 1, this._geometry));
  return result;
};


EquirectTile.prototype.neighbors = function() {
  return [];
};


EquirectTile.prototype.hash = function() {
  return hash(this.z);
};


EquirectTile.prototype.equals = function(that) {
  return this._geometry === that._geometry && this.z === that.z;
};


EquirectTile.prototype.cmp = function(that) {
  return cmp(this.z, that.z);
};


EquirectTile.prototype.str = function() {
  return 'EquirectTile(' + tile.z + ')';
};


function EquirectLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);
  this._width = levelProperties.width;
}

inherits(EquirectLevel, Level);


EquirectLevel.prototype.width = function() {
  return this._width;
};


EquirectLevel.prototype.height = function() {
  return this._width/2;
};


EquirectLevel.prototype.tileWidth = function() {
  return this._width;
};


EquirectLevel.prototype.tileHeight = function() {
  return this._width/2;
};


/**
 * @class EquirectGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for equirectangular images with a
 * 2:1 aspect ratio.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
*/
function EquirectGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = common.makeLevelList(levelPropertiesList, EquirectLevel);
  this.selectableLevelList = common.makeSelectableLevelList(this.levelList);
}


EquirectGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


EquirectGeometry.prototype.levelTiles = function(level, result) {
  var levelIndex = this.levelList.indexOf(level);
  result = result || [];
  result.push(new EquirectTile(levelIndex, this));
  return result;
};


EquirectGeometry.prototype.visibleTiles = function(view, level, result) {
  var tile = new EquirectTile(this.levelList.indexOf(level), this);
  result = result || [];
  result.length = 0;
  result.push(tile);
};


EquirectGeometry.Tile = EquirectGeometry.prototype.Tile = EquirectTile;
EquirectGeometry.type = EquirectGeometry.prototype.type = 'equirect';
EquirectTile.type = EquirectTile.prototype.type = 'equirect';


module.exports = EquirectGeometry;

},{"../util/cmp":81,"../util/hash":92,"../util/inherits":93,"../util/type":105,"./Level":53,"./common":54}],52:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var mod = require('../util/mod');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec2 = require('gl-matrix').vec2;
var vec4 = require('gl-matrix').vec4;

var neighborsCacheSize = 64;

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class FlatTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a {@link FlatGeometry}.
 */
function FlatTile(x, y, z, geometry) {
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


FlatTile.prototype.rotX = function() {
  return 0;
};


FlatTile.prototype.rotY = function() {
  return 0;
};


FlatTile.prototype.centerX = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  return (this.x * tileWidth + 0.5 * this.width()) / levelWidth - 0.5;
};


FlatTile.prototype.centerY = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  return 0.5 - (this.y * tileHeight + 0.5 * this.height()) / levelHeight;
};


FlatTile.prototype.scaleX = function() {
  var levelWidth = this._level.width();
  return this.width() / levelWidth;
};


FlatTile.prototype.scaleY = function() {
  var levelHeight = this._level.height();
  return this.height() / levelHeight;
};


FlatTile.prototype.width = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  if (this.x === this._level.numHorizontalTiles() - 1) {
    var widthRemainder = mod(levelWidth, tileWidth);
    return widthRemainder || tileWidth;
  } else {
    return tileWidth;
  }
};


FlatTile.prototype.height = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  if (this.y === this._level.numVerticalTiles() - 1) {
    var heightRemainder = mod(levelHeight, tileHeight);
    return heightRemainder || tileHeight;
  } else {
    return tileHeight;
  }
};


FlatTile.prototype.levelWidth = function() {
  return this._level.width();
};


FlatTile.prototype.levelHeight = function() {
  return this._level.height();
};


FlatTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec2.create(), vec2.create(), vec2.create(), vec2.create()];
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  vec2.set(result[0], left, top);
  vec2.set(result[1], right, top);
  vec2.set(result[2], right, bottom);
  vec2.set(result[3], left, bottom);

  return result;
};


FlatTile.prototype.parent = function() {


  if (this.z === 0) {
    return null;
  }

  var geometry = this._geometry;

  var z = this.z - 1;
  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  var x = Math.floor(this.x / 2);
  var y = Math.floor(this.y / 2);

  return new FlatTile(x, y, z, geometry);

};


FlatTile.prototype.children = function(result) {
  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }

  var geometry = this._geometry;
  var z = this.z + 1;

  result = result || [];

  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  result.push(new FlatTile(2*this.x  , 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x  , 2*this.y+1, z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y+1, z, geometry));

  return result;

};


FlatTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles() - 1;
  var numY = level.numVerticalTiles() - 1;

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;

    if (0 <= newX && newX <= numX && 0 <= newY && newY <= numY) {
      result.push(new FlatTile(newX, newY, newZ, geometry));
    }
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


FlatTile.prototype.hash = function() {
  return hash(this.z, this.y, this.x);
};


FlatTile.prototype.equals = function(that) {
  return (this._geometry === that._geometry &&
      this.z === that.z && this.y === that.y && this.x === that.x);
};


FlatTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) || cmp(this.y, that.y) || cmp(this.x, that.x));
};


FlatTile.prototype.str = function() {
  return 'FlatTile(' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function FlatLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._width = levelProperties.width;
  this._height = levelProperties.height;
  this._tileWidth = levelProperties.tileWidth;
  this._tileHeight = levelProperties.tileHeight;
}

inherits(FlatLevel, Level);


FlatLevel.prototype.width = function() {
  return this._width;
};


FlatLevel.prototype.height = function() {
  return this._height;
};


FlatLevel.prototype.tileWidth = function() {
  return this._tileWidth;
};


FlatLevel.prototype.tileHeight = function() {
  return this._tileHeight;
};


FlatLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();

  if (width % parentWidth !== 0) {
    return new Error('Level width must be multiple of parent level: ' +
                     width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    return new Error('Level height must be multiple of parent level: ' +
                     height + ' vs. ' + parentHeight);
  }

  if (tileWidth % parentTileWidth !== 0) {
    return new Error('Level tile width must be multiple of parent level: ' +
                     tileWidth + ' vs. ' + parentTileWidth);
  }

  if (tileHeight % parentTileHeight !== 0) {
    return new Error('Level tile height must be multiple of parent level: ' +
                     tileHeight + ' vs. ' + parentTileHeight);
  }

};


/**
 * @class FlatGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled flat images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles must be square, except when in the last row or column position,
 *     and must form a rectangular grid;
 *   - The width and height of a level must be multiples of the parent level
 *     width and height.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
 * @param {number} levelPropertiesList[].tileWidth Tile width in pixels for
 *                 square tiles
 * @param {number} levelPropertiesList[].height Level height in pixels
 * @param {number} levelPropertiesList[].tileHeight Tile height in pixels for
 *                 square tiles
 */
function FlatGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, FlatLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


FlatGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


FlatGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  if (!result) {
    result = [];
  }

  for (var x = 0; x <= maxX; x++) {
    for (var y = 0; y <= maxY; y++) {
      result.push(new FlatTile(x, y, levelIndex, this));
    }
  }

  return result;

};


FlatGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 1, 1);
  vec4.transformMat4(ray, ray, view.inverseProjection());

  // Compute the image coordinates that the view ray points into.
  var x = 0.5 + ray[0];
  var y = 0.5 - ray[1];

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var levelWidth = level.width();
  var levelHeight = level.height();
  var tileWidth = level.tileWidth();
  var tileHeight = level.tileHeight();
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor(x * levelWidth / tileWidth), 0, numX - 1);
  var tileY = clamp(Math.floor(y * levelHeight / tileHeight), 0, numY - 1);

  return new FlatTile(tileX, tileY, tileZ, this);
};


FlatGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    throw new Error('Starting tile is not visible');
  }

  return result;
};


FlatGeometry.Tile = FlatGeometry.prototype.Tile = FlatTile;
FlatGeometry.type = FlatGeometry.prototype.type = 'flat';
FlatTile.type = FlatTile.prototype.type = 'flat';


module.exports = FlatGeometry;

},{"../TileSearcher":23,"../collections/LruMap":29,"../util/clamp":79,"../util/cmp":81,"../util/hash":92,"../util/inherits":93,"../util/mod":95,"../util/type":105,"./Level":53,"./common":54,"gl-matrix":3}],53:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function Level(levelProperties) {
  this._fallbackOnly = !!levelProperties.fallbackOnly;
}

Level.prototype.numHorizontalTiles = function() {
  return Math.ceil(this.width() / this.tileWidth());
};

Level.prototype.numVerticalTiles = function() {
  return Math.ceil(this.height() / this.tileHeight());
};

Level.prototype.fallbackOnly = function() {
  return this._fallbackOnly;
};

module.exports = Level;
},{}],54:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var cmp = require('../util/cmp');

function makeLevelList(levelPropertiesList, LevelClass) {
  var list = [];

  for (var i = 0; i < levelPropertiesList.length; i++) {
    list.push(new LevelClass(levelPropertiesList[i]));
  }

  list.sort(function(level1, level2) {
    return cmp(level1.width(), level2.width());
  });

  return list;
}

function makeSelectableLevelList(levelList) {
  var list = [];

  for (var i = 0; i < levelList.length; i++) {
    if (!levelList[i]._fallbackOnly) {
      list.push(levelList[i]);
    }
  }

  if (!list.length) {
    throw new Error('No selectable levels in list');
  }

  return list;
}

module.exports = {
  makeLevelList: makeLevelList,
  makeSelectableLevelList: makeSelectableLevelList
};

},{"../util/cmp":81}],55:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = {

  // Stages.
  WebGlStage: require('./stages/WebGl'),

  // Renderers.
  WebGlCubeRenderer: require('./renderers/WebGlCube'),
  WebGlFlatRenderer: require('./renderers/WebGlFlat'),
  WebGlEquirectRenderer: require('./renderers/WebGlEquirect'),
  registerDefaultRenderers: require('./renderers/registerDefaultRenderers'),

  // Geometries.
  CubeGeometry: require('./geometries/Cube'),
  FlatGeometry: require('./geometries/Flat'),
  EquirectGeometry: require('./geometries/Equirect'),

  // Views.
  RectilinearView: require('./views/Rectilinear'),
  FlatView: require('./views/Flat'),

  // Sources.
  ImageUrlSource: require('./sources/ImageUrl'),
  SingleAssetSource: require('./sources/SingleAsset'),

  // Assets.
  StaticAsset: require('./assets/Static'),
  DynamicAsset: require('./assets/Dynamic'),

  // Texture store.
  TextureStore: require('./TextureStore'),

  // Layer.
  Layer: require('./Layer'),

  // Render loop.
  RenderLoop: require('./RenderLoop'),

  // Controls.
  KeyControlMethod: require('./controls/Key'),
  DragControlMethod: require('./controls/Drag'),
  QtvrControlMethod: require('./controls/Qtvr'),
  ScrollZoomControlMethod: require('./controls/ScrollZoom'),
  PinchZoomControlMethod: require('./controls/PinchZoom'),
  VelocityControlMethod: require('./controls/Velocity'),
  ElementPressControlMethod: require('./controls/ElementPress'),
  Controls: require('./controls/Controls'),
  Dynamics: require('./controls/Dynamics'),

  // High-level API.
  Viewer: require('./Viewer'),
  Scene: require('./Scene'),

  // Hotspots.
  Hotspot: require('./Hotspot'),
  HotspotContainer: require('./HotspotContainer'),

  // Effects.
  colorEffects: require('./colorEffects'),

  // Miscellaneous functions.
  registerDefaultControls: require('./controls/registerDefaultControls'),
  autorotate: require('./autorotate'),

  // Utility functions.
  util: {
    async: require('./util/async'),
    cancelize: require('./util/cancelize'),
    chain: require('./util/chain'),
    clamp: require('./util/clamp'),
    clearOwnProperties: require('./util/clearOwnProperties'),
    cmp: require('./util/cmp'),
    compose: require('./util/compose'),
    convertFov: require('./util/convertFov'),
    decimal: require('./util/decimal'),
    defaults: require('./util/defaults'),
    defer: require('./util/defer'),
    degToRad: require('./util/degToRad'),
    delay: require('./util/delay'),
    dom: require('./util/dom'),
    extend: require('./util/extend'),
    hash: require('./util/hash'),
    inherits: require('./util/inherits'),
    mod: require('./util/mod'),
    noop: require('./util/noop'),
    now: require('./util/now'),
    once: require('./util/once'),
    pixelRatio: require('./util/pixelRatio'),
    radToDeg: require('./util/radToDeg'),
    real: require('./util/real'),
    retry: require('./util/retry'),
    tween: require('./util/tween'),
    type: require('./util/type')
  },

  // Expose dependencies for clients to use.
  dependencies: {
    bowser: require('bowser'),
    glMatrix: require('gl-matrix'),
    eventEmitter: require('minimal-event-emitter'),
    hammerjs: require('hammerjs')
  }
};

},{"./Hotspot":16,"./HotspotContainer":17,"./Layer":18,"./RenderLoop":20,"./Scene":21,"./TextureStore":22,"./Viewer":25,"./assets/Dynamic":26,"./assets/Static":27,"./autorotate":28,"./colorEffects":35,"./controls/Controls":38,"./controls/Drag":39,"./controls/Dynamics":40,"./controls/ElementPress":41,"./controls/Key":43,"./controls/PinchZoom":44,"./controls/Qtvr":45,"./controls/ScrollZoom":46,"./controls/Velocity":47,"./controls/registerDefaultControls":48,"./geometries/Cube":50,"./geometries/Equirect":51,"./geometries/Flat":52,"./renderers/WebGlCube":59,"./renderers/WebGlEquirect":61,"./renderers/WebGlFlat":62,"./renderers/registerDefaultRenderers":63,"./sources/ImageUrl":70,"./sources/SingleAsset":71,"./stages/WebGl":74,"./util/async":75,"./util/cancelize":77,"./util/chain":78,"./util/clamp":79,"./util/clearOwnProperties":80,"./util/cmp":81,"./util/compose":82,"./util/convertFov":83,"./util/decimal":84,"./util/defaults":85,"./util/defer":86,"./util/degToRad":87,"./util/delay":88,"./util/dom":89,"./util/extend":90,"./util/hash":92,"./util/inherits":93,"./util/mod":95,"./util/noop":96,"./util/now":97,"./util/once":98,"./util/pixelRatio":99,"./util/radToDeg":101,"./util/real":102,"./util/retry":103,"./util/tween":104,"./util/type":105,"./views/Flat":106,"./views/Rectilinear":107,"bowser":1,"gl-matrix":3,"hammerjs":13,"minimal-event-emitter":14}],56:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('../assets/Static');
var NetworkError = require('../NetworkError');
var browser = require('bowser');
var global = require('../util/global');
var once = require('../util/once');

// TODO: Move the load queue into the loader.

// Whether to use createImageBitmap instead of a canvas for cropping.
// See https://caniuse.com/?search=createimagebitmap
var useCreateImageBitmap =
  !!global.createImageBitmap &&
  !browser.firefox &&
  !browser.safari &&
  !/iPhone|iPad|iPod|Safari/.test(navigator.userAgent);
// var useCreateImageBitmap =
//   !!global.createImageBitmap &&
//   !browser.firefox &&
//   !/iPhone|iPad|iPod|Safari/.test(navigator.userAgent);
  // var useCreateImageBitmap = false;

  // Options for createImageBitmap.
  var createImageBitmapOpts = {
    imageOrientation: 'flipY',
    premultiplyAlpha: 'premultiply'
  };

/**
 * @class HtmlImageLoader
 * @implements ImageLoader
 * @classdesc
 *
 * A {@link Loader} for HTML images.
 *
 * @param {Stage} stage The stage which is going to request images to be loaded.
 */
function HtmlImageLoader(stage) {
  this._stage = stage;
}

/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
HtmlImageLoader.prototype.loadImage = function (url, rect, done) {
  var self = this;

  var img = new Image();

  // Allow cross-domain image loading.
  // This is required to be able to create WebGL textures from images fetched
  // from a different domain. Note that setting the crossorigin attribute to
  // 'anonymous' will trigger a CORS preflight for cross-domain requests, but no
  // credentials (cookies or HTTP auth) will be sent; to do so, the attribute
  // would have to be set to 'use-credentials' instead. Unfortunately, this is
  // not a safe choice, as it causes requests to fail when the response contains
  // an Access-Control-Allow-Origin header with a wildcard. See the section
  // "Credentialed requests and wildcards" on:
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
  img.crossOrigin = 'anonymous';

  var x = rect && rect.x || 0;
  var y = rect && rect.y || 0;
  var width = rect && rect.width || 1;
  var height = rect && rect.height || 1;

  done = once(done);

  img.onload = function () {
    self._handleLoad(img, x, y, width, height, done);
  };

  img.onerror = function () {
    self._handleError(url, done);
  };

  img.src = url;

  function cancel() {
    img.onload = img.onerror = null;
    img.src = '';
    done.apply(null, arguments);
  }

  return cancel;
};

HtmlImageLoader.prototype._handleLoad = function (img, x, y, width, height, done) {
  if (x === 0 && y === 0 && width === 1 && height === 1) {
    // Fast path for when cropping is not needed.
    done(null, new StaticAsset(img));
    return;
  }

  x *= img.naturalWidth;
  y *= img.naturalHeight;
  width *= img.naturalWidth;
  height *= img.naturalHeight;

  if (useCreateImageBitmap) {
    // Prefer to crop using createImageBitmap, which can potentially offload
    // work to another thread and avoid blocking the user interface.
    // Assume that the promise is never rejected.
    global.createImageBitmap(img, x, y, width, height, createImageBitmapOpts)
      .then(function (bitmap) {
        done(null, new StaticAsset(bitmap));
      });
  } else {
    // Fall back to cropping using a canvas, which can potentially block the
    // user interface, but is the best we can do.
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.drawImage(img, x, y, width, height, 0, 0, width, height);
    done(null, new StaticAsset(canvas));
  }
};

HtmlImageLoader.prototype._handleError = function (url, done) {
  // TODO: is there any way to distinguish a network error from other
  // kinds of errors? For now we always return NetworkError since this
  // prevents images to be retried continuously while we are offline.
  done(new NetworkError('Network error: ' + url));
};

module.exports = HtmlImageLoader;

},{"../NetworkError":19,"../assets/Static":27,"../util/global":91,"../util/once":98,"bowser":1}],57:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexNormal');
var fragmentSrc = require('../shaders/fragmentNormal');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition', 'aTextureCoord'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uProjMatrix', 'uViewMatrix', 'uModelMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix'
];


function WebGlBaseRenderer(gl) {
  this.gl = gl;

  // The projection matrix positions the tiles in world space.
  // We compute it in Javascript because lack of precision in the vertex shader
  // causes seams to appear between adjacent tiles at large zoom levels.
  this.projMatrix = mat4.create();

  // TODO Why save this value here? the same question to the projMatrix.
  this.viewMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  // Translation and scale vectors for tiles.
  this.translateVector = vec3.create();
  this.scaleVector = vec3.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlBaseRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};

WebGlBaseRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
  gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlBaseRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlBaseRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var projMatrix = this.projMatrix;
  var viewMatrix = this.viewMatrix;
  var translateVector = this.translateVector;
  var scaleVector = this.scaleVector;

  mat4.copy(projMatrix, layer.view().projection());
  gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);

  mat4.copy(viewMatrix, layer.view().viewMatrix());
  gl.uniformMatrix4fv(shaderProgram.uViewMatrix, false, viewMatrix);
  
  // Generate ModelMatrix.
  // TODO Cache the matrix in the tile object?
  translateVector[0] = tile.centerX();
  translateVector[1] = tile.centerY();
  translateVector[2] = -0.5;

  scaleVector[0] = tile.scaleX();
  scaleVector[1] = tile.scaleY();
  scaleVector[2] = 1.0;

  var modelMatrix = mat4.create();
  mat4.rotateX(modelMatrix, modelMatrix, tile.rotX());
  mat4.rotateY(modelMatrix, modelMatrix, tile.rotY());
  mat4.translate(modelMatrix, modelMatrix, translateVector);
  mat4.scale(modelMatrix, modelMatrix, scaleVector);

  gl.uniformMatrix4fv(shaderProgram.uModelMatrix, false, modelMatrix);

  setDepth(gl, shaderProgram, layerZ, tile.z);
  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlBaseRenderer;

},{"../shaders/fragmentNormal":66,"../shaders/vertexNormal":69,"../util/clearOwnProperties":80,"./WebGlCommon":58,"gl-matrix":3}],58:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// These are used to set the WebGl depth for a tile.
var MAX_LAYERS = 256; // Max number of layers per stage.
var MAX_LEVELS = 256; // Max number of levels per layer.

var clamp = require('../util/clamp');
var vec4 = require('gl-matrix').vec4;
var vec3 = require('gl-matrix').vec3;
var mat4 = require('gl-matrix').mat4;


function createShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw gl.getShaderInfoLog(shader);
  }
  return shader;
}


function createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList) {

  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

  var shaderProgram = gl.createProgram();

  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    throw gl.getProgramInfoLog(shaderProgram);
  }

  for (var i = 0; i < attribList.length; i++) {
    var attrib = attribList[i];
    shaderProgram[attrib] = gl.getAttribLocation(shaderProgram, attrib);
    if (shaderProgram[attrib] === -1) {
      throw new Error('Shader program has no ' + attrib + ' attribute');
    }
  }

  for (var j = 0; j < uniformList.length; j++) {
    var uniform = uniformList[j];
    shaderProgram[uniform] = gl.getUniformLocation(shaderProgram, uniform);
    if (shaderProgram[uniform] === -1) {
      throw new Error('Shader program has no ' + uniform + ' uniform');
    }
  }

  return shaderProgram;
}


function destroyShaderProgram(gl, shaderProgram) {
  var shaderList = gl.getAttachedShaders(shaderProgram);
  for (var i = 0; i < shaderList.length; i++) {
    var shader = shaderList[i];
    gl.detachShader(shaderProgram, shader);
    gl.deleteShader(shader);
  }
  gl.deleteProgram(shaderProgram);
}


function createConstantBuffer(gl, target, usage, value) {
  var buffer = gl.createBuffer();
  gl.bindBuffer(target, buffer);
  gl.bufferData(target, value, usage);
  return buffer;
}


function createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords) {
  return {
    vertexIndices: createConstantBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, new Uint16Array(vertexIndices)),
    vertexPositions: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(vertexPositions)),
    textureCoords: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(textureCoords))
  };
}


function destroyConstantBuffers(gl, constantBuffers) {
  gl.deleteBuffer(constantBuffers.vertexIndices);
  gl.deleteBuffer(constantBuffers.vertexPositions);
  gl.deleteBuffer(constantBuffers.textureCoords);
}


function enableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.enableVertexAttribArray(i);
  }
}


function disableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.disableVertexAttribArray(i);
  }
}


function setTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture._texture);
  gl.uniform1i(shaderProgram.uSampler, 0);
}

function setDepthmapTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, texture._texture);
  gl.uniform1i(shaderProgram.uDepthmap, 1);
}

function setDepth(gl, shaderProgram, layerZ, tileZ) {
  var depth = (((layerZ + 1) * MAX_LEVELS) - tileZ) / (MAX_LEVELS * MAX_LAYERS);
  gl.uniform1f(shaderProgram.uDepth, depth);
}


var defaultOpacity = 1.0;
var defaultColorOffset = vec4.create();
var defaultColorMatrix = mat4.create();
mat4.identity(defaultColorMatrix);

function setupPixelEffectUniforms(gl, effects, uniforms) {
  var opacity = defaultOpacity;
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }
  gl.uniform1f(uniforms.opacity, opacity);

  var colorOffset = defaultColorOffset;
  if (effects && effects.colorOffset) {
    colorOffset = effects.colorOffset;
  }
  gl.uniform4fv(uniforms.colorOffset, colorOffset);

  var colorMatrix = defaultColorMatrix;
  if (effects && effects.colorMatrix) {
    colorMatrix = effects.colorMatrix;
  }
  gl.uniformMatrix4fv(uniforms.colorMatrix, false, colorMatrix);
}


// Temporary vectors for setViewport.
var translateVector = vec3.create();
var scaleVector = vec3.create();


// Sets the WebGL viewport and returns a viewport clamping compensation matrix.
//
// Negative viewport origin coordinates cause rendering issues. Letting the
// viewport dimensions extend beyond the visible area do not seem to cause
// rendering issues, but they may still have an impact on performance.
// Therefore, when the scene's rect is not fully contained in the rendering
// area, we clamp the viewport to the rendering area, and return a compensation
// matrix to scale and translate vertices accordingly.
function setViewport(gl, layer, rect, viewportMatrix) {
  if (rect.x === 0 && rect.width === 1 && rect.y === 0 && rect.height === 1) {
    // Fast path for full rect.
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    mat4.identity(viewportMatrix);
    return;
  }

  var offsetX = rect.x;
  var clampedOffsetX = clamp(offsetX, 0, 1);
  var leftExcess = clampedOffsetX - offsetX;
  var maxClampedWidth = 1 - clampedOffsetX;
  var clampedWidth = clamp(rect.width - leftExcess, 0, maxClampedWidth);
  var rightExcess = rect.width - clampedWidth;

  var offsetY = 1 - rect.height - rect.y;
  var clampedOffsetY = clamp(offsetY, 0, 1);
  var bottomExcess = clampedOffsetY - offsetY;
  var maxClampedHeight = 1 - clampedOffsetY;
  var clampedHeight = clamp(rect.height - bottomExcess, 0, maxClampedHeight);
  var topExcess = rect.height - clampedHeight;

  vec3.set(
    scaleVector,
    rect.width / clampedWidth,
    rect.height / clampedHeight,
    1);

  vec3.set(
    translateVector,
    (rightExcess - leftExcess) / clampedWidth,
    (topExcess - bottomExcess) / clampedHeight,
    0);

  mat4.identity(viewportMatrix);
  mat4.translate(viewportMatrix, viewportMatrix, translateVector);
  mat4.scale(viewportMatrix, viewportMatrix, scaleVector);

  gl.viewport(gl.drawingBufferWidth * clampedOffsetX,
              gl.drawingBufferHeight * clampedOffsetY,
              gl.drawingBufferWidth * clampedWidth,
              gl.drawingBufferHeight * clampedHeight);
}

module.exports = {
  createShaderProgram: createShaderProgram,
  destroyShaderProgram: destroyShaderProgram,
  createConstantBuffers: createConstantBuffers,
  destroyConstantBuffers: destroyConstantBuffers,
  enableAttributes: enableAttributes,
  disableAttributes: disableAttributes,
  setTexture: setTexture,
  setDepthmapTexture: setDepthmapTexture,
  setDepth: setDepth,
  setViewport: setViewport,
  setupPixelEffectUniforms: setupPixelEffectUniforms
};

},{"../util/clamp":79,"gl-matrix":3}],59:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlCubeRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView}, appropriate
 * for a {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlCubeRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlCubeRenderer, WebGlBaseRenderer);

module.exports = WebGlCubeRenderer;

},{"../util/inherits":93,"./WebGlBase":57}],60:[function(require,module,exports){
'use strict';

var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;
var setDepthmapTexture = WebGlCommon.setDepthmapTexture

var vertexSrc = require('../shaders/vertexCubeDepth');
var fragmentSrc = require('../shaders/fragmentCubeDepth');

// Initialize arrays for vertexIndices, vertexPositions, and textureCoords
var vertexIndices = [];
var vertexPositions = [];
var textureCoords = [];

var defaultWidthSegments = 40;
var defaultHeightSegments = 40;

function createVertexDatas(widthSegments, heightSegments) {

  // Loop through each row and column to generate vertices, texture coordinates, and indices
  for (var row = 0; row <= heightSegments; row++) {
    var v = row / heightSegments;
    for (var col = 0; col <= widthSegments; col++) {
      var u = col / widthSegments;

      // Calculate vertex positions
      var x = u - 0.5;
      var y = v - 0.5;
      var z = 0.0;
      vertexPositions.push(x, y, z);

      // Calculate texture coordinates
      textureCoords.push(u, v);

      // Calculate vertex indices
      if (row < heightSegments && col < widthSegments) {
        var a = row * (widthSegments + 1) + col;
        var b = a + 1;
        var c = (row + 1) * (widthSegments + 1) + col;
        var d = c + 1;
        vertexIndices.push(a, b, c, b, d, c);
      }
    }
  }
}

var attribList = ['aVertexPosition', 'aTextureCoord'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uDepthmap', 'uProjMatrix', 'uViewMatrix',
  'uModelMatrix', 'uViewportMatrix', 'uColorOffset', 'uColorMatrix'
];



/**
 * @class WebGlCubeDepthRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView} with depthmap, appropriate
 * for a {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlCubeDepthRenderer(gl, opts) {
  this.gl = gl;

  // The projection matrix positions the tiles in world space.
  // We compute it in Javascript because lack of precision in the vertex shader
  // causes seams to appear between adjacent tiles at large zoom levels.
  this.projMatrix = mat4.create();

  // TODO Why save this value here? the same question to the projMatrix.
  this.viewMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  // Translation and scale vectors for tiles.
  this.translateVector = vec3.create();
  this.scaleVector = vec3.create();

  var widthSegments = opts && opts.widthSegments ? opts.widthSegments : defaultWidthSegments;
  var heightSegments = opts && opts.heightSegments ? opts.heightSegments : defaultHeightSegments;
  createVertexDatas(widthSegments, heightSegments);
  
  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlCubeDepthRenderer.prototype.destroy = function () {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};

WebGlCubeDepthRenderer.prototype.startLayer = function (layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
  gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};

WebGlCubeDepthRenderer.prototype.endLayer = function (layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};

WebGlCubeDepthRenderer.prototype.renderTile = function (tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var projMatrix = this.projMatrix;
  var viewMatrix = this.viewMatrix;
  var translateVector = this.translateVector;
  var scaleVector = this.scaleVector;

  mat4.copy(projMatrix, layer.view().projection());
  gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);

  mat4.copy(viewMatrix, layer.view().viewMatrix());
  gl.uniformMatrix4fv(shaderProgram.uViewMatrix, false, viewMatrix);

  // Generate ModelMatrix.
  // TODO Cache the matrix in the tile object?
  translateVector[0] = tile.centerX();
  translateVector[1] = tile.centerY();
  translateVector[2] = -0.5;

  scaleVector[0] = tile.scaleX();
  scaleVector[1] = tile.scaleY();
  scaleVector[2] = 1.0;

  var modelMatrix = mat4.create();
  mat4.rotateY(modelMatrix, modelMatrix, -Math.PI / 2);
  mat4.rotateX(modelMatrix, modelMatrix, tile.rotX());
  mat4.rotateY(modelMatrix, modelMatrix, tile.rotY());
  mat4.translate(modelMatrix, modelMatrix, translateVector);
  mat4.scale(modelMatrix, modelMatrix, scaleVector);

  gl.uniformMatrix4fv(shaderProgram.uModelMatrix, false, modelMatrix);

  // Depth, Texture, DepthmapTexture.
  setDepth(gl, shaderProgram, layerZ, tile.z);
  setTexture(gl, shaderProgram, texture);
  setDepthmapTexture(gl, shaderProgram, layer.depthmapStore().texture());

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};

module.exports = WebGlCubeDepthRenderer;
},{"../shaders/fragmentCubeDepth":64,"../shaders/vertexCubeDepth":67,"../util/clearOwnProperties":80,"./WebGlCommon":58,"gl-matrix":3}],61:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexEquirect');
var fragmentSrc = require('../shaders/fragmentEquirect');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uInvProjMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix', 'uTextureX', 'uTextureY', 'uTextureWidth',
  'uTextureHeight'
];


/**
 * @class WebGlEquirectRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link EquirectGeometry} and {@link RectilinearView},
 * appropriate for {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlEquirectRenderer(gl) {
  this.gl = gl;

  // The inverse projection matrix.
  this.invProjMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlEquirectRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};


WebGlEquirectRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var invProjMatrix = this.invProjMatrix;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);

  // Compute and set the inverse projection matrix.
  mat4.copy(invProjMatrix, layer.view().projection());
  mat4.invert(invProjMatrix, invProjMatrix);

  gl.uniformMatrix4fv(shaderProgram.uInvProjMatrix, false, invProjMatrix);

  // Compute and set the texture scale and crop offsets.
  var textureCrop = layer.effects().textureCrop || {};
  var textureX = textureCrop.x != null ? textureCrop.x : 0;
  var textureY = textureCrop.y != null ? textureCrop.y : 0;
  var textureWidth = textureCrop.width != null ? textureCrop.width : 1;
  var textureHeight = textureCrop.height != null ? textureCrop.height : 1;

  gl.uniform1f(shaderProgram.uTextureX, textureX);
  gl.uniform1f(shaderProgram.uTextureY, textureY);
  gl.uniform1f(shaderProgram.uTextureWidth, textureWidth);
  gl.uniform1f(shaderProgram.uTextureHeight, textureHeight);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlEquirectRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlEquirectRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;

  setDepth(gl, shaderProgram, layerZ, tile.z);

  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlEquirectRenderer;

},{"../shaders/fragmentEquirect":65,"../shaders/vertexEquirect":68,"../util/clearOwnProperties":80,"./WebGlCommon":58,"gl-matrix":3}],62:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlFlatRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link FlatGeometry} and {@link FlatView}, appropriate for a
 * {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlFlatRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlFlatRenderer, WebGlBaseRenderer);

module.exports = WebGlFlatRenderer;

},{"../util/inherits":93,"./WebGlBase":57}],63:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlFlat = require('./WebGlFlat');
var WebGlCube = require('./WebGlCube');
var WebGlCubeDepth = require('./WebGlCubeDepth');
var WebGlEquirect = require('./WebGlEquirect');

/**
 * Registers all known renderers for the given stage type into that stage.
 * Most users will not need to register renderers, as {@link Viewer} does it for
 * them.
 *
 * @param {Stage} stage The stage where the renderers are to be registered.
 * @throws An error if the stage type is unknown.
 */
function registerDefaultRenderers(stage) {
  switch (stage.type) {
    case 'webgl':
      stage.registerRenderer('flat', 'flat', WebGlFlat);
      stage.registerRenderer('cube', 'rectilinear', WebGlCube);
      stage.registerRenderer('cube+depth', 'rectilinear', WebGlCubeDepth);
      stage.registerRenderer('equirect', 'rectilinear', WebGlEquirect);
      break;
    default:
      throw new Error('Unknown stage type: ' + stage.type);
  }
}

module.exports = registerDefaultRenderers;

},{"./WebGlCube":59,"./WebGlCubeDepth":60,"./WebGlEquirect":61,"./WebGlFlat":62}],64:[function(require,module,exports){
'use strict';

module.exports = [
  '#ifdef GL_FRAGMENT_PRECISION_HIGH',
  'precision highp float;',
  '#else',
  'precision mediump float;',
  '#endif',

  'uniform sampler2D uSampler;',
  'uniform float uOpacity;',
  'uniform vec4 uColorOffset;',
  'uniform mat4 uColorMatrix;',

  'varying vec2 vTextureCoord;',

  `
  void main(void) {
    if (!gl_FrontFacing) {
      discard; // Discard the front-facing triangles
    } else {
      vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;
      gl_FragColor = vec4(color.rgba * uOpacity);
    }
  }
  `
].join('\n');

},{}],65:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform float uTextureX;',
'uniform float uTextureY;',
'uniform float uTextureWidth;',
'uniform float uTextureHeight;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec4 vRay;',

'const float PI = 3.14159265358979323846264;',

'void main(void) {',
'  float r = inversesqrt(vRay.x * vRay.x + vRay.y * vRay.y + vRay.z * vRay.z);',
'  float phi  = acos(vRay.y * r);',
'  float theta = atan(vRay.x, -1.0*vRay.z);',
'  float s = 0.5 + 0.5 * theta / PI;',
'  float t = 1.0 - phi / PI;',

'  s = s * uTextureWidth + uTextureX;',
'  t = t * uTextureHeight + uTextureY;',

'  vec4 color = texture2D(uSampler, vec2(s, t)) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],66:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float;',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',

`
if (!gl_FrontFacing) {
  discard; // Discard the front-facing triangles
} else {
  vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;
  gl_FragColor = vec4(color.rgba * uOpacity);
}
`,

// '  vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;',
// '  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],67:[function(require,module,exports){
'use strict';

module.exports = [
  'attribute vec3 aVertexPosition;',
  'attribute vec2 aTextureCoord;',

  'uniform sampler2D uDepthmap;',
  'uniform float uDepth;',
  'uniform mat4 uViewportMatrix;',
  'uniform mat4 uProjMatrix;',
  'uniform mat4 uViewMatrix;',
  'uniform mat4 uModelMatrix;',

  'varying vec2 vTextureCoord;',

  `
  float i(in float a, in float b) {
    return b == 0.0 ? sign(a)*1.570796 : atan(a, b);
  }

  void main(void) {
    vec3 c = normalize(vec3(uModelMatrix * vec4(aVertexPosition, 1.0)));

    float x = (1.0 - i(-c.z, c.x)/3.141593)*0.5;
    float y = 0.5 - i(-c.y, sqrt(c.x*c.x + c.z*c.z))/3.141593;
    vec4 f = texture2D(uDepthmap, vec2(x, y));

    float j = (f.r*65536.0 + f.g*256.0 + f.b)/65793.0;
    vec3 b = c*(1.0 - j);
    vec3 a = vec3(uViewMatrix * vec4(b.z, b.y, -b.x, 1));

    gl_Position = uViewportMatrix * uProjMatrix * vec4(a, 1.0);
    gl_Position.z = uDepth * gl_Position.w;
    vTextureCoord = aTextureCoord;
  }
  `
].join('\n');

},{}],68:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uInvProjMatrix;',

'varying vec4 vRay;',

'void main(void) {',
'  vRay = uInvProjMatrix * vec4(aVertexPosition.xy, 1.0, 1.0);',
'  gl_Position = uViewportMatrix * vec4(aVertexPosition.xy, uDepth, 1.0);',
'}'
].join('\n');

},{}],69:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',
'attribute vec2 aTextureCoord;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uProjMatrix;',
'uniform mat4 uViewMatrix;',
'uniform mat4 uModelMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',
'  gl_Position = uViewportMatrix * uProjMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);',
'  gl_Position.z = uDepth * gl_Position.w;',
'  vTextureCoord = aTextureCoord;',
'}'
].join('\n');

},{}],70:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var NetworkError = require('../NetworkError');
var WorkPool = require('../collections/WorkPool');
var chain = require('../util/chain');
var delay = require('../util/delay');
var now = require('../util/now');


// Map template properties to their corresponding tile properties.
var templateProperties = {
  x: 'x',
  y: 'y',
  z: 'z',
  f: 'face'
};

// Default face order for cube maps.
var defaultCubeMapFaceOrder = 'bdflru';

// Default maximum number of concurrent requests.
var defaultConcurrency = 4;

// Default milliseconds to wait before retrying failed requests.
var defaultRetryDelay = 10000;


/**
 * @class ImageUrlSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that loads {@link Asset assets} from images given a URL and
 * a crop rectangle.
 *
 * @param {Function} sourceFromTile Function that receives a tile and returns
 * a `{ url, rect }` object, where `url` is an image URL and `rect`, when
 * present, is an `{ x, y, width, height }` object in normalized coordinates
 * denoting the portion of the image to use.
 * @param {Object} opts
 * @param {number} [opts.concurrency=4] Maximum number of tiles to request at
 *     the same time. The limit is per {@link ImageSourceUrl} instance.
 * @param {number} [opts.retryDelay=10000] Time in milliseconds to wait before
 *     retrying a failed request.
 */
function ImageUrlSource(sourceFromTile, opts) {

  opts = opts ? opts : {};

  this._loadPool = new WorkPool({
    concurrency: opts.concurrency || defaultConcurrency
  });

  this._retryDelay = opts.retryDelay || defaultRetryDelay;
  this._retryMap = {};

  this._sourceFromTile = sourceFromTile;
}

eventEmitter(ImageUrlSource);


ImageUrlSource.prototype.loadAsset = function(stage, tile, done) {

  var self = this;

  var retryDelay = this._retryDelay;
  var retryMap = this._retryMap;

  var tileSource = this._sourceFromTile(tile);
  var url = tileSource.url;
  var rect = tileSource.rect;

  var loadImage = stage.loadImage.bind(stage, url, rect);

  var loadFn = function(done) {
    // TODO: Deduplicate load requests for the same URL. Although the browser
    // might be smart enough to avoid duplicate requests, they are still unduly
    // impacted by the concurrency parameter.
    return self._loadPool.push(loadImage, function(err, asset) {
      if (err) {
        if (err instanceof NetworkError) {
          // If a network error occurred, wait before retrying.
          retryMap[url] = now();
          self.emit('networkError', err, tile);
        }
        done(err, tile);
      } else {
        // On a successful fetch, forget the previous timeout.
        delete retryMap[url];
        done(null, tile, asset);
      }
    });
  };

  // Check whether we are retrying a failed request.
  var delayAmount;
  var lastTime = retryMap[url];
  if (lastTime != null) {
    var currentTime = now();
    var elapsed = currentTime - lastTime;
    if (elapsed < retryDelay) {
      // Wait before retrying.
      delayAmount = retryDelay - elapsed;
    } else {
      // Retry timeout expired; perform the request at once.
      delayAmount = 0;
      delete retryMap[url];
    }
  }

  var delayFn = delay.bind(null, delayAmount);

  return chain(delayFn, loadFn)(done);
};


/**
 * Creates an ImageUrlSource from a string template.
 *
 * @param {String} url Tile URL template, which may contain the following
 *    placeholders:
 *    - `{f}` : tile face (one of `b`, `d`, `f`, `l`, `r`, `u`)
 *    - `{z}` : tile level index (0 is the smallest level)
 *    - `{x}` : tile horizontal index
 *    - `{y}` : tile vertical index
 * @param {Object} opts In addition to the options already supported by the
 *     {@link ImageUrlSource} constructor.
 * @param {String} opts.cubeMapPreviewUrl URL to use as the preview level.
 *     This must be a single image containing six cube faces laid out
 *     vertically according to the face order parameter.
 * @param {String} [opts.cubeMapPreviewFaceOrder='bdflru'] Face order within
 *     the preview image.
 */
ImageUrlSource.fromString = function(url, opts) {
  opts = opts || {};

  var faceOrder = opts && opts.cubeMapPreviewFaceOrder || defaultCubeMapFaceOrder;

  var urlFn = opts.cubeMapPreviewUrl ? withPreview : withoutPreview;

  return new ImageUrlSource(urlFn, opts);

  function withoutPreview(tile) {
    var tileUrl = url;

    for (var property in templateProperties) {
      var templateProperty = templateProperties[property];
      var regExp = propertyRegExp(property);
      var valueFromTile = tile.hasOwnProperty(templateProperty) ? tile[templateProperty] : '';
      tileUrl = tileUrl.replace(regExp, valueFromTile);
    }

    return { url: tileUrl };
  }

  function withPreview(tile) {
    if (tile.z === 0) {
      return cubeMapUrl(tile);
    }
    else {
      return withoutPreview(tile);
    }
  }

  function cubeMapUrl(tile) {
    var y = faceOrder.indexOf(tile.face) / 6;
    return {
      url: opts.cubeMapPreviewUrl,
      rect: { x: 0, y: y, width: 1, height: 1/6 }
    };
  }
};

function propertyRegExp(property) {
  var regExpStr = '\\{(' + property + ')\\}';
  return new RegExp(regExpStr, 'g');
}

module.exports = ImageUrlSource;

},{"../NetworkError":19,"../collections/WorkPool":33,"../util/chain":78,"../util/delay":88,"../util/now":97,"minimal-event-emitter":14}],71:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class SingleAssetSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that always provides the same {@link Asset}.
 *
 * @param {Asset} asset The asset.
*/
function SingleAssetSource(asset) {
  this._asset = asset;
}

SingleAssetSource.prototype.asset = function() {
  return this._asset;
};

SingleAssetSource.prototype.loadAsset = function(stage, tile, done) {
  var self = this;

  var timeout = setTimeout(function() {
    done(null, tile, self._asset);
  }, 0);

  function cancel() {
    clearTimeout(timeout);
    done.apply(null, arguments);
  }

  return cancel;
};

module.exports = SingleAssetSource;

},{}],72:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class RendererRegistry
 * @classdesc
 *
 * A RendererRegistry maps pairs of {@link Geometry} and {@link View} type into
 * the appropriate {@link Renderer} class. It is used by a {@link Stage} to
 * determine the appropriate renderer for a {@link Layer}.
 *
 * See also {@link Stage#registerRenderer}.
 */
function RendererRegistry() {
  this._renderers = {};
}

/**
 * Registers a renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
RendererRegistry.prototype.set = function(geometryType, viewType, Renderer) {
  if (!this._renderers[geometryType]) {
    this._renderers[geometryType] = {};
  }
  this._renderers[geometryType][viewType] = Renderer;
};

/**
 * Retrieves the renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class, or null if no such renderer has been
 * registered.
 */
RendererRegistry.prototype.get = function(geometryType, viewType) {
  var Renderer = this._renderers[geometryType] &&
      this._renderers[geometryType][viewType];
  return Renderer || null;
};

module.exports = RendererRegistry;

},{}],73:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var WorkQueue = require('../collections/WorkQueue');
var calcRect = require('../util/calcRect');
var async = require('../util/async');
var cancelize = require('../util/cancelize');
var clearOwnProperties = require('../util/clearOwnProperties');

var RendererRegistry = require('./RendererRegistry');

function forwardTileCmp(t1, t2) {
  return t1.cmp(t2);
}

function reverseTileCmp(t1, t2) {
  return -t1.cmp(t2);
}

/**
 * Signals that the stage has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Stage#renderComplete
 */

/**
 * Signals that the contents of the stage have been invalidated and must be
 * rendered again.
 *
 * This is used by the {@link RenderLoop} implementation.
 *
 * @event Stage#renderInvalid
 */

/**
 * @interface Stage
 * @classdesc
 *
 * A Stage is a container with the ability to render a stack of
 * {@link Layer layers}.
 *
 * This class should never be instantiated directly. Use {@link WebGlStage}
 * instead.
 *
 * @param {Object} opts
 * @param {boolean} [opts.progressive=false]
 *
 * Options listed here may be passed into the `opts` constructor argument of
 * subclasses.
 *
 * The `progressive` option controls whether resolution levels are loaded in
 * order, from lowest to highest. This results in a more pleasing effect when
 * zooming past several levels in a large panoramas, but consumes additional
 * bandwidth.
 */
function Stage(opts) {
  this._progressive = !!(opts && opts.progressive);

  // The list of layers in display order (background to foreground).
  this._layers = [];

  // The list of renderers; the i-th renderer is for the i-th layer.
  this._renderers = [];

  // The lists of tiles to load and render, populated during render().
  this._tilesToLoad = [];
  this._tilesToRender = [];

  // Temporary tile lists.
  this._tmpVisible = [];
  this._tmpChildren = [];

  // Cached stage dimensions.
  // Start with zero, which inhibits rendering until setSize() is called.
  this._width = 0;
  this._height = 0;

  // Temporary variable for rect.
  this._tmpRect = {};

  // Temporary variable for size.
  this._tmpSize = {};

  // Work queue for createTexture.
  this._createTextureWorkQueue = new WorkQueue();

  // Function to emit event when render parameters have changed.
  this._emitRenderInvalid = this._emitRenderInvalid.bind(this);

  // The renderer registry maps each geometry/view pair into the respective
  // Renderer class.
  this._rendererRegistry = new RendererRegistry();
}

eventEmitter(Stage);


/**
 * Destructor.
 */
Stage.prototype.destroy = function() {
  this.removeAllLayers();
  clearOwnProperties(this);
};


/**
 * Registers a {@link Renderer} for the given {@link Geometry} and {@link View}
 * type.
 *
 * The {@link registerDefaultRenderers} utility function may be used to
 * register all known renderers for a stage type into that stage. Most users
 * will not need to register renderers, as {@link Viewer} does it for them.
 *
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
Stage.prototype.registerRenderer = function(geometryType, viewType, Renderer) {
  return this._rendererRegistry.set(geometryType, viewType, Renderer);
};


/**
 * Returns the underlying DOM element.
 *
 * Must be overridden by subclasses.
 *
 * @return {Element}
 */
Stage.prototype.domElement = function() {
  throw new Error('Stage implementation must override domElement');
};


/**
 * Get the stage width.
 * @return {number}
 */
Stage.prototype.width = function() {
  return this._width;
};


/**
 * Get the stage height.
 * @return {number}
 */
Stage.prototype.height = function() {
  return this._height;
};


/**
 * Get the stage dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 *
 * @param {Size=} size
 */
Stage.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Set the stage dimensions.
 *
 * This contains the size update logic common to all stage types. Subclasses
 * must define the {@link Stage#setSizeForType} method to perform their own
 * logic.
 *
 * @param {Size} size
 */
Stage.prototype.setSize = function(size) {
  this._width = size.width;
  this._height = size.height;

  this.setSizeForType(); // must be defined by subclasses.

  this.emit('resize');
  this._emitRenderInvalid();
};


/**
 * Call {@link Stage#setSize} instead.
 *
 * This contains the size update logic specific to a stage type. It is called by
 * {@link Stage#setSize} after the base class has been updated to reflect the
 * new size, but before any events are emitted.
 *
 * @param {Size} size
 */
Stage.prototype.setSizeForType = function(size) {
  throw new Error('Stage implementation must override setSizeForType');
};


/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
Stage.prototype.loadImage = function() {
  throw new Error('Stage implementation must override loadImage');
};


Stage.prototype._emitRenderInvalid = function() {
  this.emit('renderInvalid');
};


/**
 * Verifies that the layer is valid for this stage, throwing an exception
 * otherwise.
 *
 * @param {Layer} layer
 * @throws {Error} If the layer is not valid for this stage.
 */
Stage.prototype.validateLayer = function(layer) {
  throw new Error('Stage implementation must override validateLayer');
};


/**
 * Returns a list of all {@link Layer layers} belonging to the stage. The
 * returned list is in display order, background to foreground.
 * @return {Layer[]}
 */
Stage.prototype.listLayers = function() {
  // Return a copy to prevent unintended mutation by the caller.
  return [].concat(this._layers);
};


/**
 * Return whether a {@link Layer layer} belongs to the stage.
 * @param {Layer} layer
 * @return {boolean}
 */
Stage.prototype.hasLayer = function(layer) {
  return this._layers.indexOf(layer) >= 0;
};


/**
 * Adds a {@link Layer layer} into the stage.
 * @param {Layer} layer The layer to add.
 * @param {number|undefined} i The optional position, where 0 ≤ i ≤ n and n is
 *     the current number of layers. The default is n, which inserts at the
 *     top of the display stack.
 * @throws An error if the layer already belongs to the stage or if the position
 *     is invalid.
 */
Stage.prototype.addLayer = function(layer, i) {
  if (this._layers.indexOf(layer) >= 0) {
    throw new Error('Layer already in stage');
  }

  if (i == null) {
    i = this._layers.length;
  }
  if (i < 0 || i > this._layers.length) {
    throw new Error('Invalid layer position');
  }

  this.validateLayer(layer); // must be defined by subclasses.

  var geometryType = layer.geometry().type;
  if (layer.depthmap()) {
    geometryType += '+depth';
  }
  var viewType = layer.view().type;
  var rendererClass = this._rendererRegistry.get(geometryType, viewType);
  if (!rendererClass) {
    throw new Error('No ' + this.type + ' renderer avaiable for ' +
        geometryType + ' geometry and ' + viewType + ' view');
  }
  var renderer = this.createRenderer(rendererClass);

  this._layers.splice(i, 0, layer);
  this._renderers.splice(i, 0, renderer);

  // Listeners for render invalid.
  layer.addEventListener('viewChange', this._emitRenderInvalid);
  layer.addEventListener('effectsChange', this._emitRenderInvalid);
  layer.addEventListener('fixedLevelChange', this._emitRenderInvalid);
  layer.addEventListener('textureStoreChange', this._emitRenderInvalid);

  this._emitRenderInvalid();
};


/**
 * Moves a {@link Layer layer} into a different position in the display stack.
 * @param {Layer} layer The layer to move.
 * @param {number} i The position, where 0 ≤ i ≤ n-1 and n is the current number
 *     of layers.
 * @throws An error if the layer does not belong to the stage or if the position
 *     is invalid.
 */
Stage.prototype.moveLayer = function(layer, i) {
  var index = this._layers.indexOf(layer);
  if (index < 0) {
    throw new Error('No such layer in stage');
  }

  if (i < 0 || i >= this._layers.length) {
    throw new Error('Invalid layer position');
  }

  layer = this._layers.splice(index, 1)[0];
  var renderer = this._renderers.splice(index, 1)[0];

  this._layers.splice(i, 0, layer);
  this._renderers.splice(i, 0, renderer);

  this._emitRenderInvalid();
};


/**
 * Removes a {@link Layer} from the stage.
 * @param {Layer} layer The layer to remove.
 * @throws An error if the layer does not belong to the stage.
 */
Stage.prototype.removeLayer = function(layer) {
  var index = this._layers.indexOf(layer);
  if (index < 0) {
    throw new Error('No such layer in stage');
  }

  var removedLayer = this._layers.splice(index, 1)[0];
  var renderer = this._renderers.splice(index, 1)[0];

  this.destroyRenderer(renderer);

  removedLayer.removeEventListener('viewChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('effectsChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('fixedLevelChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('textureStoreChange', this._emitRenderInvalid);

  this._emitRenderInvalid();
};


/**
 * Removes all {@link Layer layers} from the stage.
 */
Stage.prototype.removeAllLayers = function() {
  while (this._layers.length > 0) {
    this.removeLayer(this._layers[0]);
  }
};


/**
 * Called before a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.startFrame = function() {
  throw new Error('Stage implementation must override startFrame');
};


/**
 * Called after a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.endFrame = function() {
  throw new Error('Stage implementation must override endFrame');
};


/**
 * Render the current frame. Usually called from a {@link RenderLoop}.
 *
 * This contains the rendering logic common to all stage types. Subclasses
 * define the startFrame() and endFrame() methods to perform their own logic.
 */
Stage.prototype.render = function() {
  var i, j;

  var tilesToLoad = this._tilesToLoad;
  var tilesToRender = this._tilesToRender;

  var stableStage = true;
  var stableLayer;

  // Get the stage dimensions.
  var width = this._width;
  var height = this._height;

  var rect = this._tmpRect;
  var size = this._tmpSize;

  if (width <= 0 || height <= 0) {
    return;
  }

  this.startFrame(); // defined by subclasses

  // Signal start of frame to the texture stores.
  for (i = 0; i < this._layers.length; i++) {
    this._layers[i].textureStore().startFrame();
  }

  // Render layers.
  for (i = 0; i < this._layers.length; i++) {
    var layer = this._layers[i];
    var effects = layer.effects();
    var view = layer.view();
    var textureStore = layer.textureStore();
    var renderer = this._renderers[i];
    var depth = this._layers.length - i;
    var tile, texture;

    // Convert the rect effect into a normalized rect.
    // TODO: avoid doing this on every frame.
    calcRect(width, height, effects && effects.rect, rect);

    if (rect.width <= 0 || rect.height <= 0) {
      // Skip rendering on a null viewport.
      continue;
    }

    // Update the view size.
    size.width = rect.width * this._width;
    size.height = rect.height * this._height;
    view.setSize(size);

    // Signal start of layer to the renderer.
    renderer.startLayer(layer, rect);

    // We render with both alpha blending and depth testing enabled. Thus, when
    // rendering a subsequent pixel at the same location than an existing one,
    // the subsequent pixel gets discarded unless it has smaller depth, and is
    // otherwise composited with the existing pixel.
    //
    // When using fallback tiles to fill a gap in the preferred resolution
    // level, we prefer higher resolution fallbacks to lower resolution ones.
    // However, where fallbacks overlap, we want higher resolution ones to
    // prevail, and we don't want multiple fallbacks to be composited with each
    // other, as that would produce a bad result when semitransparent textures
    // are involved.
    //
    // In order to achieve this within the constraints of alpha blending and
    // depth testing, the depth of a tile must be inversely proportional to its
    // resolution, and higher-resolution tiles must be rendered before lower-
    // resolution ones.

    // Collect the lists of tiles to load and render.
    stableLayer = this._collectTiles(layer, textureStore);

    // Mark all the tiles whose textures must be loaded.
    // This will either trigger loading (for textures not yet loaded) or
    // prevent unloading (for textures already loaded).
    for (j = 0; j < tilesToLoad.length; j++) {
      tile = tilesToLoad[j];
      textureStore.markTile(tile);
    }

    // Render tiles.
    for (j = 0; j < tilesToRender.length; j++) {
      tile = tilesToRender[j];
      texture = textureStore.texture(tile);
      renderer.renderTile(tile, texture, layer, depth);
    }

    layer.emit('renderComplete', stableLayer);
    if (!stableLayer) {
      stableStage = false;
    }

    // Signal end of layer to the renderer.
    renderer.endLayer(layer, rect);
  }

  // Signal end of frame to the texture stores.
  for (i = 0; i < this._layers.length; i++) {
    this._layers[i].textureStore().endFrame();
  }

  this.endFrame(); // defined by subclasses

  this.emit('renderComplete', stableStage);
};

Stage.prototype._collectTiles = function(layer, textureStore) {
  var tilesToLoad = this._tilesToLoad;
  var tilesToRender = this._tilesToRender;
  var tmpVisible = this._tmpVisible;

  tilesToLoad.length = 0;
  tilesToRender.length = 0;
  tmpVisible.length = 0;

  layer.visibleTiles(tmpVisible);

  var isStable = true;

  for (var i = 0; i < tmpVisible.length; i++) {
    var tile = tmpVisible[i];
    var needsFallback;
    this._collectTileToLoad(tile);
    if (textureStore.texture(tile)) {
      // The preferred texture is available.
      // No fallback is required.
      needsFallback = false;
      this._collectTileToRender(tile);
    } else {
      // The preferred texture is unavailable.
      // Collect children for rendering as a fallback.
      needsFallback = this._collectChildren(tile, textureStore);
      isStable = false;
    }
    // Collect all parents for loading, and the closest parent for rendering if
    // a fallback is required.
    this._collectParents(tile, textureStore, needsFallback);
  }

  // Sort tiles to load in ascending resolution order.
  tilesToLoad.sort(forwardTileCmp);

  // Sort tiles to render in descending resolution order.
  tilesToRender.sort(reverseTileCmp);

  return isStable;
};

Stage.prototype._collectChildren = function(tile, textureStore) {
  var tmpChildren = this._tmpChildren;

  var needsFallback = true;

  // Fall back as many levels as necessary on single-child geometries, but do
  // not go beyond immediate children on multiple-child geometries, to avoid
  // exploring an exponential number of tiles.
  do {
    tmpChildren.length = 0;
    if (!tile.children(tmpChildren)) {
      break;
    }
    needsFallback = false;
    for (var i = 0; i < tmpChildren.length; i++) {
      tile = tmpChildren[i];
      if (textureStore.texture(tile)) {
        this._collectTileToLoad(tile);
        this._collectTileToRender(tile);
      } else {
        needsFallback = true;
      }
    }
  } while (needsFallback && tmpChildren.length === 1)

  return needsFallback;
};

Stage.prototype._collectParents = function(tile, textureStore, needsFallback) {
  // Recursively visit parent tiles until:
  //   - all parents have been marked for loading, if progressive rendering is
  //     enabled; and
  //   - at least one parent has been marked for both loading and rendering, if
  //     a fallback is required.
  var needsLoading = this._progressive;
  while ((needsLoading || needsFallback) && (tile = tile.parent()) != null) {
    if (needsFallback) {
      if (textureStore.texture(tile)) {
        this._collectTileToRender(tile);
        needsFallback = false;
      } else if (!this._progressive) {
        continue;
      }
    }
    if (!this._collectTileToLoad(tile)) {
      needsLoading = false;
    }
  }
  return needsFallback;
};

Stage.prototype._collectTileToLoad = function(tile) {
  return this._collectTileIntoList(tile, this._tilesToLoad);
};

Stage.prototype._collectTileToRender = function(tile) {
  return this._collectTileIntoList(tile, this._tilesToRender);
};

Stage.prototype._collectTileIntoList = function(tile, tileList) {
  // TODO: Investigate whether it's worth it to make this better than O(n²).
  var found = false;
  for (var i = 0; i < tileList.length; i++) {
    if (tile.equals(tileList[i])) {
      found = true;
      break;
    }
  }
  if (!found) {
    tileList.push(tile);
  }
  return !found;
};

/**
 * Create a texture for the given tile and asset. Called by {@link TextureStore}.
 * @param {Tile} tile
 * @param {Asset} asset
 * @param {Function} done
 */
Stage.prototype.createTexture = function(tile, asset, done) {

  var self = this;

  function makeTexture() {
    return new self.TextureClass(self, tile, asset);
  }

  var fn = cancelize(async(makeTexture));

  return this._createTextureWorkQueue.push(fn, function(err, texture) {
    done(err, tile, asset, texture);
  });

};

/**
 * The stage type, used to determine the appropriate renderer for a given
 * geometry and view.
 *
 * The sole known value is `"webgl".
 *
 * See also {@link Stage#registerRenderer}.
 *
 * @property {string}
 * @name Stage#type
 */

module.exports = Stage;

},{"../collections/WorkQueue":34,"../util/async":75,"../util/calcRect":76,"../util/cancelize":77,"../util/clearOwnProperties":80,"./RendererRegistry":72,"minimal-event-emitter":14}],74:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Stage = require('./Stage');
var HtmlImageLoader = require('../loaders/HtmlImage');
var browser = require('bowser');
var inherits = require('../util/inherits');
var pixelRatio = require('../util/pixelRatio');
var ispot = require('../util/ispot');
var setAbsolute = require('../util/dom').setAbsolute;
var setFullSize = require('../util/dom').setFullSize;
var clearOwnProperties = require('../util/clearOwnProperties');

// TODO(tjgq): Unify Stage and WebGlStage.

// Browser-specific workarounds.
var browserQuirks = {
  // Whether to use texImage2D instead of texSubImage2D when repainting an
  // existing texture from a video element. On most browsers texSubImage2D is
  // faster, but on Chrome the performance degrades significantly. See:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=612542
  videoUseTexImage2D: browser.chrome
};


function initWebGlContext(canvas, opts) {
  var options = {
    alpha: true,
    premultipliedAlpha: true,
    antialias: !!(opts && opts.antialias),
    preserveDrawingBuffer: !!(opts && opts.preserveDrawingBuffer)
  };

  var gl = (canvas.getContext) && (canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options));

  if (!gl) {
    throw new Error('Could not get WebGL context');
  }

  if (opts.wrapContext) {
    gl = opts.wrapContext(gl);
  }

  return gl;
}

/**
 * @class WebGlStage
 * @extends Stage
 * @classdesc
 *
 * A {@link Stage} implementation using WebGl.
 *
 * @param {Object} opts
 * @param {boolean} [opts.antialias=false]
 * @param {boolean} [opts.preserveDrawingBuffer=false]
 * @param {boolean} [opts.generateMipmaps=false]
 * @param {function} [opts.wrapContext]
 *
 * The `antialias` and `preserveDrawingBuffer` options control the WebGL
 * context attributes of the same name. The `alpha` and `premultipliedAlpha`
 * WebGL context attributes are set to their default true value and cannot
 * be overriden; this allows semitransparent textures to be composited with
 * the page. See:
 * https://www.khronos.org/registry/webgl/specs/1.0/#WEBGLCONTEXTATTRIBUTES
 *
 * The `generateMipmaps` option controls texture mipmap generation. Mipmaps
 * may improve rendering quality, at the cost of increased memory usage.
 * Due to technical limitations, they are only generated for textures whose
 * dimensions are a power of two. See:
 * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
 *
 * The `wrapContext` option is a function that receives and returns a
 * WebGLRenderingContext. The stage will use its return value as the context.
 * This is useful when used together with WebGLDebugUtils to debug WebGL issues.
 * See https://www.khronos.org/webgl/wiki/Debugging.
 *
 * Also see the available {@link Stage} options.
 */
function WebGlStage(opts) {
  opts = opts || {};

  var self = this;

  this.constructor.super_.call(this, opts);

  this._generateMipmaps = opts.generateMipmaps != null ?
    opts.generateMipmaps : false;

  this._loader = new HtmlImageLoader(this);

  this._domElement = document.createElement('canvas');

  setAbsolute(this._domElement);
  setFullSize(this._domElement);

  this._gl = initWebGlContext(this._domElement, opts);

  this._handleContextLoss = function() {
    self.emit('webglcontextlost');
    self._gl = null;
  };

  // Handle WebGl context loss.
  this._domElement.addEventListener('webglcontextlost', this._handleContextLoss);

  // WebGl renderers are singletons for a given stage. This list stores the
  // existing renderers so they can be reused across layers with the same
  // geometry and view type.
  this._rendererInstances = [];

  // Width and Height segments for depthmap mesh.
  this._widthSegments = opts.widthSegments ? opts.widthSegments : undefined;
  this._heightSegments = opts.heightSegments ? opts.heightSegments : undefined;
}

inherits(WebGlStage, Stage);


/**
 * Destructor.
 */
WebGlStage.prototype.destroy = function() {
  this._domElement.removeEventListener('webglcontextlost', this._handleContextLoss);
  // Delegate clearing own properties to the Stage destructor.
  this.constructor.super_.prototype.destroy.call(this);
};


/**
 * Returns the underlying DOM element.
 *
 * @return {Element}
 */
WebGlStage.prototype.domElement = function() {
  return this._domElement;
};


/**
 * Returns the underlying WebGL rendering context.
 *
 * @return {WebGLRenderingContext }
 */
WebGlStage.prototype.webGlContext = function() {
  return this._gl;
};


WebGlStage.prototype.setSizeForType = function() {
  // Update the size of the canvas coordinate space.
  //
  // The size is obtained by taking the stage dimensions, which are set in CSS
  // pixels, and multiplying them by the device pixel ratio. Crucially, this
  // must be the only place where the WebGL rendering pipeline accesses the
  // pixel ratio; subsequent uses should reference the `drawingBufferWidth` and
  // `drawingBufferHeight` properties on the WebGLRenderingContext. Failing to
  // do so will break the rendering if the pixel ratio changes but the stage
  // size does not, e.g. when moving the window across screens.
  var ratio = pixelRatio();
  this._domElement.width = ratio * this._width;
  this._domElement.height = ratio * this._height;
};


WebGlStage.prototype.loadImage = function(url, rect, done) {
  return this._loader.loadImage(url, rect, done);
};


WebGlStage.prototype.maxTextureSize = function() {
  return this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);
};


WebGlStage.prototype.validateLayer = function(layer) {
  var tileSize = layer.geometry().maxTileSize();
  var maxTextureSize = this.maxTextureSize();
  if (tileSize > maxTextureSize) {
    throw new Error('Layer has level with tile size larger than maximum texture size (' + tileSize + ' vs. ' + maxTextureSize + ')');
  }
};


WebGlStage.prototype.createRenderer = function(Renderer) {
  var rendererInstances = this._rendererInstances;
  for (var i = 0; i < rendererInstances.length; i++) {
    if (rendererInstances[i] instanceof Renderer) {
      return rendererInstances[i];
    }
  }
  var renderer = new Renderer(this._gl, {
    widthSegments: this._widthSegments,
    heightSegments: this._heightSegments
  });
  rendererInstances.push(renderer);
  return renderer;
};


WebGlStage.prototype.destroyRenderer = function(renderer) {
  var rendererInstances = this._rendererInstances;
  if (this._renderers.indexOf(renderer) < 0) {
    renderer.destroy();
    var index = rendererInstances.indexOf(renderer);
    if (index >= 0) {
      rendererInstances.splice(index, 1);
    }
  }
};


WebGlStage.prototype.startFrame = function() {

  var gl = this._gl;

  if (!gl) {
    throw new Error('Bad WebGL context - maybe context was lost?');
  }

  // Set the WebGL viewport.
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

  // Clear framebuffer.
  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Enable depth testing.
  gl.enable(gl.DEPTH_TEST);

  // Enable blending. ONE and ONE_MINUS_SRC_ALPHA are the right choices for
  // premultiplied textures.
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

};


WebGlStage.prototype.endFrame = function() {};


WebGlStage.prototype.takeSnapshot = function(options) {

  // Validate passed argument
  if (typeof options !== 'object' || options == null) {
    options = {};
  }

  var quality = options.quality;

  // Set default quality if it is not passed
  if (typeof quality == 'undefined') {
    quality = 75;
  }

  // Throw if quality is of invlid type or out of bounds
  if (typeof quality !== 'number' || quality < 0 || quality > 100) {
    throw new Error('WebGLStage: Snapshot quality needs to be a number between 0 and 100');
  }

  // Canvas method "toDataURL" needs to be called in the same
  // context as where the actual rendering is done. Hence this.
  this.render();

  // Return the snapshot
  return this._domElement.toDataURL('image/jpeg', quality / 100);
}


WebGlStage.type = WebGlStage.prototype.type = 'webgl';


function WebGlTexture(stage, tile, asset) {
  this._stage = stage;
  this._gl = stage._gl;
  this._texture = null;
  this._timestamp = null;
  this._width = this._height = null;
  this.refresh(tile, asset);
}


WebGlTexture.prototype.refresh = function(tile, asset) {

  var gl = this._gl;
  var stage = this._stage;
  var texture;

  // Check whether the texture needs to be updated.
  var timestamp = asset.timestamp();
  if (timestamp === this._timestamp) {
    return;
  }

  // Get asset element.
  var element = asset.element();

  // Get asset dimensions.
  var width = asset.width();
  var height = asset.height();

  if (width !== this._width || height !== this._height) {

    // If the texture dimensions have changed since the last refresh, create
    // a new texture with the correct size.

    // Check if texture dimensions would exceed the maximum texture size.
    var maxSize = stage.maxTextureSize();
    if (width > maxSize) {
      throw new Error('Texture width larger than max size (' + width + ' vs. ' + maxSize + ')');
    }
    if (height > maxSize) {
      throw new Error('Texture height larger than max size (' + height + ' vs. ' + maxSize + ')');
    }

    // Delete the current texture if it exists.
    // This is necessary for Chrome on Android. If it isn't done the textures
    // do not render when the size changes.
    if (this._texture) {
      gl.deleteTexture(texture);
    }

    // The texture must be premultiplied by alpha to ensure correct blending of
    // semitransparent textures. For details, see:
    // http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
    texture = this._texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);

  } else {

    // If the texture dimensions remain the same, repaint the existing texture.
    // Repainting with texSubImage2D is usually faster than with texImage2D,
    // except in the case noted in browserQuirks.

    texture = this._texture;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    if (element instanceof HTMLVideoElement && browserQuirks.videoUseTexImage2D) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, element);
    }

  }

  // Generate mipmap if the corresponding stage option is set and the texture
  // dimensions are powers of two.
  if (stage._generateMipmaps && ispot(width) && ispot(height)) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.generateMipmap(gl.TEXTURE_2D);
  } else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  }

  // Clamp texture to edges.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // Unbind texture.
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Update texture dimensions and timestamp.
  this._timestamp = timestamp;
  this._width = width;
  this._height = height;

};


WebGlTexture.prototype.destroy = function() {
  if (this._texture) {
    this._gl.deleteTexture(this._texture);
  }
  clearOwnProperties(this);
};


WebGlStage.TextureClass = WebGlStage.prototype.TextureClass = WebGlTexture;


module.exports = WebGlStage;

},{"../loaders/HtmlImage":56,"../util/clearOwnProperties":80,"../util/dom":89,"../util/inherits":93,"../util/ispot":94,"../util/pixelRatio":99,"./Stage":73,"bowser":1}],75:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Transform a synchronous function into an asynchronous one.
function async(fn) {
  return function asynced(done) {
    var err, ret;
    try {
      ret = fn();
    } catch (e) {
      err = e;
    } finally {
      if (err) {
        done(err);
      } else {
        done(null, ret);
      }
    }
  };
}

module.exports = async;

},{}],76:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Converts a {@link RectSpec} into an equivalent {@link Rect}.
 *
 * A {@link RectSpec} is a convenient user API format, providing default values
 * and the flexibility of specifying absolute, relative or mixed dimensions.
 *
 * A {@link Rect} is a more convenient format for the rendering pipeline. It is
 * always expressed in normalized coordinates, and all its properties are
 * guaranteed to be present.
 *
 * @param {number} totalWidth The total width of the rendering area in pixels.
 * @param {number} totalHeight The total height of the rendering area in pixels.
 * @param {RectSpec} spec The input spec, defaulting to the full rendering area
 *     if null or undefined.
 * @param {Rect} result The output spec. If the argument is present, it is
 *     filled in and returned; otherwise, a fresh object is returned.
 */
function calcRect(totalWidth, totalHeight, spec, result) {

  result = result || {};

  var width;
  if (spec != null && spec.absoluteWidth != null) {
    width = spec.absoluteWidth / totalWidth;
  } else if (spec != null && spec.relativeWidth != null) {
    width = spec.relativeWidth;
  } else {
    width = 1;
  }

  var height;
  if (spec && spec.absoluteHeight != null) {
    height = spec.absoluteHeight / totalHeight;
  } else if (spec != null && spec.relativeHeight != null) {
    height = spec.relativeHeight;
  } else {
    height = 1;
  }

  var x;
  if (spec != null && spec.absoluteX != null) {
    x = spec.absoluteX / totalWidth;
  } else if (spec != null && spec.relativeX != null) {
    x = spec.relativeX;
  } else {
    x = 0;
  }

  var y;
  if (spec != null && spec.absoluteY != null) {
    y = spec.absoluteY / totalHeight;
  } else if (spec != null && spec.relativeY != null) {
    y = spec.relativeY;
  } else {
    y = 0;
  }

  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;

  return result;
}

module.exports = calcRect;

},{}],77:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var once = require('./once');

// A cancelable function is an asynchronous function (i.e., one whose last
// argument is a callback receiving an error plus zero or more return values)
// that (synchronously) returns a cancel() function. Calling cancel() should
// abort the asynchronous operation and call the callback with the arguments
// that were passed into cancel(). Calling cancel() twice, as with callbacks,
// is not guaranteed to be safe.

// Wrap a non-cancellable asynchronous function into a cancelable one.
//
// Calling cancel() on the returned function will not interrupt the execution
// of the original function; it will merely ignore its return value.
//
// Usually, instead of wrapping your function, you want to implement cancel()
// yourself in order to have some abort logic. This utility function provides a
// straighforward solution for cases in which no custom abort logic is required.
function cancelize(fn) {
  return function cancelized() {
    if (!arguments.length) {
      throw new Error('cancelized: expected at least one argument');
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var done = args[args.length - 1] = once(args[args.length - 1]);

    function cancel() {
      done.apply(null, arguments);
    }

    fn.apply(null, args);

    return cancel;
  };
}

module.exports = cancelize;

},{"./once":98}],78:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a function that executes its arguments (which should be cancelables)
// in sequence, so that each of them passes its return values to the next.
// Execution is aborted if one of the functions returns an error; in that case
// the last function in the sequence is called with the error.
// See util/cancelize.js for an explanation of what cancelables are.
function chain() {

  // The list of functions to chain together.
  var argList = Array.prototype.slice.call(arguments, 0);

  return function chained() {

    // List of remaining functions to be executed.
    // Make a copy of the original list so we can mutate the former while
    // preserving the latter intact for future invocations of the chain.
    var fnList = argList.slice(0);

    // Currently executing function.
    var fn = null;

    // Cancel method for the currently executing function.
    var cfn = null;

    // Arguments for the first function.
    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];

    // Callback for the chain.
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    // Execute the next function in the chain.
    // Receives the error and return values from the previous function.
    function exec() {

      // Extract error from arguments.
      var err = arguments[0];

      // Abort chain on error.
      if (err) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Terminate if there are no functions left in the chain.
      if (!fnList.length) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Advance to the next function in the chain.
      fn = fnList.shift();
      var _fn = fn;

      // Extract arguments to pass into the next function.
      var ret = Array.prototype.slice.call(arguments, 1);

      // Call next function with previous return value and call back exec.
      ret.push(exec);
      var _cfn = fn.apply(null, ret); // fn(null, ret..., exec)

      // Detect when fn has completed synchronously and do not clobber the
      // internal state in that case. You're not expected to understand this.
      if (_fn !== fn) {
        return;
      }

      // Remember the cancel method for the currently executing function.
      // Detect chaining on non-cancellable function.
      if (typeof _cfn !== 'function') {
        throw new Error('chain: chaining on non-cancellable function');
      } else {
        cfn = _cfn;
      }

    }

    // Cancel chain execution.
    function cancel() {
      if (cfn) {
        cfn.apply(null, arguments);
      }
    }

    // Start chain execution.
    // We call exec as if linking from a previous function in the chain,
    // except that the error is always null. As a consequence, chaining on an
    // empty list yields the identity function.
    args.unshift(null);
    exec.apply(null, args); // exec(null, args...)

    return cancel;

  };

}

module.exports = chain;

},{"./noop":96}],79:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

module.exports = clamp;
},{}],80:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Sets an object's own properties to undefined. This may be called by
// destructors to avoid retaining references and help detect incorrect use of
// destroyed instances.
function clearOwnProperties(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      obj[prop] = undefined;
    }
  }
}

module.exports = clearOwnProperties;

},{}],81:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function cmp(x, y) {
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
}

module.exports = cmp;
},{}],82:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
  * Compose multiple functions
  *
  * `compose(f, g)` returns `function(x) { return f(g(x)); }`
  *
  * @memberof util
  * @param {Function[]} functions The functions to compose
  * @return {Function}
  */
function compose() {
  var fnList = arguments;
  return function composed(initialArg) {
    var ret = initialArg;
    for (var i = 0; i < fnList.length; i++) {
      var fn = fnList[i];
      ret = fn.call(null, ret);
    }
    return ret;
  };
}

module.exports = compose;
},{}],83:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Convert fov
 *
 * For example, to convert from hfov to vfov one would call 
 * `convert(hfov, width, height)`
 *
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function convert(fov, fromDimension, toDimension) {
  return 2 * Math.atan(toDimension * Math.tan(fov / 2) / fromDimension);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htov(fov, width, height) {
  return convert(fov, width, height);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htod(fov, width, height) {
  return convert(fov, width, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtoh(fov, width, height) {
  return convert(fov, height, width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtod(fov, width, height) {
  return convert(fov, height, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtoh(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtov(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), height);
}

/**
 * @namespace util.convertFov
 */
module.exports = {
  convert: convert,
  htov: htov,
  htod: htod,
  vtoh: vtoh,
  vtod: vtod,
  dtoh: dtoh,
  dtov: dtov
};

},{}],84:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Convert a number to a string in decimal notation.
function decimal(x) {
  // Double-precision floats have 15 significant decimal digits.
  return x.toPrecision(15);
}

module.exports = decimal;
},{}],85:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defaults(obj, defaultsObj) {
  for (var key in defaultsObj) {
    if (!(key in obj)) {
      obj[key] = defaultsObj[key];
    }
  }
  return obj;
}

module.exports = defaults;
},{}],86:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defer(fn, args) {
  function deferred() {
    if (args && args.length > 0) {
      fn.apply(null, args);
    } else {
      fn();
    }
  }
  setTimeout(deferred, 0);
}

module.exports = defer;
},{}],87:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} deg
 * @return {number}
 */
function degToRad(deg) {
  return deg * Math.PI / 180;
}

module.exports = degToRad;
},{}],88:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Perform a cancelable delay.
// See util/cancelize.js for an explanation of what cancelables are.
function delay(ms, done) {

  // Work around IE8 bug whereby a setTimeout callback may still be called
  // after the corresponding clearTimeout is invoked.
  var timer = null;

  function finish() {
    if (timer != null) {
      timer = null;
      done(null);
    }
  }

  function cancel() {
    if (timer != null) {
      clearTimeout(timer);
      timer = null;
      done.apply(null, arguments);
    }
  }

  timer = setTimeout(finish, ms);

  return cancel;

}

module.exports = delay;

},{}],89:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


function prefixProperty(property) {

  var style = document.documentElement.style;
  var prefixList = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

  for (var i = 0; i < prefixList.length; i++) {
    var prefix = prefixList[i];
    var capitalizedProperty = property[0].toUpperCase() + property.slice(1);
    var prefixedProperty = prefix + capitalizedProperty;

    if (prefixedProperty in style) {
      return prefixedProperty;
    }
  }

  return property;

}


function getWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function getPropertyWithVendorPrefix(element) {
    return element.style[prefixedProperty];
  };

}


function setWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function setPropertyWithVendorPrefix(element, val) {
    return (element.style[prefixedProperty] = val);
  };
}


var setTransform = setWithVendorPrefix('transform');
var setTransformOrigin = setWithVendorPrefix('transformOrigin');


function setNullTransform(element) {
  setTransform(element, 'translateZ(0)');
}


function setNullTransformOrigin(element) {
  setTransformOrigin(element, '0 0 0');
}


function setAbsolute(element) {
  element.style.position = 'absolute';
}


function setPixelPosition(element, x, y) {
  element.style.left = x + 'px';
  element.style.top = y + 'px';
}


function setPixelSize(element, width, height) {
  element.style.width = width + 'px';
  element.style.height = height + 'px';
}


function setNullSize(element) {
  element.style.width = element.style.height = 0;
}


function setFullSize(element) {
  element.style.width = element.style.height = '100%';
}


function setOverflowHidden(element) {
  element.style.overflow = 'hidden';
}


function setOverflowVisible(element) {
  element.style.overflow = 'visible';
}


function setNoPointerEvents(element) {
  element.style.pointerEvents = 'none';
}


module.exports = {
  prefixProperty: prefixProperty,
  getWithVendorPrefix: getWithVendorPrefix,
  setWithVendorPrefix: setWithVendorPrefix,
  setTransform: setTransform,
  setTransformOrigin: setTransformOrigin,
  setNullTransform: setNullTransform,
  setNullTransformOrigin: setNullTransformOrigin,
  setAbsolute: setAbsolute,
  setPixelPosition: setPixelPosition,
  setPixelSize: setPixelSize,
  setNullSize: setNullSize,
  setFullSize: setFullSize,
  setOverflowHidden: setOverflowHidden,
  setOverflowVisible: setOverflowVisible,
  setNoPointerEvents: setNoPointerEvents
};

},{}],90:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function extend(obj, sourceObj) {
  for (var key in sourceObj) {
    obj[key] = sourceObj[key];
  }
  return obj;
}

module.exports = extend;
},{}],91:[function(require,module,exports){
(function (global){(function (){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// The global object.
var globalObject = (function() {
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  return null;
})();

module.exports = globalObject;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],92:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Jenkins one-at-a-time hash
// http://www.burtleburtle.net/bob/hash/doobs.html
// Input: an array of integers
// Output: an integer

function hash() {
  var h = 0;
  for (var i = 0; i < arguments.length; i++) {
    var k = arguments[i];
    h += k;
    h += k << 10;
    h ^= k >> 6;
  }
  h += h << 3;
  h ^= h >> 11;
  h += h << 15;
  return h >= 0 ? h : -h;
}

module.exports = hash;
},{}],93:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Make ctor a subclass of superCtor.
// Do not depend on ES5 Object.create semantics because of older browsers.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

module.exports = inherits;
},{}],94:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Returns whether n is a power of two.
function ispot(n) {
  return (n & (n - 1)) == 0;
}

module.exports = ispot;
},{}],95:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Modulo operation
 *
 * @memberof util
 * @param {Number} dividend
 * @param {Number} divisor
 * @returns {Number} Value in range `[0,divisor[`
 */
function mod(a, b) {
  return (+a % (b = +b) + b) % b;
}

module.exports = mod;
},{}],96:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function noop() {}

module.exports = noop;
},{}],97:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function getNow() {
  if (typeof performance !== 'undefined' && performance.now) {
    return function performanceNow() {
      return performance.now();
    };
  }
  return function dateNow() {
    return Date.now();
  };
}

module.exports = getNow();

},{}],98:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function once(fn) {
  var called = false;
  var value;
  return function onced() {
    if (!called) {
      called = true;
      value = fn.apply(null, arguments);
    }
    return value;
  };
}

module.exports = once;
},{}],99:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaultPixelRatio = 1;

function pixelRatio() {
  if (typeof window !== 'undefined') {
    if (window.devicePixelRatio) {
      return window.devicePixelRatio;
    }
    else {
      var screen = window.screen;
      if (screen && screen.deviceXDPI && screen.logicalXDPI) {
        return screen.deviceXDPI / screen.logicalXDPI;
      } else if (screen && screen.systemXDPI && screen.logicalXDPI) {
        return screen.systemXDPI / screen.logicalXDPI;
      }
    }
  }
  return defaultPixelRatio;
}

module.exports = pixelRatio;

},{}],100:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var setTransform = require('./dom').setTransform;
var decimal = require('./decimal');

function positionAbsolutely(element, x, y, extraTransforms) {
  extraTransforms = extraTransforms || '';
  // A translateZ(0) transform improves performance on Chrome by creating a
  // new layer for the element, which prevents unnecessary repaints.
  var transform = 'translateX(' + decimal(x) + 'px) translateY(' + decimal(y) + 'px) translateZ(0) ' + extraTransforms;
  setTransform(element, transform);
}

module.exports = positionAbsolutely;

},{"./decimal":84,"./dom":89}],101:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} rad
 * @return {number}
 */
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

module.exports = radToDeg;
},{}],102:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function real(x) {
  return typeof x === 'number' && isFinite(x);
}

module.exports = real;
},{}],103:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a cancelable function that executes fn in a loop until it returns
// successfully.
function retry(fn) {

  return function retried() {

    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    var cfn = null;
    var canceled = false;

    function exec() {
      var err = arguments[0];
      if (!err || canceled) {
        done.apply(null, arguments);
      } else {
        cfn = fn.apply(null, args);
      }
    }

    args.push(exec);
    exec(true);

    return function cancel() {
      canceled = true;
      cfn.apply(null, arguments);
    };

  };

}

module.exports = retry;

},{"./noop":96}],104:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('./now');

function tween(duration, update, done) {
  var cancelled = false;

  var startTime = now();

  function runUpdate() {
    if(cancelled) { return; }
    var tweenVal = (now() - startTime)/duration;
    if(tweenVal < 1) {
      update(tweenVal);
      requestAnimationFrame(runUpdate);
    }
    else {
      update(1);
      done();
    }
  }

  update(0);
  requestAnimationFrame(runUpdate);

  return function cancel() {
    cancelled = true;
    done.apply(null, arguments);
  }
}

module.exports = tween;
},{"./now":97}],105:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function type(x) {
  var typ = typeof x;
  if (typ === 'object') {
    if (x === null) {
      return 'null';
    }
    if (Object.prototype.toString.call(x) === '[object Array]') {
      return 'array';
    }
    if (Object.prototype.toString.call(x) === '[object RegExp]') {
      return 'regexp';
    }
  }
  return typ;
}

module.exports = type;

},{}],106:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var pixelRatio = require('../util/pixelRatio');
var real = require('../util/real');
var clamp = require('../util/clamp');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultX = 0.5;
var defaultY = 0.5;
var defaultZoom = 1;

// Constant values used to simplify the frustum culling logic.
// planeAxes[i] indicates the coordinate value that defines a frustum plane.
// planeCmp[i] indicates how point and plane coordinates should be compared
// to determine whether the point is on the outer side of the plane.
var planeAxes = [
  1, // top
  0, // right
  1, // bottom
  0  // left
];
var planeCmp = [
  -1, // top
  -1, // right
   1, // bottom
   1  // left
];

// A zoom of exactly 0 breaks some computations, so we force a minimum positive
// value. We use 6 decimal places for the epsilon value to avoid broken
// rendering due to loss of precision in floating point computations.
var zoomLimitEpsilon = 0.000001;


/**
 * @interface FlatViewParams
 *
 * A camera configuration for a {@link FlatView}.
 *
 * @property {number} x The horizontal coordinate of the image point displayed
 *     at the viewport center, in the [0, 1] range.
 *     When `x === 0.5`, the image is centered horizontally.
 *     When `x === 0`, the left edge of the image is at the viewport center.
 *     When `x === 1`, the right edge of the image is at the viewport center.
 * @property {number} y The vertical coordinate of the image point displayed at
 *     the viewport center, in the [0, 1] range.
 *     When `y === 0.5`, the image is centered vertically.
 *     When `y === 0`, the top edge of the image is at the viewport center.
 *     When `y === 1`, the bottom edge of the image is at the viewport center.
 * @property {number} zoom The horizontal zoom, in the [0, ∞) range.
 *     When `zoom === 1`, the viewport is as wide as the image.
 *     When `zoom < 1`, the image is zoomed in.
 *     When `zoom > 1`, the image is zoomed out.
 * @property {number} mediaAspectRatio The image aspect ratio.
 *     When `mediaAspectRatio === 1`, the image width equals its height.
 *     When `mediaAspectRatio < 1`, the image width is less than its height.
 *     When `mediaAspectRatio > 1`, the image height is less than its width.
 */


/**
 * @interface FlatViewCoords
 *
 * The position of a point in a flat image.
 *
 * @property {number} x The horizontal coordinate, in the [0, 1] range.
 * @property {number} y The vertical coordinate, in the [0, 1] range.
 */


/**
 * @typedef {function} FlatViewLimiter
 *
 * View limiter for a {@link FlatView}.
 *
 * A view limiter is a function that receives a {@link FlatViewParams} object,
 * optionally modifies it in place, and returns it. It can be used to enforce
 * constraints on the view parameters.
 *
 * See {@link FlatView.limit} for commonly used limiters. They may be composed
 * together or with user-defined limiters with {@link util.compose}.
 *
 * @param {FlatViewParams} params
 * @return {FlatViewParams}
 */


/**
 * @class FlatView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing an orthogonal projection for flat images.
 *
 * @param {FlatViewParams} params The initial view parameters. The
 *     `mediaAspectRatio` parameter must always be set. The other parameters
 *     default to `{x: 0.5, y: 0.5, z: 1 }` if unspecified.
 * @param {FlatViewLimiter=} limiter The view limiter. If unspecified, no view
 *     limiting is applied. See {@link FlatView.limit} for commonly used
 *     limiters.
 */
function FlatView(params, limiter) {
  // Require an aspect ratio to be specified.
  if (!(params && params.mediaAspectRatio != null)) {
    throw new Error('mediaAspectRatio must be defined');
  }

  // The initial values for the view parameters.
  this._x = params && params.x != null ? params.x : defaultX;
  this._y = params && params.y != null ? params.y : defaultY;
  this._zoom = params && params.zoom != null ? params.zoom : defaultZoom;
  this._mediaAspectRatio = params.mediaAspectRatio;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    0, // top
    0, // right
    0, // bottom
    0  // left
  ];

  // Whether the projection matrices and view frustum need to be updated.
  this._projectionChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._vec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(FlatView);


/**
 * Destructor.
 */
FlatView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the x parameter.
 * @return {number}
 */
FlatView.prototype.x = function() {
  return this._x;
};


/**
 * Get the y parameter.
 * @return {number}
 */
FlatView.prototype.y = function() {
  return this._y;
};


/**
 * Get the zoom value.
 * @return {number}
 */
FlatView.prototype.zoom = function() {
  return this._zoom;
};


/**
 * Get the media aspect ratio.
 * @return {number}
 */
FlatView.prototype.mediaAspectRatio = function() {
  return this._mediaAspectRatio;
};


/**
 * Get the viewport width.
 * @return {number}
 */
FlatView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
FlatView.prototype.height = function() {
  return this._height;
};


/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
FlatView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {FlatViewParams=} params
 * @return {FlatViewParams}
 */
FlatView.prototype.parameters = function(params) {
  params = params || {};
  params.x = this._x;
  params.y = this._y;
  params.zoom = this._zoom;
  params.mediaAspectRatio = this._mediaAspectRatio;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?FlatViewLimiter}
 */
FlatView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the x parameter.
 * @param {number} x
 */
FlatView.prototype.setX = function(x) {
  this._resetParams();
  this._params.x = x;
  this._update(this._params);
};


/**
 * Set the y parameter.
 * @param {number} y
 */
FlatView.prototype.setY = function(y) {
  this._resetParams();
  this._params.y = y;
  this._update(this._params);
};


/**
 * Set the zoom value.
 * @param {number} zoom
 */
FlatView.prototype.setZoom = function(zoom) {
  this._resetParams();
  this._params.zoom = zoom;
  this._update(this._params);
};


/**
 * Add xOffset to the x parameter.
 * @param {number} xOffset
 */
FlatView.prototype.offsetX = function(xOffset) {
  this.setX(this._x + xOffset);
};


/**
 * Add yOffset to the y parameter.
 * @param {number} yOffset
 */
FlatView.prototype.offsetY = function(yOffset)
{
  this.setY(this._y + yOffset);
};


/**
 * Add zoomOffset to the zoom value.
 * @param {number} zoomOffset
 */
FlatView.prototype.offsetZoom = function(zoomOffset) {
  this.setZoom(this._zoom + zoomOffset);
};


/**
 * Set the media aspect ratio.
 * @param {number} mediaAspectRatio
 */
FlatView.prototype.setMediaAspectRatio = function(mediaAspectRatio) {
  this._resetParams();
  this._params.mediaAspectRatio = mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
FlatView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};


/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {FlatViewParameters} params
 */
FlatView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.x = params.x;
  this._params.y = params.y;
  this._params.zoom = params.zoom;
  this._params.mediaAspectRatio = params.mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?FlatViewLimiter} limiter The new limiter, or null to unset.
 */
FlatView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


FlatView.prototype._resetParams = function() {
  var params = this._params;
  params.x = null;
  params.y = null;
  params.zoom = null;
  params.mediaAspectRatio = null;
  params.width = null;
  params.height = null;
};


FlatView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldX = this._x;
  var oldY = this._y;
  var oldZoom = this._zoom;
  var oldMediaAspectRatio = this._mediaAspectRatio;
  var oldWidth = this._width;
  var oldHeight = this._height;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.x = params.x != null ? params.x : oldX;
  params.y = params.y != null ? params.y : oldY;
  params.zoom = params.zoom != null ? params.zoom : oldZoom;
  params.mediaAspectRatio = params.mediaAspectRatio != null ?
    params.mediaAspectRatio : oldMediaAspectRatio;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Grab the limited parameters.
  var newX = params.x;
  var newY = params.y;
  var newZoom = params.zoom;
  var newMediaAspectRatio = params.mediaAspectRatio;
  var newWidth = params.width;
  var newHeight = params.height;

  // Consistency check.
  if (!real(newX) || !real(newY) || !real(newZoom) ||
      !real(newMediaAspectRatio) || !real(newWidth) || !real(newHeight)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Constrain zoom.
  newZoom = clamp(newZoom, zoomLimitEpsilon, Infinity);

  // Update parameters.
  this._x = newX;
  this._y = newY;
  this._zoom = newZoom;
  this._mediaAspectRatio = newMediaAspectRatio;
  this._width = newWidth;
  this._height = newHeight;

  // Check whether the parameters changed and emit the corresponding events.
  if (newX !== oldX || newY !== oldY || newZoom !== oldZoom ||
      newMediaAspectRatio !== oldMediaAspectRatio ||
      newWidth !== oldWidth || newHeight !== oldHeight) {
    this._projectionChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }

};


FlatView.prototype._zoomX = function() {
  return this._zoom;
};


FlatView.prototype._zoomY = function() {
  var mediaAspectRatio = this._mediaAspectRatio;
  var aspect = this._width / this._height;
  var zoomX = this._zoom;
  var zoomY = zoomX * mediaAspectRatio / aspect;
  if (isNaN(zoomY)) {
    zoomY = zoomX;
  }
  return zoomY;
};


FlatView.prototype.updateWithControlParameters = function(parameters) {
  var scale = this.zoom();
  var zoomX = this._zoomX();
  var zoomY = this._zoomY();

  // TODO: should the scale be the same for both axes?
  this.offsetX(parameters.axisScaledX * zoomX + parameters.x * scale);
  this.offsetY(parameters.axisScaledY * zoomY + parameters.y * scale);
  this.offsetZoom(parameters.zoom * scale);
};


FlatView.prototype._updateProjection = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var frustum = this._frustum;

  // Recalculate projection matrix when required.
  if (this._projectionChanged) {
    var x = this._x;
    var y = this._y;
    var zoomX = this._zoomX();
    var zoomY = this._zoomY();

    // Recalculate view frustum.
    var top     = frustum[0] = (0.5 - y) + 0.5 * zoomY;
    var right   = frustum[1] = (x - 0.5) + 0.5 * zoomX;
    var bottom  = frustum[2] = (0.5 - y) - 0.5 * zoomY;
    var left    = frustum[3] = (x - 0.5) - 0.5 * zoomX;

    // Recalculate projection matrix and its inverse.
    mat4.ortho(projMatrix, left, right, bottom, top, -1, 1);
    mat4.invert(invProjMatrix, projMatrix);

    this._projectionChanged = false;
  }
};


/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.projection = function() {
  this._updateProjection();
  return this._projMatrix;
};


/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.inverseProjection = function() {
  this._updateProjection();
  return this._invProjMatrix;
};


/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec3[]} rectangle The vertices of the rectangle.
 */
FlatView.prototype.intersects = function(rectangle) {
  this._updateProjection();

  var frustum = this._frustum;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the fruouter
  for (var i = 0; i < frustum.length; i++) {
    var limit = frustum[i];
    var axis = planeAxes[i];
    var cmp = planeCmp[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var vertex = rectangle[j];
      if (cmp < 0 && vertex[axis] < limit || cmp > 0 && vertex[axis] > limit) {
        inside = true;
        break;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
FlatView.prototype.selectLevel = function(levels) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of the image that would be visible at the current
  // zoom value. Then, for each level, multiply by the level width to get the
  // width in pixels of the portion that would be visible.
  //
  // Search for the smallest level that satifies the the required width,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this.width();
  var zoomFactor = this._zoom;

  for (var i = 0; i < levels.length; i++) {
    var level = levels[i];
    if (zoomFactor * level.width() >= requiredPixels) {
      return level;
    }
  }

  return levels[levels.length - 1];

};


/**
 * Convert view coordinates into screen coordinates. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {FlatViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
FlatView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Extract coordinates from argument, filling in default values.
  var x = coords && coords.x != null ? coords.x : defaultX;
  var y = coords && coords.y != null ? coords.y : defaultY;

  // Project view ray onto clip space.
  vec4.set(ray, x - 0.5, 0.5 - y, -1, 1);
  vec4.transformMat4(ray, ray, this.projection());

  // Calculate perspective divide.
  for (var i = 0; i < 3; i++) {
    ray[i] /= ray[3];
  }

  // Convert to viewport coordinates and return.
  result.x = width * (ray[0] + 1) / 2;
  result.y = height * (1 - ray[1]) / 2;

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {FlatViewCoords=} result The result argument for the view coordinates.
 * @return {FlatViewCoords}
 */
FlatView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to flat coordinates.
  result.x = 0.5 + ray[0];
  result.y = 0.5 - ray[1];

  return result;
};


/**
 * Factory functions for view limiters. See {@link FlatViewLimiter}.
 * @namespace
 */
FlatView.limit = {

  /**
   * Returns a view limiter that constrains the x parameter.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  x: function(min, max) {
    return function limitX(params) {
      params.x = clamp(params.x, min, max);
      return params;
    };
  },

  /**
   * Return a view limiter that constrains the y parameter.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  y: function(min, max) {
    return function limitY(params) {
      params.y = clamp(params.y, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter than constrains the zoom parameter.
   * @param {number} min The minimum zoom value.
   * @param {number} max The maximum zoom value.
   * @return {FlatViewLimiter}
   */
  zoom: function(min, max) {
    return function limitZoom(params) {
      params.zoom = clamp(params.zoom, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The image width in pixels.
   * @return {FlatViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }
      var width = params.width;
      var minZoom = pixelRatio() * width / size;
      params.zoom = clamp(params.zoom, minZoom, Infinity);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the x parameter that
   * are inside the viewport.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum x value.
   * @return {FlatViewLimiter}
   */
  visibleX: function(min, max) {
    return function limitVisibleX(params) {
      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = max - min;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound X such that the image is visible up to the range edges.
      var minX = min + 0.5 * params.zoom;
      var maxX = max - 0.5 * params.zoom;
      params.x = clamp(params.x, minX, maxX);

      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the y parameter that
   * are inside the viewport.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  visibleY: function(min, max) {
    return function limitVisibleY(params) {

      // Do nothing for a null viewport.
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }

      // Calculate the X to Y conversion factor.
      var viewportAspectRatio = params.width / params.height;
      var factor = viewportAspectRatio / params.mediaAspectRatio;

      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = (max - min) * factor;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound Y such that the image is visible up to the range edges.
      var minY = min + 0.5 * params.zoom / factor;
      var maxY = max - 0.5 * params.zoom / factor;
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  },


  /**
   * Returns a view limiter that constrains the zoom parameter such that
   * zooming out is prevented beyond the point at which the image is fully
   * visible. Unless the image and the viewport have the same aspect ratio,
   * this will cause bands to appear around the image.
   * @return {FlatViewLimiter}
   */
  letterbox: function() {
    return function limitLetterbox(params) {
      if(params.width <= 0 || params.height <= 0) {
        return params;
      }
      var viewportAspectRatio = params.width / params.height;

      var fullWidthZoom = 1.0;
      var fullHeightZoom = viewportAspectRatio / params.mediaAspectRatio;

      // If the image is wider than the viewport, limit the horizontal zoom to
      // the image width.
      if (params.mediaAspectRatio >= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullWidthZoom);
      }

      // If the image is narrower than the viewport, limit the vertical zoom to
      // the image height.
      if (params.mediaAspectRatio <= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullHeightZoom);
      }

      // If the full image width is visible, limit x to the central point.
      // Else, bound x such that image is visible up to the horizontal edges.
      var minX, maxX;
      if (params.zoom > fullWidthZoom) {
        minX = maxX = 0.5;
      } else {
        minX = 0.0 + 0.5 * params.zoom / fullWidthZoom;
        maxX = 1.0 - 0.5 * params.zoom / fullWidthZoom;
      }

      // If the full image height is visible, limit y to the central point.
      // Else, bound y such that image is visible up to the vertical edges.
      var minY, maxY;
      if (params.zoom > fullHeightZoom) {
        minY = maxY = 0.5;
      } else {
        minY = 0.0 + 0.5 * params.zoom / fullHeightZoom;
        maxY = 1.0 - 0.5 * params.zoom / fullHeightZoom;
      }

      // Clamp x and y into the calculated bounds.
      params.x = clamp(params.x, minX, maxX);
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  }

};


FlatView.type = FlatView.prototype.type = 'flat';


module.exports = FlatView;

},{"../util/clamp":79,"../util/clearOwnProperties":80,"../util/pixelRatio":99,"../util/real":102,"gl-matrix":3,"minimal-event-emitter":14}],107:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var vec3 = require('gl-matrix').vec3;
var pixelRatio = require('../util/pixelRatio');
var convertFov = require('../util/convertFov');
var mod = require('../util/mod');
var real = require('../util/real');
var clamp = require('../util/clamp');
var decimal = require('../util/decimal');
var compose = require('../util/compose');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultYaw = 0;
var defaultPitch = 0;
var defaultRoll = 0;
var defaultFov = Math.PI/4;
var defaultProjectionCenterX = 0;
var defaultProjectionCenterY = 0;
var defaultTx = 0;
var defaultTy = 0;
var defaultTz = 0;
var defaultOx = 0;
var defaultOy = 0;
var defaultOz = 0;

// A fov of exactly 0 or π breaks some computations, so we constrain it to the
// [fovLimitEpsilon, π - fovLimitEpsilon] interval. We use 6 decimal places for
// the epsilon value to avoid broken rendering due to loss of precision in
// floating point computations.
var fovLimitEpsilon = 0.000001;


/**
 * @interface RectilinearViewParams
 *
 * A camera configuration for a {@link RectilinearView}.
 *
 * @property {number} yaw The yaw angle, in the [-π, π] range.
 *     When `yaw < 0`, the view rotates to the left.
 *     When `yaw > 0`, the view rotates to the right.
 *
 * @property {number} pitch The pitch angle, in the [-π, π] range.
 *     When `pitch < 0`, the view rotates downwards.
 *     When `pitch > 0`, the view rotates upwards.
 *
 * @property {number} roll The roll angle, in the [-π, π] range.
 *     When `roll < 0`, the view rotates clockwise.
 *     When `roll > 0`, the view rotates counter-clockwise.
 *
 * @property {fov} fov The vertical field of view, in the [0, π] range.
 */


/**
 * @interface RectilinearViewCoords
 *
 * The position of a point in a 360° image.
 *
 * @property {number} yaw The yaw angle, in the [-π, π] range.
 * @property {number} pitch The pitch angle, in the [-π, π] range.
 */


/**
 * @typedef {function} RectilinearViewLimiter
 *
 * View limiter for a {@link RectilinearView}.
 *
 * A view limiter is a function that receives a {@link RectilinearViewParams}
 * object, optionally modifies it in place, and returns it. It can be used to
 * enforce constraints on the view parameters.
 *
 * See {@link RectilinearView.limit} for commonly used limiters. They may be
 * composed together or with user-defined limiters with {@link util.compose}.
 *
 * @param {RectilinearViewParams} params
 * @return {RectilinearViewParams}
 */

/**
 * @class RectilinearView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing a rectilinear projection for 360° images.
 *
 * @param {RectilinearViewParams=} params The initial view parameters. If
 *     unspecified, defaults to `{yaw: 0, pitch: 0, roll: 0, fov: Math.PI/4 }`.
 * @param {RectilinearViewLimiter=} limiter The view limiter. If unspecified,
 *     no view limiting is applied. See {@link RectilinearView.limit} for
 *     commonly used limiters.
 */
function RectilinearView(params, limiter) {
  // The initial values for the view parameters.
  this._yaw = params && params.yaw != null ? params.yaw : defaultYaw;
  this._pitch = params && params.pitch != null ? params.pitch : defaultPitch;
  this._roll = params && params.roll != null ? params.roll : defaultRoll;
  this._fov = params && params.fov != null ? params.fov : defaultFov;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;
  this._projectionCenterX = params && params.projectionCenterX != null ?
    params.projectionCenterX : defaultProjectionCenterX;
  this._projectionCenterY = params && params.projectionCenterY != null ?
    params.projectionCenterY : defaultProjectionCenterY;

  // A 3D translation of the viewpoint.
  this._tx = params && params.tx != null ? params.tx : defaultTx;
  this._ty = params && params.ty != null ? params.ty : defaultTy;
  this._tz = params && params.tz != null ? params.tz : defaultTz;

  // An additional 3D translation offset of the viewpoint. 
  // But the viewing rotation will be still from the non-offset point.
  this._ox = params && params.ox != null ? params.ox : defaultOx;
  this._oy = params && params.oy != null ? params.oy : defaultOy;
  this._oz = params && params.oz != null ? params.oz : defaultOz;

  // Invert control.
  this._invertControl = params && params.invertControl != null ? params.invertControl : false;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view matrix and its inverse.
  this._viewMatrix = mat4.create();
  this._invViewMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    vec4.create(), // left
    vec4.create(), // right
    vec4.create(), // bottom
    vec4.create(), // top
    vec4.create()  // camera
  ];

  // Whether the projection matrices and the view frustum need to be updated.
  this._matrixChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._fovs = {};
  this._tmpVec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(RectilinearView);


/**
 * Destructor.
 */
RectilinearView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the yaw angle.
 * @return {number}
 */
RectilinearView.prototype.yaw = function() {
  return this._yaw;
};


/**
 * Get the pitch angle.
 * @return {number}
 */
RectilinearView.prototype.pitch = function() {
  return this._pitch;
};


/**
 * Get the roll angle.
 * @return {number}
 */
RectilinearView.prototype.roll = function() {
  return this._roll;
};


RectilinearView.prototype.projectionCenterX = function() {
  return this._projectionCenterX;
};


RectilinearView.prototype.projectionCenterY = function() {
  return this._projectionCenterY;
};

/**
 * Get the fov value.
 * @return {number}
 */
RectilinearView.prototype.fov = function() {
  return this._fov;
};


/**
 * Get the viewport width.
 * @return {number}
 */
RectilinearView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
RectilinearView.prototype.height = function() {
  return this._height;
};

/**
 * Get the viewpoint's tx.
 * @return {number}
 */
RectilinearView.prototype.tx = function() {
  return this._tx;
};

/**
 * Get the viewpoint's ty.
 * @return {number}
 */
RectilinearView.prototype.ty = function() {
  return this._ty;
};

/**
 * Get the viewpoint's tz.
 * @return {number}
 */
RectilinearView.prototype.tz = function() {
  return this._tz;
};

/**
 * Get the viewpoint's ox.
 * @return {number}
 */
RectilinearView.prototype.ox = function() {
  return this._ox;
};

/**
 * Get the viewpoint's oy.
 * @return {number}
 */
RectilinearView.prototype.oy = function() {
  return this._oy;
};

/**
 * Get the viewpoint's tz.
 * @return {number}
 */
RectilinearView.prototype.oz = function() {
  return this._oz;
};

/**
 * Get the invert control flag.
 * @return {boolean}
 */
RectilinearView.prototype.invertControl = function() {
  return this._invertControl;
};

/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
RectilinearView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {RectilinearViewParams=} obj
 * @return {RectilinearViewParams}
 */
RectilinearView.prototype.parameters = function(params) {
  params = params || {};
  params.yaw = this._yaw;
  params.pitch = this._pitch;
  params.roll = this._roll;
  params.fov = this._fov;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?RectilinearViewLimiter}
 */
RectilinearView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the yaw angle.
 * @param {number} yaw
 */
RectilinearView.prototype.setYaw = function(yaw) {
  this._resetParams();
  this._params.yaw = yaw;
  this._update(this._params);
};


/**
 * Set the pitch angle.
 * @param {number} pitch
 */
RectilinearView.prototype.setPitch = function(pitch) {
  this._resetParams();
  this._params.pitch = pitch;
  this._update(this._params);
};


/**
 * Set the roll angle.
 * @param {number} roll
 */
RectilinearView.prototype.setRoll = function(roll) {
  this._resetParams();
  this._params.roll = roll;
  this._update(this._params);
};


/**
 * Set the fov value.
 * @param {number} fov
 */
RectilinearView.prototype.setFov = function(fov) {
  this._resetParams();
  this._params.fov = fov;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterX = function(projectionCenterX) {
  this._resetParams();
  this._params.projectionCenterX = projectionCenterX;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterY = function(projectionCenterY) {
  this._resetParams();
  this._params.projectionCenterY = projectionCenterY;
  this._update(this._params);
};


/**
 * Add yawOffset to the current yaw value.
 * @param {number} yawOffset
 */
RectilinearView.prototype.offsetYaw = function(yawOffset) {
  this.setYaw(this._yaw + yawOffset);
};


/**
 * Add pitchOffset to the current pitch value.
 * @param {number} pitchOffset
 */
RectilinearView.prototype.offsetPitch = function(pitchOffset) {
  this.setPitch(this._pitch + pitchOffset);
};


/**
 * Add rollOffset to the current roll value.
 * @param {number} rollOffset
 */
RectilinearView.prototype.offsetRoll = function(rollOffset) {
  this.setRoll(this._roll + rollOffset);
};


/**
 * Add fovOffset to the current fov value.
 * @param {number} fovOffset
 */
RectilinearView.prototype.offsetFov = function(fovOffset) {
  this.setFov(this._fov + fovOffset);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
RectilinearView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};

/**
 * Set the viewpoint's tx.
 * @param {number} tx
 */
RectilinearView.prototype.setTx = function(tx) {
  this._resetParams();
  this._params.tx = tx;
  this._update(this._params);
}

/**
 * Set the viewpoint's ty.
 * @param {number} ty
 */
RectilinearView.prototype.setTy = function(ty) {
  this._resetParams();
  this._params.ty = ty;
  this._update(this._params);
}

/**
 * Set the viewpoint's tz.
 * @param {number} tz
 */
RectilinearView.prototype.setTz = function(tz) {
  this._resetParams();
  this._params.tz = tz;
  this._update(this._params);
}

/**
 * Set the viewpoint's ox.
 * @param {number} tx
 */
RectilinearView.prototype.setOx = function(ox) {
  this._resetParams();
  this._params.ox = ox;
  this._update(this._params);
}

/**
 * Set the viewpoint's oy.
 * @param {number} oy
 */
RectilinearView.prototype.setOy = function(oy) {
  this._resetParams();
  this._params.oy = oy;
  this._update(this._params);
}

/**
 * Set the viewpoint's oz.
 * @param {number} oz
 */
RectilinearView.prototype.setOz = function(oz) {
  this._resetParams();
  this._params.oz = oz;
  this._update(this._params);
}

/**
 * Get the invert control flag.
 * @return {boolean}
 */
RectilinearView.prototype.setInvertControl = function(invertControl) {
  this._invertControl = invertControl;
};

/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {RectilinearViewParameters} params
 */
RectilinearView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.yaw = params.yaw;
  this._params.pitch = params.pitch;
  this._params.roll = params.roll;
  this._params.fov = params.fov;
  this._params.projectionCenterX = params.projectionCenterX;
  this._params.projectionCenterY = params.projectionCenterY;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?RectilinearViewLimiter} limiter The new limiter, or null to unset.
 */
RectilinearView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


RectilinearView.prototype._resetParams = function() {
  var params = this._params;
  params.yaw = null;
  params.pitch = null;
  params.roll = null;
  params.fov = null;
  params.width = null;
  params.height = null;
  params.position = null;
};


RectilinearView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldYaw = this._yaw;
  var oldPitch = this._pitch;
  var oldRoll = this._roll;
  var oldFov = this._fov;
  var oldProjectionCenterX = this._projectionCenterX;
  var oldProjectionCenterY = this._projectionCenterY;
  var oldWidth = this._width;
  var oldHeight = this._height;
  
  var oldTx = this._tx;
  var oldTy = this._ty;
  var oldTz = this._tz;
  var oldOx = this._ox;
  var oldOy = this._oy;
  var oldOz = this._oz;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.yaw = params.yaw != null ? params.yaw : oldYaw;
  params.pitch = params.pitch != null ? params.pitch : oldPitch;
  params.roll = params.roll != null ? params.roll : oldRoll;
  params.fov = params.fov != null ? params.fov : oldFov;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;
  params.projectionCenterX = params.projectionCenterX != null ?
    params.projectionCenterX : oldProjectionCenterX;
  params.projectionCenterY = params.projectionCenterY != null ?
    params.projectionCenterY : oldProjectionCenterY;

  params.tx = params.tx != null ? params.tx : oldTx;
  params.ty = params.ty != null ? params.ty : oldTy;
  params.tz = params.tz != null ? params.tz : oldTz;
  params.ox = params.ox != null ? params.ox : oldOx;
  params.oy = params.oy != null ? params.oy : oldOy;
  params.oz = params.oz != null ? params.oz : oldOz;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Normalize parameters.
  params = this._normalize(params);

  // Grab the limited parameters.
  var newYaw = params.yaw;
  var newPitch = params.pitch;
  var newRoll = params.roll;
  var newFov = params.fov;
  var newWidth = params.width;
  var newHeight = params.height;
  var newProjectionCenterX = params.projectionCenterX;
  var newProjectionCenterY = params.projectionCenterY;

  var newTx = params.tx;
  var newTy = params.ty;
  var newTz = params.tz;
  var newOx = params.ox;
  var newOy = params.oy;
  var newOz = params.oz;

  // Consistency check.
  if (!real(newYaw) || !real(newPitch) || !real(newRoll) ||
      !real(newFov) || !real(newWidth) || !real(newHeight) ||
      !real(newProjectionCenterX) || !real(newProjectionCenterY)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Update parameters.
  this._yaw = newYaw;
  this._pitch = newPitch;
  this._roll = newRoll;
  this._fov = newFov;
  this._width = newWidth;
  this._height = newHeight;
  this._projectionCenterX = newProjectionCenterX;
  this._projectionCenterY = newProjectionCenterY;
  
  this._tx = newTx;
  this._ty = newTy;
  this._tz = newTz;
  this._ox = newOx;
  this._oy = newOy;
  this._oz = newOz;

  // Check whether the parameters changed and emit the corresponding events.
  if (newYaw !== oldYaw || newPitch !== oldPitch || newRoll !== oldRoll ||
      newFov !== oldFov || newWidth !== oldWidth || newHeight !== oldHeight ||
      newProjectionCenterX !== oldProjectionCenterX ||
      newProjectionCenterY !== oldProjectionCenterY ||
      newTx !== oldTx || newTy !== oldTy || newTz !== oldTz ||
      newOx !== oldOx || newOy !== oldOy || newOz !== oldOz) {
    this._matrixChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }
};


RectilinearView.prototype._normalize = function(params) {

  this._normalizeCoordinates(params);

  // Make sure that neither the horizontal nor the vertical fields of view
  // exceed π - fovLimitEpsilon.
  var hfovPi = convertFov.htov(Math.PI, params.width, params.height);
  var maxFov = isNaN(hfovPi) ? Math.PI : Math.min(Math.PI, hfovPi);
  params.fov = clamp(params.fov, fovLimitEpsilon, maxFov - fovLimitEpsilon);

  return params;
};


RectilinearView.prototype._normalizeCoordinates = function(params) {
  // Constrain yaw, pitch and roll to the [-π, π] interval.
  if ('yaw' in params) {
    params.yaw = mod(params.yaw - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('pitch' in params) {
    params.pitch = mod(params.pitch - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('roll' in params) {
    params.roll = mod(params.roll - Math.PI, -2*Math.PI) + Math.PI;
  }
  return params;
};


/**
 * Normalize view coordinates so that they are the closest to the current view.
 * Useful for tweening the view through the shortest path. If a result argument
 * is supplied, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {RectilinearViewCoords} result The result argument for the normalized
 *     view coordinates.
 */
RectilinearView.prototype.normalizeToClosest = function(coords, result) {

  var viewYaw = this._yaw;
  var viewPitch = this._pitch;

  var coordYaw = coords.yaw;
  var coordPitch = coords.pitch;

  // Check if the yaw is closer after subtracting or adding a full circle.
  var prevYaw = coordYaw - 2*Math.PI;
  var nextYaw = coordYaw + 2*Math.PI;
  if (Math.abs(prevYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = prevYaw;
  }
  else if (Math.abs(nextYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = nextYaw;
  }

  // Check if the pitch is closer after subtracting or adding a full circle.
  var prevPitch = coordPitch - 2*Math.PI;
  var nextPitch = coordPitch + 2*Math.PI;
  if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = prevPitch;
  }
  else if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = nextPitch;
  }

  result = result || {};
  result.yaw = coordYaw;
  result.pitch = coordPitch;
  return result;

};


RectilinearView.prototype.updateWithControlParameters = function(parameters) {
  // axisScaledX and axisScaledY are scaled according to their own axis
  // x and y are scaled by the same value

  // If the viewport dimensions are zero, assume a square viewport
  // when converting from hfov to vfov.
  var vfov = this._fov;
  var hfov = convertFov.vtoh(vfov, this._width, this._height);
  if (isNaN(hfov)) {
    hfov = vfov;
  }

  // TODO: revisit this after we rethink the control parameters.
  this.offsetYaw(parameters.axisScaledX * hfov + parameters.x * 2 * hfov + parameters.yaw);
  this.offsetPitch(parameters.axisScaledY * vfov + parameters.y * 2 * hfov + parameters.pitch);
  this.offsetRoll(-parameters.roll);
  this.offsetFov(parameters.zoom * vfov);
};


RectilinearView.prototype._updateMatrix = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var viewMatrix = this._viewMatrix;
  var invViewMatrix = this._invViewMatrix;
  var frustum = this._frustum;

  if (this._matrixChanged) {
    var width = this._width;
    var height = this._height;

    var vfov = this._fov;
    var hfov = convertFov.vtoh(vfov, width, height);
    var aspect = width / height;

    var projectionCenterX = this._projectionCenterX;
    var projectionCenterY = this._projectionCenterY;

    // Projection Matrix.
    if (projectionCenterX !== 0 || projectionCenterY !== 0) {
      var offsetAngleX = Math.atan(projectionCenterX * 2 * Math.tan(hfov/2));
      var offsetAngleY = Math.atan(projectionCenterY * 2 * Math.tan(vfov/2));
      var fovs = this._fovs;
      fovs.leftDegrees = (hfov/2 + offsetAngleX) * 180/Math.PI;
      fovs.rightDegrees = (hfov/2 - offsetAngleX) * 180/Math.PI;
      fovs.upDegrees = (vfov/2 + offsetAngleY) * 180/Math.PI;
      fovs.downDegrees = (vfov/2 - offsetAngleY) * 180/Math.PI;
      mat4.perspectiveFromFieldOfView(projMatrix, fovs, -1, 1);
    } else {
      mat4.perspective(projMatrix, vfov, aspect, -1, 1);
    }

    // mat4.invert(invProjMatrix, projMatrix);

    // // View Matrix.
    // mat4.identity(viewMatrix);
    // mat4.translate(viewMatrix, viewMatrix, vec3.negate(vec3.create(), [this._ox, this._oy, this._oz]));

    // // Invert control.
    // var roll = this._invertControl ? -this._roll : this._roll;
    // var pitch = this._invertControl ? -this._pitch :this._pitch;
    // var yaw = this._invertControl ? -this._yaw : this._yaw;
    // mat4.rotateZ(viewMatrix, viewMatrix, roll);
    // mat4.rotateX(viewMatrix, viewMatrix, pitch);
    // mat4.rotateY(viewMatrix, viewMatrix, yaw);

    // mat4.translate(viewMatrix, viewMatrix, vec3.negate(vec3.create(), [this._tx, this._ty, this._tz]));

    // mat4.invert(invViewMatrix, viewMatrix);

    // // Get the frustum planes.
    // var matrix = mat4.create();
    // mat4.multiply(matrix, projMatrix, viewMatrix);
    // this._matrixToFrustum(matrix, frustum);

    mat4.rotateZ(projMatrix, projMatrix, this._roll);
    mat4.rotateX(projMatrix, projMatrix, this._pitch);
    mat4.rotateY(projMatrix, projMatrix, this._yaw);
    mat4.translate(projMatrix, projMatrix, vec3.negate(vec3.create(), [this._tx, this._ty, this._tz]));
    mat4.invert(invProjMatrix, projMatrix);
    this._matrixToFrustum(projMatrix, frustum);

    this._matrixChanged = false;
  }
};

RectilinearView.prototype._matrixToFrustum = function(p, f) {
  // Extract frustum planes from projection matrix.
  // http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
  vec4.set(f[0], p[3] + p[0], p[7] + p[4], p[11] + p[8], p[15] + p[12]); // left
  vec4.set(f[1], p[3] - p[0], p[7] - p[4], p[11] - p[8], p[15] - p[12]); // right
  vec4.set(f[2], p[3] + p[1], p[7] + p[5], p[11] + p[9], p[15] + p[13]); // top
  vec4.set(f[3], p[3] - p[1], p[7] - p[5], p[11] - p[9], p[15] - p[13]); // bottom
  vec4.set(f[4], p[3] + p[2], p[7] + p[6], p[11] + p[10], p[15] + p[14]); // camera
};

/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.projection = function() {
  this._updateMatrix();
  return this._projMatrix;
};

/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.inverseProjection = function() {
  this._updateMatrix();
  return this._invProjMatrix;
};

/**
 * Returns the view matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.viewMatrix = function() {
  this._updateMatrix();
  return this._viewMatrix;
}

/**
 * Returns the inverse view matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.inverseViewMatrix = function() {
  this._updateMatrix();
  return this._invViewMatrix;
}

/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec2[]} rectangle The vertices of the rectangle.
 */
RectilinearView.prototype.intersects = function(rectangle) {
  this._updateMatrix();

  var frustum = this._frustum;
  var vertex = this._tmpVec;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the frustum.
  for (var i = 0; i < frustum.length; i++) {
    var plane = frustum[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var corner = rectangle[j];
      vec4.set(vertex, corner[0], corner[1], corner[2], 1.0);
      if (vec4.dot(plane, vertex) >= 0) {
        inside = true;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
RectilinearView.prototype.selectLevel = function(levelList) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of a cube face that would be visible given the
  // current vertical field of view. Then, for each level, multiply by the
  // level height to get the height in pixels of the portion that would be
  // visible.
  //
  // Search for the smallest level that satifies the the required height,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this._height;
  var coverFactor = Math.tan(0.5 * this._fov);

  for (var i = 0; i < levelList.length; i++) {
    var level = levelList[i];
    if (coverFactor * level.height() >= requiredPixels) {
      return level;
    }
  }

  return levelList[levelList.length - 1];

};


/**
 * Convert view parameters into screen position. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
RectilinearView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Compute view ray pointing into the (yaw, pitch) direction.
  var yaw = coords.yaw;
  var pitch = coords.pitch;
  var x = Math.sin(yaw) * Math.cos(pitch);
  var y = -Math.sin(pitch);
  var z = -Math.cos(yaw) * Math.cos(pitch);
  vec4.set(ray, x, y, z, 1);

  // Project view ray onto clip space.
  vec4.transformMat4(ray, ray, this.projection());

  // w in clip space equals -z in camera space.
  if (ray[3] >= 0) {
    // Point is in front of camera.
    // Convert to viewport coordinates.
    result.x = width * (ray[0] / ray[3] + 1) / 2;
    result.y = height * (1 - ray[1] / ray[3]) / 2;
  } else {
    // Point is behind camera.
    result.x = null;
    result.y = null;
    return null;
  }

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {RectilinearViewCoords=} result The view coordinates.
 * @return {RectilinearViewCoords}
 */
RectilinearView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to spherical coordinates.
  var r = Math.sqrt(ray[0] * ray[0] + ray[1] * ray[1] + ray[2] * ray[2]);
  result.yaw = Math.atan2(ray[0], -ray[2]);
  result.pitch = Math.acos(ray[1] / r) - Math.PI/2;

  this._normalizeCoordinates(result);

  return result;
};


/**
 * Calculate the perspective transform required to position an element with
 * perspective.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {number} radius Radius of the sphere embedding the element.
 * @param {string} extraTransforms Extra transformations to be applied after
 *     the element is positioned. This may be used to rotate the element.
 * @return {string} The CSS 3D transform to be applied to the element.
 */
RectilinearView.prototype.coordinatesToPerspectiveTransform = function(
    coords, radius, extraTransforms) {
  extraTransforms = extraTransforms || "";

  var height = this._height;
  var width = this._width;
  var fov = this._fov;
  var perspective = 0.5 * height / Math.tan(fov / 2);

  var transform = '';

  // Center hotspot in screen.
  transform += 'translateX(' + decimal(width/2) + 'px) ';
  transform += 'translateY(' + decimal(height/2) + 'px) ';
  transform += 'translateX(-50%) translateY(-50%) ';

  // Set the perspective depth.
  transform += 'perspective(' + decimal(perspective) + 'px) ';
  transform += 'translateZ(' + decimal(perspective) + 'px) ';

  // Set the camera rotation.
  transform += 'rotateZ(' + decimal(-this._roll) + 'rad) ';
  transform += 'rotateX(' + decimal(-this._pitch) + 'rad) ';
  transform += 'rotateY(' + decimal(this._yaw) + 'rad) ';

  // Set the hotspot rotation.
  transform += 'rotateY(' + decimal(-coords.yaw) + 'rad) ';
  transform += 'rotateX(' + decimal(coords.pitch) + 'rad) ';

  // Move back to sphere.
  transform += 'translateZ(' + decimal(-radius) + 'px) ';

  // Apply the extra transformations
  transform += extraTransforms + ' ';

  return transform;
};


/**
 * Factory functions for view limiters. See {@link RectilinearViewLimiter}.
 * @namespace
 */
RectilinearView.limit = {

  /**
   * Returns a view limiter that constrains the yaw angle.
   * @param {number} min The minimum yaw value.
   * @param {number} max The maximum yaw value.
   * @return {RectilinearViewLimiter}
   */
  yaw: function(min, max) {
    return function limitYaw(params) {
      params.yaw = clamp(params.yaw, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the pitch angle.
   * @param {number} min The minimum pitch value.
   * @param {number} max The maximum pitch value.
   * @return {RectilinearViewLimiter}
   */
  pitch: function(min, max) {
    return function limitPitch(params) {
      params.pitch = clamp(params.pitch, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the roll angle.
   * @param {number} min The minimum roll value.
   * @param {number} max The maximum roll value.
   * @return {RectilinearViewLimiter}
   */
  roll: function(min, max) {
    return function limitRoll(params) {
      params.roll = clamp(params.roll, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the horizontal field of view.
   * @param {number} min The minimum horizontal field of view.
   * @param {number} max The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  hfov: function(min, max) {
    return function limitHfov(params) {
      var width = params.width;
      var height = params.height;
      if (width > 0 && height > 0) {
        var vmin = convertFov.htov(min, width, height);
        var vmax = convertFov.htov(max, width, height);
        params.fov = clamp(params.fov, vmin, vmax);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the vertical field of view.
   * @param {number} min The minimum vertical field of view.
   * @param {number} max The maximum vertical field of view.
   * @return {RectilinearViewLimiter}
   */
  vfov: function(min, max) {
    return function limitVfov(params) {
      params.fov = clamp(params.fov, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The cube face width in pixels or, equivalently, one
   *     fourth of the equirectangular width in pixels.
   * @return {RectilinearViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      var height = params.height;
      if (height) {
        var requiredPixels = pixelRatio() * height;
        var minFov = 2 * Math.atan(requiredPixels / size);
        params.fov = clamp(params.fov, minFov, Infinity);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that limits the horizontal and vertical field of
   * view, prevents zooming in past the image resolution, and limits the pitch
   * range to prevent the camera wrapping around at the poles. These are the
   * most common view constraints for a 360° panorama.
   * @param {number} maxResolution The cube face width in pixels or,
   *     equivalently, one fourth of the equirectangular width in pixels.
   * @param {number} maxVFov The maximum vertical field of view.
   * @param {number} [maxHFov=maxVFov] The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  traditional: function(maxResolution, maxVFov, maxHFov) {
    maxHFov = maxHFov != null ? maxHFov : maxVFov;

    return compose(
      RectilinearView.limit.resolution(maxResolution),
      RectilinearView.limit.vfov(0, maxVFov),
      RectilinearView.limit.hfov(0, maxHFov),
      RectilinearView.limit.pitch(-Math.PI/2, Math.PI/2));
  }

};


RectilinearView.type = RectilinearView.prototype.type = 'rectilinear';


module.exports = RectilinearView;

},{"../util/clamp":79,"../util/clearOwnProperties":80,"../util/compose":82,"../util/convertFov":83,"../util/decimal":84,"../util/mod":95,"../util/pixelRatio":99,"../util/real":102,"gl-matrix":3,"minimal-event-emitter":14}]},{},[55])(55)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYm93c2VyL3NyYy9ib3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9tYXQyZC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvcXVhdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL3F1YXQyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL3ZlYzMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy92ZWM0LmpzIiwibm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcyIsIm5vZGVfbW9kdWxlcy9taW5pbWFsLWV2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJzcmMvRGVwdGhtYXBTdG9yZS5qcyIsInNyYy9Ib3RzcG90LmpzIiwic3JjL0hvdHNwb3RDb250YWluZXIuanMiLCJzcmMvTGF5ZXIuanMiLCJzcmMvTmV0d29ya0Vycm9yLmpzIiwic3JjL1JlbmRlckxvb3AuanMiLCJzcmMvU2NlbmUuanMiLCJzcmMvVGV4dHVyZVN0b3JlLmpzIiwic3JjL1RpbGVTZWFyY2hlci5qcyIsInNyYy9UaW1lci5qcyIsInNyYy9WaWV3ZXIuanMiLCJzcmMvYXNzZXRzL0R5bmFtaWMuanMiLCJzcmMvYXNzZXRzL1N0YXRpYy5qcyIsInNyYy9hdXRvcm90YXRlLmpzIiwic3JjL2NvbGxlY3Rpb25zL0xydU1hcC5qcyIsInNyYy9jb2xsZWN0aW9ucy9McnVTZXQuanMiLCJzcmMvY29sbGVjdGlvbnMvTWFwLmpzIiwic3JjL2NvbGxlY3Rpb25zL1NldC5qcyIsInNyYy9jb2xsZWN0aW9ucy9Xb3JrUG9vbC5qcyIsInNyYy9jb2xsZWN0aW9ucy9Xb3JrUXVldWUuanMiLCJzcmMvY29sb3JFZmZlY3RzLmpzIiwic3JjL2NvbnRyb2xzL0NvbXBvc2VyLmpzIiwic3JjL2NvbnRyb2xzL0NvbnRyb2xDdXJzb3IuanMiLCJzcmMvY29udHJvbHMvQ29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvRHJhZy5qcyIsInNyYy9jb250cm9scy9EeW5hbWljcy5qcyIsInNyYy9jb250cm9scy9FbGVtZW50UHJlc3MuanMiLCJzcmMvY29udHJvbHMvSGFtbWVyR2VzdHVyZXMuanMiLCJzcmMvY29udHJvbHMvS2V5LmpzIiwic3JjL2NvbnRyb2xzL1BpbmNoWm9vbS5qcyIsInNyYy9jb250cm9scy9RdHZyLmpzIiwic3JjL2NvbnRyb2xzL1Njcm9sbFpvb20uanMiLCJzcmMvY29udHJvbHMvVmVsb2NpdHkuanMiLCJzcmMvY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvdXRpbC5qcyIsInNyYy9nZW9tZXRyaWVzL0N1YmUuanMiLCJzcmMvZ2VvbWV0cmllcy9FcXVpcmVjdC5qcyIsInNyYy9nZW9tZXRyaWVzL0ZsYXQuanMiLCJzcmMvZ2VvbWV0cmllcy9MZXZlbC5qcyIsInNyYy9nZW9tZXRyaWVzL2NvbW1vbi5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXJzL0h0bWxJbWFnZS5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xCYXNlLmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbENvbW1vbi5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xDdWJlLmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbEN1YmVEZXB0aC5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xFcXVpcmVjdC5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xGbGF0LmpzIiwic3JjL3JlbmRlcmVycy9yZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMuanMiLCJzcmMvc2hhZGVycy9mcmFnbWVudEN1YmVEZXB0aC5qcyIsInNyYy9zaGFkZXJzL2ZyYWdtZW50RXF1aXJlY3QuanMiLCJzcmMvc2hhZGVycy9mcmFnbWVudE5vcm1hbC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleEN1YmVEZXB0aC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleEVxdWlyZWN0LmpzIiwic3JjL3NoYWRlcnMvdmVydGV4Tm9ybWFsLmpzIiwic3JjL3NvdXJjZXMvSW1hZ2VVcmwuanMiLCJzcmMvc291cmNlcy9TaW5nbGVBc3NldC5qcyIsInNyYy9zdGFnZXMvUmVuZGVyZXJSZWdpc3RyeS5qcyIsInNyYy9zdGFnZXMvU3RhZ2UuanMiLCJzcmMvc3RhZ2VzL1dlYkdsLmpzIiwic3JjL3V0aWwvYXN5bmMuanMiLCJzcmMvdXRpbC9jYWxjUmVjdC5qcyIsInNyYy91dGlsL2NhbmNlbGl6ZS5qcyIsInNyYy91dGlsL2NoYWluLmpzIiwic3JjL3V0aWwvY2xhbXAuanMiLCJzcmMvdXRpbC9jbGVhck93blByb3BlcnRpZXMuanMiLCJzcmMvdXRpbC9jbXAuanMiLCJzcmMvdXRpbC9jb21wb3NlLmpzIiwic3JjL3V0aWwvY29udmVydEZvdi5qcyIsInNyYy91dGlsL2RlY2ltYWwuanMiLCJzcmMvdXRpbC9kZWZhdWx0cy5qcyIsInNyYy91dGlsL2RlZmVyLmpzIiwic3JjL3V0aWwvZGVnVG9SYWQuanMiLCJzcmMvdXRpbC9kZWxheS5qcyIsInNyYy91dGlsL2RvbS5qcyIsInNyYy91dGlsL2V4dGVuZC5qcyIsInNyYy91dGlsL2dsb2JhbC5qcyIsInNyYy91dGlsL2hhc2guanMiLCJzcmMvdXRpbC9pbmhlcml0cy5qcyIsInNyYy91dGlsL2lzcG90LmpzIiwic3JjL3V0aWwvbW9kLmpzIiwic3JjL3V0aWwvbm9vcC5qcyIsInNyYy91dGlsL25vdy5qcyIsInNyYy91dGlsL29uY2UuanMiLCJzcmMvdXRpbC9waXhlbFJhdGlvLmpzIiwic3JjL3V0aWwvcG9zaXRpb25BYnNvbHV0ZWx5LmpzIiwic3JjL3V0aWwvcmFkVG9EZWcuanMiLCJzcmMvdXRpbC9yZWFsLmpzIiwic3JjL3V0aWwvcmV0cnkuanMiLCJzcmMvdXRpbC90d2Vlbi5qcyIsInNyYy91dGlsL3R5cGUuanMiLCJzcmMvdmlld3MvRmxhdC5qcyIsInNyYy92aWV3cy9SZWN0aWxpbmVhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5M0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy91QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyohXG4gKiBCb3dzZXIgLSBhIGJyb3dzZXIgZGV0ZWN0b3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm93c2VyXG4gKiBNSVQgTGljZW5zZSB8IChjKSBEdXN0aW4gRGlheiAyMDE1XG4gKi9cblxuIWZ1bmN0aW9uIChyb290LCBuYW1lLCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKG5hbWUsIGRlZmluaXRpb24pXG4gIGVsc2Ugcm9vdFtuYW1lXSA9IGRlZmluaXRpb24oKVxufSh0aGlzLCAnYm93c2VyJywgZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICAqIFNlZSB1c2VyYWdlbnRzLmpzIGZvciBleGFtcGxlcyBvZiBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgKi9cblxuICB2YXIgdCA9IHRydWVcblxuICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0TWF0Y2gocmVnZXgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsxXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Vjb25kTWF0Y2gocmVnZXgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsyXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGlvc2RldmljZSA9IGdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZXxpcGFkKS9pKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGxpa2VBbmRyb2lkID0gL2xpa2UgYW5kcm9pZC9pLnRlc3QodWEpXG4gICAgICAsIGFuZHJvaWQgPSAhbGlrZUFuZHJvaWQgJiYgL2FuZHJvaWQvaS50ZXN0KHVhKVxuICAgICAgLCBuZXh1c01vYmlsZSA9IC9uZXh1c1xccypbMC02XVxccyovaS50ZXN0KHVhKVxuICAgICAgLCBuZXh1c1RhYmxldCA9ICFuZXh1c01vYmlsZSAmJiAvbmV4dXNcXHMqWzAtOV0rL2kudGVzdCh1YSlcbiAgICAgICwgY2hyb21lb3MgPSAvQ3JPUy8udGVzdCh1YSlcbiAgICAgICwgc2lsayA9IC9zaWxrL2kudGVzdCh1YSlcbiAgICAgICwgc2FpbGZpc2ggPSAvc2FpbGZpc2gvaS50ZXN0KHVhKVxuICAgICAgLCB0aXplbiA9IC90aXplbi9pLnRlc3QodWEpXG4gICAgICAsIHdlYm9zID0gLyh3ZWJ8aHB3KShvfDApcy9pLnRlc3QodWEpXG4gICAgICAsIHdpbmRvd3NwaG9uZSA9IC93aW5kb3dzIHBob25lL2kudGVzdCh1YSlcbiAgICAgICwgc2Ftc3VuZ0Jyb3dzZXIgPSAvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKVxuICAgICAgLCB3aW5kb3dzID0gIXdpbmRvd3NwaG9uZSAmJiAvd2luZG93cy9pLnRlc3QodWEpXG4gICAgICAsIG1hYyA9ICFpb3NkZXZpY2UgJiYgIXNpbGsgJiYgL21hY2ludG9zaC9pLnRlc3QodWEpXG4gICAgICAsIGxpbnV4ID0gIWFuZHJvaWQgJiYgIXNhaWxmaXNoICYmICF0aXplbiAmJiAhd2Vib3MgJiYgL2xpbnV4L2kudGVzdCh1YSlcbiAgICAgICwgZWRnZVZlcnNpb24gPSBnZXRTZWNvbmRNYXRjaCgvZWRnKFtlYV18aW9zKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgICwgdmVyc2lvbklkZW50aWZpZXIgPSBnZXRGaXJzdE1hdGNoKC92ZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgLCB0YWJsZXQgPSAvdGFibGV0L2kudGVzdCh1YSkgJiYgIS90YWJsZXQgcGMvaS50ZXN0KHVhKVxuICAgICAgLCBtb2JpbGUgPSAhdGFibGV0ICYmIC9bXi1dbW9iaS9pLnRlc3QodWEpXG4gICAgICAsIHhib3ggPSAveGJveC9pLnRlc3QodWEpXG4gICAgICAsIHJlc3VsdFxuXG4gICAgaWYgKC9vcGVyYS9pLnRlc3QodWEpKSB7XG4gICAgICAvLyAgYW4gb2xkIE9wZXJhXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdPcGVyYSdcbiAgICAgICwgb3BlcmE6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmF8b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL29wclxcL3xvcGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICAvLyBhIG5ldyBPcGVyYVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEnXG4gICAgICAgICwgb3BlcmE6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpvcHJ8b3Bpb3MpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9TYW1zdW5nQnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkJ1xuICAgICAgICAsIHNhbXN1bmdCcm93c2VyOiB0XG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9XaGFsZS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdOQVZFUiBXaGFsZSBicm93c2VyJ1xuICAgICAgICAsIHdoYWxlOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86d2hhbGUpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL01aQnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdNWiBCcm93c2VyJ1xuICAgICAgICAsIG16YnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Ok1aQnJvd3NlcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY29hc3QvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEgQ29hc3QnXG4gICAgICAgICwgY29hc3Q6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpjb2FzdClbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2ZvY3VzL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ZvY3VzJ1xuICAgICAgICAsIGZvY3VzOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3lhYnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdZYW5kZXggQnJvd3NlcidcbiAgICAgICwgeWFuZGV4YnJvd3NlcjogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzp5YWJyb3dzZXIpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC91Y2Jyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIG5hbWU6ICdVQyBCcm93c2VyJ1xuICAgICAgICAsIHVjYnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnVjYnJvd3NlcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvbXhpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTWF4dGhvbidcbiAgICAgICAgLCBtYXh0aG9uOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXhpb3MpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2VwaXBoYW55L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0VwaXBoYW55J1xuICAgICAgICAsIGVwaXBoYW55OiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3B1ZmZpbi9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdQdWZmaW4nXG4gICAgICAgICwgcHVmZmluOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86cHVmZmluKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zbGVpcG5pci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTbGVpcG5pcidcbiAgICAgICAgLCBzbGVpcG5pcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnNsZWlwbmlyKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9rLW1lbGVvbi9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdLLU1lbGVvbidcbiAgICAgICAgLCBrTWVsZW9uOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93c3Bob25lKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdXaW5kb3dzIFBob25lJ1xuICAgICAgLCBvc25hbWU6ICdXaW5kb3dzIFBob25lJ1xuICAgICAgLCB3aW5kb3dzcGhvbmU6IHRcbiAgICAgIH1cbiAgICAgIGlmIChlZGdlVmVyc2lvbikge1xuICAgICAgICByZXN1bHQubXNlZGdlID0gdFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGVkZ2VWZXJzaW9uXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm1zaWUgPSB0XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvaWVtb2JpbGVcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9tc2llfHRyaWRlbnQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnSW50ZXJuZXQgRXhwbG9yZXInXG4gICAgICAsIG1zaWU6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNocm9tZW9zKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnXG4gICAgICAsIG9zbmFtZTogJ0Nocm9tZSBPUydcbiAgICAgICwgY2hyb21lb3M6IHRcbiAgICAgICwgY2hyb21lQm9vazogdFxuICAgICAgLCBjaHJvbWU6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL2VkZyhbZWFdfGlvcykvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTWljcm9zb2Z0IEVkZ2UnXG4gICAgICAsIG1zZWRnZTogdFxuICAgICAgLCB2ZXJzaW9uOiBlZGdlVmVyc2lvblxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvdml2YWxkaS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdWaXZhbGRpJ1xuICAgICAgICAsIHZpdmFsZGk6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC92aXZhbGRpXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzYWlsZmlzaCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2FpbGZpc2gnXG4gICAgICAsIG9zbmFtZTogJ1NhaWxmaXNoIE9TJ1xuICAgICAgLCBzYWlsZmlzaDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zYWlsZmlzaFxccz9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2VhbW9ua2V5XFwvL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NlYU1vbmtleSdcbiAgICAgICwgc2VhbW9ua2V5OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NlYW1vbmtleVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ZpcmVmb3gnXG4gICAgICAsIGZpcmVmb3g6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpWyBcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgICAgaWYgKC9cXCgobW9iaWxlfHRhYmxldCk7W15cXCldKnJ2OltcXGRcXC5dK1xcKS9pLnRlc3QodWEpKSB7XG4gICAgICAgIHJlc3VsdC5maXJlZm94b3MgPSB0XG4gICAgICAgIHJlc3VsdC5vc25hbWUgPSAnRmlyZWZveCBPUydcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lsaykge1xuICAgICAgcmVzdWx0ID0gIHtcbiAgICAgICAgbmFtZTogJ0FtYXpvbiBTaWxrJ1xuICAgICAgLCBzaWxrOiB0XG4gICAgICAsIHZlcnNpb24gOiBnZXRGaXJzdE1hdGNoKC9zaWxrXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvcGhhbnRvbS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdQaGFudG9tSlMnXG4gICAgICAsIHBoYW50b206IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvcGhhbnRvbWpzXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2xpbWVyanMvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2xpbWVySlMnXG4gICAgICAgICwgc2xpbWVyOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2xpbWVyanNcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLnRlc3QodWEpIHx8IC9yaW1cXHN0YWJsZXQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQmxhY2tCZXJyeSdcbiAgICAgICwgb3NuYW1lOiAnQmxhY2tCZXJyeSBPUydcbiAgICAgICwgYmxhY2tiZXJyeTogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcZF0rXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJvcykge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnV2ViT1MnXG4gICAgICAsIG9zbmFtZTogJ1dlYk9TJ1xuICAgICAgLCB3ZWJvczogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC93KD86ZWIpP29zYnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH07XG4gICAgICAvdG91Y2hwYWRcXC8vaS50ZXN0KHVhKSAmJiAocmVzdWx0LnRvdWNocGFkID0gdClcbiAgICB9XG4gICAgZWxzZSBpZiAoL2JhZGEvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQmFkYSdcbiAgICAgICwgb3NuYW1lOiAnQmFkYSdcbiAgICAgICwgYmFkYTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9kb2xmaW5cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0aXplbikge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnVGl6ZW4nXG4gICAgICAsIG9zbmFtZTogJ1RpemVuJ1xuICAgICAgLCB0aXplbjogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp0aXplblxccz8pP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgvcXVwemlsbGEvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUXVwWmlsbGEnXG4gICAgICAgICwgcXVwemlsbGE6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpxdXB6aWxsYSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY2hyb21pdW0vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21pdW0nXG4gICAgICAgICwgY2hyb21pdW06IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWl1bSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY2hyb21lfGNyaW9zfGNybW8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJ1xuICAgICAgICAsIGNocm9tZTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYW5kcm9pZCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQW5kcm9pZCdcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2FmYXJpfGFwcGxld2Via2l0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhZmFyaSdcbiAgICAgICwgc2FmYXJpOiB0XG4gICAgICB9XG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpb3NkZXZpY2UpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZSA6IGlvc2RldmljZSA9PSAnaXBob25lJyA/ICdpUGhvbmUnIDogaW9zZGV2aWNlID09ICdpcGFkJyA/ICdpUGFkJyA6ICdpUG9kJ1xuICAgICAgfVxuICAgICAgLy8gV1RGOiB2ZXJzaW9uIGlzIG5vdCBwYXJ0IG9mIHVzZXIgYWdlbnQgaW4gd2ViIGFwcHNcbiAgICAgIGlmICh2ZXJzaW9uSWRlbnRpZmllcikge1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYoL2dvb2dsZWJvdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdHb29nbGVib3QnXG4gICAgICAsIGdvb2dsZWJvdDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9nb29nbGVib3RcXC8oXFxkKyhcXC5cXGQrKSkvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IGdldEZpcnN0TWF0Y2goL14oLiopXFwvKC4qKSAvKSxcbiAgICAgICAgdmVyc2lvbjogZ2V0U2Vjb25kTWF0Y2goL14oLiopXFwvKC4qKSAvKVxuICAgICB9O1xuICAgfVxuXG4gICAgLy8gc2V0IHdlYmtpdCBvciBnZWNrbyBmbGFnIGZvciBicm93c2VycyBiYXNlZCBvbiB0aGVzZSBlbmdpbmVzXG4gICAgaWYgKCFyZXN1bHQubXNlZGdlICYmIC8oYXBwbGUpP3dlYmtpdC9pLnRlc3QodWEpKSB7XG4gICAgICBpZiAoLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaS50ZXN0KHVhKSkge1xuICAgICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiQmxpbmtcIlxuICAgICAgICByZXN1bHQuYmxpbmsgPSB0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiV2Via2l0XCJcbiAgICAgICAgcmVzdWx0LndlYmtpdCA9IHRcbiAgICAgIH1cbiAgICAgIGlmICghcmVzdWx0LnZlcnNpb24gJiYgdmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5vcGVyYSAmJiAvZ2Vja29cXC8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkdlY2tvXCJcbiAgICAgIHJlc3VsdC5nZWNrbyA9IHRcbiAgICAgIHJlc3VsdC52ZXJzaW9uID0gcmVzdWx0LnZlcnNpb24gfHwgZ2V0Rmlyc3RNYXRjaCgvZ2Vja29cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgfVxuXG4gICAgLy8gc2V0IE9TIGZsYWdzIGZvciBwbGF0Zm9ybXMgdGhhdCBoYXZlIG11bHRpcGxlIGJyb3dzZXJzXG4gICAgaWYgKCFyZXN1bHQud2luZG93c3Bob25lICYmIChhbmRyb2lkIHx8IHJlc3VsdC5zaWxrKSkge1xuICAgICAgcmVzdWx0LmFuZHJvaWQgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ0FuZHJvaWQnXG4gICAgfSBlbHNlIGlmICghcmVzdWx0LndpbmRvd3NwaG9uZSAmJiBpb3NkZXZpY2UpIHtcbiAgICAgIHJlc3VsdFtpb3NkZXZpY2VdID0gdFxuICAgICAgcmVzdWx0LmlvcyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnaU9TJ1xuICAgIH0gZWxzZSBpZiAobWFjKSB7XG4gICAgICByZXN1bHQubWFjID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdtYWNPUydcbiAgICB9IGVsc2UgaWYgKHhib3gpIHtcbiAgICAgIHJlc3VsdC54Ym94ID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdYYm94J1xuICAgIH0gZWxzZSBpZiAod2luZG93cykge1xuICAgICAgcmVzdWx0LndpbmRvd3MgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ1dpbmRvd3MnXG4gICAgfSBlbHNlIGlmIChsaW51eCkge1xuICAgICAgcmVzdWx0LmxpbnV4ID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdMaW51eCdcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3dzVmVyc2lvbiAocykge1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJ05UJzogcmV0dXJuICdOVCdcbiAgICAgICAgY2FzZSAnWFAnOiByZXR1cm4gJ1hQJ1xuICAgICAgICBjYXNlICdOVCA1LjAnOiByZXR1cm4gJzIwMDAnXG4gICAgICAgIGNhc2UgJ05UIDUuMSc6IHJldHVybiAnWFAnXG4gICAgICAgIGNhc2UgJ05UIDUuMic6IHJldHVybiAnMjAwMydcbiAgICAgICAgY2FzZSAnTlQgNi4wJzogcmV0dXJuICdWaXN0YSdcbiAgICAgICAgY2FzZSAnTlQgNi4xJzogcmV0dXJuICc3J1xuICAgICAgICBjYXNlICdOVCA2LjInOiByZXR1cm4gJzgnXG4gICAgICAgIGNhc2UgJ05UIDYuMyc6IHJldHVybiAnOC4xJ1xuICAgICAgICBjYXNlICdOVCAxMC4wJzogcmV0dXJuICcxMCdcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9TIHZlcnNpb24gZXh0cmFjdGlvblxuICAgIHZhciBvc1ZlcnNpb24gPSAnJztcbiAgICBpZiAocmVzdWx0LndpbmRvd3MpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldFdpbmRvd3NWZXJzaW9uKGdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2kpKVxuICAgIH0gZWxzZSBpZiAocmVzdWx0LndpbmRvd3NwaG9uZSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQubWFjKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9NYWMgT1MgWCAoXFxkKyhbX1xcLlxcc11cXGQrKSopL2kpO1xuICAgICAgb3NWZXJzaW9uID0gb3NWZXJzaW9uLnJlcGxhY2UoL1tfXFxzXS9nLCAnLicpO1xuICAgIH0gZWxzZSBpZiAoaW9zZGV2aWNlKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9vcyAoXFxkKyhbX1xcc11cXGQrKSopIGxpa2UgbWFjIG9zIHgvaSk7XG4gICAgICBvc1ZlcnNpb24gPSBvc1ZlcnNpb24ucmVwbGFjZSgvW19cXHNdL2csICcuJyk7XG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9hbmRyb2lkWyBcXC8tXShcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQud2Vib3MpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goLyg/OndlYnxocHcpb3NcXC8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmJsYWNrYmVycnkpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3JpbVxcc3RhYmxldFxcc29zXFxzKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5iYWRhKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9iYWRhXFwvKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC50aXplbikge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bXFwvXFxzXShcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfVxuICAgIGlmIChvc1ZlcnNpb24pIHtcbiAgICAgIHJlc3VsdC5vc3ZlcnNpb24gPSBvc1ZlcnNpb247XG4gICAgfVxuXG4gICAgLy8gZGV2aWNlIHR5cGUgZXh0cmFjdGlvblxuICAgIHZhciBvc01ham9yVmVyc2lvbiA9ICFyZXN1bHQud2luZG93cyAmJiBvc1ZlcnNpb24uc3BsaXQoJy4nKVswXTtcbiAgICBpZiAoXG4gICAgICAgICB0YWJsZXRcbiAgICAgIHx8IG5leHVzVGFibGV0XG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwYWQnXG4gICAgICB8fCAoYW5kcm9pZCAmJiAob3NNYWpvclZlcnNpb24gPT0gMyB8fCAob3NNYWpvclZlcnNpb24gPj0gNCAmJiAhbW9iaWxlKSkpXG4gICAgICB8fCByZXN1bHQuc2lsa1xuICAgICkge1xuICAgICAgcmVzdWx0LnRhYmxldCA9IHRcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgbW9iaWxlXG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwaG9uZSdcbiAgICAgIHx8IGlvc2RldmljZSA9PSAnaXBvZCdcbiAgICAgIHx8IGFuZHJvaWRcbiAgICAgIHx8IG5leHVzTW9iaWxlXG4gICAgICB8fCByZXN1bHQuYmxhY2tiZXJyeVxuICAgICAgfHwgcmVzdWx0LndlYm9zXG4gICAgICB8fCByZXN1bHQuYmFkYVxuICAgICkge1xuICAgICAgcmVzdWx0Lm1vYmlsZSA9IHRcbiAgICB9XG5cbiAgICAvLyBHcmFkZWQgQnJvd3NlciBTdXBwb3J0XG4gICAgLy8gaHR0cDovL2RldmVsb3Blci55YWhvby5jb20veXVpL2FydGljbGVzL2dic1xuICAgIGlmIChyZXN1bHQubXNlZGdlIHx8XG4gICAgICAgIChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA+PSAxMCkgfHxcbiAgICAgICAgKHJlc3VsdC55YW5kZXhicm93c2VyICYmIHJlc3VsdC52ZXJzaW9uID49IDE1KSB8fFxuXHRcdCAgICAocmVzdWx0LnZpdmFsZGkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMS4wKSB8fFxuICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYW1zdW5nQnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSA0KSB8fFxuICAgICAgICAocmVzdWx0LndoYWxlICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICcxLjAnXSkgPT09IDEpIHx8XG4gICAgICAgIChyZXN1bHQubXpicm93c2VyICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICc2LjAnXSkgPT09IDEpIHx8XG4gICAgICAgIChyZXN1bHQuZm9jdXMgJiYgY29tcGFyZVZlcnNpb25zKFtyZXN1bHQudmVyc2lvbiwgJzEuMCddKSA9PT0gMSkgfHxcbiAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uID49IDIwLjApIHx8XG4gICAgICAgIChyZXN1bHQuc2FmYXJpICYmIHJlc3VsdC52ZXJzaW9uID49IDYpIHx8XG4gICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA+PSA2KSB8fFxuICAgICAgICAocmVzdWx0LmJsYWNrYmVycnkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMSlcbiAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMClcbiAgICAgICAgKSB7XG4gICAgICByZXN1bHQuYSA9IHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA8IDEwKSB8fFxuICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA8IDIwKSB8fFxuICAgICAgICAocmVzdWx0LmZpcmVmb3ggJiYgcmVzdWx0LnZlcnNpb24gPCAyMC4wKSB8fFxuICAgICAgICAocmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA8IDYpIHx8XG4gICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPCAxMC4wKSB8fFxuICAgICAgICAocmVzdWx0LmlvcyAmJiByZXN1bHQub3N2ZXJzaW9uICYmIHJlc3VsdC5vc3ZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgNilcbiAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA8IDIwKVxuICAgICAgICApIHtcbiAgICAgIHJlc3VsdC5jID0gdFxuICAgIH0gZWxzZSByZXN1bHQueCA9IHRcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHZhciBib3dzZXIgPSBkZXRlY3QodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnIDogJycpXG5cbiAgYm93c2VyLnRlc3QgPSBmdW5jdGlvbiAoYnJvd3Nlckxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb3dzZXJMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYnJvd3Nlckl0ZW0gPSBicm93c2VyTGlzdFtpXTtcbiAgICAgIGlmICh0eXBlb2YgYnJvd3Nlckl0ZW09PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGJyb3dzZXJJdGVtIGluIGJvd3Nlcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdmVyc2lvbiBwcmVjaXNpb25zIGNvdW50XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgZ2V0VmVyc2lvblByZWNpc2lvbihcIjEuMTAuM1wiKSAvLyAzXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmVyc2lvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gdmVyc2lvbi5zcGxpdChcIi5cIikubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFycmF5OjptYXAgcG9seWZpbGxcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBtYXAoYXJyLCBpdGVyYXRvcikge1xuICAgIHZhciByZXN1bHQgPSBbXSwgaTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcnIsIGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3IoYXJyW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJyb3dzZXIgdmVyc2lvbiB3ZWlnaHRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS44LjIuMS45MCddKSAgICAvLyAxXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4wMTAuMi4xJywgJzEuMDkuMi4xLjkwJ10pOyAgLy8gMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjEwLjIuMSddKTsgICAgIC8vIDBcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4wODAwLjInXSk7ICAgICAvLyAtMVxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSB2ZXJzaW9ucyB2ZXJzaW9ucyB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGFyaXNvbiByZXN1bHRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9ucykge1xuICAgIC8vIDEpIGdldCBjb21tb24gcHJlY2lzaW9uIGZvciBib3RoIHZlcnNpb25zLCBmb3IgZXhhbXBsZSBmb3IgXCIxMC4wXCIgYW5kIFwiOVwiIGl0IHNob3VsZCBiZSAyXG4gICAgdmFyIHByZWNpc2lvbiA9IE1hdGgubWF4KGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbnNbMF0pLCBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzFdKSk7XG4gICAgdmFyIGNodW5rcyA9IG1hcCh2ZXJzaW9ucywgZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgIHZhciBkZWx0YSA9IHByZWNpc2lvbiAtIGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbik7XG5cbiAgICAgIC8vIDIpIFwiOVwiIC0+IFwiOS4wXCIgKGZvciBwcmVjaXNpb24gPSAyKVxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24gKyBuZXcgQXJyYXkoZGVsdGEgKyAxKS5qb2luKFwiLjBcIik7XG5cbiAgICAgIC8vIDMpIFwiOS4wXCIgLT4gW1wiMDAwMDAwMDAwXCJcIiwgXCIwMDAwMDAwMDlcIl1cbiAgICAgIHJldHVybiBtYXAodmVyc2lvbi5zcGxpdChcIi5cIiksIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KDIwIC0gY2h1bmsubGVuZ3RoKS5qb2luKFwiMFwiKSArIGNodW5rO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIGJ5IHJldmVyc2VkIGNodW5rcyBhcnJheVxuICAgIHdoaWxlICgtLXByZWNpc2lvbiA+PSAwKSB7XG4gICAgICAvLyA0KSBjb21wYXJlOiBcIjAwMDAwMDAwOVwiID4gXCIwMDAwMDAwMTBcIiA9IGZhbHNlIChidXQgXCI5XCIgPiBcIjEwXCIgPSB0cnVlKVxuICAgICAgaWYgKGNodW5rc1swXVtwcmVjaXNpb25dID4gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjaHVua3NbMF1bcHJlY2lzaW9uXSA9PT0gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICAgIC8vIGFsbCB2ZXJzaW9uIGNodW5rcyBhcmUgc2FtZVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBicm93c2VyIGlzIHVuc3VwcG9ydGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgYm93c2VyLmlzVW5zdXBwb3J0ZWRCcm93c2VyKHtcbiAgICogICAgIG1zaWU6IFwiMTBcIixcbiAgICogICAgIGZpcmVmb3g6IFwiMjNcIixcbiAgICogICAgIGNocm9tZTogXCIyOVwiLFxuICAgKiAgICAgc2FmYXJpOiBcIjUuMVwiLFxuICAgKiAgICAgb3BlcmE6IFwiMTZcIixcbiAgICogICAgIHBoYW50b206IFwiNTM0XCJcbiAgICogICB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgbWluVmVyc2lvbnMgbWFwIG9mIG1pbmltYWwgdmVyc2lvbiB0byBicm93c2VyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcbiAgICB2YXIgX2Jvd3NlciA9IGJvd3NlcjtcblxuICAgIC8vIG1ha2Ugc3RyaWN0TW9kZSBwYXJhbSBvcHRpb25hbCB3aXRoIHVhIHBhcmFtIHVzYWdlXG4gICAgaWYgKHR5cGVvZiBzdHJpY3RNb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgdWEgPSBzdHJpY3RNb2RlO1xuICAgICAgc3RyaWN0TW9kZSA9IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdE1vZGUgPT09IHZvaWQoMCkpIHtcbiAgICAgIHN0cmljdE1vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHVhKSB7XG4gICAgICBfYm93c2VyID0gZGV0ZWN0KHVhKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IFwiXCIgKyBfYm93c2VyLnZlcnNpb247XG4gICAgZm9yICh2YXIgYnJvd3NlciBpbiBtaW5WZXJzaW9ucykge1xuICAgICAgaWYgKG1pblZlcnNpb25zLmhhc093blByb3BlcnR5KGJyb3dzZXIpKSB7XG4gICAgICAgIGlmIChfYm93c2VyW2Jyb3dzZXJdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtaW5WZXJzaW9uc1ticm93c2VyXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciB2ZXJzaW9uIGluIHRoZSBtaW5WZXJzaW9uIG1hcCBzaG91bGQgYmUgYSBzdHJpbmc6ICcgKyBicm93c2VyICsgJzogJyArIFN0cmluZyhtaW5WZXJzaW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGJyb3dzZXIgdmVyc2lvbiBhbmQgbWluIHN1cHBvcnRlZCB2ZXJzaW9uLlxuICAgICAgICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnMoW3ZlcnNpb24sIG1pblZlcnNpb25zW2Jyb3dzZXJdXSkgPCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmljdE1vZGU7IC8vIG5vdCBmb3VuZFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJyb3dzZXIgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbWluVmVyc2lvbnMgbWFwIG9mIG1pbmltYWwgdmVyc2lvbiB0byBicm93c2VyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBjaGVjayhtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcbiAgICByZXR1cm4gIWlzVW5zdXBwb3J0ZWRCcm93c2VyKG1pblZlcnNpb25zLCBzdHJpY3RNb2RlLCB1YSk7XG4gIH1cblxuICBib3dzZXIuaXNVbnN1cHBvcnRlZEJyb3dzZXIgPSBpc1Vuc3VwcG9ydGVkQnJvd3NlcjtcbiAgYm93c2VyLmNvbXBhcmVWZXJzaW9ucyA9IGNvbXBhcmVWZXJzaW9ucztcbiAgYm93c2VyLmNoZWNrID0gY2hlY2s7XG5cbiAgLypcbiAgICogU2V0IG91ciBkZXRlY3QgbWV0aG9kIHRvIHRoZSBtYWluIGJvd3NlciBvYmplY3Qgc28gd2UgY2FuXG4gICAqIHJldXNlIGl0IHRvIHRlc3Qgb3RoZXIgdXNlciBhZ2VudHMuXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBmdXR1cmUgdGVzdHMuXG4gICAqL1xuICBib3dzZXIuX2RldGVjdCA9IGRldGVjdDtcblxuICAvKlxuICAgKiBTZXQgb3VyIGRldGVjdCBwdWJsaWMgbWV0aG9kIHRvIHRoZSBtYWluIGJvd3NlciBvYmplY3RcbiAgICogVGhpcyBpcyBuZWVkZWQgdG8gaW1wbGVtZW50IGJvd3NlciBpbiBzZXJ2ZXIgc2lkZVxuICAgKi9cbiAgYm93c2VyLmRldGVjdCA9IGRldGVjdDtcbiAgcmV0dXJuIGJvd3NlclxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0TWF0cml4QXJyYXlUeXBlID0gc2V0TWF0cml4QXJyYXlUeXBlO1xuZXhwb3J0cy50b1JhZGlhbiA9IHRvUmFkaWFuO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLlJBTkRPTSA9IGV4cG9ydHMuQVJSQVlfVFlQRSA9IGV4cG9ydHMuRVBTSUxPTiA9IHZvaWQgMDtcblxuLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG52YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0cy5FUFNJTE9OID0gRVBTSUxPTjtcbnZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydHMuQVJSQVlfVFlQRSA9IEFSUkFZX1RZUEU7XG52YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcclxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2VzXHJcbiAqXHJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XHJcbiAqL1xuXG5leHBvcnRzLlJBTkRPTSA9IFJBTkRPTTtcblxuZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgZXhwb3J0cy5BUlJBWV9UWVBFID0gQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuLyoqXHJcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBBbmdsZSBpbiBEZWdyZWVzXHJcbiAqL1xuXG5mdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xufVxuXG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlYzQgPSBleHBvcnRzLnZlYzMgPSBleHBvcnRzLnZlYzIgPSBleHBvcnRzLnF1YXQyID0gZXhwb3J0cy5xdWF0ID0gZXhwb3J0cy5tYXQ0ID0gZXhwb3J0cy5tYXQzID0gZXhwb3J0cy5tYXQyZCA9IGV4cG9ydHMubWF0MiA9IGV4cG9ydHMuZ2xNYXRyaXggPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmV4cG9ydHMuZ2xNYXRyaXggPSBnbE1hdHJpeDtcblxudmFyIG1hdDIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQyLmpzXCIpKTtcblxuZXhwb3J0cy5tYXQyID0gbWF0MjtcblxudmFyIG1hdDJkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0MmQuanNcIikpO1xuXG5leHBvcnRzLm1hdDJkID0gbWF0MmQ7XG5cbnZhciBtYXQzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0My5qc1wiKSk7XG5cbmV4cG9ydHMubWF0MyA9IG1hdDM7XG5cbnZhciBtYXQ0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0NC5qc1wiKSk7XG5cbmV4cG9ydHMubWF0NCA9IG1hdDQ7XG5cbnZhciBxdWF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcXVhdC5qc1wiKSk7XG5cbmV4cG9ydHMucXVhdCA9IHF1YXQ7XG5cbnZhciBxdWF0MiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1YXQyLmpzXCIpKTtcblxuZXhwb3J0cy5xdWF0MiA9IHF1YXQyO1xuXG52YXIgdmVjMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzIuanNcIikpO1xuXG5leHBvcnRzLnZlYzIgPSB2ZWMyO1xuXG52YXIgdmVjMyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzMuanNcIikpO1xuXG5leHBvcnRzLnZlYzMgPSB2ZWMzO1xuXG52YXIgdmVjNCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzQuanNcIikpO1xuXG5leHBvcnRzLnZlYzQgPSB2ZWM0O1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5hZGpvaW50ID0gYWRqb2ludDtcbmV4cG9ydHMuZGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLkxEVSA9IExEVTtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyID0gbXVsdGlwbHlTY2FsYXI7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gbXVsdGlwbHlTY2FsYXJBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogMngyIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcclxuICpcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDIgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9IGEwICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAtcztcbiAgb3V0WzNdID0gYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cblxuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xufVxuLyoqXHJcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdIC8gYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tVHJhbnNsYXRpb24gPSBmcm9tVHJhbnNsYXRpb247XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDJ4MyBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQyZFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcclxuICogPHByZT5cclxuICogW2EsIGIsXHJcbiAqICBjLCBkLFxyXG4gKiAgdHgsIHR5XVxyXG4gKiA8L3ByZT5cclxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxyXG4gKiA8cHJlPlxyXG4gKiBbYSwgYiwgMCxcclxuICogIGMsIGQsIDAsXHJcbiAqICB0eCwgdHksIDFdXHJcbiAqIDwvcHJlPlxyXG4gKiBUaGUgbGFzdCBjb2x1bW4gaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcclxuICpcclxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDJkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBBIG5ldyBtYXQyZFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhYSA9IGFbMF0sXG4gICAgICBhYiA9IGFbMV0sXG4gICAgICBhYyA9IGFbMl0sXG4gICAgICBhZCA9IGFbM107XG4gIHZhciBhdHggPSBhWzRdLFxuICAgICAgYXR5ID0gYVs1XTtcbiAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwO1xuICBvdXRbMV0gPSBhMTtcbiAgb3V0WzJdID0gYTI7XG4gIG91dFszXSA9IGEzO1xuICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdlswXTtcbiAgb3V0WzVdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MmQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIsIFwiICsgYVs0XSArIFwiLCBcIiArIGFbNV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCAxKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5mcm9tTWF0NCA9IGZyb21NYXQ0O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLmZyb21NYXQyZCA9IGZyb21NYXQyZDtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMubm9ybWFsRnJvbU1hdDQgPSBub3JtYWxGcm9tTWF0NDtcbmV4cG9ydHMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDN4MyBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQzXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzRdO1xuICBvdXRbNF0gPSBhWzVdO1xuICBvdXRbNV0gPSBhWzZdO1xuICBvdXRbNl0gPSBhWzhdO1xuICBvdXRbN10gPSBhWzldO1xuICBvdXRbOF0gPSBhWzEwXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQzIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gIHZhciBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGIwMSAqIGRldDtcbiAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgb3V0WzNdID0gYjExICogZGV0O1xuICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgb3V0WzBdID0gYTExICogYTIyIC0gYTEyICogYTIxO1xuICBvdXRbMV0gPSBhMDIgKiBhMjEgLSBhMDEgKiBhMjI7XG4gIG91dFsyXSA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgb3V0WzNdID0gYTEyICogYTIwIC0gYTEwICogYTIyO1xuICBvdXRbNF0gPSBhMDAgKiBhMjIgLSBhMDIgKiBhMjA7XG4gIG91dFs1XSA9IGEwMiAqIGExMCAtIGEwMCAqIGExMjtcbiAgb3V0WzZdID0gYTEwICogYTIxIC0gYTExICogYTIwO1xuICBvdXRbN10gPSBhMDEgKiBhMjAgLSBhMDAgKiBhMjE7XG4gIG91dFs4XSA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMCA9IGJbMF0sXG4gICAgICBiMDEgPSBiWzFdLFxuICAgICAgYjAyID0gYlsyXTtcbiAgdmFyIGIxMCA9IGJbM10sXG4gICAgICBiMTEgPSBiWzRdLFxuICAgICAgYjEyID0gYls1XTtcbiAgdmFyIGIyMCA9IGJbNl0sXG4gICAgICBiMjEgPSBiWzddLFxuICAgICAgYjIyID0gYls4XTtcbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcbiAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG4gIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IHZbMF07XG4gIG91dFs3XSA9IHZbMV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHZbMV07XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSBhWzRdO1xuICBvdXRbN10gPSBhWzVdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gLTE7XG4gIG91dFs3XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cblxuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN10sXG4gICAgICBhOCA9IGFbOF07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN10sXG4gICAgICBiOCA9IGJbOF07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21YUm90YXRpb24gPSBmcm9tWFJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tWVJvdGF0aW9uID0gZnJvbVlSb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVpSb3RhdGlvbiA9IGZyb21aUm90YXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21RdWF0MiA9IGZyb21RdWF0MjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuZ2V0U2NhbGluZyA9IGdldFNjYWxpbmc7XG5leHBvcnRzLmdldFJvdGF0aW9uID0gZ2V0Um90YXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbjtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMuZnJ1c3R1bSA9IGZydXN0dW07XG5leHBvcnRzLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG5leHBvcnRzLnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc7XG5leHBvcnRzLm9ydGhvID0gb3J0aG87XG5leHBvcnRzLmxvb2tBdCA9IGxvb2tBdDtcbmV4cG9ydHMudGFyZ2V0VG8gPSB0YXJnZXRUbztcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5mcm9iID0gZnJvYjtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhciA9IG11bHRpcGx5U2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhckFuZEFkZCA9IG11bHRpcGx5U2NhbGFyQW5kQWRkO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogNHg0IE1hdHJpeDxicj5Gb3JtYXQ6IGNvbHVtbi1tYWpvciwgd2hlbiB0eXBlZCBvdXQgaXQgbG9va3MgbGlrZSByb3ctbWFqb3I8YnI+VGhlIG1hdHJpY2VzIGFyZSBiZWluZyBwb3N0IG11bHRpcGxpZWQuXHJcbiAqIEBtb2R1bGUgbWF0NFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgIHZhciBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuICAgIHZhciBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgb3V0WzBdID0gYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpO1xuICBvdXRbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSA9IGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzNdID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSA9IGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKTtcbiAgb3V0WzZdID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gPSBhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFs4XSA9IGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKTtcbiAgb3V0WzldID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07XG4gICAgYTAxID0gYVsxXTtcbiAgICBhMDIgPSBhWzJdO1xuICAgIGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTtcbiAgICBhMTEgPSBhWzVdO1xuICAgIGExMiA9IGFbNl07XG4gICAgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdO1xuICAgIGEyMSA9IGFbOV07XG4gICAgYTIyID0gYVsxMF07XG4gICAgYTIzID0gYVsxMV07XG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG4gICAgb3V0WzNdID0gYTAzO1xuICAgIG91dFs0XSA9IGExMDtcbiAgICBvdXRbNV0gPSBhMTE7XG4gICAgb3V0WzZdID0gYTEyO1xuICAgIG91dFs3XSA9IGExMztcbiAgICBvdXRbOF0gPSBhMjA7XG4gICAgb3V0WzldID0gYTIxO1xuICAgIG91dFsxMF0gPSBhMjI7XG4gICAgb3V0WzExXSA9IGEyMztcbiAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSB2WzFdO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gdlsyXTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBmcm9tIGEgZHVhbCBxdWF0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBNYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7bWF0NH0gbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhdDIob3V0LCBhKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICB2YXIgbWFnbml0dWRlID0gYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6ICsgYncgKiBidzsgLy9Pbmx5IHNjYWxlIGlmIGl0IG1ha2VzIHNlbnNlXG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMiAvIG1hZ25pdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgfVxuXG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgYSwgdHJhbnNsYXRpb24pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxyXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgdmFyIG0xMSA9IG1hdFswXTtcbiAgdmFyIG0xMiA9IG1hdFsxXTtcbiAgdmFyIG0xMyA9IG1hdFsyXTtcbiAgdmFyIG0yMSA9IG1hdFs0XTtcbiAgdmFyIG0yMiA9IG1hdFs1XTtcbiAgdmFyIG0yMyA9IG1hdFs2XTtcbiAgdmFyIG0zMSA9IG1hdFs4XTtcbiAgdmFyIG0zMiA9IG1hdFs5XTtcbiAgdmFyIG0zMyA9IG1hdFsxMF07XG4gIG91dFswXSA9IE1hdGguaHlwb3QobTExLCBtMTIsIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguaHlwb3QobTIxLCBtMjIsIG0yMyk7XG4gIG91dFsyXSA9IE1hdGguaHlwb3QobTMxLCBtMzIsIG0zMyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxyXG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcclxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxyXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIHZhciBzY2FsaW5nID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIGdldFNjYWxpbmcoc2NhbGluZywgbWF0KTtcbiAgdmFyIGlzMSA9IDEgLyBzY2FsaW5nWzBdO1xuICB2YXIgaXMyID0gMSAvIHNjYWxpbmdbMV07XG4gIHZhciBpczMgPSAxIC8gc2NhbGluZ1syXTtcbiAgdmFyIHNtMTEgPSBtYXRbMF0gKiBpczE7XG4gIHZhciBzbTEyID0gbWF0WzFdICogaXMyO1xuICB2YXIgc20xMyA9IG1hdFsyXSAqIGlzMztcbiAgdmFyIHNtMjEgPSBtYXRbNF0gKiBpczE7XG4gIHZhciBzbTIyID0gbWF0WzVdICogaXMyO1xuICB2YXIgc20yMyA9IG1hdFs2XSAqIGlzMztcbiAgdmFyIHNtMzEgPSBtYXRbOF0gKiBpczE7XG4gIHZhciBzbTMyID0gbWF0WzldICogaXMyO1xuICB2YXIgc20zMyA9IG1hdFsxMF0gKiBpczM7XG4gIHZhciB0cmFjZSA9IHNtMTEgKyBzbTIyICsgc20zMztcbiAgdmFyIFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHtcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20xMSA+IHNtMjIgJiYgc20xMSA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMTEgLSBzbTIyIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsyXSA9IChzbTMxICsgc20xMykgLyBTO1xuICB9IGVsc2UgaWYgKHNtMjIgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTIyIC0gc20xMSAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMF0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMzMgLSBzbTExIC0gc20yMikgKiAyO1xuICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgIG91dFswXSA9IChzbTMxICsgc20xMykgLyBTO1xuICAgIG91dFsxXSA9IChzbTIzICsgc20zMikgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIHZhciBveCA9IG9bMF07XG4gIHZhciBveSA9IG9bMV07XG4gIHZhciBveiA9IG9bMl07XG4gIHZhciBvdXQwID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIHZhciBvdXQxID0gKHh5ICsgd3opICogc3g7XG4gIHZhciBvdXQyID0gKHh6IC0gd3kpICogc3g7XG4gIHZhciBvdXQ0ID0gKHh5IC0gd3opICogc3k7XG4gIHZhciBvdXQ1ID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIHZhciBvdXQ2ID0gKHl6ICsgd3gpICogc3k7XG4gIHZhciBvdXQ4ID0gKHh6ICsgd3kpICogc3o7XG4gIHZhciBvdXQ5ID0gKHl6IC0gd3gpICogc3o7XG4gIHZhciBvdXQxMCA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICBvdXRbNl0gPSBvdXQ2O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBvdXQ4O1xuICBvdXRbOV0gPSBvdXQ5O1xuICBvdXRbMTBdID0gb3V0MTA7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dDAgKiBveCArIG91dDQgKiBveSArIG91dDggKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0MSAqIG94ICsgb3V0NSAqIG95ICsgb3V0OSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXQyICogb3ggKyBvdXQ2ICogb3kgKyBvdXQxMCAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6eCArIHd5O1xuICBvdXRbOV0gPSB6eSAtIHd4O1xuICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgbmY7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTVdID0gMDtcblxuICBpZiAoZmFyICE9IG51bGwgJiYgZmFyICE9PSBJbmZpbml0eSkge1xuICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzEwXSA9IC0xO1xuICAgIG91dFsxNF0gPSAtMiAqIG5lYXI7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGZpZWxkIG9mIHZpZXcuXHJcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcclxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbik7XG4gIHZhciB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcbiAgb3V0WzBdID0geFNjYWxlO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICBvdXRbNF0gPSAwLjA7XG4gIG91dFs1XSA9IHlTY2FsZTtcbiAgb3V0WzZdID0gMC4wO1xuICBvdXRbN10gPSAwLjA7XG4gIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICBvdXRbOV0gPSAodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTVdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIHZhciBleWV4ID0gZXllWzBdO1xuICB2YXIgZXlleSA9IGV5ZVsxXTtcbiAgdmFyIGV5ZXogPSBleWVbMl07XG4gIHZhciB1cHggPSB1cFswXTtcbiAgdmFyIHVweSA9IHVwWzFdO1xuICB2YXIgdXB6ID0gdXBbMl07XG4gIHZhciBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICB2YXIgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgdmFyIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gIH1cblxuICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuICBsZW4gPSAxIC8gTWF0aC5oeXBvdCh6MCwgejEsIHoyKTtcbiAgejAgKj0gbGVuO1xuICB6MSAqPSBsZW47XG4gIHoyICo9IGxlbjtcbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh4MCwgeDEsIHgyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHgwID0gMDtcbiAgICB4MSA9IDA7XG4gICAgeDIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICBsZW4gPSBNYXRoLmh5cG90KHkwLCB5MSwgeTIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgdmFyIGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcbiAgdmFyIHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgdmFyIGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIHZhciB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdLCBhWzldLCBhWzEwXSwgYVsxMV0sIGFbMTJdLCBhWzEzXSwgYVsxNF0sIGFbMTVdKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3NcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICBvdXRbOV0gPSBhWzldICogYjtcbiAgb3V0WzEwXSA9IGFbMTBdICogYjtcbiAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgb3V0WzEzXSA9IGFbMTNdICogYjtcbiAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICBvdXRbOV0gPSBhWzldICsgYls5XSAqIHNjYWxlO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXSAqIHNjYWxlO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXSAqIHNjYWxlO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXSAqIHNjYWxlO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXSAqIHNjYWxlO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XSAqIHNjYWxlO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBhOCA9IGFbOF0sXG4gICAgICBhOSA9IGFbOV0sXG4gICAgICBhMTAgPSBhWzEwXSxcbiAgICAgIGExMSA9IGFbMTFdO1xuICB2YXIgYTEyID0gYVsxMl0sXG4gICAgICBhMTMgPSBhWzEzXSxcbiAgICAgIGExNCA9IGFbMTRdLFxuICAgICAgYTE1ID0gYVsxNV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIHZhciBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHZhciBiOCA9IGJbOF0sXG4gICAgICBiOSA9IGJbOV0sXG4gICAgICBiMTAgPSBiWzEwXSxcbiAgICAgIGIxMSA9IGJbMTFdO1xuICB2YXIgYjEyID0gYlsxMl0sXG4gICAgICBiMTMgPSBiWzEzXSxcbiAgICAgIGIxNCA9IGJbMTRdLFxuICAgICAgYjE1ID0gYlsxNV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJiBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiYgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJiBNYXRoLmFicyhhMTEgLSBiMTEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiYgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJiBNYXRoLmFicyhhMTQgLSBiMTQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuc2V0QXhpc0FuZ2xlID0gc2V0QXhpc0FuZ2xlO1xuZXhwb3J0cy5nZXRBeGlzQW5nbGUgPSBnZXRBeGlzQW5nbGU7XG5leHBvcnRzLmdldEFuZ2xlID0gZ2V0QW5nbGU7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLmNhbGN1bGF0ZVcgPSBjYWxjdWxhdGVXO1xuZXhwb3J0cy5leHAgPSBleHA7XG5leHBvcnRzLmxuID0gbG47XG5leHBvcnRzLnBvdyA9IHBvdztcbmV4cG9ydHMuc2xlcnAgPSBzbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmNvbmp1Z2F0ZSA9IGNvbmp1Z2F0ZTtcbmV4cG9ydHMuZnJvbU1hdDMgPSBmcm9tTWF0MztcbmV4cG9ydHMuZnJvbUV1bGVyID0gZnJvbUV1bGVyO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLnNldEF4ZXMgPSBleHBvcnRzLnNxbGVycCA9IGV4cG9ydHMucm90YXRpb25UbyA9IGV4cG9ydHMuZXF1YWxzID0gZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxdWFyZWRMZW5ndGggPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMubGVuZ3RoID0gZXhwb3J0cy5sZXJwID0gZXhwb3J0cy5kb3QgPSBleHBvcnRzLnNjYWxlID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLmFkZCA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5jb3B5ID0gZXhwb3J0cy5mcm9tVmFsdWVzID0gZXhwb3J0cy5jbG9uZSA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxudmFyIG1hdDMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQzLmpzXCIpKTtcblxudmFyIHZlYzMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWMzLmpzXCIpKTtcblxudmFyIHZlYzQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWM0LmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIFF1YXRlcm5pb25cclxuICogQG1vZHVsZSBxdWF0XHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXHJcbiAqIHRoZW4gcmV0dXJucyBpdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LCBheGlzLCByYWQpIHtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cclxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcclxuICogIHNldEF4aXNBbmdsZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWVcclxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XHJcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXHJcbiAqIEV4YW1wbGU6IFRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieSBheGlzIFswLCAwLCAxXSBhbmRcclxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcclxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cclxuICogQHBhcmFtICB7dmVjM30gb3V0X2F4aXMgIFZlY3RvciByZWNlaXZpbmcgdGhlIGF4aXMgb2Ygcm90YXRpb25cclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMsIHEpIHtcbiAgdmFyIHJhZCA9IE1hdGguYWNvcyhxWzNdKSAqIDIuMDtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuXG4gIGlmIChzID4gZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIG91dF9heGlzWzBdID0gcVswXSAvIHM7XG4gICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgIG91dF9heGlzWzBdID0gMTtcbiAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgb3V0X2F4aXNbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJhZDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGJldHdlZW4gdHdvIHVuaXQgcXVhdGVybmlvbnNcclxuICpcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0fSBhICAgICBPcmlnaW4gdW5pdCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdH0gYiAgICAgRGVzdGluYXRpb24gdW5pdCBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBiZXR3ZWVuIHRoZSB0d28gcXVhdGVybmlvbnNcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0QW5nbGUoYSwgYikge1xuICB2YXIgZG90cHJvZHVjdCA9IGRvdChhLCBiKTtcbiAgcmV0dXJuIE1hdGguYWNvcygyICogZG90cHJvZHVjdCAqIGRvdHByb2R1Y3QgLSAxKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgYncgPSBiWzNdO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ5ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieiA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxyXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxyXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cChvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgZXQgPSBNYXRoLmV4cCh3KTtcbiAgdmFyIHMgPSByID4gMCA/IGV0ICogTWF0aC5zaW4ocikgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHM7XG4gIG91dFsxXSA9IHkgKiBzO1xuICBvdXRbMl0gPSB6ICogcztcbiAgb3V0WzNdID0gZXQgKiBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbG4ob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIHQgPSByID4gMCA/IE1hdGguYXRhbjIociwgdykgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHQ7XG4gIG91dFsxXSA9IHkgKiB0O1xuICBvdXRbMl0gPSB6ICogdDtcbiAgb3V0WzNdID0gMC41ICogTWF0aC5sb2coeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgc2NhbGFyIHBvd2VyIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgcXVhdGVybmlvbiBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBvdyhvdXQsIGEsIGIpIHtcbiAgbG4ob3V0LCBhKTtcbiAgc2NhbGUob3V0LCBvdXQsIGIpO1xuICBleHAob3V0LCBvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2xlcnAob3V0LCBhLCBiLCB0KSB7XG4gIC8vIGJlbmNobWFya3M6XG4gIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTsgLy8gY2FsYyBjb3NpbmVcblxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7IC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuXG4gIGlmIChjb3NvbSA8IDAuMCkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLWJ4O1xuICAgIGJ5ID0gLWJ5O1xuICAgIGJ6ID0gLWJ6O1xuICAgIGJ3ID0gLWJ3O1xuICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcblxuXG4gIGlmICgxLjAgLSBjb3NvbSA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHVuaXQgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0KSB7XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcbiAgLy8gVE9ETzogQ2FsbGluZyByYW5kb20gMyB0aW1lcyBpcyBwcm9iYWJseSBub3QgdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiAgdmFyIHUxID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MiA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTMgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHNxcnQxTWludXNVMSA9IE1hdGguc3FydCgxIC0gdTEpO1xuICB2YXIgc3FydFUxID0gTWF0aC5zcXJ0KHUxKTtcbiAgb3V0WzBdID0gc3FydDFNaW51c1UxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzFdID0gc3FydDFNaW51c1UxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzJdID0gc3FydFUxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgb3V0WzNdID0gc3FydFUxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGRvdCA9IGEwICogYTAgKyBhMSAqIGExICsgYTIgKiBhMiArIGEzICogYTM7XG4gIHZhciBpbnZEb3QgPSBkb3QgPyAxLjAgLyBkb3QgOiAwOyAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gIG91dFswXSA9IC1hMCAqIGludkRvdDtcbiAgb3V0WzFdID0gLWExICogaW52RG90O1xuICBvdXRbMl0gPSAtYTIgKiBpbnZEb3Q7XG4gIG91dFszXSA9IGEzICogaW52RG90O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcclxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxyXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSByb3RhdGlvbiBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICB2YXIgZlJvb3Q7XG5cbiAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xuXG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsgLy8gMS8oNHcpXG5cbiAgICBvdXRbMF0gPSAobVs1XSAtIG1bN10pICogZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0gLSBtWzJdKSAqIGZSb290O1xuICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChtWzRdID4gbVswXSkgaSA9IDE7XG4gICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgIHZhciBqID0gKGkgKyAxKSAlIDM7XG4gICAgdmFyIGsgPSAoaSArIDIpICUgMztcbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kgKiAzICsgaV0gLSBtW2ogKiAzICsgal0gLSBtW2sgKiAzICsga10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiAqIDMgKyBrXSAtIG1bayAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEBwYXJhbSB7eX0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBZIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tRXVsZXIob3V0LCB4LCB5LCB6KSB7XG4gIHZhciBoYWxmVG9SYWQgPSAwLjUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gIHggKj0gaGFsZlRvUmFkO1xuICB5ICo9IGhhbGZUb1JhZDtcbiAgeiAqPSBoYWxmVG9SYWQ7XG4gIHZhciBzeCA9IE1hdGguc2luKHgpO1xuICB2YXIgY3ggPSBNYXRoLmNvcyh4KTtcbiAgdmFyIHN5ID0gTWF0aC5zaW4oeSk7XG4gIHZhciBjeSA9IE1hdGguY29zKHkpO1xuICB2YXIgc3ogPSBNYXRoLnNpbih6KTtcbiAgdmFyIGN6ID0gTWF0aC5jb3Moeik7XG4gIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gIG91dFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwicXVhdChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBjbG9uZSA9IHZlYzQuY2xvbmU7XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbnZhciBmcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbnZhciBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuY29weSA9IGNvcHk7XG52YXIgc2V0ID0gdmVjNC5zZXQ7XG4vKipcclxuICogQWRkcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc2V0ID0gc2V0O1xudmFyIGFkZCA9IHZlYzQuYWRkO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmFkZCA9IGFkZDtcbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzY2FsZSA9IHZlYzQuc2NhbGU7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbnZhciBkb3QgPSB2ZWM0LmRvdDtcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZG90ID0gZG90O1xudmFyIGxlcnAgPSB2ZWM0LmxlcnA7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0cy5sZXJwID0gbGVycDtcbnZhciBsZW5ndGggPSB2ZWM0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xudmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogTm9ybWFsaXplIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xudmFyIG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbnZhciBleGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG52YXIgZXF1YWxzID0gdmVjNC5lcXVhbHM7XG4vKipcclxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxyXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cclxuICpcclxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuXG52YXIgcm90YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApO1xuICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcblxuICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgIGlmICh2ZWMzLmxlbih0bXB2ZWMzKSA8IDAuMDAwMDAxKSB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgIHNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSAwO1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IDA7XG4gICAgICBvdXRbM10gPSAxO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB9XG4gIH07XG59KCk7XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmV4cG9ydHMucm90YXRpb25UbyA9IHJvdGF0aW9uVG87XG5cbnZhciBzcWxlcnAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZW1wMSA9IGNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBzbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgc2xlcnAodGVtcDIsIGIsIGMsIHQpO1xuICAgIHNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCk7XG4vKipcclxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cclxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXHJcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5leHBvcnRzLnNxbGVycCA9IHNxbGVycDtcblxudmFyIHNldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgbWF0cls3XSA9IHVwWzJdO1xuICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgbWF0cls4XSA9IC12aWV3WzJdO1xuICAgIHJldHVybiBub3JtYWxpemUob3V0LCBmcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5zZXRBeGVzID0gc2V0QXhlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcyA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tVHJhbnNsYXRpb24gPSBmcm9tVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvbiA9IGZyb21Sb3RhdGlvbjtcbmV4cG9ydHMuZnJvbU1hdDQgPSBmcm9tTWF0NDtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuZ2V0RHVhbCA9IGdldER1YWw7XG5leHBvcnRzLnNldER1YWwgPSBzZXREdWFsO1xuZXhwb3J0cy5nZXRUcmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLnJvdGF0ZUJ5UXVhdEFwcGVuZCA9IHJvdGF0ZUJ5UXVhdEFwcGVuZDtcbmV4cG9ydHMucm90YXRlQnlRdWF0UHJlcGVuZCA9IHJvdGF0ZUJ5UXVhdFByZXBlbmQ7XG5leHBvcnRzLnJvdGF0ZUFyb3VuZEF4aXMgPSByb3RhdGVBcm91bmRBeGlzO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmNvbmp1Z2F0ZSA9IGNvbmp1Z2F0ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLmxlbmd0aCA9IGV4cG9ydHMuZG90ID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLnNldFJlYWwgPSBleHBvcnRzLmdldFJlYWwgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbnZhciBxdWF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcXVhdC5qc1wiKSk7XG5cbnZhciBtYXQ0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0NC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiBEdWFsIFF1YXRlcm5pb248YnI+XHJcbiAqIEZvcm1hdDogW3JlYWwsIGR1YWxdPGJyPlxyXG4gKiBRdWF0ZXJuaW9uIGZvcm1hdDogWFlaVzxicj5cclxuICogTWFrZSBzdXJlIHRvIGhhdmUgbm9ybWFsaXplZCBkdWFsIHF1YXRlcm5pb25zLCBvdGhlcndpc2UgdGhlIGZ1bmN0aW9ucyBtYXkgbm90IHdvcmsgYXMgaW50ZW5kZWQuPGJyPlxyXG4gKiBAbW9kdWxlIHF1YXQyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBkdWFsIHF1YXRcclxuICpcclxuICogQHJldHVybnMge3F1YXQyfSBhIG5ldyBkdWFsIHF1YXRlcm5pb24gW3JlYWwgLT4gcm90YXRpb24sIGR1YWwgLT4gdHJhbnNsYXRpb25dXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBkcVswXSA9IDA7XG4gICAgZHFbMV0gPSAwO1xuICAgIGRxWzJdID0gMDtcbiAgICBkcVs0XSA9IDA7XG4gICAgZHFbNV0gPSAwO1xuICAgIGRxWzZdID0gMDtcbiAgICBkcVs3XSA9IDA7XG4gIH1cblxuICBkcVszXSA9IDE7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gY2xvbmVcclxuICogQHJldHVybnMge3F1YXQyfSBuZXcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IGFbMF07XG4gIGRxWzFdID0gYVsxXTtcbiAgZHFbMl0gPSBhWzJdO1xuICBkcVszXSA9IGFbM107XG4gIGRxWzRdID0gYVs0XTtcbiAgZHFbNV0gPSBhWzVdO1xuICBkcVs2XSA9IGFbNl07XG4gIGRxWzddID0gYVs3XTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIGRxWzRdID0geDI7XG4gIGRxWzVdID0geTI7XG4gIGRxWzZdID0gejI7XG4gIGRxWzddID0gdzI7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBmcm9tIHRoZSBnaXZlbiB2YWx1ZXMgKHF1YXQgYW5kIHRyYW5zbGF0aW9uKVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50ICh0cmFuc2xhdGlvbilcclxuICogQHJldHVybnMge3F1YXQyfSBuZXcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcyh4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6Mikge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSB4MTtcbiAgZHFbMV0gPSB5MTtcbiAgZHFbMl0gPSB6MTtcbiAgZHFbM10gPSB3MTtcbiAgdmFyIGF4ID0geDIgKiAwLjUsXG4gICAgICBheSA9IHkyICogMC41LFxuICAgICAgYXogPSB6MiAqIDAuNTtcbiAgZHFbNF0gPSBheCAqIHcxICsgYXkgKiB6MSAtIGF6ICogeTE7XG4gIGRxWzVdID0gYXkgKiB3MSArIGF6ICogeDEgLSBheCAqIHoxO1xuICBkcVs2XSA9IGF6ICogdzEgKyBheCAqIHkxIC0gYXkgKiB4MTtcbiAgZHFbN10gPSAtYXggKiB4MSAtIGF5ICogeTEgLSBheiAqIHoxO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGR1YWwgcXVhdCBmcm9tIGEgcXVhdGVybmlvbiBhbmQgYSB0cmFuc2xhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBhIG5vcm1hbGl6ZWQgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdCB0cmFubGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB0KSB7XG4gIHZhciBheCA9IHRbMF0gKiAwLjUsXG4gICAgICBheSA9IHRbMV0gKiAwLjUsXG4gICAgICBheiA9IHRbMl0gKiAwLjUsXG4gICAgICBieCA9IHFbMF0sXG4gICAgICBieSA9IHFbMV0sXG4gICAgICBieiA9IHFbMl0sXG4gICAgICBidyA9IHFbM107XG4gIG91dFswXSA9IGJ4O1xuICBvdXRbMV0gPSBieTtcbiAgb3V0WzJdID0gYno7XG4gIG91dFszXSA9IGJ3O1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSAtYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHRyYW5zbGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB0IHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB0WzBdICogMC41O1xuICBvdXRbNV0gPSB0WzFdICogMC41O1xuICBvdXRbNl0gPSB0WzJdICogMC41O1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgdGhlIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHEpIHtcbiAgb3V0WzBdID0gcVswXTtcbiAgb3V0WzFdID0gcVsxXTtcbiAgb3V0WzJdID0gcVsyXTtcbiAgb3V0WzNdID0gcVszXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBmcm9tIGEgbWF0cml4ICg0eDQpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICAvL1RPRE8gT3B0aW1pemUgdGhpc1xuICB2YXIgb3V0ZXIgPSBxdWF0LmNyZWF0ZSgpO1xuICBtYXQ0LmdldFJvdGF0aW9uKG91dGVyLCBhKTtcbiAgdmFyIHQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgbWF0NC5nZXRUcmFuc2xhdGlvbih0LCBhKTtcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBvdXRlciwgdCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIGR1YWwgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIHNvdXJjZSBkdWFsIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgZHVhbCBxdWF0IHRvIHRoZSBpZGVudGl0eSBkdWFsIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBkdWFsIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MSBXIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzIgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICBvdXRbMF0gPSB4MTtcbiAgb3V0WzFdID0geTE7XG4gIG91dFsyXSA9IHoxO1xuICBvdXRbM10gPSB3MTtcbiAgb3V0WzRdID0geDI7XG4gIG91dFs1XSA9IHkyO1xuICBvdXRbNl0gPSB6MjtcbiAgb3V0WzddID0gdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcmVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCByZWFsIHBhcnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gcmVhbCBwYXJ0XHJcbiAqL1xuXG5cbnZhciBnZXRSZWFsID0gcXVhdC5jb3B5O1xuLyoqXHJcbiAqIEdldHMgdGhlIGR1YWwgcGFydCBvZiBhIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgZHVhbCBwYXJ0XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IGR1YWwgcGFydFxyXG4gKi9cblxuZXhwb3J0cy5nZXRSZWFsID0gZ2V0UmVhbDtcblxuZnVuY3Rpb24gZ2V0RHVhbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVs0XTtcbiAgb3V0WzFdID0gYVs1XTtcbiAgb3V0WzJdID0gYVs2XTtcbiAgb3V0WzNdID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIHJlYWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcmVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgc2V0UmVhbCA9IHF1YXQuY29weTtcbi8qKlxyXG4gKiBTZXQgdGhlIGR1YWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgZHVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zZXRSZWFsID0gc2V0UmVhbDtcblxuZnVuY3Rpb24gc2V0RHVhbChvdXQsIHEpIHtcbiAgb3V0WzRdID0gcVswXTtcbiAgb3V0WzVdID0gcVsxXTtcbiAgb3V0WzZdID0gcVsyXTtcbiAgb3V0WzddID0gcVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiBhIG5vcm1hbGl6ZWQgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCB0cmFuc2xhdGlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXHJcbiAqIEByZXR1cm4ge3ZlYzN9IHRyYW5zbGF0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgYSkge1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICBvdXRbMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICBvdXRbMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgYSBkdWFsIHF1YXQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYXgxID0gYVswXSxcbiAgICAgIGF5MSA9IGFbMV0sXG4gICAgICBhejEgPSBhWzJdLFxuICAgICAgYXcxID0gYVszXSxcbiAgICAgIGJ4MSA9IHZbMF0gKiAwLjUsXG4gICAgICBieTEgPSB2WzFdICogMC41LFxuICAgICAgYnoxID0gdlsyXSAqIDAuNSxcbiAgICAgIGF4MiA9IGFbNF0sXG4gICAgICBheTIgPSBhWzVdLFxuICAgICAgYXoyID0gYVs2XSxcbiAgICAgIGF3MiA9IGFbN107XG4gIG91dFswXSA9IGF4MTtcbiAgb3V0WzFdID0gYXkxO1xuICBvdXRbMl0gPSBhejE7XG4gIG91dFszXSA9IGF3MTtcbiAgb3V0WzRdID0gYXcxICogYngxICsgYXkxICogYnoxIC0gYXoxICogYnkxICsgYXgyO1xuICBvdXRbNV0gPSBhdzEgKiBieTEgKyBhejEgKiBieDEgLSBheDEgKiBiejEgKyBheTI7XG4gIG91dFs2XSA9IGF3MSAqIGJ6MSArIGF4MSAqIGJ5MSAtIGF5MSAqIGJ4MSArIGF6MjtcbiAgb3V0WzddID0gLWF4MSAqIGJ4MSAtIGF5MSAqIGJ5MSAtIGF6MSAqIGJ6MSArIGF3MjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVYKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVkob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWihvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGJ5IGEgZ2l2ZW4gcXVhdGVybmlvbiAoYSAqIHEpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlQnlRdWF0QXBwZW5kKG91dCwgYSwgcSkge1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbMV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbMl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbM10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICBheCA9IGFbNF07XG4gIGF5ID0gYVs1XTtcbiAgYXogPSBhWzZdO1xuICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogcXcgKyBhdyAqIHF4ICsgYXkgKiBxeiAtIGF6ICogcXk7XG4gIG91dFs1XSA9IGF5ICogcXcgKyBhdyAqIHF5ICsgYXogKiBxeCAtIGF4ICogcXo7XG4gIG91dFs2XSA9IGF6ICogcXcgKyBhdyAqIHF6ICsgYXggKiBxeSAtIGF5ICogcXg7XG4gIG91dFs3XSA9IGF3ICogcXcgLSBheCAqIHF4IC0gYXkgKiBxeSAtIGF6ICogcXo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKHEgKiBhKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdFByZXBlbmQob3V0LCBxLCBhKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBieCA9IGFbMF0sXG4gICAgICBieSA9IGFbMV0sXG4gICAgICBieiA9IGFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFszXSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIGJ4ID0gYVs0XTtcbiAgYnkgPSBhWzVdO1xuICBieiA9IGFbNl07XG4gIGJ3ID0gYVs3XTtcbiAgb3V0WzRdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzVdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzZdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzddID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCBhIGdpdmVuIGF4aXMuIERvZXMgdGhlIG5vcm1hbGlzYXRpb24gYXV0b21hdGljYWxseVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBob3cgZmFyIHRoZSByb3RhdGlvbiBzaG91bGQgYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlQXJvdW5kQXhpcyhvdXQsIGEsIGF4aXMsIHJhZCkge1xuICAvL1NwZWNpYWwgY2FzZSBmb3IgcmFkID0gMFxuICBpZiAoTWF0aC5hYnMocmFkKSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gY29weShvdXQsIGEpO1xuICB9XG5cbiAgdmFyIGF4aXNMZW5ndGggPSBNYXRoLmh5cG90KGF4aXNbMF0sIGF4aXNbMV0sIGF4aXNbMl0pO1xuICByYWQgPSByYWQgKiAwLjU7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGJ4ID0gcyAqIGF4aXNbMF0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYnkgPSBzICogYXhpc1sxXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBieiA9IHMgKiBheGlzWzJdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGF4MSA9IGFbMF0sXG4gICAgICBheTEgPSBhWzFdLFxuICAgICAgYXoxID0gYVsyXSxcbiAgICAgIGF3MSA9IGFbM107XG4gIG91dFswXSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbMV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzJdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFszXSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbNV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbNl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIGR1YWwgcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXgwID0gYVswXSxcbiAgICAgIGF5MCA9IGFbMV0sXG4gICAgICBhejAgPSBhWzJdLFxuICAgICAgYXcwID0gYVszXSxcbiAgICAgIGJ4MSA9IGJbNF0sXG4gICAgICBieTEgPSBiWzVdLFxuICAgICAgYnoxID0gYls2XSxcbiAgICAgIGJ3MSA9IGJbN10sXG4gICAgICBheDEgPSBhWzRdLFxuICAgICAgYXkxID0gYVs1XSxcbiAgICAgIGF6MSA9IGFbNl0sXG4gICAgICBhdzEgPSBhWzddLFxuICAgICAgYngwID0gYlswXSxcbiAgICAgIGJ5MCA9IGJbMV0sXG4gICAgICBiejAgPSBiWzJdLFxuICAgICAgYncwID0gYlszXTtcbiAgb3V0WzBdID0gYXgwICogYncwICsgYXcwICogYngwICsgYXkwICogYnowIC0gYXowICogYnkwO1xuICBvdXRbMV0gPSBheTAgKiBidzAgKyBhdzAgKiBieTAgKyBhejAgKiBieDAgLSBheDAgKiBiejA7XG4gIG91dFsyXSA9IGF6MCAqIGJ3MCArIGF3MCAqIGJ6MCArIGF4MCAqIGJ5MCAtIGF5MCAqIGJ4MDtcbiAgb3V0WzNdID0gYXcwICogYncwIC0gYXgwICogYngwIC0gYXkwICogYnkwIC0gYXowICogYnowO1xuICBvdXRbNF0gPSBheDAgKiBidzEgKyBhdzAgKiBieDEgKyBheTAgKiBiejEgLSBhejAgKiBieTEgKyBheDEgKiBidzAgKyBhdzEgKiBieDAgKyBheTEgKiBiejAgLSBhejEgKiBieTA7XG4gIG91dFs1XSA9IGF5MCAqIGJ3MSArIGF3MCAqIGJ5MSArIGF6MCAqIGJ4MSAtIGF4MCAqIGJ6MSArIGF5MSAqIGJ3MCArIGF3MSAqIGJ5MCArIGF6MSAqIGJ4MCAtIGF4MSAqIGJ6MDtcbiAgb3V0WzZdID0gYXowICogYncxICsgYXcwICogYnoxICsgYXgwICogYnkxIC0gYXkwICogYngxICsgYXoxICogYncwICsgYXcxICogYnowICsgYXgxICogYnkwIC0gYXkxICogYngwO1xuICBvdXRbN10gPSBhdzAgKiBidzEgLSBheDAgKiBieDEgLSBheTAgKiBieTEgLSBhejAgKiBiejEgKyBhdzEgKiBidzAgLSBheDEgKiBieDAgLSBheTEgKiBieTAgLSBhejEgKiBiejA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBkdWFsIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIGR1YWwgcXVhdCBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBkdWFsIHF1YXQncyAoVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSByZWFsIHBhcnRzKVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgZG90ID0gcXVhdC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBkdWFsIHF1YXRzJ3NcclxuICogTk9URTogVGhlIHJlc3VsdGluZyBkdWFsIHF1YXRlcm5pb25zIHdvbid0IGFsd2F5cyBiZSBub3JtYWxpemVkIChUaGUgZXJyb3IgaXMgbW9zdCBub3RpY2VhYmxlIHdoZW4gdCA9IDAuNSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydHMuZG90ID0gZG90O1xuXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgbXQgPSAxIC0gdDtcbiAgaWYgKGRvdChhLCBiKSA8IDApIHQgPSAtdDtcbiAgb3V0WzBdID0gYVswXSAqIG10ICsgYlswXSAqIHQ7XG4gIG91dFsxXSA9IGFbMV0gKiBtdCArIGJbMV0gKiB0O1xuICBvdXRbMl0gPSBhWzJdICogbXQgKyBiWzJdICogdDtcbiAgb3V0WzNdID0gYVszXSAqIG10ICsgYlszXSAqIHQ7XG4gIG91dFs0XSA9IGFbNF0gKiBtdCArIGJbNF0gKiB0O1xuICBvdXRbNV0gPSBhWzVdICogbXQgKyBiWzVdICogdDtcbiAgb3V0WzZdID0gYVs2XSAqIG10ICsgYls2XSAqIHQ7XG4gIG91dFs3XSA9IGFbN10gKiBtdCArIGJbN10gKiB0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBkdWFsIHF1YXQuIElmIHRoZXkgYXJlIG5vcm1hbGl6ZWQsIGNvbmp1Z2F0ZSBpcyBjaGVhcGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIHNxbGVuID0gc3F1YXJlZExlbmd0aChhKTtcbiAgb3V0WzBdID0gLWFbMF0gLyBzcWxlbjtcbiAgb3V0WzFdID0gLWFbMV0gLyBzcWxlbjtcbiAgb3V0WzJdID0gLWFbMl0gLyBzcWxlbjtcbiAgb3V0WzNdID0gYVszXSAvIHNxbGVuO1xuICBvdXRbNF0gPSAtYVs0XSAvIHNxbGVuO1xuICBvdXRbNV0gPSAtYVs1XSAvIHNxbGVuO1xuICBvdXRbNl0gPSAtYVs2XSAvIHNxbGVuO1xuICBvdXRbN10gPSBhWzddIC8gc3FsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgZHVhbCBxdWF0XHJcbiAqIElmIHRoZSBkdWFsIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0Mi5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb25qdWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IC1hWzRdO1xuICBvdXRbNV0gPSAtYVs1XTtcbiAgb3V0WzZdID0gLWFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXQgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIGxlbmd0aCA9IHF1YXQubGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3F1YXJlZExlbmd0aCA9IHF1YXQuc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgbWFnbml0dWRlID0gc3F1YXJlZExlbmd0aChhKTtcblxuICBpZiAobWFnbml0dWRlID4gMCkge1xuICAgIG1hZ25pdHVkZSA9IE1hdGguc3FydChtYWduaXR1ZGUpO1xuICAgIHZhciBhMCA9IGFbMF0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGExID0gYVsxXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTIgPSBhWzJdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMyA9IGFbM10gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGIwID0gYVs0XTtcbiAgICB2YXIgYjEgPSBhWzVdO1xuICAgIHZhciBiMiA9IGFbNl07XG4gICAgdmFyIGIzID0gYVs3XTtcbiAgICB2YXIgYV9kb3RfYiA9IGEwICogYjAgKyBhMSAqIGIxICsgYTIgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gKGIwIC0gYTAgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNV0gPSAoYjEgLSBhMSAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs2XSA9IChiMiAtIGEyICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzddID0gKGIzIC0gYTMgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGR1YWwgcXVhdGVuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZHVhbCBxdWF0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInF1YXQyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdGVybmlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXQuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMuZGl2aWRlID0gZGl2aWRlO1xuZXhwb3J0cy5jZWlsID0gY2VpbDtcbmV4cG9ydHMuZmxvb3IgPSBmbG9vcjtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLnJvdW5kID0gcm91bmQ7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLnNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5pbnZlcnNlID0gaW52ZXJzZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG5leHBvcnRzLnRyYW5zZm9ybU1hdDIgPSB0cmFuc2Zvcm1NYXQyO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQyZCA9IHRyYW5zZm9ybU1hdDJkO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQzID0gdHJhbnNmb3JtTWF0MztcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuemVybyA9IHplcm87XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSBleHBvcnRzLmxlbiA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjMlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcclxuICpcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgMkQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IFRoZSByZWNlaXZpbmcgdmVjMlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cblxuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgICAgeTEgPSBhWzFdLFxuICAgICAgeDIgPSBiWzBdLFxuICAgICAgeTIgPSBiWzFdLFxuICAgICAgLy8gbWFnIGlzIHRoZSBwcm9kdWN0IG9mIHRoZSBtYWduaXR1ZGVzIG9mIGEgYW5kIGJcbiAgbWFnID0gTWF0aC5zcXJ0KHgxICogeDEgKyB5MSAqIHkxKSAqIE1hdGguc3FydCh4MiAqIHgyICsgeTIgKiB5MiksXG4gICAgICAvLyBtYWcgJiYuLiBzaG9ydCBjaXJjdWl0cyBpZiBtYWcgPT0gMFxuICBjb3NpbmUgPSBtYWcgJiYgKHgxICogeDIgKyB5MSAqIHkyKSAvIG1hZzsgLy8gTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpIGNsYW1wcyB0aGUgY29zaW5lIGJldHdlZW4gLTEgYW5kIDFcblxuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3ViID0gc3ViO1xudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpdiA9IGRpdjtcbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpc3QgPSBkaXN0O1xudmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJEaXN0ID0gc3FyRGlzdDtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAyO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuZm9yRWFjaCA9IGZvckVhY2g7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmhlcm1pdGUgPSBoZXJtaXRlO1xuZXhwb3J0cy5iZXppZXIgPSBiZXppZXI7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDMgPSB0cmFuc2Zvcm1NYXQzO1xuZXhwb3J0cy50cmFuc2Zvcm1RdWF0ID0gdHJhbnNmb3JtUXVhdDtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuemVybyA9IHplcm87XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMuc3FyRGlzdCA9IGV4cG9ydHMuZGlzdCA9IGV4cG9ydHMuZGl2ID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLnN1YiA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjM1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcclxuICpcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBiZXppZXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcclxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF07XG4gIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4ocmFkKSArIHBbMF0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhyYWQpIC0gcFswXSAqIE1hdGguc2luKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIG1hZzEgPSBNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkgKyBheiAqIGF6KSxcbiAgICAgIG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6KSxcbiAgICAgIG1hZyA9IG1hZzEgKiBtYWcyLFxuICAgICAgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnN1YiA9IHN1YjtcbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5kaXYgPSBkaXY7XG52YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5kaXN0ID0gZGlzdDtcbnZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJEaXN0ID0gc3FyRGlzdDtcbnZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJMZW4gPSBzcXJMZW47XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIHZlY1syXSA9IGFbaSArIDJdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQ0ID0gdHJhbnNmb3JtTWF0NDtcbmV4cG9ydHMudHJhbnNmb3JtUXVhdCA9IHRyYW5zZm9ybVF1YXQ7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZm9yRWFjaCA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiA0IERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IHggKiBsZW47XG4gIG91dFsxXSA9IHkgKiBsZW47XG4gIG91dFsyXSA9IHogKiBsZW47XG4gIG91dFszXSA9IHcgKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzIGluIGEgNC1kaW1lbnNpb25hbCBzcGFjZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFYgdGhlIHNlY29uZCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgdSwgdiwgdykge1xuICB2YXIgQSA9IHZbMF0gKiB3WzFdIC0gdlsxXSAqIHdbMF0sXG4gICAgICBCID0gdlswXSAqIHdbMl0gLSB2WzJdICogd1swXSxcbiAgICAgIEMgPSB2WzBdICogd1szXSAtIHZbM10gKiB3WzBdLFxuICAgICAgRCA9IHZbMV0gKiB3WzJdIC0gdlsyXSAqIHdbMV0sXG4gICAgICBFID0gdlsxXSAqIHdbM10gLSB2WzNdICogd1sxXSxcbiAgICAgIEYgPSB2WzJdICogd1szXSAtIHZbM10gKiB3WzJdO1xuICB2YXIgRyA9IHVbMF07XG4gIHZhciBIID0gdVsxXTtcbiAgdmFyIEkgPSB1WzJdO1xuICB2YXIgSiA9IHVbM107XG4gIG91dFswXSA9IEggKiBGIC0gSSAqIEUgKyBKICogRDtcbiAgb3V0WzFdID0gLShHICogRikgKyBJICogQyAtIEogKiBCO1xuICBvdXRbMl0gPSBHICogRSAtIEggKiBDICsgSiAqIEE7XG4gIG91dFszXSA9IC0oRyAqIEQpICsgSCAqIEIgLSBJICogQTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIHZhciBhdyA9IGFbM107XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7IC8vIE1hcnNhZ2xpYSwgR2VvcmdlLiBDaG9vc2luZyBhIFBvaW50IGZyb20gdGhlIFN1cmZhY2Ugb2YgYVxuICAvLyBTcGhlcmUuIEFubi4gTWF0aC4gU3RhdGlzdC4gNDMgKDE5NzIpLCBuby4gMiwgNjQ1LS02NDYuXG4gIC8vIGh0dHA6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9ldWNsaWQuYW9tcy8xMTc3NjkyNjQ0O1xuXG4gIHZhciB2MSwgdjIsIHYzLCB2NDtcbiAgdmFyIHMxLCBzMjtcblxuICBkbyB7XG4gICAgdjEgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHYyID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMSA9IHYxICogdjEgKyB2MiAqIHYyO1xuICB9IHdoaWxlIChzMSA+PSAxKTtcblxuICBkbyB7XG4gICAgdjMgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHY0ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMiA9IHYzICogdjMgKyB2NCAqIHY0O1xuICB9IHdoaWxlIChzMiA+PSAxKTtcblxuICB2YXIgZCA9IE1hdGguc3FydCgoMSAtIHMxKSAvIHMyKTtcbiAgb3V0WzBdID0gc2NhbGUgKiB2MTtcbiAgb3V0WzFdID0gc2NhbGUgKiB2MjtcbiAgb3V0WzJdID0gc2NhbGUgKiB2MyAqIGQ7XG4gIG91dFszXSA9IHNjYWxlICogdjQgKiBkO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTsgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcblxuICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zdWIgPSBzdWI7XG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGl2ID0gZGl2O1xudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG52YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyRGlzdCA9IHNxckRpc3Q7XG52YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuID0gbGVuO1xudmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDQ7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIHZlY1szXSA9IGFbaSArIDNdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdO1xuICAgICAgYVtpICsgMV0gPSB2ZWNbMV07XG4gICAgICBhW2kgKyAyXSA9IHZlY1syXTtcbiAgICAgIGFbaSArIDNdID0gdmVjWzNdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoOyIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjQgLSAyMDE0LTA5LTI4XHJcbiAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXI7XHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xyXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgZXhwb3J0TmFtZSwgdW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTVMnLCAnbXMnLCAnbyddO1xyXG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XHJcblxyXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xyXG52YXIgYWJzID0gTWF0aC5hYnM7XHJcbnZhciBub3cgPSBEYXRlLm5vdztcclxuXHJcbi8qKlxyXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiBzZXRUaW1lb3V0KGJpbmRGbihmbiwgY29udGV4dCksIHRpbWVvdXQpO1xyXG59XHJcblxyXG4vKipcclxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcclxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXHJcbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxyXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcclxuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICBpZiAoIW9iaikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2JqLmZvckVhY2gpIHtcclxuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xyXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogZXh0ZW5kIG9iamVjdC5cclxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcclxuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2VdXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXHJcbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcclxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcclxuICAgICAgICBjaGlsZFA7XHJcblxyXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XHJcbiAgICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcclxuICAgIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcclxuXHJcbiAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgIGV4dGVuZChjaGlsZFAsIHByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcclxuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxyXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcclxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcclxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PSBUWVBFX0ZVTkNUSU9OKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXHJcbiAqIEBwYXJhbSB7Kn0gdmFsMVxyXG4gKiBAcGFyYW0geyp9IHZhbDJcclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XHJcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcclxuICovXHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcclxuICAgIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxyXG4gKiBAbWV0aG9kIGhhc1BhcmVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxyXG4gKi9cclxuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xyXG4gICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcclxuICovXHJcbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xyXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cclxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcclxuICovXHJcbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcclxuICAgIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcclxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xyXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XHJcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc29ydCkge1xyXG4gICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uIHNvcnRVbmlxdWVBcnJheShhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XHJcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxyXG4gKi9cclxuZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHByZWZpeCwgcHJvcDtcclxuICAgIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XHJcblxyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xyXG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xyXG5cclxuICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgYSB1bmlxdWUgaWRcclxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcclxuICovXHJcbnZhciBfdW5pcXVlSWQgPSAxO1xyXG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcclxuICAgIHJldHVybiBfdW5pcXVlSWQrKztcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XHJcbiAgICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93KTtcclxufVxyXG5cclxudmFyIE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcclxuXHJcbnZhciBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XHJcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcclxudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcblxyXG52YXIgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XHJcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xyXG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XHJcbnZhciBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xyXG5cclxudmFyIENPTVBVVEVfSU5URVJWQUwgPSAyNTtcclxuXHJcbnZhciBJTlBVVF9TVEFSVCA9IDE7XHJcbnZhciBJTlBVVF9NT1ZFID0gMjtcclxudmFyIElOUFVUX0VORCA9IDQ7XHJcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xyXG5cclxudmFyIERJUkVDVElPTl9OT05FID0gMTtcclxudmFyIERJUkVDVElPTl9MRUZUID0gMjtcclxudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XHJcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xyXG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcclxuXHJcbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xyXG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XHJcbnZhciBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XHJcblxyXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xyXG52YXIgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICogQHJldHVybnMge0lucHV0fVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xyXG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XHJcblxyXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXHJcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXHJcbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xyXG4gICAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XHJcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmluaXQoKTtcclxuXHJcbn1cclxuXHJcbklucHV0LnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7IH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcclxuICAgICAqL1xyXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdW5iaW5kIHRoZSBldmVudHNcclxuICAgICAqL1xyXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXHJcbiAqIEByZXR1cm5zIHtJbnB1dH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xyXG4gICAgdmFyIFR5cGU7XHJcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xyXG5cclxuICAgIGlmIChpbnB1dENsYXNzKSB7XHJcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XHJcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcclxuICAgICAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XHJcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xyXG4gICAgICAgIFR5cGUgPSBUb3VjaElucHV0O1xyXG4gICAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xyXG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xyXG4gICAgdmFyIHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XHJcbiAgICB2YXIgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcclxuICAgIHZhciBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xyXG5cclxuICAgIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XHJcbiAgICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xyXG5cclxuICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgbWFuYWdlci5zZXNzaW9uID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcclxuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xyXG4gICAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG5cclxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xyXG4gICAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XHJcblxyXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcclxuICAgIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xyXG5cclxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcclxuICAgIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcclxuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XHJcbiAgICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcclxuICAgIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xyXG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xyXG5cclxuICAgIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cclxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XHJcbiAgICAgICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcclxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xyXG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcclxuICAgIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcclxuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlyc3RJbnB1dCA9IHNlc3Npb24uZmlyc3RJbnB1dDtcclxuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xyXG4gICAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xyXG5cclxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xyXG4gICAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XHJcbiAgICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcclxuXHJcbiAgICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcclxuICAgIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xyXG5cclxuICAgIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcclxuICAgIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XHJcblxyXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcclxuICAgIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XHJcblxyXG4gICAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcclxuXHJcbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxyXG4gICAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIGlmIChoYXNQYXJlbnQoaW5wdXQuc3JjRXZlbnQudGFyZ2V0LCB0YXJnZXQpKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xyXG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcclxuICAgIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xyXG4gICAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xyXG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xyXG5cclxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xyXG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xyXG4gICAgICAgICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXHJcbiAgICAgICAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XHJcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxyXG4gICAgICAgICAgICB5OiBjZW50ZXIueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XHJcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xyXG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcclxuICAgICAgICBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcCxcclxuICAgICAgICB2ZWxvY2l0eSwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIGRpcmVjdGlvbjtcclxuXHJcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgdmFyIGRlbHRhWCA9IGxhc3QuZGVsdGFYIC0gaW5wdXQuZGVsdGFYO1xyXG4gICAgICAgIHZhciBkZWx0YVkgPSBsYXN0LmRlbHRhWSAtIGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgdmFyIHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcclxuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XHJcbiAgICAgICAgdmVsb2NpdHlZID0gdi55O1xyXG4gICAgICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcclxuICAgICAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XHJcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XHJcbiAgICAgICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcclxuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcclxuICAgIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcclxuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcclxuICAgIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxyXG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXHJcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgcG9pbnRlcnNbaV0gPSB7XHJcbiAgICAgICAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxyXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcclxuICAgICAgICBwb2ludGVyczogcG9pbnRlcnMsXHJcbiAgICAgICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxyXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxyXG4gICAgICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcclxuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxyXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXHJcbiAgICAgICAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcclxuICAgICAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XHJcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXHJcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxyXG4gICAgICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0ge051bWJlcn0geFxyXG4gKiBAcGFyYW0ge051bWJlcn0geVxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcclxuICAgIGlmICh4ID09PSB5KSB7XHJcbiAgICAgICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cclxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xyXG4gICAgfVxyXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXHJcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcclxuICogQHBhcmFtIHtPYmplY3R9IHAxXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpIHtcclxuICAgICAgICBwcm9wcyA9IFBST1BTX1hZO1xyXG4gICAgfVxyXG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXHJcbiAgICAgICAgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xyXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpIC0gZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xyXG59XHJcblxyXG4vKipcclxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcclxuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XHJcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XHJcbn1cclxuXHJcbnZhciBNT1VTRV9JTlBVVF9NQVAgPSB7XHJcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxyXG4gICAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxyXG4gICAgbW91c2V1cDogSU5QVVRfRU5EXHJcbn07XHJcblxyXG52YXIgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcclxudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xyXG5cclxuLyoqXHJcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcclxuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xyXG5cclxuICAgIHRoaXMuYWxsb3cgPSB0cnVlOyAvLyB1c2VkIGJ5IElucHV0LlRvdWNoTW91c2UgdG8gZGlzYWJsZSBtb3VzZSBldmVudHNcclxuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KE1vdXNlSW5wdXQsIElucHV0LCB7XHJcbiAgICAvKipcclxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xyXG5cclxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xyXG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd24sIGFuZCBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQgKHNlZSB0aGUgVG91Y2hNb3VzZSBpbnB1dClcclxuICAgICAgICBpZiAoIXRoaXMucHJlc3NlZCB8fCAhdGhpcy5hbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xyXG4gICAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxyXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXHJcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcclxuICAgIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcclxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cclxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XHJcbiAgICAyOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXHJcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxyXG4gICAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XHJcbn07XHJcblxyXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XHJcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xyXG5cclxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXHJcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcclxuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XHJcbiAgICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xyXG59XHJcblxyXG4vKipcclxuICogUG9pbnRlciBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xyXG5cclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xyXG59XHJcblxyXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcclxuICAgICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xyXG5cclxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XHJcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XHJcblxyXG4gICAgICAgIHZhciBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpO1xyXG5cclxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxyXG4gICAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XHJcblxyXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cclxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xyXG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xyXG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXHJcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXHJcbiAgICAgICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogc3RvcmUsXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXHJcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XHJcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcclxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcclxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXHJcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXHJcbn07XHJcblxyXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XHJcbnZhciBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XHJcblxyXG4vKipcclxuICogVG91Y2ggZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcclxuICAgIHRoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcclxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoU2luZ2xlVG91Y2hJbnB1dCwgSW5wdXQsIHtcclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xyXG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcclxuXHJcbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xyXG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xyXG5cclxuICAgICAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXHJcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXHJcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cclxuICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcclxuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcclxuICAgIHZhciBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xyXG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcclxuXHJcbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XHJcbn1cclxuXHJcbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XHJcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcclxuICAgIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcclxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXHJcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXHJcbn07XHJcblxyXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XHJcblxyXG4vKipcclxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBUb3VjaElucHV0KCkge1xyXG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XHJcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xyXG5cclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcclxuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XHJcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHRoaXMge1RvdWNoSW5wdXR9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XHJcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XHJcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XHJcblxyXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcclxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSxcclxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxyXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyksXHJcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcclxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcclxuXHJcbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXHJcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcclxuICAgICAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGNvbGxlY3QgdG91Y2hlc1xyXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xyXG4gICAgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcclxuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xyXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXHJcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxyXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXHJcbiAgICBdO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XHJcbiAqXHJcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxyXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xyXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xyXG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XHJcbiAgICB0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcclxufVxyXG5cclxuaW5oZXJpdChUb3VjaE1vdXNlSW5wdXQsIElucHV0LCB7XHJcbiAgICAvKipcclxuICAgICAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcclxuICAgICAgICB2YXIgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCksXHJcbiAgICAgICAgICAgIGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfTU9VU0UpO1xyXG5cclxuICAgICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHNvICBibG9jayBhbGwgdXBjb21pbmcgbW91c2UgZXZlbnRzXHJcbiAgICAgICAgLy8gbW9zdCBtb2JpbGUgYnJvd3NlciBhbHNvIGVtaXQgbW91c2VldmVudHMsIHJpZ2h0IGFmdGVyIHRvdWNoc3RhcnRcclxuICAgICAgICBpZiAoaXNUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmICF0aGlzLm1vdXNlLmFsbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBhbGxvd01vdXNlIHdoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgIGlmIChpbnB1dEV2ZW50ICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqL1xyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLm1vdXNlLmRlc3Ryb3koKTtcclxuICAgIH1cclxufSk7XHJcblxyXG52YXIgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcclxudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcclxuXHJcbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcclxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XHJcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxyXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XHJcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcclxuXHJcbi8qKlxyXG4gKiBUb3VjaCBBY3Rpb25cclxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XHJcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgdGhpcy5zZXQodmFsdWUpO1xyXG59XHJcblxyXG5Ub3VjaEFjdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgcHJldmVudERlZmF1bHRzOiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIC8vIG5vdCBuZWVkZWQgd2l0aCBuYXRpdmUgc3VwcG9ydCBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5XHJcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXHJcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcclxuICAgICAgICB2YXIgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKTtcclxuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XHJcbiAgICAgICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG5cclxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxyXG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcclxuICAgICAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJldmVudFNyYzogZnVuY3Rpb24oc3JjRXZlbnQpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xyXG4gICAgLy8gbm9uZVxyXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xyXG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XHJcbiAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XHJcblxyXG4gICAgLy8gcGFuLXggYW5kIHBhbi15IGNhbiBiZSBjb21iaW5lZFxyXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xyXG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fUEFOX1ggKyAnICcgKyBUT1VDSF9BQ1RJT05fUEFOX1k7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcclxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcclxuICAgICAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtYW5pcHVsYXRpb25cclxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xyXG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcclxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxyXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcclxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXHJcbiAqXHJcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcclxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cclxuICpcclxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xyXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxyXG4gKlxyXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXHJcbiAqICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXHJcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XHJcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXHJcbiAqL1xyXG52YXIgU1RBVEVfUE9TU0lCTEUgPSAxO1xyXG52YXIgU1RBVEVfQkVHQU4gPSAyO1xyXG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XHJcbnZhciBTVEFURV9FTkRFRCA9IDg7XHJcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XHJcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcclxudmFyIFNUQVRFX0ZBSUxFRCA9IDMyO1xyXG5cclxuLyoqXHJcbiAqIFJlY29nbml6ZXJcclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xyXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XHJcblxyXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcclxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMgfHwge30sIHRoaXMuZGVmYXVsdHMpO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcclxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XHJcblxyXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcclxuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcclxufVxyXG5cclxuUmVjb2duaXplci5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxyXG4gICAgICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgcmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xyXG4gICAgICAgICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcclxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xyXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcclxuICAgICAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xyXG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBkcm9wUmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcclxuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xyXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICovXHJcbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBlbWl0KHdpdGhTdGF0ZSkge1xyXG4gICAgICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyAod2l0aFN0YXRlID8gc3RhdGVTdHIoc3RhdGUpIDogJycpLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcclxuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgICAgICBlbWl0KHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW1pdCgpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXHJcblxyXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXHJcbiAgICAgICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XHJcbiAgICAgICAgICAgIGVtaXQodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcclxuICAgICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcclxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICovXHJcbiAgICB0cnlFbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FuIHdlIGVtaXQ/XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgY2FuRW1pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcclxuICAgICAqL1xyXG4gICAgcmVjb2duaXplOiBmdW5jdGlvbihpbnB1dERhdGEpIHtcclxuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxyXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXHJcbiAgICAgICAgdmFyIGlucHV0RGF0YUNsb25lID0gZXh0ZW5kKHt9LCBpbnB1dERhdGEpO1xyXG5cclxuICAgICAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cclxuICAgICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcclxuXHJcbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXHJcbiAgICAgICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0RGF0YSkgeyB9LCAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcclxuICAgICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxyXG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xyXG4gICAgICAgIHJldHVybiAnY2FuY2VsJztcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgIHJldHVybiAnZW5kJztcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XHJcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcclxuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xyXG4gICAgICAgIHJldHVybiAnc3RhcnQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXHJcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTikge1xyXG4gICAgICAgIHJldHVybiAnZG93bic7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcclxuICAgICAgICByZXR1cm4gJ3VwJztcclxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9MRUZUKSB7XHJcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcclxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IERJUkVDVElPTl9SSUdIVCkge1xyXG4gICAgICAgIHJldHVybiAncmlnaHQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXHJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcclxuICAgIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xyXG4gICAgaWYgKG1hbmFnZXIpIHtcclxuICAgICAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICBwb2ludGVyczogMVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxyXG4gICAgICovXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICogQHJldHVybnMgeyp9IFN0YXRlXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gaW5wdXQuZXZlbnRUeXBlO1xyXG5cclxuICAgICAgICB2YXIgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcclxuICAgICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xyXG5cclxuICAgICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXHJcbiAgICAgICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUGFuXHJcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcclxuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5wWCA9IG51bGw7XHJcbiAgICB0aGlzLnBZID0gbnVsbDtcclxufVxyXG5cclxuaW5oZXJpdChQYW5SZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncGFuJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxyXG4gICAgICAgIHBvaW50ZXJzOiAxLFxyXG4gICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcclxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXJlY3Rpb25UZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcclxuICAgICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgLy8gbG9jayB0byBheGlzP1xyXG4gICAgICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XHJcbiAgICAgICAgICAgICAgICBoYXNNb3ZlZCA9IHggIT0gdGhpcy5wWDtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xyXG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXHJcbiAgICAgICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcclxuICAgICAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xyXG5cclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFBpbmNoXHJcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMCxcclxuICAgICAgICBwb2ludGVyczogMlxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xyXG4gICAgICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xyXG4gICAgICAgICAgICB2YXIgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0LCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQcmVzc1xyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XHJcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XHJcbn1cclxuXHJcbmluaGVyaXQoUHJlc3NSZWNvZ25pemVyLCBSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBQcmVzc1JlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3ByZXNzJyxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICB0aW1lOiA1MDAsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXHJcbiAgICAgICAgdGhyZXNob2xkOiA1IC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcclxuICAgICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XHJcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcclxuXHJcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcclxuICAgICAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXHJcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xyXG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWUsIHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFJvdGF0ZVxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFJvdGF0ZVJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMCxcclxuICAgICAgICBwb2ludGVyczogMlxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTd2lwZVxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcclxuICAgIEF0dHJSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoU3dpcGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgU3dpcGVSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdzd2lwZScsXHJcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcclxuICAgICAgICB2ZWxvY2l0eTogMC42NSxcclxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxyXG4gICAgICAgIHBvaW50ZXJzOiAxXHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHZlbG9jaXR5O1xyXG5cclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xyXG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGlucHV0LnZlbG9jaXR5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eVg7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQuZGlyZWN0aW9uICYmXHJcbiAgICAgICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxyXG4gICAgICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXHJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xyXG4gKiBhIHNpbmdsZSB0YXAuXHJcbiAqXHJcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxyXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xyXG4gICAgUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcclxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xyXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG4gICAgdGhpcy5jb3VudCA9IDA7XHJcbn1cclxuXHJcbmluaGVyaXQoVGFwUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUGluY2hSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICd0YXAnLFxyXG4gICAgICAgIHBvaW50ZXJzOiAxLFxyXG4gICAgICAgIHRhcHM6IDEsXHJcbiAgICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcclxuICAgICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXHJcbiAgICAgICAgdGhyZXNob2xkOiAyLCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xyXG4gICAgICAgIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcclxuICAgIH0sXHJcblxyXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xyXG4gICAgICAgIHZhciB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG5cclxuICAgICAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XHJcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxyXG4gICAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xyXG4gICAgICAgICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxyXG4gICAgICAgICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxyXG4gICAgICAgICAgICB2YXIgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xyXG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcclxuICAgICAgICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgZmFpbFRpbWVvdXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsLCB0aGlzKTtcclxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfUkVDT0dOSVpFRCApIHtcclxuICAgICAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGFuIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XHJcbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge3N0cmluZ31cclxuICovXHJcbkhhbW1lci5WRVJTSU9OID0gJzIuMC40JztcclxuXHJcbi8qKlxyXG4gKiBkZWZhdWx0IHNldHRpbmdzXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbkhhbW1lci5kZWZhdWx0cyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cclxuICAgICAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGRvbUV2ZW50czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cclxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IGNvbXB1dGVcclxuICAgICAqL1xyXG4gICAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcclxuICAgICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxyXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cclxuICAgICAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcbiAgICBpbnB1dFRhcmdldDogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXHJcbiAgICAgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgaW5wdXRDbGFzczogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxyXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgcHJlc2V0OiBbXHJcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXHJcbiAgICAgICAgW1JvdGF0ZVJlY29nbml6ZXIsIHsgZW5hYmxlOiBmYWxzZSB9XSxcclxuICAgICAgICBbUGluY2hSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfSwgWydyb3RhdGUnXV0sXHJcbiAgICAgICAgW1N3aXBlUmVjb2duaXplcix7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfV0sXHJcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHsgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB9LCBbJ3N3aXBlJ11dLFxyXG4gICAgICAgIFtUYXBSZWNvZ25pemVyXSxcclxuICAgICAgICBbVGFwUmVjb2duaXplciwgeyBldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDIgfSwgWyd0YXAnXV0sXHJcbiAgICAgICAgW1ByZXNzUmVjb2duaXplcl1cclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxyXG4gICAgICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICovXHJcbiAgICBjc3NQcm9wczoge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b3VjaFNlbGVjdDogJ25vbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxyXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xyXG4gICAgICAgICAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1c2VyRHJhZzogJ25vbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxyXG4gICAgICAgICAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBTVE9QID0gMTtcclxudmFyIEZPUkNFRF9TVE9QID0gMjtcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VyXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgSGFtbWVyLmRlZmF1bHRzKTtcclxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xyXG5cclxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xyXG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xyXG5cclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcclxuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcclxuXHJcbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcclxuXHJcbiAgICBlYWNoKG9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICB2YXIgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xyXG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xyXG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcclxuICAgIH0sIHRoaXMpO1xyXG59XHJcblxyXG5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcclxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxyXG4gICAgICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cclxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXHJcbiAgICAgKi9cclxuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxyXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxyXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XHJcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XHJcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxyXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XHJcblxyXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xyXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XHJcblxyXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxyXG4gICAgICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcclxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXHJcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXHJcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXHJcbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xyXG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXHJcbiAgICAgICAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxyXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcclxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXHJcbiAgICAgICAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxyXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cclxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXHJcbiAgICAgICAgICAgICAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcclxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcclxuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxyXG4gICAgICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcclxuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XHJcbiAgICAgKi9cclxuICAgIGdldDogZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxyXG4gICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgJ2FkZCcsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xyXG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XHJcbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xyXG4gICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKSwgMSk7XHJcblxyXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYmluZCBldmVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBvbjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcclxuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcclxuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XHJcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgICAqL1xyXG4gICAgZW1pdDogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XHJcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGEudHlwZSA9IGV2ZW50O1xyXG4gICAgICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcclxuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcclxuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxyXG4gKi9cclxuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSldID0gYWRkID8gdmFsdWUgOiAnJztcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogdHJpZ2dlciBkb20gZXZlbnRcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcclxuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xyXG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xyXG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xyXG59XHJcblxyXG5leHRlbmQoSGFtbWVyLCB7XHJcbiAgICBJTlBVVF9TVEFSVDogSU5QVVRfU1RBUlQsXHJcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxyXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXHJcbiAgICBJTlBVVF9DQU5DRUw6IElOUFVUX0NBTkNFTCxcclxuXHJcbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXHJcbiAgICBTVEFURV9CRUdBTjogU1RBVEVfQkVHQU4sXHJcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxyXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxyXG4gICAgU1RBVEVfUkVDT0dOSVpFRDogU1RBVEVfUkVDT0dOSVpFRCxcclxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxyXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXHJcblxyXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxyXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxyXG4gICAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXHJcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcclxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcclxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcclxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxyXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcclxuXHJcbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxyXG4gICAgSW5wdXQ6IElucHV0LFxyXG4gICAgVG91Y2hBY3Rpb246IFRvdWNoQWN0aW9uLFxyXG5cclxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXHJcbiAgICBNb3VzZUlucHV0OiBNb3VzZUlucHV0LFxyXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxyXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXHJcbiAgICBTaW5nbGVUb3VjaElucHV0OiBTaW5nbGVUb3VjaElucHV0LFxyXG5cclxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXHJcbiAgICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXHJcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXHJcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXHJcbiAgICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxyXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcclxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcclxuICAgIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXHJcblxyXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxyXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVycyxcclxuICAgIGVhY2g6IGVhY2gsXHJcbiAgICBtZXJnZTogbWVyZ2UsXHJcbiAgICBleHRlbmQ6IGV4dGVuZCxcclxuICAgIGluaGVyaXQ6IGluaGVyaXQsXHJcbiAgICBiaW5kRm46IGJpbmRGbixcclxuICAgIHByZWZpeGVkOiBwcmVmaXhlZFxyXG59KTtcclxuXHJcbmlmICh0eXBlb2YgZGVmaW5lID09IFRZUEVfRlVOQ1RJT04gJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBIYW1tZXI7XHJcbiAgICB9KTtcclxufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcclxufSBlbHNlIHtcclxuICAgIHdpbmRvd1tleHBvcnROYW1lXSA9IEhhbW1lcjtcclxufVxyXG5cclxufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIE1pbmltYWxpc3RpYyBldmVudCBlbWl0dGVyIG1peGluLlxuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC4gSWYgdGhlIGxpc3RlbmVyIGhhc1xuICogYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCwgdGhpcyBpcyBhIG5vLW9wLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICB2YXIgZXZlbnRNYXAgPSB0aGlzLl9fZXZlbnRzID0gdGhpcy5fX2V2ZW50cyB8fCB7fTtcbiAgdmFyIGhhbmRsZXJMaXN0ID0gZXZlbnRNYXBbbmFtZV0gPSBldmVudE1hcFtuYW1lXSB8fCBbXTtcbiAgaWYgKGhhbmRsZXJMaXN0LmluZGV4T2YoZm4pIDwgMCkge1xuICAgIGhhbmRsZXJMaXN0LnB1c2goZm4pO1xuICB9XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIHNwZWNpZmllZCBldmVudC4gSWYgdGhlIGxpc3RlbmVyXG4gKiBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnQsIHRoaXMgaXMgYSBuby1vcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgdmFyIGV2ZW50TWFwID0gdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG4gIHZhciBoYW5kbGVyTGlzdCA9IGV2ZW50TWFwW25hbWVdO1xuICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSBoYW5kbGVyTGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaGFuZGxlckxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRW1pdHMgYW4gZXZlbnQsIGNhdXNpbmcgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGF0IGV2ZW50IHRvIGJlXG4gKiBjYWxsZWQgaW4gcmVnaXN0cmF0aW9uIG9yZGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBcmd1bWVudHMgdG8gY2FsbCBsaXN0ZW5lcnMgd2l0aC5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24obmFtZSwgdmFyX2FyZ3MpIHtcbiAgdmFyIGV2ZW50TWFwID0gdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG4gIHZhciBoYW5kbGVyTGlzdCA9IGV2ZW50TWFwW25hbWVdO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIGlmIChoYW5kbGVyTGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IGhhbmRsZXJMaXN0W2ldO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peGVzIGluIHtAbGluayBFdmVudEVtaXR0ZXJ9IGludG8gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZXZlbnRFbWl0dGVyKGN0b3IpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgaWYgKEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGN0b3IucHJvdG90eXBlW3Byb3BdID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtwcm9wXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIERlcHRobWFwU3RvcmVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIERlcHRobWFwU3RvcmUgbWFpbnRhaW5zIGEgY2FjaGUgb2YgZGVwdGhtYXAgZGF0YSB1c2VkIHRvIHJlbmRlciBhIHtAbGluayBMYXllcn0uXG4gKlxuICogTXVsdGlwbGUgbGF5ZXJzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSB1bmRlcmx5aW5nIHtAbGluayBXZWJHbFN0YWdlfSBtYXlcbiAqIHNoYXJlIHRoZSBzYW1lIERlcHRobWFwU3RvcmUuIExheWVycyBiZWxvbmdpbmcgdG8gZGlzdGluY3Qge0BsaW5rIFdlYkdsU3RhZ2V9XG4gKiBpbnN0YW5jZXMgbWF5IG5vdCBkbyBzbyBkdWUgdG8gcmVzdHJpY3Rpb25zIG9uIHRoZSB1c2Ugb2YgdGV4dHVyZXMgYWNyb3NzXG4gKiBzdGFnZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgdW5kZXJseWluZyBzb3VyY2UgdXJsLlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zLlxuICovXG5mdW5jdGlvbiBEZXB0aG1hcFN0b3JlKHNvdXJjZSwgc3RhZ2UsIG9wdHMpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgc2VsZi5fc291cmNlID0gc291cmNlO1xuICBzZWxmLl9zdGFnZSA9IHN0YWdlO1xuXG4gIHNlbGYuX2Fzc2V0ID0gbnVsbDtcbiAgc2VsZi5fdGV4dHVyZSA9IG51bGw7XG5cbiAgLy8gVE9ETyBPdGhlciB0eXBlcyBvZiBkZXB0aG1hcC5cbiAgc3RhZ2UubG9hZEltYWdlKHNvdXJjZSwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYXNzZXQpIHtcbiAgICBcbiAgICAvLyBUT0RPIGVycm9yLlxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGFnZS5jcmVhdGVUZXh0dXJlKG51bGwsIGFzc2V0LCBmdW5jdGlvbiAoZXJyLCBfdGlsZSwgYXNzZXQsIHRleHR1cmUpIHtcblxuICAgICAgLy8gVE9ETyBlcnJvci5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9hc3NldCA9IGFzc2V0O1xuICAgICAgc2VsZi5fdGV4dHVyZSA9IHRleHR1cmU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5ldmVudEVtaXR0ZXIoRGVwdGhtYXBTdG9yZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5EZXB0aG1hcFN0b3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBhc3NldCA9IHRoaXMuX2Fzc2V0O1xuICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG5cbiAgLy8gRGVzdHJveSBhc3NldC5cbiAgaWYgKGFzc2V0KSB7XG4gICAgYXNzZXQuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gRGVzdHJveSB0ZXh0dXJlLlxuICBpZiAodGV4dHVyZSkge1xuICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICB9XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgdW5kZXJseWluZyB7QGxpbmsgU3RhZ2V9LlxuICogQHJldHVybiB7U3RhZ2V9XG4gKi9cbkRlcHRobWFwU3RvcmUucHJvdG90eXBlLnN0YWdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc3RhZ2U7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRGVwdGhtYXBTdG9yZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVwdGhtYXAgdGV4dHVyZSB7QGxpbmsgU291cmNlfS5cbiAqIEByZXR1cm4ge1dUZXh0dXJlfVxuICovXG5EZXB0aG1hcFN0b3JlLnByb3RvdHlwZS5hc3NldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Fzc2V0O1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVwdGhtYXAgdGV4dHVyZSB7QGxpbmsgV2ViR2xUZXh0dXJlfS5cbiAqIEByZXR1cm4ge1dlYkdsVGV4dHVyZX1cbiAqL1xuRGVwdGhtYXBTdG9yZS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGVwdGhtYXBTdG9yZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIHBvc2l0aW9uQWJzb2x1dGVseSA9IHJlcXVpcmUoJy4vdXRpbC9wb3NpdGlvbkFic29sdXRlbHknKTtcbnZhciBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0VHJhbnNmb3JtO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgSG90c3BvdFxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgSG90c3BvdCBhbGxvd3MgYSBET00gZWxlbWVudCB0byBiZSBwbGFjZWQgYXQgYSBmaXhlZCBwb3NpdGlvbiBpbiB0aGVcbiAqIGltYWdlLiBUaGUgcG9zaXRpb24gaXMgdXBkYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHtAbGluayBWaWV3IHZpZXd9XG4gKiBjaGFuZ2VzLlxuICpcbiAqIFBvc2l0aW9uaW5nIGlzIHBlcmZvcm1lZCB3aXRoIHRoZSBgdHJhbnNmb3JtYCBDU1MgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGBwb3NpdGlvbmAsIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcyB3aGVuIG5vdC5cbiAqIEluIGJvdGggY2FzZXMsIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQgaXMgcGxhY2VkIGluIHRoZSByZXF1ZXN0ZWRcbiAqIHBvc2l0aW9uOyBjbGllbnRzIGFyZSBleHBlY3RlZCB0byB1c2UgYWRkaXRpb25hbCBjaGlsZHJlbiBlbGVtZW50cyBvciBvdGhlclxuICogQ1NTIHByb3BlcnRpZXMgdG8gYWNoaWV2ZSBtb3JlIHNvcGhpc3RpY2F0ZWQgbGF5b3V0cy5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGtpbmRzIG9mIGhvdHNwb3RzOiByZWd1bGFyIGFuZCBlbWJlZGRlZC4gQSByZWd1bGFyIGhvdHNwb3RcbiAqIGRvZXMgbm90IGNoYW5nZSBzaXplIGRlcGVuZGluZyBvbiB0aGUgem9vbSBsZXZlbC4gQW4gZW1iZWRkZWQgaG90c3BvdCBpc1xuICogZGlzcGxheWVkIGF0IGEgZml4ZWQgc2l6ZSByZWxhdGl2ZSB0byB0aGUgcGFub3JhbWEsIGFsd2F5cyBjb3ZlcmluZyB0aGVcbiAqIHNhbWUgcG9ydGlvbiBvZiB0aGUgaW1hZ2UuXG4gKlxuICogQ2xpZW50cyBzaG91bGQgY2FsbCB7QGxpbmsgSG90c3BvdENvbnRhaW5lciNjcmVhdGVIb3RzcG90fSBpbnN0ZWFkIG9mXG4gKiBpbnZva2luZyB0aGUgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50IFRoZSBET00gZWxlbWVudC5cbiAqIEBwYXJhbSB7Vmlld30gdmlldyBUaGUgdmlldy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgVGhlIGhvdHNwb3QgY29vcmRpbmF0ZXMuXG4gKiAgICAgVXNlIHtAbGluayBSZWN0aWxpbmVhclZpZXdDb29yZHN9IGZvciBhIHtAbGluayBSZWN0aWxpbmVhclZpZXd9IG9yXG4gKiAgICAge0BsaW5rIEZsYXRWaWV3Q29vcmRzfSBmb3IgYSB7QGxpbmsgRmxhdFZpZXd9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgQWRkaXRpb25hbCBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMucGVyc3BlY3RpdmUgUGVyc3BlY3RpdmUgb3B0aW9ucyBmb3IgZW1iZWRkZWQgaG90c3BvdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGVyc3BlY3RpdmUucmFkaXVzPW51bGxdIElmIHNldCwgZW1iZWQgdGhlIGhvdHNwb3RcbiAqICAgICBpbnRvIHRoZSBpbWFnZSBieSB0cmFuc2Zvcm1pbmcgaXQgaW50byB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZSB3aXRoIHRoaXNcbiAqICAgICByYWRpdXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zPW51bGxdIElmIHNldCwgYXBwZW5kIHRoaXNcbiAqICAgICB2YWx1ZSB0byB0aGUgQ1NTIGB0cmFuc2Zvcm1gIHByb3BlcnR5IHVzZWQgdG8gcG9zaXRpb24gdGhlIGhvdHNwb3QuIFRoaXNcbiAqICAgICBtYXkgYmUgdXNlZCB0byByb3RhdGUgYW4gZW1iZWRkZWQgaG90c3BvdC5cbiAqL1xuZnVuY3Rpb24gSG90c3BvdChkb21FbGVtZW50LCBwYXJlbnREb21FbGVtZW50LCB2aWV3LCBjb29yZHMsIG9wdHMpIHtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy5wZXJzcGVjdGl2ZSA9IG9wdHMucGVyc3BlY3RpdmUgfHwge307XG4gIG9wdHMucGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zID1cbiAgICAgIG9wdHMucGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zICE9IG51bGwgPyBvcHRzLnBlcnNwZWN0aXZlLmV4dHJhVHJhbnNmb3JtcyA6IFwiXCI7XG5cbiAgdGhpcy5fZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQgPSBwYXJlbnREb21FbGVtZW50O1xuICB0aGlzLl92aWV3ID0gdmlldztcbiAgdGhpcy5fY29vcmRzID0ge307XG4gIHRoaXMuX3BlcnNwZWN0aXZlID0ge307XG5cbiAgdGhpcy5zZXRQb3NpdGlvbihjb29yZHMpO1xuXG4gIC8vIEFkZCBob3RzcG90IGludG8gdGhlIERPTS5cbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9kb21FbGVtZW50KTtcblxuICB0aGlzLnNldFBlcnNwZWN0aXZlKG9wdHMucGVyc3BlY3RpdmUpO1xuXG4gIC8vIFdoZXRoZXIgdGhlIGhvdHNwb3QgaXMgdmlzaWJsZS5cbiAgLy8gVGhlIGhvdHNwb3QgbWF5IHN0aWxsIGJlIGhpZGRlbiBpZiBpdCdzIGluc2lkZSBhIGhpZGRlbiBIb3RzcG90Q29udGFpbmVyLlxuICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcblxuICAvLyBUaGUgY3VycmVudCBjYWxjdWxhdGVkIHNjcmVlbiBwb3NpdGlvbi5cbiAgdGhpcy5fcG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbn1cblxuZXZlbnRFbWl0dGVyKEhvdHNwb3QpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqIENsaWVudHMgc2hvdWxkIGNhbGwge0BsaW5rIEhvdHNwb3RDb250YWluZXIjZGVzdHJveUhvdHNwb3R9IGluc3RlYWQuXG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9kb21FbGVtZW50KTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRzO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHNcbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgZm9yICh2YXIga2V5IGluIGNvb3Jkcykge1xuICAgIHRoaXMuX2Nvb3Jkc1trZXldID0gY29vcmRzW2tleV07XG4gIH1cbiAgdGhpcy5fdXBkYXRlKCk7XG4gIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBlbWl0IGEgaG90c3BvdHNDaGFuZ2UgZXZlbnQgb24gdGhlIHBhcmVudFxuICAvLyBIb3RzcG90Q29udGFpbmVyLiBXaGF0J3MgdGhlIGJlc3Qgd2F5IHRvIGRvIHNvP1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSG90c3BvdC5wcm90b3R5cGUucGVyc3BlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BlcnNwZWN0aXZlO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5zZXRQZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKHBlcnNwZWN0aXZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBwZXJzcGVjdGl2ZSkge1xuICAgIHRoaXMuX3BlcnNwZWN0aXZlW2tleV0gPSBwZXJzcGVjdGl2ZVtrZXldO1xuICB9XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG4vKipcbiAqIFNob3cgdGhlIGhvdHNwb3RcbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEhpZGUgdGhlIGhvdHNwb3RcbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG5Ib3RzcG90LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbGVtZW50ID0gdGhpcy5fZG9tRWxlbWVudDtcblxuICB2YXIgcGFyYW1zID0gdGhpcy5fY29vcmRzO1xuICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcbiAgdmFyIHgsIHk7XG5cbiAgdmFyIGlzVmlzaWJsZSA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuXG4gICAgaWYgKHRoaXMuX3BlcnNwZWN0aXZlLnJhZGl1cykge1xuICAgICAgLy8gSG90c3BvdHMgdGhhdCBhcmUgZW1iZWRkZWQgaW4gdGhlIHBhbm9yYW1hIG1heSBiZSB2aXNpYmxlIGV2ZW4gd2hlblxuICAgICAgLy8gcG9zaXRpb25lZCBiZWhpbmQgdGhlIGNhbWVyYS5cbiAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLl9zZXRFbWJlZGRlZFBvc2l0aW9uKHZpZXcsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXIgaG90c3BvdHMgYXJlIG9ubHkgdmlzaWJsZSB3aGVuIHBvc2l0aW9uZWQgaW4gZnJvbnQgb2YgdGhlXG4gICAgICAvLyBjYW1lcmEuIE5vdGUgdGhhdCB0aGV5IG1heSBiZSBwYXJ0aWFsbHkgdmlzaWJsZSB3aGVuIHBvc2l0aW9uZWQgb3V0c2lkZVxuICAgICAgLy8gdGhlIHZpZXdwb3J0LlxuICAgICAgdmlldy5jb29yZGluYXRlc1RvU2NyZWVuKHBhcmFtcywgcG9zaXRpb24pO1xuICAgICAgeCA9IHBvc2l0aW9uLng7XG4gICAgICB5ID0gcG9zaXRpb24ueTtcblxuICAgICAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2hvdyBpZiB2aXNpYmxlLCBoaWRlIGlmIG5vdC5cbiAgaWYgKGlzVmlzaWJsZSkge1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIH1cbiAgZWxzZSB7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgfVxuXG59O1xuXG5cbkhvdHNwb3QucHJvdG90eXBlLl9zZXRFbWJlZGRlZFBvc2l0aW9uID0gZnVuY3Rpb24odmlldywgcGFyYW1zKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSB2aWV3LmNvb3JkaW5hdGVzVG9QZXJzcGVjdGl2ZVRyYW5zZm9ybShcbiAgICAgIHBhcmFtcywgdGhpcy5fcGVyc3BlY3RpdmUucmFkaXVzLCB0aGlzLl9wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMpO1xuICBzZXRUcmFuc2Zvcm0odGhpcy5fZG9tRWxlbWVudCwgdHJhbnNmb3JtKTtcbn07XG5cblxuSG90c3BvdC5wcm90b3R5cGUuX3NldFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICBwb3NpdGlvbkFic29sdXRlbHkodGhpcy5fZG9tRWxlbWVudCwgeCwgeSwgdGhpcy5fcGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIb3RzcG90O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgSG90c3BvdCA9IHJlcXVpcmUoJy4vSG90c3BvdCcpO1xudmFyIGNhbGNSZWN0ID0gcmVxdWlyZSgnLi91dGlsL2NhbGNSZWN0Jyk7XG52YXIgcG9zaXRpb25BYnNvbHV0ZWx5ID0gcmVxdWlyZSgnLi91dGlsL3Bvc2l0aW9uQWJzb2x1dGVseScpO1xudmFyIHNldEFic29sdXRlID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEFic29sdXRlO1xudmFyIHNldE92ZXJmbG93SGlkZGVuID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldE92ZXJmbG93SGlkZGVuO1xudmFyIHNldE92ZXJmbG93VmlzaWJsZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRPdmVyZmxvd1Zpc2libGU7XG52YXIgc2V0TnVsbFNpemUgPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0TnVsbFNpemU7XG52YXIgc2V0UGl4ZWxTaXplID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldFBpeGVsU2l6ZTtcbnZhciBzZXRQb2ludGVyRXZlbnRzID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldFdpdGhWZW5kb3JQcmVmaXgoJ3BvaW50ZXItZXZlbnRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIGhvdHNwb3QgaGFzIGJlZW4gY3JlYXRlZCBvciBkZXN0cm95ZWQgb24gdGhlIGNvbnRhaW5lci5cbiAqIEBldmVudCBIb3RzcG90Q29udGFpbmVyI2hvdHNwb3RzQ2hhbmdlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgSG90c3BvdENvbnRhaW5lclxuICogQGNsYXNzZGVzY1xuICpcbiAqIENyZWF0ZXMgYSBET00gZWxlbWVudCB0byBob2xkIHtAbGluayBIb3RzcG90IGhvdHNwb3RzfSBhbmQgdXBkYXRlcyB0aGVpclxuICogcG9zaXRpb24gd2hlbiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnREb21FbGVtZW50IFRoZSBET00gZWxlbWVudCBpbnNpZGUgd2hpY2ggdGhlIGNvbnRhaW5lclxuICogICAgIHNob3VsZCBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBob3RzcG90cyBhcmUgcG9zaXRpb25lZC5cbiAqIEBwYXJhbSB7UmVuZGVyTG9vcH0gcmVuZGVyTG9vcCBUaGUgcmVuZGVyIGxvb3AgaW5kaWNhdGluZyB3aGVuIHRoZSBob3RzcG90c1xuICogICAgIG11c3QgYmUgcmVuZGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtSZWN0U3BlY30gb3B0cy5yZWN0IFJlY3Rhbmd1bGFyIHJlZ2lvbiBjb3ZlcmVkIGJ5IHRoZSBjb250YWluZXIuIFNlZVxuICogICAge0BsaW5rIEVmZmVjdHMjcmVjdH0uXG4gKi9cbmZ1bmN0aW9uIEhvdHNwb3RDb250YWluZXIocGFyZW50RG9tRWxlbWVudCwgc3RhZ2UsIHZpZXcsIHJlbmRlckxvb3AsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudCA9IHBhcmVudERvbUVsZW1lbnQ7XG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG4gIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICB0aGlzLl9yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcblxuICAvLyBIb3RzcG90IGxpc3QuXG4gIHRoaXMuX2hvdHNwb3RzID0gW107XG5cbiAgLy8gV2hldGhlciB0aGUgaG90c3BvdCBjb250YWluZXIgc2hvdWxkIGJlIHZpc2libGUuXG4gIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXG4gIC8vIFRoZSBjdXJyZW50IHJlY3QuXG4gIHRoaXMuX3JlY3QgPSBvcHRzLnJlY3Q7XG5cbiAgLy8gV2hldGhlciB0aGUgdmlzaWJpbGl0eSBvciB0aGUgcmVjdCBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgRE9NIHVwZGF0ZS5cbiAgdGhpcy5fdmlzaWJpbGl0eU9yUmVjdENoYW5nZWQgPSB0cnVlO1xuXG4gIC8vIFRoZSBsYXN0IHNlZW4gc3RhZ2UgZGltZW5zaW9ucy5cbiAgdGhpcy5fc3RhZ2VXaWR0aCA9IG51bGw7XG4gIHRoaXMuX3N0YWdlSGVpZ2h0ID0gbnVsbDtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgdG8gaG9sZCB0aGUgY2FsY3VsYXRlZCBwb3NpdGlvbiBhbmQgc2l6ZS5cbiAgdGhpcy5fdG1wUmVjdCA9IHt9O1xuXG4gIC8vIFdyYXBwZXIgZWxlbWVudC4gV2hlbiB0aGUgcmVjdCBlZmZlY3QgaXMgc2V0LCB0aGUgd3JhcHBlciB3aWxsIGhhdmUgbm9uemVyb1xuICAvLyBkaW1lbnNpb25zIGFuZCBgcG9pbnRlci1ldmVudHM6IG5vbmVgIHNvIHRoYXQgaG90c3BvdHMgb3V0c2lkZSB0aGUgcmVjdCBhcmVcbiAgLy8gaGlkZGVuLCBidXQgbm8gbW91c2UgZXZlbnRzIGFyZSBoaWphY2tlZC5cbiAgdGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2V0QWJzb2x1dGUodGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXIpO1xuICBzZXRQb2ludGVyRXZlbnRzKHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyLCAnbm9uZScpO1xuICB0aGlzLl9wYXJlbnREb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyKTtcblxuICAvLyBIb3RzcG90IGNvbnRhaW5lciBlbGVtZW50LiBJdCBoYXMgemVybyBkaW1lbnNpb25zIGFuZCBgcG9pbnRlci1ldmVudHM6IGFsbGBcbiAgLy8gdG8gb3ZlcnJpZGUgdGhlIGBwb2ludGVyLWV2ZW50czogbm9uZWAgb24gdGhlIHdyYXBwZXIgYW5kIGFsbG93IGhvdHNwb3RzIHRvXG4gIC8vIGJlIGludGVyYWN0ZWQgd2l0aC5cbiAgdGhpcy5faG90c3BvdENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzZXRBYnNvbHV0ZSh0aGlzLl9ob3RzcG90Q29udGFpbmVyKTtcbiAgc2V0UG9pbnRlckV2ZW50cyh0aGlzLl9ob3RzcG90Q29udGFpbmVyLCAnYWxsJyk7XG4gIHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuX2hvdHNwb3RDb250YWluZXIpO1xuXG4gIC8vIFVwZGF0ZSB3aGVuIHRoZSBob3RzcG90cyBjaGFuZ2Ugb3Igc2NlbmUgaXMgcmUtcmVuZGVyZWQuXG4gIHRoaXMuX3VwZGF0ZUhhbmRsZXIgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgdGhpcy5fcmVuZGVyTG9vcC5hZGRFdmVudExpc3RlbmVyKCdhZnRlclJlbmRlcicsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpO1xufVxuXG5ldmVudEVtaXR0ZXIoSG90c3BvdENvbnRhaW5lcik7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLl9ob3RzcG90cy5sZW5ndGgpIHtcbiAgICB0aGlzLmRlc3Ryb3lIb3RzcG90KHRoaXMuX2hvdHNwb3RzWzBdKTtcbiAgfVxuXG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXIpO1xuXG4gIHRoaXMuX3JlbmRlckxvb3AucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWZ0ZXJSZW5kZXInLCB0aGlzLl91cGRhdGVIYW5kbGVyKTtcblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faG90c3BvdENvbnRhaW5lcjtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1JlY3R9IHJlY3RcbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuc2V0UmVjdCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gIHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtSZWN0fVxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5yZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWN0O1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaG90c3BvdCBpbiB0aGlzIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnQgRE9NIGVsZW1lbnQgdG8gdXNlIGZvciB0aGUgaG90c3BvdFxuICogQHBhcmFtIHtPYmplY3R9IGNvb3JkcyBUaGUgaG90c3BvdCBjb29yZGluYXRlcy5cbiAqICAgICBVc2Uge0BsaW5rIFJlY3RpbGluZWFyVmlld0Nvb3Jkc31gIGZvciBhIHtAbGluayBSZWN0aWxpbmVhclZpZXd9IG9yXG4gKiAgICAge0BsaW5rIEZsYXRWaWV3Q29vcmRzfSBmb3IgYSB7QGxpbmsgRmxhdFZpZXd9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucyBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIGBvcHRzYCBhcmd1bWVudCB0b1xuICogICAgIHRoZSB7QGxpbmsgSG90c3BvdH0gY29uc3RydWN0b3IuXG4gKiBAcmV0dXJuIHtIb3RzcG90fVxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5jcmVhdGVIb3RzcG90ID0gZnVuY3Rpb24oZG9tRWxlbWVudCwgY29vcmRzLCBvcHRzKSB7XG4gIGNvb3JkcyA9IGNvb3JkcyB8fCB7fTtcblxuICB2YXIgaG90c3BvdCA9IG5ldyBIb3RzcG90KFxuICAgICAgZG9tRWxlbWVudCwgdGhpcy5faG90c3BvdENvbnRhaW5lciwgdGhpcy5fdmlldywgY29vcmRzLCBvcHRzKTtcbiAgdGhpcy5faG90c3BvdHMucHVzaChob3RzcG90KTtcbiAgaG90c3BvdC5fdXBkYXRlKCk7XG5cbiAgdGhpcy5lbWl0KCdob3RzcG90c0NoYW5nZScpO1xuXG4gIHJldHVybiBob3RzcG90O1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7SG90c3BvdH0gaG90c3BvdFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuaGFzSG90c3BvdCA9IGZ1bmN0aW9uKGhvdHNwb3QpIHtcbiAgcmV0dXJuIHRoaXMuX2hvdHNwb3RzLmluZGV4T2YoaG90c3BvdCkgPj0gMDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtIb3RzcG90W119XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmxpc3RIb3RzcG90cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW10uY29uY2F0KHRoaXMuX2hvdHNwb3RzKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGEgaG90c3BvdCBmcm9tIHRoZSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtIb3RzcG90fSBob3RzcG90XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmRlc3Ryb3lIb3RzcG90ID0gZnVuY3Rpb24oaG90c3BvdCkge1xuICB2YXIgaSA9IHRoaXMuX2hvdHNwb3RzLmluZGV4T2YoaG90c3BvdCk7XG4gIGlmIChpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBob3RzcG90Jyk7XG4gIH1cbiAgdGhpcy5faG90c3BvdHMuc3BsaWNlKGksIDEpO1xuXG4gIGhvdHNwb3QuZGVzdHJveSgpO1xuICB0aGlzLmVtaXQoJ2hvdHNwb3RzQ2hhbmdlJyk7XG59O1xuXG5cbi8qKlxuICogSGlkZSB0aGUgY29udGFpbmVyJ3MgRE9NIGVsZW1lbnQsIGNhdXNpbmcgZXZlcnkgY29udGFpbmVkIHtAbGluayBIb3RzcG90fSB0b1xuICogYmUgaGlkZGVuLlxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNob3cgdGhlIGNvbnRhaW5lcidzIERPTSBlbGVtZW50LCBjYXVzaW5nIGV2ZXJ5IGNvbnRhaW5lZCB7QGxpbmsgSG90c3BvdH0gdG9cbiAqIGJlIHNob3duLlxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3cmFwcGVyID0gdGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXI7XG4gIHZhciB3aWR0aCA9IHRoaXMuX3N0YWdlLndpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9zdGFnZS5oZWlnaHQoKTtcbiAgdmFyIHRtcFJlY3QgPSB0aGlzLl90bXBSZWN0O1xuXG4gIC8vIEF2b2lkIHVwZGF0aW5nIHRoZSB3cmFwcGVyIERPTSB1bmxlc3MgbmVjZXNzYXJ5LlxuICBpZiAodGhpcy5fdmlzaWJpbGl0eU9yUmVjdENoYW5nZWQgfHxcbiAgICAgICh0aGlzLl9yZWN0ICYmICh3aWR0aCAhPT0gdGhpcy5fc3RhZ2VXaWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuX3N0YWdlSGVpZ2h0KSkpIHtcbiAgICB2YXIgdmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG4gICAgd3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSc7XG5cbiAgICBpZiAodmlzaWJsZSkge1xuICAgICAgaWYgKHRoaXMuX3JlY3QpIHtcbiAgICAgICAgY2FsY1JlY3Qod2lkdGgsIGhlaWdodCwgdGhpcy5fcmVjdCwgdG1wUmVjdCk7XG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGVseSh3cmFwcGVyLCB3aWR0aCAqIHRtcFJlY3QueCwgaGVpZ2h0ICogdG1wUmVjdC55KTtcbiAgICAgICAgc2V0UGl4ZWxTaXplKHdyYXBwZXIsIHdpZHRoICogdG1wUmVjdC53aWR0aCwgaGVpZ2h0ICogdG1wUmVjdC5oZWlnaHQpO1xuICAgICAgICBzZXRPdmVyZmxvd0hpZGRlbih3cmFwcGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGVseSh3cmFwcGVyLCAwLCAwKTtcbiAgICAgICAgc2V0TnVsbFNpemUod3JhcHBlcik7XG4gICAgICAgIHNldE92ZXJmbG93VmlzaWJsZSh3cmFwcGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdGFnZVdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fc3RhZ2VIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fdmlzaWJpbGl0eU9yUmVjdENoYW5nZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBob3RzcG90cyB1bmNvbmRpdGlvbmFsbHksIGFzIHRoZSB2aWV3IHBhcmFtZXRlcnMgbWF5IGhhdmUgY2hhbmdlZC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob3RzcG90cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2hvdHNwb3RzW2ldLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvdHNwb3RDb250YWluZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbC9leHRlbmQnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBsYXllciBoYXMgYmVlbiByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWJsZSBXaGV0aGVyIGFsbCB0aWxlcyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB3aXRob3V0XG4gKiAgICAgbWlzc2luZyB0ZXh0dXJlcyBvciByZXNvcnRpbmcgdG8gZmFsbGJhY2tzLlxuICogQGV2ZW50IExheWVyI3JlbmRlckNvbXBsZXRlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIExheWVyIGlzIGEgY29tYmluYXRpb24gb2Yge0BsaW5rIFNvdXJjZX0sIHtAbGluayBHZW9tZXRyeX0sIHtAbGluayBWaWV3fVxuICogYW5kIHtAbGluayBUZXh0dXJlU3RvcmV9IHRoYXQgbWF5IGJlIGFkZGVkIGludG8gYSB7QGxpbmsgU3RhZ2V9IGFuZCByZW5kZXJlZFxuICogd2l0aCB7QGxpbmsgRWZmZWN0c30uXG4gKlxuICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXB0aG1hcFxuICogQHBhcmFtIHtWaWV3fSB2aWV3XG4gKiBAcGFyYW0ge1RleHR1cmVTdG9yZX0gdGV4dHVyZVN0b3JlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtFZmZlY3RzfSBvcHRzLmVmZmVjdHNcbiovXG5mdW5jdGlvbiBMYXllcihzb3VyY2UsIGdlb21ldHJ5LCBkZXB0aG1hcCwgdmlldywgdGV4dHVyZVN0b3JlLCBkZXB0aG1hcFN0b3JlLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gIHRoaXMuX2RlcHRobWFwID0gZGVwdGhtYXA7XG4gIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICB0aGlzLl90ZXh0dXJlU3RvcmUgPSB0ZXh0dXJlU3RvcmU7XG4gIHRoaXMuX2RlcHRobWFwU3RvcmUgPSBkZXB0aG1hcFN0b3JlO1xuXG4gIHRoaXMuX2VmZmVjdHMgPSBvcHRzLmVmZmVjdHMgfHwge307XG5cbiAgdGhpcy5fZml4ZWRMZXZlbEluZGV4ID0gbnVsbDtcblxuICB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3ZpZXdDaGFuZ2UnLCBzZWxmLnZpZXcoKSk7XG4gIH07XG5cbiAgdGhpcy5fdmlldy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG5cbiAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3RleHR1cmVTdG9yZUNoYW5nZScsIHNlbGYudGV4dHVyZVN0b3JlKCkpO1xuICB9O1xuXG4gIHRoaXMuX3RleHR1cmVTdG9yZS5hZGRFdmVudExpc3RlbmVyKCd0ZXh0dXJlTG9hZCcsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3RleHR1cmVTdG9yZS5hZGRFdmVudExpc3RlbmVyKCd0ZXh0dXJlRXJyb3InLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZUludmFsaWQnLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xufVxuXG5ldmVudEVtaXR0ZXIoTGF5ZXIpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuTGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZUxvYWQnLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZUVycm9yJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RleHR1cmVJbnZhbGlkJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFNvdXJjZSBzb3VyY2V9LlxuICogQHJldHVybiB7U291cmNlfVxuICovXG5MYXllci5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGRlcHRobWFwLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTGF5ZXIucHJvdG90eXBlLmRlcHRobWFwID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGVwdGhtYXA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgR2VvbWV0cnkgZ2VvbWV0cnl9LlxuICogQHJldHVybiB7R2VvbWV0cnl9XG4gKi9cbkxheWVyLnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFZpZXcgdmlld30uXG4gKiBAcmV0dXJuIHtWaWV3fVxuICovXG5MYXllci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZpZXc7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgVGV4dHVyZVN0b3JlIHRleHR1cmUgc3RvcmV9LlxuICogQHJldHVybiB7VGV4dHVyZVN0b3JlfVxuICovXG5MYXllci5wcm90b3R5cGUudGV4dHVyZVN0b3JlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdGV4dHVyZVN0b3JlO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIERlcHRobWFwU3RvcmUgZGF0ZSBzdG9yZX0uXG4gKiBAcmV0dXJuIHtEZXB0aG1hcFN0b3JlfVxuICovXG5MYXllci5wcm90b3R5cGUuZGVwdGhtYXBTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RlcHRobWFwU3RvcmU7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IHNldCB7QGxpbmsgRWZmZWN0cyBlZmZlY3RzfS5cbiAqIEByZXR1cm4ge0VmZmVjdHN9XG4gKi9cbkxheWVyLnByb3RvdHlwZS5lZmZlY3RzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZWZmZWN0cztcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSB7QGxpbmsgRWZmZWN0cyBlZmZlY3RzfS5cbiAqIEBwYXJhbSB7RWZmZWN0c30gZWZmZWN0c1xuICovXG5MYXllci5wcm90b3R5cGUuc2V0RWZmZWN0cyA9IGZ1bmN0aW9uIChlZmZlY3RzKSB7XG4gIHRoaXMuX2VmZmVjdHMgPSBlZmZlY3RzO1xuICB0aGlzLmVtaXQoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lZmZlY3RzKTtcbn07XG5cblxuLyoqXG4gKiBNZXJnZXMgZWZmZWN0cyBpbnRvIHRoZSBjdXJyZW50bHkgc2V0IG9uZXMuIFRoZSBtZXJnZSBpcyBub24tcmVjdXJzaXZlOyBmb3JcbiAqIGluc3RhbmNlLCBpZiBjdXJyZW50IGVmZmVjdHMgYXJlIGB7IHJlY3Q6IHsgcmVsYXRpdmVXaWR0aDogMC41IH0gfWAsXG4gKiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggYHsgcmVjdDogeyByZWxhdGl2ZVg6IDAuNSB9fWAgd2lsbCByZXNldFxuICogYHJlY3QucmVsYXRpdmVXaWR0aGAuXG4gKlxuICogQHBhcmFtIHtFZmZlY3RzfSBlZmZlY3RzXG4gKi9cbkxheWVyLnByb3RvdHlwZS5tZXJnZUVmZmVjdHMgPSBmdW5jdGlvbiAoZWZmZWN0cykge1xuICBleHRlbmQodGhpcy5fZWZmZWN0cywgZWZmZWN0cyk7XG4gIHRoaXMuZW1pdCgnZWZmZWN0c0NoYW5nZScsIHRoaXMuX2VmZmVjdHMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpeGVkIGxldmVsIGluZGV4LlxuICogQHJldHVybiB7KG51bWJlcnxudWxsKX1cbiAqL1xuTGF5ZXIucHJvdG90eXBlLmZpeGVkTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9maXhlZExldmVsSW5kZXg7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgZml4ZWQgbGV2ZWwgaW5kZXguIFdoZW4gc2V0LCB0aGUgY29ycmVzcG9uZGluZyBsZXZlbCB3aWxsIGJlXG4gKiB1c2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zZXQgd2l0aCBhIG51bGwgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHsobnVtYmVyfG51bGwpfSBsZXZlbEluZGV4XG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBsZXZlbCBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gKi9cbkxheWVyLnByb3RvdHlwZS5zZXRGaXhlZExldmVsID0gZnVuY3Rpb24gKGxldmVsSW5kZXgpIHtcbiAgaWYgKGxldmVsSW5kZXggIT09IHRoaXMuX2ZpeGVkTGV2ZWxJbmRleCkge1xuICAgIGlmIChsZXZlbEluZGV4ICE9IG51bGwgJiYgKGxldmVsSW5kZXggPj0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0Lmxlbmd0aCB8fFxuICAgICAgbGV2ZWxJbmRleCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZXZlbCBpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgbGV2ZWxJbmRleCk7XG4gICAgfVxuICAgIHRoaXMuX2ZpeGVkTGV2ZWxJbmRleCA9IGxldmVsSW5kZXg7XG4gICAgdGhpcy5lbWl0KCdmaXhlZExldmVsQ2hhbmdlJywgdGhpcy5fZml4ZWRMZXZlbEluZGV4KTtcbiAgfVxufTtcblxuXG5MYXllci5wcm90b3R5cGUuX3NlbGVjdExldmVsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV2ZWw7XG4gIGlmICh0aGlzLl9maXhlZExldmVsSW5kZXggIT0gbnVsbCkge1xuICAgIGxldmVsID0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0W3RoaXMuX2ZpeGVkTGV2ZWxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgbGV2ZWwgPSB0aGlzLl92aWV3LnNlbGVjdExldmVsKHRoaXMuX2dlb21ldHJ5LnNlbGVjdGFibGVMZXZlbExpc3QpO1xuICB9XG4gIHJldHVybiBsZXZlbDtcbn07XG5cblxuTGF5ZXIucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgdmFyIGxldmVsID0gdGhpcy5fc2VsZWN0TGV2ZWwoKTtcbiAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5LnZpc2libGVUaWxlcyh0aGlzLl92aWV3LCBsZXZlbCwgcmVzdWx0KTtcbn07XG5cblxuLyoqXG4gKiBQaW4gYSB3aG9sZSBsZXZlbCBpbnRvIHRoZSB0ZXh0dXJlIHN0b3JlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXhcbiAqL1xuTGF5ZXIucHJvdG90eXBlLnBpbkxldmVsID0gZnVuY3Rpb24gKGxldmVsSW5kZXgpIHtcbiAgdmFyIGxldmVsID0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0W2xldmVsSW5kZXhdO1xuICB2YXIgdGlsZXMgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbFRpbGVzKGxldmVsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX3RleHR1cmVTdG9yZS5waW4odGlsZXNbaV0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogVW5waW4gYSB3aG9sZSBsZXZlbCBmcm9tIHRoZSB0ZXh0dXJlIHN0b3JlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXhcbiAqL1xuTGF5ZXIucHJvdG90eXBlLnVucGluTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWxJbmRleCkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3RbbGV2ZWxJbmRleF07XG4gIHZhciB0aWxlcyA9IHRoaXMuX2dlb21ldHJ5LmxldmVsVGlsZXMobGV2ZWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlLnVucGluKHRpbGVzW2ldKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBpbiB0aGUgZmlyc3QgbGV2ZWwuIEVxdWl2YWxlbnQgdG8gYHBpbkxldmVsKDApYC5cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnBpbkZpcnN0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBpbkxldmVsKDApO1xufTtcblxuXG4vKipcbiAqIFVucGluIHRoZSBmaXJzdCBsZXZlbC4gRXF1aXZhbGVudCB0byBgdW5waW5MZXZlbCgwKWAuXG4gKi9cbkxheWVyLnByb3RvdHlwZS51bnBpbkZpcnN0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnVucGluTGV2ZWwoMCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGF5ZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbC9pbmhlcml0cycpO1xuXG4vKipcbiAqIEBjbGFzcyBOZXR3b3JrRXJyb3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTaWduYWxzIGFuIGVycm9yIHRoYXQgb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgYSBVUkwuIFRoaXMgaXMgdXNlZCBieVxuICoge0BsaW5rIExvYWRlciBsb2FkZXJzfSB0byBkaXN0aW5ndWlzaCBuZXR3b3JrIGZhaWx1cmVzIGZyb20gb3RoZXIgZXJyb3JzLlxuICovXG5mdW5jdGlvbiBOZXR3b3JrRXJyb3IobWVzc2FnZSkge1xuICAvLyBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzODIxMDcvd2hhdHMtYS1nb29kLXdheS10by1leHRlbmQtZXJyb3ItaW4tamF2YXNjcmlwdFxuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5pbmhlcml0cyhOZXR3b3JrRXJyb3IsIEVycm9yKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZXR3b3JrRXJyb3I7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHtAbGluayBTdGFnZSNyZW5kZXJ9IGlzIGFib3V0IHRvIGJlIGNhbGxlZC5cbiAqIEBldmVudCBSZW5kZXJMb29wI2JlZm9yZVJlbmRlclxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHtAbGluayBTdGFnZSNyZW5kZXJ9IGhhcyBqdXN0IGJlZW4gY2FsbGVkLlxuICogQGV2ZW50IFJlbmRlckxvb3AjYWZ0ZXJSZW5kZXJcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBSZW5kZXJMb29wXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBSZW5kZXJMb29wIHdyYXBzIGEge0BsaW5rIFN0YWdlfSBhbmQgY2FsbHMge0BsaW5rIFN0YWdlI3JlbmRlcn0gb24gdGhlIG5leHRcbiAqIGZyYW1lIHdoZW5ldmVyIGl0IGZpcmVzIHtAbGluayBTdGFnZSNyZW5kZXJJbnZhbGlkfS4gSXQgbWF5IGJlIHN0YXJ0ZWQgYW5kXG4gKiBzdG9wcGVkLCBhbmQgaXMgaW5pdGlhbGx5IGluIHRoZSBzdG9wcGVkIHN0YXRlLCBpbiB3aGljaCBubyBjYWxsIHRvXG4gKiB7QGxpbmsgU3RhZ2UjcmVuZGVyfSBvY2N1cnMuXG4gKlxuICogQGxpc3RlbnMgU3RhZ2UjcmVuZGVySW52YWxpZFxuICpcbiAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG4gKi9cbmZ1bmN0aW9uIFJlbmRlckxvb3Aoc3RhZ2UpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gVGhlIHN0YWdlIHdyYXBwZWQgYnkgdGhlIGxvb3AuXG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG5cbiAgLy8gV2hldGhlciB0aGUgbG9vcCBpcyBydW5uaW5nLlxuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgLy8gV2hldGhlciB0aGUgbG9vcCBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICB0aGlzLl9yZW5kZXJpbmcgPSBmYWxzZTtcblxuICAvLyBUaGUgY3VycmVudCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaGFuZGxlLlxuICB0aGlzLl9yZXF1ZXN0SGFuZGxlID0gbnVsbDtcblxuICAvLyBUaGUgY2FsbGJhY2sgcGFzc2VkIGludG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuICB0aGlzLl9ib3VuZExvb3AgPSB0aGlzLl9sb29wLmJpbmQodGhpcyk7XG5cbiAgLy8gSGFuZGxlciBmb3IgcmVuZGVySW52YWxpZCBldmVudHMgZW1pdHRlZCBieSB0aGUgc3RhZ2UuXG4gIHRoaXMuX3JlbmRlckludmFsaWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgcmVuZGVyaW5nLCB0aGVyZSdzIG5vIG5lZWQgdG8gc2NoZWR1bGUgYSBuZXcgcmVuZGVyXG4gICAgLy8gb24gdGhlIG5leHQgZnJhbWUuXG4gICAgaWYgKCFzZWxmLl9yZW5kZXJpbmcpIHtcbiAgICAgIHNlbGYucmVuZGVyT25OZXh0RnJhbWUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlIHJlbmRlckludmFsaWQgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlIHN0YWdlLlxuICB0aGlzLl9zdGFnZS5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXJJbnZhbGlkJywgdGhpcy5fcmVuZGVySW52YWxpZEhhbmRsZXIpO1xuXG59XG5cbmV2ZW50RW1pdHRlcihSZW5kZXJMb29wKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdG9wKCk7XG4gIHRoaXMuX3N0YWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbmRlckludmFsaWQnLCB0aGlzLl9yZW5kZXJJbnZhbGlkSGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHN0YWdlLlxuICogQHJldHVybiB7U3RhZ2V9XG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLnN0YWdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zdGFnZTtcbn07XG5cblxuLyoqXG4gKiBTdGFydHMgdGhlIHJlbmRlciBsb29wLlxuICovXG5SZW5kZXJMb29wLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgdGhpcy5yZW5kZXJPbk5leHRGcmFtZSgpO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSByZW5kZXIgbG9vcC5cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZSkge1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXF1ZXN0SGFuZGxlKTtcbiAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlID0gbnVsbDtcbiAgfVxuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogRm9yY2VzIHRoZSBzdGFnZSB0byByZW5kZXIgb24gdGhlIG5leHQgZnJhbWUsIGV2ZW4gaWYgaXRzIGNvbnRlbnRzIHJlbWFpblxuICogdmFsaWQuIERvZXMgbm90aGluZyBpZiB0aGUgbG9vcCBpcyBzdG9wcGVkLlxuICovXG5SZW5kZXJMb29wLnByb3RvdHlwZS5yZW5kZXJPbk5leHRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcnVubmluZyAmJiAhdGhpcy5fcmVxdWVzdEhhbmRsZSkge1xuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kTG9vcCk7XG4gIH1cbn07XG5cblxuUmVuZGVyTG9vcC5wcm90b3R5cGUuX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXIgbG9vcCBydW5uaW5nIHdoaWxlIGluIHN0b3BwZWQgc3RhdGUnKTtcbiAgfVxuICB0aGlzLl9yZXF1ZXN0SGFuZGxlID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyaW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdiZWZvcmVSZW5kZXInKTtcbiAgdGhpcy5fcmVuZGVyaW5nID0gZmFsc2U7XG4gIHRoaXMuX3N0YWdlLnJlbmRlcigpO1xuICB0aGlzLmVtaXQoJ2FmdGVyUmVuZGVyJyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyTG9vcDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xudmFyIFRleHR1cmVTdG9yZSA9IHJlcXVpcmUoJy4vVGV4dHVyZVN0b3JlJyk7XG52YXIgRGVwdGhtYXBTdG9yZSA9IHJlcXVpcmUoJy4vRGVwdGhtYXBTdG9yZScpO1xudmFyIEhvdHNwb3RDb250YWluZXIgPSByZXF1aXJlKCcuL0hvdHNwb3RDb250YWluZXInKTtcbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBub3cgPSByZXF1aXJlKCcuL3V0aWwvbm93Jyk7XG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vdXRpbC9ub29wJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vdXRpbC90eXBlJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBzY2VuZSdzIHZpZXcgaGFzIGNoYW5nZWQuIFNlZSB7QGxpbmsgVmlldyNldmVudDpjaGFuZ2V9LlxuICogQGV2ZW50IFNjZW5lI3ZpZXdDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgc2NlbmUncyBsYXllcnMgaGF2ZSBjaGFuZ2VkLlxuICogQGV2ZW50IFNjZW5lI2xheWVyQ2hhbmdlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgU2NlbmVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFNjZW5lIGlzIGEgc3RhY2sgb2Yge0BsaW5rIExheWVyIGxheWVyc30gc2hhcmluZyB0aGUgc2FtZSB7QGxpbmsgVmlldyB2aWV3fVxuICogYW5kIHtAbGluayBIb3RzcG90Q29udGFpbmVyIGhvdHNwb3QgY29udGFpbmVyfS4gSXQgYmVsb25ncyB0byB0aGVcbiAqIHtAbGluayBWaWV3ZXIgdmlld2VyfSBpbnNpZGUgd2hpY2ggaXQgaXMgZGlzcGxheWVkLlxuICpcbiAqIENsaWVudHMgc2hvdWxkIGNhbGwge0BsaW5rIFZpZXdlciNjcmVhdGVTY2VuZX0gaW5zdGVhZCBvZiBpbnZva2luZyB0aGVcbiAqIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7Vmlld2VyfSB2aWV3ZXIgVGhlIHZpZXdlciB0aGlzIHNjZW5lIGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHNjZW5lJ3MgdW5kZXJseWluZyB2aWV3LlxuICovXG5mdW5jdGlvbiBTY2VuZSh2aWV3ZXIsIHZpZXcpIHtcbiAgdGhpcy5fdmlld2VyID0gdmlld2VyO1xuICB0aGlzLl92aWV3ID0gdmlldztcbiAgdGhpcy5fbGF5ZXJzID0gW107XG5cbiAgLy8gSG90c3BvdCBjb250YWluZXIuIEFzc3VtZSBpdCBvY2N1cGllcyBhIGZ1bGwgcmVjdC5cbiAgdGhpcy5faG90c3BvdENvbnRhaW5lciA9IG5ldyBIb3RzcG90Q29udGFpbmVyKFxuICAgIHZpZXdlci5fY29udHJvbENvbnRhaW5lcixcbiAgICB2aWV3ZXIuc3RhZ2UoKSxcbiAgICB0aGlzLl92aWV3LFxuICAgIHZpZXdlci5yZW5kZXJMb29wKCkpO1xuXG4gIC8vIFRoZSBjdXJyZW50IG1vdmVtZW50LlxuICB0aGlzLl9tb3ZlbWVudCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RhcnRUaW1lID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRTdGVwID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRQYXJhbXMgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudENhbGxiYWNrID0gbnVsbDtcblxuICAvLyBFdmVudCBsaXN0ZW5lciBmb3IgdXBkYXRpbmcgdGhlIHZpZXcgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICAvLyBUaGUgbGlzdGVuZXIgaXMgc2V0L3Vuc2V0IG9uIHRoZSByZW5kZXIgbG9vcCB3aGVuIGEgbW92ZW1lbnQgc3RhcnRzL3N0b3BzLlxuICB0aGlzLl91cGRhdGVNb3ZlbWVudEhhbmRsZXIgPSB0aGlzLl91cGRhdGVNb3ZlbWVudC5iaW5kKHRoaXMpO1xuXG4gIC8vIFNob3cgb3IgaGlkZSBob3RzcG90cyB3aGVuIHNjZW5lIGNoYW5nZXMuXG4gIHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXJIYW5kbGVyID0gdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lci5iaW5kKHRoaXMpO1xuICB0aGlzLl92aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcignc2NlbmVDaGFuZ2UnLCB0aGlzLl91cGRhdGVIb3RzcG90Q29udGFpbmVySGFuZGxlcik7XG5cbiAgLy8gRW1pdCBldmVudCB3aGVuIHZpZXcgY2hhbmdlcy5cbiAgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndmlld0NoYW5nZScpO1xuICB0aGlzLl92aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcblxuICAvLyBVcGRhdGUgdGhlIGhvdHNwb3QgY29udGFpbmVyLlxuICB0aGlzLl91cGRhdGVIb3RzcG90Q29udGFpbmVyKCk7XG59XG5cbmV2ZW50RW1pdHRlcihTY2VuZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLiBDbGllbnRzIHNob3VsZCBjYWxsIHtAbGluayBWaWV3ZXIjZGVzdHJveVNjZW5lfSBpbnN0ZWFkLlxuICovXG5TY2VuZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3ZpZXdlci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY2VuZUNoYW5nZScsIHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXJIYW5kbGVyKTtcblxuICBpZiAodGhpcy5fbW92ZW1lbnQpIHtcbiAgICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB9XG5cbiAgdGhpcy5faG90c3BvdENvbnRhaW5lci5kZXN0cm95KCk7XG5cbiAgdGhpcy5kZXN0cm95QWxsTGF5ZXJzKCk7XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUge0BsaW5rIEhvdHNwb3RDb250YWluZXIgaG90c3BvdCBjb250YWluZXJ9IGZvciB0aGUgc2NlbmUuXG4gKiBAcmV0dXJuIHtMYXllcn1cbiAqL1xuU2NlbmUucHJvdG90eXBlLmhvdHNwb3RDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9ob3RzcG90Q29udGFpbmVyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBvZiB0aGUge0BsaW5rIExheWVyIGxheWVyc30gYmVsb25naW5nIHRvIHRoZSBzY2VuZSwgb3JcbiAqIG51bGwgaWYgdGhlIHNjZW5lIGhhcyBubyBsYXllcnMuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgU2NlbmUjbGlzdExheWVyc1swXWAuIEl0IG1heSBiZSByZW1vdmVkIGluIHRoZVxuICogZnV0dXJlLlxuICpcbiAqIEByZXR1cm4ge0xheWVyfVxuICovXG5TY2VuZS5wcm90b3R5cGUubGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG59O1xuXG4vKipcbiogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHtAbGluayBMYXllciBsYXllcnN9IGJlbG9uZ2luZyB0byB0aGUgc2NlbmUuIFRoZVxuKiByZXR1cm5lZCBsaXN0IGlzIGluIGRpc3BsYXkgb3JkZXIsIGJhY2tncm91bmQgdG8gZm9yZWdyb3VuZC5cbiogQHJldHVybiB7TGF5ZXJbXX1cbiAqL1xuU2NlbmUucHJvdG90eXBlLmxpc3RMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXS5jb25jYXQodGhpcy5fbGF5ZXJzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2VuZSdzIHVuZGVybHlpbmcge0BsaW5rIFZpZXcgdmlld30uXG4gKiBAcmV0dXJuIHtWaWV3fVxuICovXG5TY2VuZS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZpZXc7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUge0BsaW5rIFZpZXdlciB2aWV3ZXJ9IHRoZSBzY2VuZSBiZWxvbmdzIHRvLlxuICogQHJldHVybiB7Vmlld2VyfVxuICovXG5TY2VuZS5wcm90b3R5cGUudmlld2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdmlld2VyO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgc2NlbmUgaXMgY3VycmVudGx5IHZpc2libGUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5TY2VuZS5wcm90b3R5cGUudmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZpZXdlci5zY2VuZSgpID09PSB0aGlzO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIExheWVyIGxheWVyfSBhbmQgYWRkcyBpdCBpbnRvIHRoZSBzY2VuZSBpbiB0aGVcbiAqIGZvcmVncm91bmQgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgTGF5ZXIgY3JlYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7U291cmNlfSBvcHRzLnNvdXJjZSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2V9LlxuICogQHBhcmFtIHtHZW9tZXRyeX0gb3B0cy5nZW9tZXRyeSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBHZW9tZXRyeX0uXG4gKiBAcGFyYW0ge1NvdXJjZX0gb3B0cy5kZXB0aG1hcCBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIGRlcHRobWFwIHtAbGluayBTb3VyY2V9LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5waW5GaXJzdExldmVsPWZhbHNlXSBXaGV0aGVyIHRvIHBpbiB0aGUgZmlyc3QgbGV2ZWwgdG9cbiAqICAgICBwcm92aWRlIGEgZmFsbGJhY2sgb2YgbGFzdCByZXNvcnQsIGF0IHRoZSBjb3N0IG9mIG1lbW9yeSBjb25zdW1wdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy50ZXh0dXJlU3RvcmVPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlXG4gKiAgICAge0BsaW5rIFRleHR1cmVTdG9yZX0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubGF5ZXJPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIHtAbGluayBMYXllcn1cbiAqICAgICBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm4ge0xheWVyfVxuICovXG5TY2VuZS5wcm90b3R5cGUuY3JlYXRlTGF5ZXIgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgdGV4dHVyZVN0b3JlT3B0cyA9IG9wdHMudGV4dHVyZVN0b3JlT3B0cyB8fCB7fTtcbiAgdmFyIGRlcHRobWFwU3RvcmVPcHRzID0gb3B0cy5kZXB0aG1hcFN0b3JlT3B0cyB8fCB7fTtcbiAgdmFyIGxheWVyT3B0cyA9IG9wdHMubGF5ZXJPcHRzIHx8IHt9O1xuXG4gIHZhciBzb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgdmFyIGdlb21ldHJ5ID0gb3B0cy5nZW9tZXRyeTtcbiAgdmFyIGRlcHRobWFwID0gb3B0cy5kZXB0aG1hcDtcbiAgdmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuICB2YXIgc3RhZ2UgPSB0aGlzLl92aWV3ZXIuc3RhZ2UoKTtcbiAgdmFyIHRleHR1cmVTdG9yZSA9IG5ldyBUZXh0dXJlU3RvcmUoc291cmNlLCBzdGFnZSwgdGV4dHVyZVN0b3JlT3B0cyk7XG4gIHZhciBkZXB0aG1hcFN0b3JlID0gZGVwdGhtYXAgJiYgbmV3IERlcHRobWFwU3RvcmUoZGVwdGhtYXAsIHN0YWdlLCBkZXB0aG1hcFN0b3JlT3B0cyk7XG5cbiAgdmFyIGxheWVyID0gbmV3IExheWVyKHNvdXJjZSwgZ2VvbWV0cnksIGRlcHRobWFwLCB2aWV3LCB0ZXh0dXJlU3RvcmUsIGRlcHRobWFwU3RvcmUsIGxheWVyT3B0cyk7XG5cbiAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xuXG4gIGlmIChvcHRzLnBpbkZpcnN0TGV2ZWwpIHtcbiAgICBsYXllci5waW5GaXJzdExldmVsKCk7XG4gIH1cblxuICAvLyBTaWduYWwgdGhhdCB0aGUgbGF5ZXJzIGhhdmUgY2hhbmdlZC5cbiAgdGhpcy5lbWl0KCdsYXllckNoYW5nZScpO1xuXG4gIHJldHVybiBsYXllcjtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyBhIHtAbGluayBMYXllciBsYXllcn0gYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgc2NlbmUuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllclxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzY2VuZS5cbiAqL1xuU2NlbmUucHJvdG90eXBlLmRlc3Ryb3lMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICB2YXIgaSA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGxheWVyIGluIHNjZW5lJyk7XG4gIH1cblxuICB0aGlzLl9sYXllcnMuc3BsaWNlKGksIDEpO1xuXG4gIC8vIFNpZ25hbCB0aGF0IHRoZSBsYXllcnMgaGF2ZSBjaGFuZ2VkLlxuICB0aGlzLmVtaXQoJ2xheWVyQ2hhbmdlJyk7XG5cbiAgbGF5ZXIudGV4dHVyZVN0b3JlKCkuZGVzdHJveSgpO1xuICBsYXllci5kZXN0cm95KCk7XG59O1xuXG5cbi8qKlxuICogRGVzdHJveXMgYWxsIHtAbGluayBMYXllciBsYXllcnN9IGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgc2NlbmUuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5kZXN0cm95QWxsTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5fbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmRlc3Ryb3lMYXllcih0aGlzLl9sYXllcnNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogU3dpdGNoZXMgdG8gdGhlIHNjZW5lLlxuICpcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9IG9uIHRoaXMgc2NlbmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucyB0byBwYXNzIGludG8ge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc3dpdGNoIGlzIGNvbXBsZXRlLlxuICovXG5TY2VuZS5wcm90b3R5cGUuc3dpdGNoVG8gPSBmdW5jdGlvbiAob3B0cywgZG9uZSkge1xuICByZXR1cm4gdGhpcy5fdmlld2VyLnN3aXRjaFNjZW5lKHRoaXMsIG9wdHMsIGRvbmUpO1xufTtcblxuXG4vKipcbiAqIFR3ZWVucyB0aGUgc2NlbmUncyB1bmRlcmx5aW5nIHtAbGluayBWaWV3IHZpZXd9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGFyZ2V0IHZpZXcgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRyYW5zaXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRzLmVhc2U9ZWFzZUluT3V0UXVhZF0gVHdlZW4gZWFzaW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuY29udHJvbHNJbnRlcnJ1cHQ9ZmFsc2VdIGFsbG93IGNvbnRyb2xzIHRvIGludGVycnVwdFxuICogICAgIGFuIG9uZ29pbmcgdHdlZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudHJhbnNpdGlvbkR1cmF0aW9uPTEwMDBdIFR3ZWVuIGR1cmF0aW9uLCBpblxuICogICAgIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5jbG9zZXN0PXRydWVdIFdoZXRoZXIgdG8gdHdlZW4gdGhyb3VnaCB0aGUgc2hvcnRlc3RcbiAqICAgIHBhdGggYmV0d2VlbiB0aGUgaW5pdGlhbCBhbmQgZmluYWwgdmlldyBwYXJhbWV0ZXJzLiBUaGlzIHJlcXVpcmVzXG4gKiAgICB7QGxpbmsgVmlldyNub3JtYWxpemVUb0Nsb3Nlc3R9IHRvIGJlIGltcGxlbWVudGVkLCBhbmQgZG9lcyBub3RoaW5nXG4gKiAgICBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdHdlZW4gZmluaXNoZXMgb3IgaXNcbiAqICAgIGludGVycnVwdGVkLlxuICovXG5TY2VuZS5wcm90b3R5cGUubG9va1RvID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0cywgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGRvbmUgPSBkb25lIHx8IG5vb3A7XG5cbiAgaWYgKHR5cGUocGFyYW1zKSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgdmlldyBwYXJhbWV0ZXJzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG5cbiAgLy8gUXVhZHJhdGljIGluL291dCBlYXNpbmcuXG4gIHZhciBlYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfTtcblxuICB2YXIgZWFzZSA9IG9wdHMuZWFzZSAhPSBudWxsID8gb3B0cy5lYXNlIDogZWFzZUluT3V0UXVhZDtcbiAgdmFyIGNvbnRyb2xzSW50ZXJydXB0ID0gb3B0cy5jb250cm9sc0ludGVycnVwdCAhPSBudWxsID8gb3B0cy5jb250cm9sc0ludGVycnVwdCA6IGZhbHNlO1xuICB2YXIgZHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiAhPSBudWxsID8gb3B0cy50cmFuc2l0aW9uRHVyYXRpb24gOiAxMDAwO1xuICB2YXIgc2hvcnRlc3QgPSBvcHRzLnNob3J0ZXN0ICE9IG51bGwgPyBvcHRzLnNob3J0ZXN0IDogdHJ1ZTtcblxuICB2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG5cbiAgdmFyIGluaXRpYWxQYXJhbXMgPSB2aWV3LnBhcmFtZXRlcnMoKTtcblxuICB2YXIgZmluYWxQYXJhbXMgPSB7fTtcbiAgZGVmYXVsdHMoZmluYWxQYXJhbXMsIHBhcmFtcyk7XG4gIGRlZmF1bHRzKGZpbmFsUGFyYW1zLCBpbml0aWFsUGFyYW1zKTtcblxuICAvLyBUd2VlbiB0aHJvdWdoIHRoZSBzaG9ydGVzdCBwYXRoIGlmIHJlcXVlc3RlZC5cbiAgLy8gVGhlIHZpZXcgbXVzdCBpbXBsZW1lbnQgdGhlIG5vcm1hbGl6ZVRvQ2xvc2VzdCgpIG1ldGhvZC5cbiAgaWYgKHNob3J0ZXN0ICYmIHZpZXcubm9ybWFsaXplVG9DbG9zZXN0KSB7XG4gICAgdmlldy5ub3JtYWxpemVUb0Nsb3Nlc3QoZmluYWxQYXJhbXMsIGZpbmFsUGFyYW1zKTtcbiAgfVxuXG4gIHZhciBtb3ZlbWVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBmaW5hbFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbXMsIGVsYXBzZWQpIHtcblxuICAgICAgaWYgKGVsYXBzZWQgPj0gZHVyYXRpb24gJiYgZmluYWxVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IE1hdGgubWluKGVsYXBzZWQgLyBkdXJhdGlvbiwgMSk7XG5cbiAgICAgIGZvciAodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbml0aWFsUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgdmFyIGVuZCA9IGZpbmFsUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgcGFyYW1zW3BhcmFtXSA9IHN0YXJ0ICsgZWFzZShkZWx0YSkgKiAoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBmaW5hbFVwZGF0ZSA9IGVsYXBzZWQgPj0gZHVyYXRpb247XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG5cbiAgICB9O1xuICB9O1xuXG4gIHZhciByZWVuYWJsZUNvbnRyb2xzID0gdGhpcy5fdmlld2VyLmNvbnRyb2xzKCkuZW5hYmxlZCgpO1xuXG4gIGlmICghY29udHJvbHNJbnRlcnJ1cHQpIHtcbiAgICB0aGlzLl92aWV3ZXIuY29udHJvbHMoKS5kaXNhYmxlKCk7XG4gIH1cblxuICB0aGlzLnN0YXJ0TW92ZW1lbnQobW92ZW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVlbmFibGVDb250cm9scykge1xuICAgICAgc2VsZi5fdmlld2VyLmNvbnRyb2xzKCkuZW5hYmxlKCk7XG4gICAgfVxuICAgIGRvbmUoKTtcbiAgfSk7XG5cbn07XG5cblxuLyoqXG4gKiBTdGFydHMgYSBtb3ZlbWVudCwgcG9zc2libHkgcmVwbGFjaW5nIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBtb3ZlbWVudCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdmVtZW50IGZpbmlzaGVzIG9yIGlzXG4gKiAgICAgaW50ZXJydXB0ZWQuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5zdGFydE1vdmVtZW50ID0gZnVuY3Rpb24gKGZuLCBkb25lKSB7XG5cbiAgdmFyIHJlbmRlckxvb3AgPSB0aGlzLl92aWV3ZXIucmVuZGVyTG9vcCgpO1xuXG4gIGlmICh0aGlzLl9tb3ZlbWVudCkge1xuICAgIHRoaXMuc3RvcE1vdmVtZW50KCk7XG4gIH1cblxuICB2YXIgc3RlcCA9IGZuKCk7XG4gIGlmICh0eXBlb2Ygc3RlcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIG1vdmVtZW50Jyk7XG4gIH1cblxuICB0aGlzLl9tb3ZlbWVudCA9IGZuO1xuICB0aGlzLl9tb3ZlbWVudFN0ZXAgPSBzdGVwO1xuICB0aGlzLl9tb3ZlbWVudFN0YXJ0VGltZSA9IG5vdygpO1xuICB0aGlzLl9tb3ZlbWVudFBhcmFtcyA9IHt9O1xuICB0aGlzLl9tb3ZlbWVudENhbGxiYWNrID0gZG9uZTtcblxuICByZW5kZXJMb29wLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZVJlbmRlcicsIHRoaXMuX3VwZGF0ZU1vdmVtZW50SGFuZGxlcik7XG4gIHJlbmRlckxvb3AucmVuZGVyT25OZXh0RnJhbWUoKTtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAqL1xuU2NlbmUucHJvdG90eXBlLnN0b3BNb3ZlbWVudCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZG9uZSA9IHRoaXMuX21vdmVtZW50Q2FsbGJhY2s7XG4gIHZhciByZW5kZXJMb29wID0gdGhpcy5fdmlld2VyLnJlbmRlckxvb3AoKTtcblxuICBpZiAoIXRoaXMuX21vdmVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2xlYXIgc3RhdGUgYmVmb3JlIGNhbGxpbmcgZG9uZSwgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIHdoZW4gdGhlXG4gIC8vIGNhbGxiYWNrIHN0YXJ0cyBhIG5ldyBtb3ZlbWVudC5cbiAgdGhpcy5fbW92ZW1lbnQgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudFN0ZXAgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudFN0YXJ0VGltZSA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50UGFyYW1zID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRDYWxsYmFjayA9IG51bGw7XG5cbiAgcmVuZGVyTG9vcC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVSZW5kZXInLCB0aGlzLl91cGRhdGVNb3ZlbWVudEhhbmRsZXIpO1xuXG4gIGlmIChkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5TY2VuZS5wcm90b3R5cGUubW92ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9tb3ZlbWVudDtcbn07XG5cblxuU2NlbmUucHJvdG90eXBlLl91cGRhdGVNb3ZlbWVudCA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIXRoaXMuX21vdmVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGNhbGwgdXBkYXRlJyk7XG4gIH1cblxuICB2YXIgcmVuZGVyTG9vcCA9IHRoaXMuX3ZpZXdlci5yZW5kZXJMb29wKCk7XG4gIHZhciB2aWV3ID0gdGhpcy5fdmlldztcblxuICB2YXIgZWxhcHNlZCA9IG5vdygpIC0gdGhpcy5fbW92ZW1lbnRTdGFydFRpbWU7XG4gIHZhciBzdGVwID0gdGhpcy5fbW92ZW1lbnRTdGVwO1xuICB2YXIgcGFyYW1zID0gdGhpcy5fbW92ZW1lbnRQYXJhbXM7XG5cbiAgcGFyYW1zID0gdmlldy5wYXJhbWV0ZXJzKHBhcmFtcyk7XG4gIHBhcmFtcyA9IHN0ZXAocGFyYW1zLCBlbGFwc2VkKTtcbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgdGhpcy5zdG9wTW92ZW1lbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICByZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lKCk7XG4gIH1cblxufTtcblxuXG5TY2VuZS5wcm90b3R5cGUuX3VwZGF0ZUhvdHNwb3RDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnZpc2libGUoKSkge1xuICAgIHRoaXMuX2hvdHNwb3RDb250YWluZXIuc2hvdygpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2hvdHNwb3RDb250YWluZXIuaGlkZSgpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NlbmU7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNYXAgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25zL01hcCcpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbnMvU2V0Jyk7XG52YXIgTHJ1U2V0ID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9McnVTZXQnKTtcbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vdXRpbC9kZWZhdWx0cycpO1xudmFyIHJldHJ5ID0gcmVxdWlyZSgnLi91dGlsL3JldHJ5Jyk7XG52YXIgY2hhaW4gPSByZXF1aXJlKCcuL3V0aWwvY2hhaW4nKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4vdXRpbC9pbmhlcml0cycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIGRlYnVnID0gdHlwZW9mIE1BUlpJUEFOT0RFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBNQVJaSVBBTk9ERUJVRy50ZXh0dXJlU3RvcmU7XG5cblxuLy8gQSBTdGFnZSBpbmZvcm1zIHRoZSBUZXh0dXJlU3RvcmUgYWJvdXQgdGhlIHNldCBvZiB2aXNpYmxlIHRpbGVzIGR1cmluZyBhXG4vLyBmcmFtZSBieSBjYWxsaW5nIHN0YXJ0RnJhbWUsIG1hcmtUaWxlIGFuZCBlbmRGcmFtZS4gSW4gYSBwYXJ0aWN1bGFyIGZyYW1lLFxuLy8gVGV4dHVyZVN0b3JlIGV4cGVjdHMgb25lIG9yIG1vcmUgY2FsbHMgdG8gc3RhcnRGcmFtZSwgZm9sbG93ZWQgYnkgemVybyBvclxuLy8gbW9yZSBjYWxscyB0byBtYXJrVGlsZSwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgY2FsbHMgdG8gZW5kRnJhbWUuIFRoZVxuLy8gbnVtYmVyIG9mIGNhbGxzIHRvIHN0YXJ0RnJhbWUgYW5kIGVuZEZyYW1lIG11c3QgbWF0Y2guIENhbGxzIHRvIG90aGVyXG4vLyBUZXh0dXJlU3RvcmUgbWV0aG9kcyBtYXkgYmUgZnJlZWx5IGludGVybGVhdmVkIHdpdGggdGhpcyBzZXF1ZW5jZS5cbi8vXG4vLyBBdCBhbnkgZ2l2ZW4gdGltZSwgVGV4dHVyZVN0b3JlIGlzIGluIG9uZSBvZiBmb3VyIHN0YXRlcy4gVGhlIFNUQVJUIHN0YXRlXG4vLyBjb3JyZXNwb25kcyB0byB0aGUgaW50ZXJ2YWwgYmV0d2VlbiB0aGUgZmlyc3Qgc3RhcnRGcmFtZSBhbmQgdGhlIGZpcnN0XG4vLyBtYXJrVGlsZSBvZiBhIGZyYW1lLiBUaGUgTUFSSyBzdGF0ZSBjb3JyZXNwb25kcyB0byB0aGUgaW50ZXJ2YWwgYmV0d2VlbiB0aGVcbi8vIGZpcnN0IG1hcmtUaWxlIGFuZCB0aGUgZmlyc3QgZW5kRnJhbWUuIFRoZSBFTkQgc3RhdGUgY29ycmVzcG9uZHMgdG8gdGhlXG4vLyBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgZW5kRnJhbWUuIEF0IGFueSBvdGhlciB0aW1lLCB0aGVcbi8vIFRleHR1cmVTdG9yZSBpcyBpbiB0aGUgSURMRSBzdGF0ZS5cbnZhciBTdGF0ZSA9IHtcbiAgSURMRTogMCxcbiAgU1RBUlQ6IDEsXG4gIE1BUks6IDIsXG4gIEVORDogM1xufTtcblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGNhY2hlZCB0ZXh0dXJlcyBmb3IgcHJldmlvdXNseSB2aXNpYmxlIHRpbGVzLlxuICBwcmV2aW91c2x5VmlzaWJsZUNhY2hlU2l6ZTogNTEyXG59O1xuXG5cbi8vIEFzc2lnbiBhbiBpZCB0byBlYWNoIG9wZXJhdGlvbiBzbyB3ZSBjYW4gdHJhY2sgaXRzIHN0YXRlLlxuLy8gV2UgYWN0dWFsbHkgb25seSBuZWVkIHRoaXMgaW4gZGVidWcgbW9kZSwgYnV0IHRoZSBjb2RlIGlzIGxlc3MgY29udm9sdXRlZFxuLy8gaWYgd2UgdHJhY2sgdW5jb25kaXRpb25hbGx5LCBhbmQgdGhlIHBlcmZvcm1hbmNlIGhpdCBpcyBtaW5pbWFsIGFueXdheS5cbnZhciBuZXh0SWQgPSAwO1xuXG5cbi8vIERpc3Rpbmd1aXNoZXMgYSBjYW5jZWxsYXRpb24gZnJvbSBvdGhlciBraW5kcyBvZiBlcnJvcnMuXG5mdW5jdGlvbiBDYW5jZWxFcnJvcigpIHt9XG5pbmhlcml0cyhDYW5jZWxFcnJvciwgRXJyb3IpO1xuXG5cbi8qKlxuICogQGNsYXNzIFRleHR1cmVTdG9yZUl0ZW1cbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBbiBpdGVtIHNhdmVkIGluIGEge0BsaW5rIFRleHR1cmVTdG9yZX0uXG4gKlxuICogQ2xpZW50cyBkbyBub3QgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLiBJdCBpcyBhdXRvbWF0aWNhbGx5IGluc3RhbnRpYXRlZCBieVxuICogYSB7QGxpbmsgVGV4dHVyZVN0b3JlfSB0byBtYW5hZ2UgdGhlIGxpZmV0aW1lIG9mIGEgc3RvcmVkIGl0ZW06IGxvYWRpbmcsXG4gKiByZWZyZXNoaW5nLCB1bmxvYWRpbmcgYW5kIGVtaXR0aW5nIGFzc29jaWF0ZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7VGV4dHVyZVN0b3JlfSBzdG9yZSBUaGUgdW5kZXJseWluZyB7QGxpbmsgVGV4dHVyZVN0b3JlfS5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdW5kZXJseWluZyB0aWxlLlxuICovXG5mdW5jdGlvbiBUZXh0dXJlU3RvcmVJdGVtKHN0b3JlLCB0aWxlKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBpZCA9IG5leHRJZCsrO1xuXG4gIHNlbGYuX2lkID0gaWQ7XG4gIHNlbGYuX3N0b3JlID0gc3RvcmU7XG4gIHNlbGYuX3RpbGUgPSB0aWxlO1xuXG4gIHNlbGYuX2Fzc2V0ID0gbnVsbDtcbiAgc2VsZi5fdGV4dHVyZSA9IG51bGw7XG5cbiAgc2VsZi5fY2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHN0b3JlLmVtaXQoJ3RleHR1cmVJbnZhbGlkJywgdGlsZSk7XG4gIH07XG5cbiAgdmFyIHNvdXJjZSA9IHN0b3JlLnNvdXJjZSgpO1xuICB2YXIgc3RhZ2UgPSBzdG9yZS5zdGFnZSgpO1xuXG4gIHZhciBsb2FkQXNzZXQgPSBzb3VyY2UubG9hZEFzc2V0LmJpbmQoc291cmNlKTtcbiAgdmFyIGNyZWF0ZVRleHR1cmUgPSBzdGFnZS5jcmVhdGVUZXh0dXJlLmJpbmQoc3RhZ2UpO1xuXG4gIC8vIFJldHJ5IGxvYWRpbmcgdGhlIGFzc2V0IHVudGlsIGl0IHN1Y2NlZWRzLCB0aGVuIGNyZWF0ZSB0aGUgdGV4dHVyZSBmcm9tIGl0LlxuICAvLyBUaGlzIHByb2Nlc3MgbWF5IGJlIGNhbmNlbGVkIGF0IGFueSBwb2ludCBieSBjYWxsaW5nIHRoZSBkZXN0cm95KCkgbWV0aG9kLlxuICB2YXIgZm4gPSBjaGFpbihyZXRyeShsb2FkQXNzZXQpLCBjcmVhdGVUZXh0dXJlKTtcblxuICBzdG9yZS5lbWl0KCd0ZXh0dXJlU3RhcnRMb2FkJywgdGlsZSk7XG4gIGlmIChkZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKCdsb2FkaW5nJywgaWQsIHRpbGUpO1xuICB9XG5cbiAgc2VsZi5fY2FuY2VsID0gZm4oc3RhZ2UsIHRpbGUsIGZ1bmN0aW9uKGVyciwgX3RpbGUsIGFzc2V0LCB0ZXh0dXJlKSB7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG8gbm90IGNhbGwgY2FuY2VsIGFmdGVyIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAgc2VsZi5fY2FuY2VsID0gbnVsbDtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIFRoZSBsb2FkaW5nIHByb2Nlc3Mgd2FzIGludGVycnVwdGVkIGJ5IGFuIGVycm9yLlxuICAgICAgLy8gVGhpcyBjb3VsZCBlaXRoZXIgYmUgYmVjYXVzZSB0aGUgdGV4dHVyZSBjcmVhdGlvbiBmYWlsZWQsIG9yIGJlY2F1c2VcbiAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGVkIGJlZm9yZSB0aGUgbG9hZGluZyB3YXMgY29tcGxldGUuXG5cbiAgICAgIC8vIERlc3Ryb3kgdGhlIGFzc2V0IGFuZCB0ZXh0dXJlLCBpZiB0aGV5IGV4aXN0LlxuICAgICAgaWYgKGFzc2V0KSB7XG4gICAgICAgIGFzc2V0LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbWl0IGV2ZW50cy5cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYW5jZWxFcnJvcikge1xuICAgICAgICBzdG9yZS5lbWl0KCd0ZXh0dXJlQ2FuY2VsJywgdGlsZSk7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjYW5jZWwnLCBpZCwgdGlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmVtaXQoJ3RleHR1cmVFcnJvcicsIHRpbGUsIGVycik7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcicsIGlkLCB0aWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2F2ZSBhIGxvY2FsIHJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZS5cbiAgICBzZWxmLl90ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgIC8vIElmIHRoZSBhc3NldCBpcyBkeW5hbWljLCBzYXZlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIGl0IGFuZCBzZXQgdXAgYVxuICAgIC8vIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIGl0IGNoYW5nZXMuIE90aGVyd2lzZSwgZGVzdHJveSB0aGUgYXNzZXRcbiAgICAvLyBhcyB3ZSB3b24ndCBiZSBuZWVkaW5nIGl0IGFueSBsb25nZXIuXG4gICAgaWYgKGFzc2V0LmlzRHluYW1pYygpKSB7XG4gICAgICBzZWxmLl9hc3NldCA9IGFzc2V0O1xuICAgICAgYXNzZXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgc2VsZi5fY2hhbmdlSGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBFbWl0IGV2ZW50LlxuICAgIHN0b3JlLmVtaXQoJ3RleHR1cmVMb2FkJywgdGlsZSk7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZygnbG9hZCcsIGlkLCB0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG59XG5cblxuVGV4dHVyZVN0b3JlSXRlbS5wcm90b3R5cGUuYXNzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fzc2V0O1xufTtcblxuXG5UZXh0dXJlU3RvcmVJdGVtLnByb3RvdHlwZS50ZXh0dXJlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90ZXh0dXJlO1xufTtcblxuXG5UZXh0dXJlU3RvcmVJdGVtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuICB2YXIgc3RvcmUgPSB0aGlzLl9zdG9yZTtcbiAgdmFyIHRpbGUgPSB0aGlzLl90aWxlO1xuICB2YXIgYXNzZXQgPSB0aGlzLl9hc3NldDtcbiAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICB2YXIgY2FuY2VsID0gdGhpcy5fY2FuY2VsO1xuXG4gIGlmIChjYW5jZWwpIHtcbiAgICAvLyBUaGUgdGV4dHVyZSBpcyBzdGlsbCBsb2FkaW5nLCBzbyBjYW5jZWwgaXQuXG4gICAgY2FuY2VsKG5ldyBDYW5jZWxFcnJvcignVGV4dHVyZSBsb2FkIGNhbmNlbGxlZCcpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZXN0cm95IGFzc2V0LlxuICBpZiAoYXNzZXQpIHtcbiAgICBhc3NldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9jaGFuZ2VIYW5kbGVyKTtcbiAgICBhc3NldC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBEZXN0cm95IHRleHR1cmUuXG4gIGlmICh0ZXh0dXJlKSB7XG4gICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBFbWl0IGV2ZW50LlxuICBzdG9yZS5lbWl0KCd0ZXh0dXJlVW5sb2FkJywgdGlsZSk7XG4gIGlmIChkZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKCd1bmxvYWQnLCBpZCwgdGlsZSk7XG4gIH1cblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5ldmVudEVtaXR0ZXIoVGV4dHVyZVN0b3JlSXRlbSk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgdGV4dHVyZSBoYXMgc3RhcnRlZCB0byBsb2FkLlxuICpcbiAqIFRoaXMgZXZlbnQgaXMgZm9sbG93ZWQgYnkgZWl0aGVyIHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZUxvYWR9LFxuICoge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlRXJyb3J9IG9yIHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZUNhbmNlbH0uXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlU3RhcnRMb2FkXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIGhhcyBzdGFydGVkIHRvIGxvYWQuXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSB0ZXh0dXJlIGhhcyBiZWVuIGxvYWRlZC5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVMb2FkXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIHdhcyBsb2FkZWQuXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSB0ZXh0dXJlIGhhcyBiZWVuIHVubG9hZGVkLlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZVVubG9hZFxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIGZvciB3aGljaCB0aGUgdGV4dHVyZSB3YXMgdW5sb2FkZWQuXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSB0ZXh0dXJlIGhhcyBiZWVuIGludmFsaWRhdGVkLlxuICpcbiAqIFRoaXMgZXZlbnQgbWF5IGJlIHJhaXNlZCBmb3IgYSB0ZXh0dXJlIHdpdGggYW4gdW5kZXJseWluZyBkeW5hbWljIGFzc2V0LiBJdFxuICogbWF5IG9ubHkgb2NjdXIgd2hpbGUgdGhlIHRleHR1cmUgaXMgbG9hZGVkLCBpLmUuLCBpbiBiZXR3ZWVuXG4gKiB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVMb2FkfSBhbmQge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlVW5sb2FkfS5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVJbnZhbGlkXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIHdhcyBpbnZhbGlkYXRlZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBsb2FkaW5nIGEgdGV4dHVyZSBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gKlxuICogVGhpcyBldmVudCBtYXkgZm9sbG93IHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZVN0YXJ0TG9hZH0gaWYgdGhlIHRleHR1cmVcbiAqIGJlY29tZXMgdW5uZWNlc3NhcnkgYmVmb3JlIGl0IGZpbmlzaGVzIGxvYWRpbmcuXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlQ2FuY2VsXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIGxvYWRpbmcgd2FzIGNhbmNlbGxlZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBsb2FkaW5nIGEgdGV4dHVyZSBoYXMgZmFpbGVkLlxuICpcbiAqIFRoaXMgZXZlbnQgbWF5IGZvbGxvdyB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVTdGFydExvYWR9IGlmIHRoZSB0ZXh0dXJlXG4gKiBmYWlscyB0byBsb2FkLlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZUVycm9yXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIGxvYWRpbmcgaGFzIGZhaWxlZC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBUZXh0dXJlU3RvcmVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFRleHR1cmVTdG9yZSBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZXh0dXJlcyB1c2VkIHRvIHJlbmRlciBhIHtAbGluayBMYXllcn0uXG4gKlxuICogQSB7QGxpbmsgU3RhZ2V9IGNvbW11bmljYXRlcyB3aXRoIHRoZSBUZXh0dXJlU3RvcmUgdGhyb3VnaCB0aGUgc3RhcnRGcmFtZSgpLFxuICogbWFya1RpbGUoKSBhbmQgZW5kRnJhbWUoKSBtZXRob2RzLCB3aGljaCBpbmRpY2F0ZSB0aGUgdGlsZXMgdGhhdCBhcmUgdmlzaWJsZVxuICogaW4gdGhlIGN1cnJlbnQgZnJhbWUuIFRleHR1cmVzIGZvciB2aXNpYmxlIHRpbGVzIGFyZSBsb2FkZWQgYW5kIHJldGFpbmVkXG4gKiBhcyBsb25nIGFzIHRoZSB0aWxlcyByZW1haW4gdmlzaWJsZS4gQSBsaW1pdGVkIGFtb3VudCBvZiB0ZXh0dXJlcyB3aG9zZVxuICogdGlsZXMgd2VyZSBwcmV2aW91c2x5IHZpc2libGUgYXJlIGNhY2hlZCBhY2NvcmRpbmcgdG8gYW4gTFJVIHBvbGljeS4gVGlsZXNcbiAqIG1heSBiZSBwaW5uZWQgdG8ga2VlcCB0aGVpciByZXNwZWN0aXZlIHRleHR1cmVzIGNhY2hlZCBldmVuIHdoZW4gdGhleSBhcmVcbiAqIGludmlzaWJsZTsgdGhlc2UgdGV4dHVyZXMgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHByZXZpb3VzbHkgdmlzaWJsZSBsaW1pdC5cbiAqXG4gKiBNdWx0aXBsZSBsYXllcnMgYmVsb25naW5nIHRvIHRoZSBzYW1lIHVuZGVybHlpbmcge0BsaW5rIFdlYkdsU3RhZ2V9IG1heVxuICogc2hhcmUgdGhlIHNhbWUgVGV4dHVyZVN0b3JlLiBMYXllcnMgYmVsb25naW5nIHRvIGRpc3RpbmN0IHtAbGluayBXZWJHbFN0YWdlfVxuICogaW5zdGFuY2VzIG1heSBub3QgZG8gc28gZHVlIHRvIHJlc3RyaWN0aW9ucyBvbiB0aGUgdXNlIG9mIHRleHR1cmVzIGFjcm9zc1xuICogc3RhZ2VzLlxuICpcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2UgVGhlIHVuZGVybHlpbmcgc291cmNlLlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnByZXZpb3VzbHlWaXNpYmxlQ2FjaGVTaXplPTMyXSBUaGUgbWF4aW11bSBudW1iZXIgb2ZcbiAqICAgICBwcmV2aW91c2x5IHZpc2libGUgdGV4dHVyZXMgdG8gY2FjaGUgYWNjb3JkaW5nIHRvIGFuIExSVSBwb2xpY3kuXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVTdG9yZShzb3VyY2UsIHN0YWdlLCBvcHRzKSB7XG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuXG4gIC8vIFRoZSBjdXJyZW50IHN0YXRlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLklETEU7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBzdGFydEZyYW1lIGNhbGxzIHlldCB0byBiZSBtYXRjaGVkIGJ5IGVuZEZyYW1lIGNhbGxzIGR1cmluZ1xuICAvLyB0aGUgY3VycmVudCBmcmFtZS5cbiAgdGhpcy5fZGVsaW1Db3VudCA9IDA7XG5cbiAgLy8gVGhlIGNhY2hlIHByb3BlcjogbWFwIGNhY2hlZCB0aWxlcyB0byB0aGVpciByZXNwZWN0aXZlIHRleHR1cmVzL2Fzc2V0cy5cbiAgdGhpcy5faXRlbU1hcCA9IG5ldyBNYXAoKTtcblxuICAvLyBUaGUgc3Vic2V0IG9mIGNhY2hlZCB0aWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgdmlzaWJsZS5cbiAgdGhpcy5fdmlzaWJsZSA9IG5ldyBTZXQoKTtcblxuICAvLyBUaGUgc3Vic2V0IG9mIGNhY2hlZCB0aWxlcyB0aGF0IHdlcmUgdmlzaWJsZSByZWNlbnRseSwgYnV0IGFyZSBub3RcbiAgLy8gdmlzaWJsZSByaWdodCBub3cuIE5ld2x5IGluc2VydGVkIHRpbGVzIHJlcGxhY2Ugb2xkZXIgb25lcy5cbiAgdGhpcy5fcHJldmlvdXNseVZpc2libGUgPSBuZXcgTHJ1U2V0KG9wdHMucHJldmlvdXNseVZpc2libGVDYWNoZVNpemUpO1xuXG4gIC8vIFRoZSBzdWJzZXQgb2YgY2FjaGVkIHRpbGVzIHRoYXQgc2hvdWxkIG5ldmVyIGJlIGV2aWN0ZWQgZnJvbSB0aGUgY2FjaGUuXG4gIC8vIEEgdGlsZSBtYXkgYmUgcGlubmVkIG1vcmUgdGhhbiBvbmNlOyBtYXAgZWFjaCB0aWxlIGludG8gYSByZWZlcmVuY2UgY291bnQuXG4gIHRoaXMuX3Bpbk1hcCA9IG5ldyBNYXAoKTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGVzLlxuICB0aGlzLl9uZXdWaXNpYmxlID0gbmV3IFNldCgpO1xuICB0aGlzLl9ub0xvbmdlclZpc2libGUgPSBbXTtcbiAgdGhpcy5fdmlzaWJsZUFnYWluID0gW107XG4gIHRoaXMuX2V2aWN0ZWQgPSBbXTtcbn1cblxuZXZlbnRFbWl0dGVyKFRleHR1cmVTdG9yZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTdGFnZX0uXG4gKiBAcmV0dXJuIHtTdGFnZX1cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5zdGFnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3RhZ2U7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2V9LlxuICogQHJldHVybiB7U291cmNlfVxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdGV4dHVyZXMgZnJvbSB0aGUgVGV4dHVyZVN0b3JlLCBpbmNsdWRpbmcgcGlubmVkIHRleHR1cmVzLlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBDb2xsZWN0IGxpc3Qgb2YgdGlsZXMgdG8gYmUgZXZpY3RlZC5cbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xuICBzZWxmLl9pdGVtTWFwLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHNlbGYuX2V2aWN0ZWQucHVzaCh0aWxlKTtcbiAgfSk7XG5cbiAgLy8gRXZpY3QgdGlsZXMuXG4gIHNlbGYuX2V2aWN0ZWQuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgc2VsZi5fdW5sb2FkVGlsZSh0aWxlKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgYWxsIGludGVybmFsIHN0YXRlLlxuICBzZWxmLl9pdGVtTWFwLmNsZWFyKCk7XG4gIHNlbGYuX3Zpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fcHJldmlvdXNseVZpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fcGluTWFwLmNsZWFyKCk7XG4gIHNlbGYuX25ld1Zpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmxlbmd0aCA9IDA7XG4gIHNlbGYuX3Zpc2libGVBZ2Fpbi5sZW5ndGggPSAwO1xuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0ZXh0dXJlcyBpbiB0aGUgVGV4dHVyZVN0b3JlLCBleGNsdWRpbmcgdW5waW5uZWQgdGV4dHVyZXMuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuY2xlYXJOb3RQaW5uZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIENvbGxlY3QgbGlzdCBvZiB0aWxlcyB0byBiZSBldmljdGVkLlxuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG4gIHNlbGYuX2l0ZW1NYXAuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKCFzZWxmLl9waW5NYXAuaGFzKHRpbGUpKSB7XG4gICAgICBzZWxmLl9ldmljdGVkLnB1c2godGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFdmljdCB0aWxlcy5cbiAgc2VsZi5fZXZpY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBzZWxmLl91bmxvYWRUaWxlKHRpbGUpO1xuICB9KTtcblxuICAvLyBDbGVhciBhbGwgY2FjaGVzIGV4Y2VwdCB0aGUgcGlubmVkIHNldC5cbiAgc2VsZi5fdmlzaWJsZS5jbGVhcigpO1xuICBzZWxmLl9wcmV2aW91c2x5VmlzaWJsZS5jbGVhcigpO1xuXG4gIC8vIENsZWFyIHRlbXBvcmFyeSB2YXJpYWJsZXMuXG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbn07XG5cblxuLyoqXG4gKiBTaWduYWwgdGhlIGJlZ2lubmluZyBvZiBhIGZyYW1lLiBDYWxsZWQgZnJvbSB7QGxpbmsgU3RhZ2V9LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnN0YXJ0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgaW4gYW4gYXBwcm9wcmlhdGUgc3RhdGUuXG4gIGlmICh0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuSURMRSAmJiB0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuU1RBUlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogc3RhcnRGcmFtZSBjYWxsZWQgb3V0IG9mIHNlcXVlbmNlJyk7XG4gIH1cblxuICAvLyBFbnRlciB0aGUgU1RBUlQgc3RhdGUsIGlmIG5vdCBhbHJlYWR5IHRoZXJlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUQVJUO1xuXG4gIC8vIEV4cGVjdCBvbmUgbW9yZSBlbmRGcmFtZSBjYWxsLlxuICB0aGlzLl9kZWxpbUNvdW50Kys7XG59O1xuXG5cbi8qKlxuICogTWFyayBhIHRpbGUgYXMgdmlzaWJsZSB3aXRoaW4gdGhlIGN1cnJlbnQgZnJhbWUuIENhbGxlZCBmcm9tIHtAbGluayBTdGFnZX0uXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgdG8gbWFyay5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5tYXJrVGlsZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgaW4gYW4gYXBwcm9wcmlhdGUgc3RhdGUuXG4gIGlmICh0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuU1RBUlQgJiYgdGhpcy5fc3RhdGUgIT09IFN0YXRlLk1BUkspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogbWFya1RpbGUgY2FsbGVkIG91dCBvZiBzZXF1ZW5jZScpO1xuICB9XG5cbiAgLy8gRW50ZXIgdGhlIE1BUksgc3RhdGUsIGlmIG5vdCBhbHJlYWR5IHRoZXJlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLk1BUks7XG5cbiAgLy8gUmVmcmVzaCB0ZXh0dXJlIGZvciBkeW5hbWljIGFzc2V0cy5cbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgdmFyIHRleHR1cmUgPSBpdGVtICYmIGl0ZW0udGV4dHVyZSgpO1xuICB2YXIgYXNzZXQgPSBpdGVtICYmIGl0ZW0uYXNzZXQoKTtcbiAgaWYgKHRleHR1cmUgJiYgYXNzZXQpIHtcbiAgICB0ZXh0dXJlLnJlZnJlc2godGlsZSwgYXNzZXQpO1xuICB9XG5cbiAgLy8gQWRkIHRpbGUgdG8gdGhlIHZpc2libGUgc2V0LlxuICB0aGlzLl9uZXdWaXNpYmxlLmFkZCh0aWxlKTtcbn07XG5cblxuLyoqXG4gKiBTaWduYWwgdGhlIGVuZCBvZiBhIGZyYW1lLiBDYWxsZWQgZnJvbSB7QGxpbmsgU3RhZ2V9LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgYXJlIGluIGFuIGFwcHJvcHJpYXRlIHN0YXRlLlxuICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlLlNUQVJUICYmIHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5NQVJLICYmIHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5FTkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogZW5kRnJhbWUgY2FsbGVkIG91dCBvZiBzZXF1ZW5jZScpO1xuICB9XG5cbiAgLy8gRW50ZXIgdGhlIEVORCBzdGF0ZSwgaWYgbm90IGFscmVhZHkgdGhlcmUuXG4gIHRoaXMuX3N0YXRlID0gU3RhdGUuRU5EO1xuXG4gIC8vIEV4cGVjdCBvbmUgbGVzcyBjYWxsIHRvIGVuZEZyYW1lLlxuICB0aGlzLl9kZWxpbUNvdW50LS07XG5cbiAgLy8gSWYgbm8gZnVydGhlciBjYWxscyBhcmUgZXhwZWN0ZWQsIHByb2Nlc3MgZnJhbWUgYW5kIGVudGVyIHRoZSBJRExFIHN0YXRlLlxuICBpZiAoIXRoaXMuX2RlbGltQ291bnQpIHtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBDYWxjdWxhdGUgdGhlIHNldCBvZiB0aWxlcyB0aGF0IHVzZWQgdG8gYmUgdmlzaWJsZSBidXQgbm8gbG9uZ2VyIGFyZS5cbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmxlbmd0aCA9IDA7XG4gIHNlbGYuX3Zpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKCFzZWxmLl9uZXdWaXNpYmxlLmhhcyh0aWxlKSkge1xuICAgICAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLnB1c2godGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIHNldCBvZiB0aWxlcyB0aGF0IHdlcmUgdmlzaWJsZSByZWNlbnRseSBhbmQgaGF2ZSBiZWNvbWVcbiAgLy8gdmlzaWJsZSBhZ2Fpbi5cbiAgc2VsZi5fdmlzaWJsZUFnYWluLmxlbmd0aCA9IDA7XG4gIHNlbGYuX25ld1Zpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLmhhcyh0aWxlKSkge1xuICAgICAgc2VsZi5fdmlzaWJsZUFnYWluLnB1c2godGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBSZW1vdmUgdGlsZXMgdGhhdCBoYXZlIGJlY29tZSB2aXNpYmxlIGFnYWluIGZyb20gdGhlIGxpc3Qgb2YgcHJldmlvdXNseVxuICAvLyB2aXNpYmxlIHRpbGVzLlxuICBzZWxmLl92aXNpYmxlQWdhaW4uZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgc2VsZi5fcHJldmlvdXNseVZpc2libGUucmVtb3ZlKHRpbGUpO1xuICB9KTtcblxuICAvLyBDYW5jZWwgbG9hZGluZyBvZiB0aWxlcyB0aGF0IGFyZSBubyBsb25nZXIgdmlzaWJsZS5cbiAgLy8gTW92ZSBubyBsb25nZXIgdmlzaWJsZSB0aWxlcyB3aXRoIGEgbG9hZGVkIHRleHR1cmUgaW50byB0aGUgcHJldmlvdXNseVxuICAvLyB2aXNpYmxlIHNldCwgYW5kIGNvbGxlY3QgdGhlIHRpbGVzIGV2aWN0ZWQgZnJvbSB0aGUgbGF0dGVyLlxuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG4gIHNlbGYuX25vTG9uZ2VyVmlzaWJsZS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICB2YXIgaXRlbSA9IHNlbGYuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICAgIHZhciB0ZXh0dXJlID0gaXRlbSAmJiBpdGVtLnRleHR1cmUoKTtcbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdmFyIG90aGVyVGlsZSA9IHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLmFkZCh0aWxlKTtcbiAgICAgIGlmIChvdGhlclRpbGUgIT0gbnVsbCkge1xuICAgICAgICBzZWxmLl9ldmljdGVkLnB1c2gob3RoZXJUaWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW0pIHtcbiAgICAgIHNlbGYuX3VubG9hZFRpbGUodGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBVbmxvYWQgZXZpY3RlZCB0aWxlcywgdW5sZXNzIHRoZXkgYXJlIHBpbm5lZC5cbiAgc2VsZi5fZXZpY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBpZiAoIXNlbGYuX3Bpbk1hcC5oYXModGlsZSkpIHtcbiAgICAgIHNlbGYuX3VubG9hZFRpbGUodGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBMb2FkIHZpc2libGUgdGlsZXMgdGhhdCBhcmUgbm90IGFscmVhZHkgaW4gdGhlIHN0b3JlLlxuICAvLyBSZWZyZXNoIHRleHR1cmUgb24gdmlzaWJsZSB0aWxlcyBmb3IgZHluYW1pYyBhc3NldHMuXG4gIHNlbGYuX25ld1Zpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgdmFyIGl0ZW0gPSBzZWxmLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHNlbGYuX2xvYWRUaWxlKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3dhcCB0aGUgb2xkIHZpc2libGUgc2V0IHdpdGggdGhlIG5ldyBvbmUuXG4gIHZhciB0bXAgPSBzZWxmLl92aXNpYmxlO1xuICBzZWxmLl92aXNpYmxlID0gc2VsZi5fbmV3VmlzaWJsZTtcbiAgc2VsZi5fbmV3VmlzaWJsZSA9IHRtcDtcblxuICAvLyBDbGVhciB0aGUgbmV3IHZpc2libGUgc2V0LlxuICBzZWxmLl9uZXdWaXNpYmxlLmNsZWFyKCk7XG5cbiAgLy8gQ2xlYXIgdGVtcG9yYXJ5IHZhcmlhYmxlcy5cbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmxlbmd0aCA9IDA7XG4gIHNlbGYuX3Zpc2libGVBZ2Fpbi5sZW5ndGggPSAwO1xuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuX2xvYWRUaWxlID0gZnVuY3Rpb24odGlsZSkge1xuICBpZiAodGhpcy5faXRlbU1hcC5oYXModGlsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogbG9hZGluZyB0ZXh0dXJlIGFscmVhZHkgaW4gY2FjaGUnKTtcbiAgfVxuICB2YXIgaXRlbSA9IG5ldyBUZXh0dXJlU3RvcmVJdGVtKHRoaXMsIHRpbGUpO1xuICB0aGlzLl9pdGVtTWFwLnNldCh0aWxlLCBpdGVtKTtcbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5fdW5sb2FkVGlsZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmRlbCh0aWxlKTtcbiAgaWYgKCFpdGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IHVubG9hZGluZyB0ZXh0dXJlIG5vdCBpbiBjYWNoZScpO1xuICB9XG4gIGl0ZW0uZGVzdHJveSgpO1xufTtcblxuXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICBpZiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmFzc2V0KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS50ZXh0dXJlKCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogUGluIGEgdGlsZS4gVGV4dHVyZXMgZm9yIHBpbm5lZCB0aWxlcyBhcmUgbmV2ZXIgZXZpY3RlZCBmcm9tIHRoZSBzdG9yZS5cbiAqIFVwb24gcGlubmluZywgdGhlIHRleHR1cmUgaXMgY3JlYXRlZCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LiBQaW5zIGFyZVxuICogcmVmZXJlbmNlLWNvdW50ZWQ7IGEgdGlsZSBtYXkgYmUgcGlubmVkIG11bHRpcGxlIHRpbWVzIGFuZCBtdXN0IGJlIHVucGlubmVkXG4gKiB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIgb2YgdGltZXMuIFBpbm5pbmcgaXMgdXNlZnVsIGUuZy4gdG8gZW5zdXJlIHRoYXRcbiAqIHRoZSBsb3dlc3QtcmVzb2x1dGlvbiBsZXZlbCBvZiBhbiBpbWFnZSBpcyBhbHdheXMgYXZhaWxhYmxlIHRvIGZhbGwgYmFja1xuICogb250by5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSB0aGUgdGlsZSB0byBwaW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwaW4gcmVmZXJlbmNlIGNvdW50LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnBpbiA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgLy8gSW5jcmVtZW50IHJlZmVyZW5jZSBjb3VudC5cbiAgdmFyIGNvdW50ID0gKHRoaXMuX3Bpbk1hcC5nZXQodGlsZSkgfHwgMCkgKyAxO1xuICB0aGlzLl9waW5NYXAuc2V0KHRpbGUsIGNvdW50KTtcbiAgLy8gSWYgdGhlIHRleHR1cmUgZm9yIHRoZSB0aWxlIGlzIG5vdCBwcmVzZW50LCBsb2FkIGl0IG5vdy5cbiAgaWYgKCF0aGlzLl9pdGVtTWFwLmhhcyh0aWxlKSkge1xuICAgIHRoaXMuX2xvYWRUaWxlKHRpbGUpO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cblxuLyoqXG4gKiBVbnBpbiBhIHRpbGUuIFBpbnMgYXJlIHJlZmVyZW5jZS1jb3VudGVkOyBhIHRpbGUgbWF5IGJlIHBpbm5lZCBtdWx0aXBsZVxuICogdGltZXMgYW5kIG11c3QgYmUgdW5waW5uZWQgdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyIG9mIHRpbWVzLlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIHRoZSB0aWxlIHRvIHVucGluXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcGluIHJlZmVyZW5jZSBjb3VudC5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS51bnBpbiA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGNvdW50ID0gdGhpcy5fcGluTWFwLmdldCh0aWxlKTtcbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmICghY291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogdW5waW4gd2hlbiBub3QgcGlubmVkJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudC5cbiAgICBjb3VudC0tO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgIHRoaXMuX3Bpbk1hcC5zZXQodGlsZSwgY291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9waW5NYXAuZGVsKHRpbGUpO1xuICAgICAgLy8gSWYgdGhlIHRpbGUgZG9lcyBub3QgYmVsb25nIHRvIGVpdGhlciB0aGUgdmlzaWJsZSBvciBwcmV2aW91c2x5XG4gICAgICAvLyB2aXNpYmxlIHNldHMsIGV2aWN0IGl0IGZyb20gdGhlIGNhY2hlLlxuICAgICAgaWYgKCF0aGlzLl92aXNpYmxlLmhhcyh0aWxlKSAmJiAhdGhpcy5fcHJldmlvdXNseVZpc2libGUuaGFzKHRpbGUpKSB7XG4gICAgICAgIHRoaXMuX3VubG9hZFRpbGUodGlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdHlwZSBmb3Ige0BsaW5rIFRleHR1cmVTdG9yZSNxdWVyeX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaWxlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlzaWJsZSBXaGV0aGVyIHRoZSB0aWxlIGlzIGluIHRoZSB2aXNpYmxlIHNldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJldmlvdXNseVZpc2libGUgV2hldGhlciB0aGUgdGlsZSBpcyBpbiB0aGUgcHJldmlvdXNseVxuICogICAgIHZpc2libGUgc2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNBc3NldCBXaGV0aGVyIHRoZSBhc3NldCBmb3IgdGhlIHRpbGUgaXMgcHJlc2VudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzVGV4dHVyZSBXaGV0aGVyIHRoZSB0ZXh0dXJlIGZvciB0aGUgdGlsZSBpcyBwcmVzZW50LlxuICogQHByb3BlcnR5IHtib29sZWFufSBwaW5uZWQgV2hldGhlciB0aGUgdGlsZSBpcyBpbiB0aGUgcGlubmVkIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaW5Db3VudCBUaGUgcGluIHJlZmVyZW5jZSBjb3VudCBmb3IgdGhlIHRpbGUuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgc3RhdGUgb2YgYSB0aWxlLlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIHRvIHF1ZXJ5LlxuICogQHJldHVybiB7VGlsZVN0YXRlfVxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICB2YXIgcGluQ291bnQgPSB0aGlzLl9waW5NYXAuZ2V0KHRpbGUpIHx8IDA7XG4gIHJldHVybiB7XG4gICAgdmlzaWJsZTogdGhpcy5fdmlzaWJsZS5oYXModGlsZSksXG4gICAgcHJldmlvdXNseVZpc2libGU6IHRoaXMuX3ByZXZpb3VzbHlWaXNpYmxlLmhhcyh0aWxlKSxcbiAgICBoYXNBc3NldDogaXRlbSAhPSBudWxsICYmIGl0ZW0uYXNzZXQoKSAhPSBudWxsLFxuICAgIGhhc1RleHR1cmU6IGl0ZW0gIT0gbnVsbCAmJiBpdGVtLnRleHR1cmUoKSAhPSBudWxsLFxuICAgIHBpbm5lZDogcGluQ291bnQgIT09IDAsXG4gICAgcGluQ291bnQ6IHBpbkNvdW50XG4gIH07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZVN0b3JlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2V0ID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9TZXQnKTtcblxuLyoqXG4gKiBAY2xhc3MgVGlsZVNlYXJjaGVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBUaWxlU2VhcmNoZXIgcGVyZm9ybXMgc2VhcmNoZXMgZm9yIHZpc2libGUgdGlsZXMuXG4gKi9cbmZ1bmN0aW9uIFRpbGVTZWFyY2hlcigpIHtcbiAgLy8gU3RhY2sgb2YgdGlsZXMgdG8gYmUgZXhwbG9yZWQuXG4gIHRoaXMuX3N0YWNrID0gW107XG5cbiAgLy8gU2V0IG9mIGFscmVhZHkgZXhwbG9yZWQgdGlsZXMuXG4gIHRoaXMuX3Zpc2l0ZWQgPSBuZXcgU2V0KCk7XG5cbiAgLy8gVGlsZSB2ZXJ0aWNlcy4gQWxsb2NhdGVkIGJ5IFRpbGUjdmVydGljZXMgb24gZmlyc3QgdXNlLlxuICB0aGlzLl92ZXJ0aWNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzZWFyY2ggZm9yIHZpc2libGUgdGlsZXMgYnkgc3RhcnRpbmcgYXQgYSBnaXZlbiB0aWxlIGFuZFxuICogcmVjdXJzaXZlbHkgZXhwbG9yaW5nIG5laWdoYm9ycyB1bnRpbCBubyBtb3JlIHZpc2libGUgdGlsZXMgYXJlIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB7Vmlld30gdmlldyBUaGUgdmlldyB1c2VkIHRvIGRlZW0gd2hldGhlciBhIHRpbGUgaXMgdmlzaWJsZS5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgc3RhcnRpbmcgdGlsZS5cbiAqIEBwYXJhbSB7VGlsZVtdfSByZXN1bHQgQW4gYXJyYXkgdG8gYXBwZW5kIHRoZSB2aXNpYmxlIHRpbGVzIHRvLCBpbmNsdWRpbmcgdGhlXG4gKiAgICAgc3RhcnRpbmcgdGlsZSB3aGVuIHZpc2libGUuIEV4aXN0aW5nIGFycmF5IG1lbWJlcnMgYXJlIHByZXNlcnZlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiB2aXNpYmxlIHRpbGVzIGZvdW5kLlxuICovXG5UaWxlU2VhcmNoZXIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHZpZXcsIHN0YXJ0aW5nVGlsZSwgcmVzdWx0KSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICB2YXIgdmlzaXRlZCA9IHRoaXMuX3Zpc2l0ZWQ7XG4gIHZhciB2ZXJ0aWNlcyA9IHRoaXMuX3ZlcnRpY2VzO1xuXG4gIHZhciBjb3VudCA9IDA7XG5cbiAgLy8gQ2xlYXIgaW50ZXJuYWwgc3RhdGUuXG4gIHRoaXMuX2NsZWFyKCk7XG5cbiAgc3RhY2sucHVzaChzdGFydGluZ1RpbGUpO1xuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHRpbGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmICh2aXNpdGVkLmhhcyh0aWxlKSkge1xuICAgICAgLy8gU2tpcCBhbHJlYWR5IHZpc2l0ZWQgdGlsZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghdmlldy5pbnRlcnNlY3RzKHRpbGUudmVydGljZXModmVydGljZXMpKSkge1xuICAgICAgLy8gU2tpcCBub24tdmlzaWJsZSB0aWxlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0aWxlIGFzIHZpc2l0ZWQuXG4gICAgdmlzaXRlZC5hZGQodGlsZSk7XG5cbiAgICAvLyBBZGQgbmVpZ2hib3JzIHRvIHRoZSBzdGFjayBvZiB0aWxlcyB0byBleHBsb3JlLlxuICAgIHZhciBuZWlnaGJvcnMgPSB0aWxlLm5laWdoYm9ycygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFjay5wdXNoKG5laWdoYm9yc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIHJlc3VsdC5cbiAgICByZXN1bHQucHVzaCh0aWxlKTtcblxuICAgIGNvdW50Kys7XG4gIH1cblxuICAvLyBSZXVzZSB0aGUgdmVydGljZXMgYXJyYXkgaW4gZnV0dXJlIHNlYXJjaGVzLlxuICB0aGlzLl92ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXG4gIC8vIENsZWFyIGludGVybmFsIHN0YXRlLlxuICB0aGlzLl9jbGVhcigpO1xuXG4gIHJldHVybiBjb3VudDtcbn07XG5cblRpbGVTZWFyY2hlci5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YWNrLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3Zpc2l0ZWQuY2xlYXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZVNlYXJjaGVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBub3cgPSByZXF1aXJlKCcuL3V0aWwvbm93Jyk7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHVyYXRpb246IEluZmluaXR5XG59O1xuXG5cbi8qKlxuICogU2lnbmFscyBhIHRpbWVvdXQuXG4gKiBAZXZlbnQgVGltZXIjdGltZW91dFxuICovXG5cblxuLyoqXG4gKiBAY2xhc3MgVGltZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFRpbWVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHJlY2VpdmUgYW4gZXZlbnQgYWZ0ZXIgYSB0aW1lb3V0LlxuICpcbiAqIEEgdGltZXIgaGFzIGEgc2V0IGR1cmF0aW9uLCBhbmQgaXMgZWl0aGVyIHN0YXJ0ZWQgb3Igc3RvcHBlZCBhdCBhIGdpdmVuIHRpbWUuXG4gKiBUaGUgdGltZXIgaXMgaW5pdGlhbGx5IHN0b3BwZWQuIFdoZW4gdGhlIHRpbWVyIGlzIHN0YXJ0ZWQsIGEgdGltZW91dCBldmVudCBpc1xuICogc2NoZWR1bGVkIHRvIGZpcmUgb25jZSB0aGUgc2V0IGR1cmF0aW9uIGVsYXBzZXMuIFdoZW4gdGhlIHRpbWVyIGlzIHN0b3BwZWQsXG4gKiB0aGUgc2NoZWR1bGVkIHRpbWVvdXQgZXZlbnQgaXMgY2FuY2VsbGVkLiBXaGVuIGEgdGltZW91dCBldmVudCBmaXJlcywgdGhlXG4gKiB0aW1lciByZXR1cm5zIHRvIHRoZSBzdG9wcGVkIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kdXJhdGlvbj1JbmZpbml0eV0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIFRpbWVyKG9wdHMpIHtcblxuICBvcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuX2R1cmF0aW9uID0gb3B0cy5kdXJhdGlvbjtcblxuICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG4gIHRoaXMuX2hhbmRsZSA9IG51bGw7XG5cbiAgdGhpcy5fY2hlY2sgPSB0aGlzLl9jaGVjay5iaW5kKHRoaXMpO1xuXG59XG5cbmV2ZW50RW1pdHRlcihUaW1lcik7XG5cblxuLyoqXG4gKiBTdGFydHMgdGhlIHRpbWVyLiBJZiB0aGUgdGltZXIgaXMgYWxyZWFkeSBzdGFydGVkLCB0aGlzIGhhcyB0aGUgZWZmZWN0IG9mXG4gKiBzdG9wcGluZyBhbmQgc3RhcnRpbmcgYWdhaW4gKGkuZS4gcmVzZXR0aW5nIHRoZSB0aW1lcikuXG4gKi9cblRpbWVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFydFRpbWUgPSBub3coKTtcbiAgaWYgKHRoaXMuX2hhbmRsZSA9PSBudWxsICYmIHRoaXMuX2R1cmF0aW9uIDwgSW5maW5pdHkpIHtcbiAgICB0aGlzLl9zZXR1cCh0aGlzLl9kdXJhdGlvbik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGluIHRoZSBzdGFydGVkIHN0YXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVGltZXIucHJvdG90eXBlLnN0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YXJ0VGltZSAhPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSB0aW1lci5cbiAqL1xuVGltZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgaWYgKHRoaXMuX2hhbmRsZSAhPSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRsZSk7XG4gICAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgfVxufTtcblxuXG5UaW1lci5wcm90b3R5cGUuX3NldHVwID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgdGhpcy5faGFuZGxlID0gc2V0VGltZW91dCh0aGlzLl9jaGVjaywgaW50ZXJ2YWwpO1xufTtcblxuXG5UaW1lci5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9oYW5kbGUpO1xuICB0aGlzLl9oYW5kbGUgPSBudWxsO1xufTtcblxuXG5UaW1lci5wcm90b3R5cGUuX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICB2YXIgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuXG4gIHRoaXMuX3RlYXJkb3duKCk7XG5cbiAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgdGhpcy5lbWl0KCd0aW1lb3V0Jyk7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPCBJbmZpbml0eSkge1xuICAgIHRoaXMuX3NldHVwKHJlbWFpbmluZyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2V0IGR1cmF0aW9uLlxuICovXG5UaW1lci5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGR1cmF0aW9uLiBJZiB0aGUgdGltZXIgaXMgYWxyZWFkeSBzdGFydGVkLCB0aGUgdGltZW91dCBldmVudCBpc1xuICogcmVzY2hlZHVsZWQgdG8gb2NjdXIgb25jZSB0aGUgbmV3IGR1cmF0aW9uIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAqIHRvIHN0YXJ0LiBJbiBwYXJ0aWN1bGFyLCBpZiBhbiBhbW91bnQgb2YgdGltZSBsYXJnZXIgdGhhbiB0aGUgbmV3IGR1cmF0aW9uXG4gKiBoYXMgYWxyZWFkeSBlbGFwc2VkLCB0aGUgdGltZW91dCBldmVudCBmaXJlcyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICovXG5UaW1lci5wcm90b3R5cGUuc2V0RHVyYXRpb24gPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICBpZiAodGhpcy5fc3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICB0aGlzLl9jaGVjaygpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcblxudmFyIFJlbmRlckxvb3AgPSByZXF1aXJlKCcuL1JlbmRlckxvb3AnKTtcbnZhciBDb250cm9scyA9IHJlcXVpcmUoJy4vY29udHJvbHMvQ29udHJvbHMnKTtcbnZhciBTY2VuZSA9IHJlcXVpcmUoJy4vU2NlbmUnKTtcbnZhciBUaW1lciA9IHJlcXVpcmUoJy4vVGltZXInKTtcblxudmFyIFdlYkdsU3RhZ2UgPSByZXF1aXJlKCcuL3N0YWdlcy9XZWJHbCcpO1xuXG52YXIgQ29udHJvbEN1cnNvciA9IHJlcXVpcmUoJy4vY29udHJvbHMvQ29udHJvbEN1cnNvcicpO1xudmFyIEhhbW1lckdlc3R1cmVzID0gcmVxdWlyZSgnLi9jb250cm9scy9IYW1tZXJHZXN0dXJlcycpO1xuXG52YXIgcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL3JlZ2lzdGVyRGVmYXVsdENvbnRyb2xzJyk7XG52YXIgcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzJyk7XG5cbnZhciBzZXRPdmVyZmxvd0hpZGRlbiA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRPdmVyZmxvd0hpZGRlbjtcbnZhciBzZXRBYnNvbHV0ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRBYnNvbHV0ZTtcbnZhciBzZXRGdWxsU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRGdWxsU2l6ZTtcblxudmFyIHR3ZWVuID0gcmVxdWlyZSgnLi91dGlsL3R3ZWVuJyk7XG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vdXRpbC9ub29wJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgY3VycmVudCBzY2VuZSBoYXMgY2hhbmdlZC5cbiAqIEBldmVudCBWaWV3ZXIjc2NlbmVDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgdmlldyBvZiB0aGUgY3VycmVudCBzY2VuZSBoYXMgY2hhbmdlZC4gU2VlXG4gKiB7QGxpbmsgVmlldyNldmVudDpjaGFuZ2V9LlxuICogQGV2ZW50IFZpZXdlciN2aWV3Q2hhbmdlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgVmlld2VyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBWaWV3ZXIgaXMgYSBjb250YWluZXIgZm9yIG11bHRpcGxlIHtAbGluayBTY2VuZSBzY2VuZXN9IHRvIGJlIGRpc3BsYXllZFxuICogaW5zaWRlIGEge0BsaW5rIFN0YWdlIHN0YWdlfSBjb250YWluZWQgaW4gdGhlIERPTS5cbiAqXG4gKiBTY2VuZXMgbWF5IGJlIGNyZWF0ZWQgYnkgY2FsbGluZyB7QGxpbmsgVmlld2VyI2NyZWF0ZVNjZW5lfS4gRXhjZXB0IGR1cmluZyBhXG4gKiBzY2VuZSBzd2l0Y2gsIGEgc2luZ2xlIG9uZSBvZiB0aGVtLCBjYWxsZWQgdGhlIGN1cnJlbnQgc2NlbmUsIGlzIHZpc2libGUuXG4gKiBDYWxsaW5nIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9IHNldHMgdGhlIGN1cnJlbnQgc2NlbmUgYW5kIHN3aXRjaGVzIHRvIGl0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tRWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gY29udGFpbiB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBWaWV3ZXIgY3JlYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRyb2xzIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvXG4gKiAgICAge0BsaW5rIHJlZ2lzdGVyRGVmYXVsdENvbnRyb2xzfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnN0YWdlIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSB7QGxpbmsgU3RhZ2V9XG4gKiAgICAgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jdXJzb3JzIEN1cnNvciBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY3Vyc29ycy5kcmFnIERyYWcgY3Vyc29yIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZVxuICogICAgIHtAbGluayBDb250cm9sQ3Vyc29yfSBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gVmlld2VyKGRvbUVsZW1lbnQsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy5fZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG5cbiAgLy8gQWRkIGBvdmVyZmxvdzogaGlkZGVuYCB0byB0aGUgZG9tRWxlbWVudC5cbiAgc2V0T3ZlcmZsb3dIaWRkZW4oZG9tRWxlbWVudCk7XG5cbiAgLy8gQ3JlYXRlIHN0YWdlLlxuICB0aGlzLl9zdGFnZSA9IG5ldyBXZWJHbFN0YWdlKG9wdHMuc3RhZ2UpO1xuXG4gIC8vIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IHJlbmRlcmVycyBmb3IgdGhlIHNlbGVjdGVkIHN0YWdlLlxuICByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnModGhpcy5fc3RhZ2UpO1xuXG4gIC8vIEFkZCB0aGUgc3RhZ2UgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gIHRoaXMuX2RvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fc3RhZ2UuZG9tRWxlbWVudCgpKTtcblxuICAvLyBDcmVhdGUgY29udHJvbCBjb250YWluZXIuXG4gIC8vIENvbnRyb2xzIGNhbm5vdCBiZSBwbGFjZWQgZGlyZWN0bHkgb24gdGhlIHJvb3QgRE9NIGVsZW1lbnQgYmVjYXVzZVxuICAvLyBIYW1tZXIuanMgd2lsbCBwcmV2ZW50IGNsaWNrIGV2ZW50cyBmcm9tIHJlYWNoaW5nIHRoZSBlbGVtZW50cyBiZW5lYXRoLlxuXG4gIC8vIFRoZSBob3RzcG90IGNvbnRhaW5lcnMgd2lsbCBiZSBhZGRlZCBpbnNpZGUgdGhlIGNvbnRyb2xzIGNvbnRhaW5lci5cbiAgdGhpcy5fY29udHJvbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzZXRBYnNvbHV0ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcbiAgc2V0RnVsbFNpemUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XG4gIGRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY29udHJvbENvbnRhaW5lcik7XG5cbiAgLy8gUmVzcG9uZCB0byB3aW5kb3cgc2l6ZSBjaGFuZ2VzLlxuICB0aGlzLl9zaXplID0ge307XG4gIHRoaXMudXBkYXRlU2l6ZSgpO1xuICB0aGlzLl91cGRhdGVTaXplTGlzdGVuZXIgPSB0aGlzLnVwZGF0ZVNpemUuYmluZCh0aGlzKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3VwZGF0ZVNpemVMaXN0ZW5lcik7XG5cbiAgLy8gQ3JlYXRlIHJlbmRlciBsb29wLlxuICB0aGlzLl9yZW5kZXJMb29wID0gbmV3IFJlbmRlckxvb3AodGhpcy5fc3RhZ2UpO1xuXG4gIC8vIENyZWF0ZSB0aGUgY29udHJvbHMgYW5kIHJlZ2lzdGVyIHRoZW0gd2l0aCB0aGUgcmVuZGVyIGxvb3AuXG4gIHRoaXMuX2NvbnRyb2xzID0gbmV3IENvbnRyb2xzKCk7XG4gIHRoaXMuX2NvbnRyb2xNZXRob2RzID0gcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHModGhpcy5fY29udHJvbHMsIHRoaXMuX2NvbnRyb2xDb250YWluZXIsIG9wdHMuY29udHJvbHMpO1xuICB0aGlzLl9jb250cm9scy5hdHRhY2godGhpcy5fcmVuZGVyTG9vcCk7XG5cbiAgLy8gRXhwb3NlIEhhbW1lckpTLlxuICB0aGlzLl9oYW1tZXJNYW5hZ2VyVG91Y2ggPSBIYW1tZXJHZXN0dXJlcy5nZXQodGhpcy5fY29udHJvbENvbnRhaW5lciwgJ3RvdWNoJyk7XG4gIHRoaXMuX2hhbW1lck1hbmFnZXJNb3VzZSA9IEhhbW1lckdlc3R1cmVzLmdldCh0aGlzLl9jb250cm9sQ29udGFpbmVyLCAnbW91c2UnKTtcblxuICAvLyBJbml0aWFsaXplIGRyYWcgY3Vyc29yLlxuICB0aGlzLl9kcmFnQ3Vyc29yID0gbmV3IENvbnRyb2xDdXJzb3IodGhpcy5fY29udHJvbHMsICdtb3VzZVZpZXdEcmFnJywgZG9tRWxlbWVudCwgb3B0cy5jdXJzb3JzICYmIG9wdHMuY3Vyc29ycy5kcmFnIHx8IHt9KTtcblxuICAvLyBTdGFydCB0aGUgcmVuZGVyIGxvb3AuXG4gIHRoaXMuX3JlbmRlckxvb3Auc3RhcnQoKTtcblxuICAvLyBTY2VuZSBsaXN0LlxuICB0aGlzLl9zY2VuZXMgPSBbXTtcblxuICAvLyBUaGUgY3VycmVudGx5IHZpc2libGUgc2NlbmUuXG4gIC8vIER1cmluZyBhIHNjZW5lIHRyYW5zaXRpb24sIHRoaXMgaXMgdGhlIHNjZW5lIGJlaW5nIHN3aXRjaGVkIHRvLlxuICB0aGlzLl9jdXJyZW50U2NlbmUgPSBudWxsO1xuXG4gIC8vIFRoZSBzY2VuZSBiZWluZyBzd2l0Y2hlZCBmcm9tIGR1cmluZyBhIHNjZW5lIHRyYW5zaXRpb24uXG4gIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHVwZGF0ZSB0aGUgbGF5ZXJzIGNvcnJlY3RseSB3aGVuIHRoZXkgYXJlIGFkZGVkIG9yXG4gIC8vIHJlbW92ZWQgZHVyaW5nIGEgdHJhbnNpdGlvbi5cbiAgdGhpcy5fcmVwbGFjZWRTY2VuZSA9IG51bGw7XG5cbiAgLy8gVGhlIGN1cnJlbnQgdHJhbnNpdGlvbi5cbiAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuID0gbnVsbDtcblxuICAvLyBUaGUgZXZlbnQgbGlzdGVuZXIgZmlyZWQgd2hlbiB0aGUgY3VycmVudCBzY2VuZSBsYXllcnMgY2hhbmdlLlxuICAvLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSBjb3JyZWN0IHNjZW5lIHdoZW5ldmVyIHRoZSBjdXJyZW50IHNjZW5lIGNoYW5nZXMuXG4gIHRoaXMuX2xheWVyQ2hhbmdlSGFuZGxlciA9IHRoaXMuX3VwZGF0ZVNjZW5lTGF5ZXJzLmJpbmQodGhpcyk7XG5cbiAgLy8gVGhlIGV2ZW50IGxpc3RlbmVyIGZpcmVkIHdoZW4gdGhlIGN1cnJlbnQgc2NlbmUgdmlldyBjaGFuZ2VzLlxuICAvLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSBjb3JyZWN0IHNjZW5lIHdoZW5ldmVyIHRoZSBjdXJyZW50IHNjZW5lIGNoYW5nZXMuXG4gIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ3ZpZXdDaGFuZ2UnKTtcblxuICAvLyBTZXR1cCB0aGUgaWRsZSB0aW1lci5cbiAgLy8gQnkgZGVmYXVsdCwgdGhlIHRpbWVyIGhhcyBhbiBpbmZpbml0ZSBkdXJhdGlvbiBzbyBpdCBkb2VzIG5vdGhpbmcuXG4gIHRoaXMuX2lkbGVUaW1lciA9IG5ldyBUaW1lcigpO1xuICB0aGlzLl9pZGxlVGltZXIuc3RhcnQoKTtcblxuICAvLyBSZXNldCB0aGUgdGltZXIgd2hlbmV2ZXIgdGhlIHZpZXcgY2hhbmdlcy5cbiAgdGhpcy5fcmVzZXRJZGxlVGltZXJIYW5kbGVyID0gdGhpcy5fcmVzZXRJZGxlVGltZXIuYmluZCh0aGlzKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd2aWV3Q2hhbmdlJywgdGhpcy5fcmVzZXRJZGxlVGltZXJIYW5kbGVyKTtcblxuICAvLyBTdGFydCB0aGUgaWRsZSBtb3ZlbWVudCB3aGVuIHRoZSBpZGxlIHRpbWVyIGZpcmVzLlxuICB0aGlzLl90cmlnZ2VySWRsZVRpbWVySGFuZGxlciA9IHRoaXMuX3RyaWdnZXJJZGxlVGltZXIuYmluZCh0aGlzKTtcbiAgdGhpcy5faWRsZVRpbWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl90cmlnZ2VySWRsZVRpbWVySGFuZGxlcik7XG5cbiAgLy8gU3RvcCBhbiBvbmdvaW5nIG1vdmVtZW50IHdoZW4gdGhlIGNvbnRyb2xzIGFyZSBhY3RpdmF0ZWQgb3Igd2hlbiB0aGVcbiAgLy8gc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fc3RvcE1vdmVtZW50SGFuZGxlciA9IHRoaXMuc3RvcE1vdmVtZW50LmJpbmQodGhpcyk7XG4gIHRoaXMuX2NvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2ZScsIHRoaXMuX3N0b3BNb3ZlbWVudEhhbmRsZXIpO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3NjZW5lQ2hhbmdlJywgdGhpcy5fc3RvcE1vdmVtZW50SGFuZGxlcik7XG5cbiAgLy8gVGhlIGN1cnJlbnRseSBwcm9ncmFtbWVkIGlkbGUgbW92ZW1lbnQuXG4gIHRoaXMuX2lkbGVNb3ZlbWVudCA9IG51bGw7XG59XG5cbmV2ZW50RW1pdHRlcihWaWV3ZXIpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl91cGRhdGVTaXplTGlzdGVuZXIpO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50U2NlbmUpIHtcbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHRoaXMuX2N1cnJlbnRTY2VuZSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVwbGFjZWRTY2VuZSkge1xuICAgIHRoaXMuX3JlbW92ZVNjZW5lRXZlbnRMaXN0ZW5lcnModGhpcy5fcmVwbGFjZWRTY2VuZSk7XG4gIH1cblxuICB0aGlzLl9kcmFnQ3Vyc29yLmRlc3Ryb3koKTtcblxuICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHRoaXMuX2NvbnRyb2xNZXRob2RzKSB7XG4gICAgdGhpcy5fY29udHJvbE1ldGhvZHNbbWV0aG9kTmFtZV0uZGVzdHJveSgpO1xuICB9XG5cbiAgd2hpbGUgKHRoaXMuX3NjZW5lcy5sZW5ndGgpIHtcbiAgICB0aGlzLmRlc3Ryb3lTY2VuZSh0aGlzLl9zY2VuZXNbMF0pO1xuICB9XG5cbiAgdGhpcy5fZG9tRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9zdGFnZS5kb21FbGVtZW50KCkpO1xuXG4gIHRoaXMuX3N0YWdlLmRlc3Ryb3koKTtcbiAgdGhpcy5fcmVuZGVyTG9vcC5kZXN0cm95KCk7XG4gIHRoaXMuX2NvbnRyb2xzLmRlc3Ryb3koKTtcbiAgdGhpcy5fY29udHJvbHMgPSBudWxsO1xuXG4gIGlmICh0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4pIHtcbiAgICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4oKTtcbiAgfVxuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGFnZSBzaXplIHRvIGZpbGwgdGhlIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyByZXNpemVkLlxuICogTW9zdCBjbGllbnRzIHdvbid0IG5lZWQgdG8gZXhwbGljaXRseSBjYWxsIGl0IHRvIGtlZXAgdGhlIHNpemUgdXAgdG8gZGF0ZS5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gIHNpemUud2lkdGggPSB0aGlzLl9kb21FbGVtZW50LmNsaWVudFdpZHRoO1xuICBzaXplLmhlaWdodCA9IHRoaXMuX2RvbUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB0aGlzLl9zdGFnZS5zZXRTaXplKHNpemUpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFN0YWdlIHN0YWdlfS5cbiAqIEByZXR1cm4ge1N0YWdlfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnN0YWdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc3RhZ2U7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgUmVuZGVyTG9vcCByZW5kZXIgbG9vcH0uXG4gKiBAcmV0dXJuIHtSZW5kZXJMb29wfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnJlbmRlckxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZW5kZXJMb29wO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIENvbnRyb2xzIGNvbnRyb2xzfS5cbiAqIEByZXR1cm4ge0NvbnRyb2xzfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmNvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fY29udHJvbHM7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgU2NlbmUgc2NlbmV9IHdpdGggYSBzaW5nbGUgbGF5ZXIgYW5kIGFkZHMgaXQgdG8gdGhlXG4gKiB2aWV3ZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgc2NlbmUgZG9lcyBub3QgY2hhbmdlLiBUbyBzd2l0Y2ggdG8gdGhlIHNjZW5lLCBjYWxsXG4gKiB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBTY2VuZSBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtWaWV3fSBvcHRzLnZpZXcgVGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlld30uXG4gKiBAcGFyYW0ge1NvdXJjZX0gb3B0cy5zb3VyY2UgVGhlIGxheWVyJ3MgdW5kZXJseWluZyB7QGxpbmsgU291cmNlfS5cbiAqIEBwYXJhbSB7R2VvbWV0cnl9IG9wdHMuZ2VvbWV0cnkgVGhlIGxheWVyJ3MgdW5kZXJseWluZyB7QGxpbmsgR2VvbWV0cnl9LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5waW5GaXJzdExldmVsPWZhbHNlXSBXaGV0aGVyIHRvIHBpbiB0aGUgZmlyc3QgbGV2ZWwgdG9cbiAqICAgICBwcm92aWRlIGEgZmFsbGJhY2sgb2YgbGFzdCByZXNvcnQsIGF0IHRoZSBjb3N0IG9mIG1lbW9yeSBjb25zdW1wdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy50ZXh0dXJlU3RvcmVPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlXG4gKiAgICAge0BsaW5rIFRleHR1cmVTdG9yZX0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubGF5ZXJPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIHtAbGluayBMYXllcn1cbiAqICAgICBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm4ge1NjZW5lfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmNyZWF0ZVNjZW5lID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHNjZW5lID0gdGhpcy5jcmVhdGVFbXB0eVNjZW5lKHsgdmlldzogb3B0cy52aWV3IH0pO1xuXG4gIHNjZW5lLmNyZWF0ZUxheWVyKHtcbiAgICBzb3VyY2U6IG9wdHMuc291cmNlLFxuICAgIGdlb21ldHJ5OiBvcHRzLmdlb21ldHJ5LFxuICAgIGRlcHRobWFwOiBvcHRzLmRlcHRobWFwLFxuICAgIHBpbkZpcnN0TGV2ZWw6IG9wdHMucGluRmlyc3RMZXZlbCxcbiAgICB0ZXh0dXJlU3RvcmVPcHRzOiBvcHRzLnRleHR1cmVTdG9yZU9wdHMsXG4gICAgbGF5ZXJPcHRzOiBvcHRzLmxheWVyT3B0c1xuICB9KTtcblxuICByZXR1cm4gc2NlbmU7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgU2NlbmUgc2NlbmV9IHdpdGggbm8gbGF5ZXJzIGFuZCBhZGRzIGl0IHRvIHRoZSB2aWV3ZXIuXG4gKlxuICogTGF5ZXJzIG1heSBiZSBhZGRlZCB0byB0aGUgc2NlbmUgYnkgY2FsbGluZyB7QGxpbmsgU2NlbmUjY3JlYXRlTGF5ZXJ9LlxuICogSG93ZXZlciwgaWYgdGhlIHNjZW5lIGhhcyBhIHNpbmdsZSBsYXllciwgaXQgaXMgc2ltcGxlciB0byBjYWxsXG4gKiB7QGxpbmsgVmlld2VyI2NyZWF0ZVNjZW5lfSBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuICpcbiAqIFRoZSBjdXJyZW50IHNjZW5lIGRvZXMgbm90IGNoYW5nZS4gVG8gc3dpdGNoIHRvIHRoZSBzY2VuZSwgY2FsbFxuICoge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgU2NlbmUgY3JlYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7Vmlld30gb3B0cy52aWV3IFRoZSBzY2VuZSdzIHVuZGVybHlpbmcge0BsaW5rIFZpZXd9LlxuICogQHJldHVybiB7U2NlbmV9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuY3JlYXRlRW1wdHlTY2VuZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBzY2VuZSA9IG5ldyBTY2VuZSh0aGlzLCBvcHRzLnZpZXcpO1xuICB0aGlzLl9zY2VuZXMucHVzaChzY2VuZSk7XG5cbiAgcmV0dXJuIHNjZW5lO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl91cGRhdGVTY2VuZUxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIHZhciBsYXllcjtcblxuICB2YXIgc3RhZ2UgPSB0aGlzLl9zdGFnZTtcbiAgdmFyIGN1cnJlbnRTY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgdmFyIHJlcGxhY2VkU2NlbmUgPSB0aGlzLl9yZXBsYWNlZFNjZW5lO1xuXG4gIHZhciBvbGRMYXllcnMgPSBzdGFnZS5saXN0TGF5ZXJzKCk7XG5cbiAgLy8gVGhlIHN0YWdlIGNvbnRhaW5zIGxheWVycyBmcm9tIGF0IG1vc3QgdHdvIHNjZW5lczogdGhlIGN1cnJlbnQgb25lLCBvbiB0b3AsXG4gIC8vIGFuZCB0aGUgb25lIGN1cnJlbnRseSBiZWluZyBzd2l0Y2hlZCBhd2F5IGZyb20sIG9uIHRoZSBib3R0b20uXG4gIHZhciBuZXdMYXllcnMgPSBbXTtcbiAgaWYgKHJlcGxhY2VkU2NlbmUpIHtcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuY29uY2F0KHJlcGxhY2VkU2NlbmUubGlzdExheWVycygpKTtcbiAgfVxuICBpZiAoY3VycmVudFNjZW5lKSB7XG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmNvbmNhdChjdXJyZW50U2NlbmUubGlzdExheWVycygpKTtcbiAgfVxuXG4gIC8vIEEgc2luZ2xlIGxheWVyIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIHNjZW5lIGF0IGEgdGltZS5cbiAgaWYgKE1hdGguYWJzKG9sZExheWVycy5sZW5ndGggLSBuZXdMYXllcnMubGVuZ3RoKSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhZ2UgYW5kIHNjZW5lIG91dCBvZiBzeW5jJyk7XG4gIH1cblxuICBpZiAobmV3TGF5ZXJzLmxlbmd0aCA8IG9sZExheWVycy5sZW5ndGgpIHtcbiAgICAvLyBBIGxheWVyIHdhcyByZW1vdmVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBvbGRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxheWVyID0gb2xkTGF5ZXJzW2ldO1xuICAgICAgaWYgKG5ld0xheWVycy5pbmRleE9mKGxheWVyKSA8IDApIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UobGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld0xheWVycy5sZW5ndGggPiBvbGRMYXllcnMubGVuZ3RoKSB7XG4gICAgLy8gQSBsYXllciB3YXMgYWRkZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGF5ZXIgPSBuZXdMYXllcnNbaV07XG4gICAgICBpZiAob2xkTGF5ZXJzLmluZGV4T2YobGF5ZXIpIDwgMCkge1xuICAgICAgICB0aGlzLl9hZGRMYXllclRvU3RhZ2UobGF5ZXIsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IFdoZW4gaW4gdGhlIG1pZGRsZSBvZiBhIHNjZW5lIHRyYW5zaXRpb24sIGNhbGwgdGhlIHRyYW5zaXRpb24gdXBkYXRlXG4gIC8vIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgYW4gYWRkZWQgbGF5ZXIgZnJvbSBmbGFzaGluZyB3aXRoIHRoZSB3cm9uZ1xuICAvLyBvcGFjaXR5LlxufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9hZGRMYXllclRvU3RhZ2UgPSBmdW5jdGlvbiAobGF5ZXIsIGkpIHtcbiAgLy8gUGluIHRoZSBmaXJzdCBsZXZlbCB0byBlbnN1cmUgYSBmYWxsYmFjayB3aGlsZSB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgZGlzdGluY3QgZnJvbSB0aGUgYHBpbkZpcnN0TGV2ZWxgIG9wdGlvbiBwYXNzZWQgdG9cbiAgLy8gY3JlYXRlU2NlbmUoKSwgd2hpY2ggcGlucyB0aGUgbGF5ZXIgZXZlbiB3aGVuIGl0J3Mgbm90IHZpc2libGUuXG4gIGxheWVyLnBpbkZpcnN0TGV2ZWwoKTtcbiAgdGhpcy5fc3RhZ2UuYWRkTGF5ZXIobGF5ZXIsIGkpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9yZW1vdmVMYXllckZyb21TdGFnZSA9IGZ1bmN0aW9uIChsYXllcikge1xuICB0aGlzLl9zdGFnZS5yZW1vdmVMYXllcihsYXllcik7XG4gIGxheWVyLnVucGluRmlyc3RMZXZlbCgpO1xuICBsYXllci50ZXh0dXJlU3RvcmUoKS5jbGVhck5vdFBpbm5lZCgpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9hZGRTY2VuZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKHNjZW5lKSB7XG4gIHNjZW5lLmFkZEV2ZW50TGlzdGVuZXIoJ2xheWVyQ2hhbmdlJywgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyKTtcbiAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIChzY2VuZSkge1xuICBzY2VuZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsYXllckNoYW5nZScsIHRoaXMuX2xheWVyQ2hhbmdlSGFuZGxlcik7XG4gIHNjZW5lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ZpZXdDaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG59O1xuXG5cbi8qKlxuICogRGVzdHJveXMgYSB7QGxpbmsgU2NlbmUgc2NlbmV9IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHZpZXdlci5cbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gKi9cblZpZXdlci5wcm90b3R5cGUuZGVzdHJveVNjZW5lID0gZnVuY3Rpb24gKHNjZW5lKSB7XG4gIHZhciBpID0gdGhpcy5fc2NlbmVzLmluZGV4T2Yoc2NlbmUpO1xuICBpZiAoaSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggc2NlbmUgaW4gdmlld2VyJyk7XG4gIH1cblxuICB2YXIgajtcbiAgdmFyIGxheWVycztcblxuICBpZiAodGhpcy5fY3VycmVudFNjZW5lID09PSBzY2VuZSkge1xuICAgIC8vIFRoZSBkZXN0cm95ZWQgc2NlbmUgaXMgdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycywgcmVtb3ZlIGxheWVycyBmcm9tIHN0YWdlIGFuZCBjYW5jZWwgdHJhbnNpdGlvbi5cbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHNjZW5lKTtcbiAgICBsYXllcnMgPSBzY2VuZS5saXN0TGF5ZXJzKCk7XG4gICAgZm9yIChqID0gMDsgaiA8IGxheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UobGF5ZXJzW2pdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbmNlbEN1cnJlbnRUd2Vlbikge1xuICAgICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKCk7XG4gICAgICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50U2NlbmUgPSBudWxsO1xuICAgIHRoaXMuZW1pdCgnc2NlbmVDaGFuZ2UnKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXBsYWNlZFNjZW5lID09PSBzY2VuZSkge1xuICAgIC8vIFRoZSBkZXN0cm95ZWQgc2NlbmUgaXMgYmVpbmcgc3dpdGNoZWQgYXdheSBmcm9tLlxuICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHJlbW92ZSBsYXllcnMgZnJvbSBzdGFnZS5cbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHNjZW5lKTtcbiAgICBsYXllcnMgPSBzY2VuZS5saXN0TGF5ZXJzKCk7XG4gICAgZm9yIChqID0gMDsgaiA8IGxheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UobGF5ZXJzW2pdKTtcbiAgICB9XG4gICAgdGhpcy5fcmVwbGFjZWRTY2VuZSA9IG51bGw7XG4gIH1cblxuICB0aGlzLl9zY2VuZXMuc3BsaWNlKGksIDEpO1xuXG4gIHNjZW5lLmRlc3Ryb3koKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyBhbGwge0BsaW5rIFNjZW5lIHNjZW5lc30gYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSB2aWV3ZXIuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuZGVzdHJveUFsbFNjZW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgd2hpbGUgKHRoaXMuX3NjZW5lcy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5kZXN0cm95U2NlbmUodGhpcy5fc2NlbmVzWzBdKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdmlld2VyIGNvbnRhaW5zIGEge0BsaW5rIFNjZW5lIHNjZW5lfS5cbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmhhc1NjZW5lID0gZnVuY3Rpb24gKHNjZW5lKSB7XG4gIHJldHVybiB0aGlzLl9zY2VuZXMuaW5kZXhPZihzY2VuZSkgPj0gMDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwge0BsaW5rIFNjZW5lIHNjZW5lc30uXG4gKiBAcmV0dXJuIHtTY2VuZVtdfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmxpc3RTY2VuZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXS5jb25jYXQodGhpcy5fc2NlbmVzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHtAbGluayBTY2VuZSBzY2VuZX0sIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgY3VycmVudCBzY2VuZSwgY2FsbCB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqXG4gKiBAcmV0dXJuIHtTY2VuZX1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zY2VuZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTY2VuZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB7QGxpbmsgVmlldyB2aWV3fSBmb3IgdGhlIGN1cnJlbnQge0BsaW5rIFNjZW5lIHNjZW5lfSwgb3IgbnVsbFxuICogaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICogQHJldHVybiB7Vmlld31cbiAqL1xuVmlld2VyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2NlbmUgPSB0aGlzLl9jdXJyZW50U2NlbmU7XG4gIGlmIChzY2VuZSkge1xuICAgIHJldHVybiBzY2VuZS52aWV3KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogVHdlZW5zIHRoZSB7QGxpbmsgVmlldyB2aWV3fSBmb3IgdGhlIGN1cnJlbnQge0BsaW5rIFNjZW5lIHNjZW5lfS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFNjZW5lI2xvb2tUb30gb24gdGhlIGN1cnJlbnRcbiAqIHNjZW5lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHtAbGluayBTY2VuZSNsb29rVG99LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHR3ZWVuIGlzIGNvbXBsZXRlLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmxvb2tUbyA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdHMsIGRvbmUpIHtcbiAgLy8gVE9ETzogaXMgaXQgYW4gZXJyb3IgdG8gY2FsbCBsb29rVG8gd2hlbiBubyBzY2VuZSBpcyBkaXNwbGF5ZWQ/XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKHNjZW5lKSB7XG4gICAgc2NlbmUubG9va1RvKHBhcmFtcywgb3B0cywgZG9uZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdGFydHMgYSBtb3ZlbWVudCwgcG9zc2libHkgcmVwbGFjaW5nIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjc3RhcnRNb3ZlbWVudH0gb24gdGhlXG4gKiBjdXJyZW50IHNjZW5lLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHNjZW5lLCB0aGlzIGlzIGEgbm8tb3AuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIG1vdmVtZW50IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW92ZW1lbnQgZmluaXNoZXMgb3IgaXNcbiAqICAgICBpbnRlcnJ1cHRlZC5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zdGFydE1vdmVtZW50ID0gZnVuY3Rpb24gKGZuLCBkb25lKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKCFzY2VuZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzY2VuZS5zdGFydE1vdmVtZW50KGZuLCBkb25lKTtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFNjZW5lI3N0b3BNb3ZlbWVudH0gb24gdGhlXG4gKiBjdXJyZW50IHNjZW5lLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHNjZW5lLCB0aGlzIGlzIGEgbm8tb3AuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuc3RvcE1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2NlbmUgPSB0aGlzLl9jdXJyZW50U2NlbmU7XG4gIGlmICghc2NlbmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2NlbmUuc3RvcE1vdmVtZW50KCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFNjZW5lI21vdmVtZW50fSBvbiB0aGVcbiAqIGN1cnJlbnQgc2NlbmUuIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2NlbmUsIHRoaXMgaXMgYSBuby1vcC5cbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5tb3ZlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoIXNjZW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBzY2VuZS5tb3ZlbWVudCgpO1xufTtcblxuXG4vKipcbiAqIFNjaGVkdWxlcyBhbiBpZGxlIG1vdmVtZW50IHRvIGJlIGF1dG9tYXRpY2FsbHkgc3RhcnRlZCB3aGVuIHRoZSB2aWV3IHJlbWFpbnNcbiAqIHVuY2hhbmdlZCBmb3IgdGhlIGdpdmVuIHRpbWVvdXQgcGVyaW9kLlxuICpcbiAqIENoYW5naW5nIHRoZSB2aWV3IHdoaWxlIHRoZSBpZGxlIG1vdmVtZW50IGlzIGFjdGl2ZSBzdG9wcyB0aGUgbW92ZW1lbnQgYW5kXG4gKiBzY2hlZHVsZXMgaXQgdG8gc3RhcnQgYWdhaW4gYWZ0ZXIgdGhlIHNhbWUgdGltZW91dCBwZXJpb2QuIFRvIGRpc2FibGUgaXRcbiAqIHBlcm1hbmVudGx5LCBjYWxsIHdpdGggYSBudWxsIG1vdmVtZW50IG9yIGFuIGluZmluaXRlIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGltZW91dCBwZXJpb2QgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW92ZW1lbnQgQXV0b21hdGljIG1vdmVtZW50IGZ1bmN0aW9uLCBvciBudWxsIHRvIGRpc2FibGUuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuc2V0SWRsZU1vdmVtZW50ID0gZnVuY3Rpb24gKHRpbWVvdXQsIG1vdmVtZW50KSB7XG4gIHRoaXMuX2lkbGVUaW1lci5zZXREdXJhdGlvbih0aW1lb3V0KTtcbiAgdGhpcy5faWRsZU1vdmVtZW50ID0gbW92ZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIGlkbGUgbW92ZW1lbnQuIEl0IHdpbGwgYmUgc3RhcnRlZCBhZ2FpbiBhZnRlciB0aGUgdGltZW91dCBzZXQgYnlcbiAqIHtAbGluayBWaWV3ZXIjc2V0SWRsZU1vdmVtZW50fS5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5icmVha0lkbGVNb3ZlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wTW92ZW1lbnQoKTtcbiAgdGhpcy5fcmVzZXRJZGxlVGltZXIoKTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fcmVzZXRJZGxlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2lkbGVUaW1lci5zdGFydCgpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl90cmlnZ2VySWRsZVRpbWVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWRsZU1vdmVtZW50ID0gdGhpcy5faWRsZU1vdmVtZW50O1xuICBpZiAoIWlkbGVNb3ZlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnN0YXJ0TW92ZW1lbnQoaWRsZU1vdmVtZW50KTtcbn07XG5cblxudmFyIGRlZmF1bHRTd2l0Y2hEdXJhdGlvbiA9IDEwMDA7XG5cbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2l0aW9uVXBkYXRlKHZhbCwgbmV3U2NlbmUsIG9sZFNjZW5lKSB7XG4gIHZhciBsYXllcnMgPSBuZXdTY2VuZS5saXN0TGF5ZXJzKCk7XG4gIGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgIGxheWVyLm1lcmdlRWZmZWN0cyh7IG9wYWNpdHk6IHZhbCB9KTtcbiAgfSk7XG5cbiAgbmV3U2NlbmUuX2hvdHNwb3RDb250YWluZXIuZG9tRWxlbWVudCgpLnN0eWxlLm9wYWNpdHkgPSB2YWw7XG59XG5cblxuLyoqXG4gKiBTd2l0Y2hlcyB0byBhbm90aGVyIHtAbGluayBTY2VuZSBzY2VuZX0gd2l0aCBhIGZhZGUgdHJhbnNpdGlvbi4gVGhpcyBzY2VuZVxuICogYmVjb21lcyB0aGUgY3VycmVudCBvbmUuXG4gKlxuICogSWYgYSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgdGFraW5nIHBsYWNlLCBpdCBpcyBpbnRlcnJ1cHRlZCBiZWZvcmUgdGhlIG5ldyBvbmVcbiAqIHN0YXJ0cy5cbiAqXG4gKiBAcGFyYW0ge1NjZW5lfSBuZXdTY2VuZSBUaGUgc2NlbmUgdG8gc3dpdGNoIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVHJhbnNpdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRyYW5zaXRpb25EdXJhdGlvbj0xMDAwXSBUcmFuc2l0aW9uIGR1cmF0aW9uLCBpblxuICogICAgIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50cmFuc2l0aW9uVXBkYXRlPWRlZmF1bHRUcmFuc2l0aW9uVXBkYXRlXVxuICogICAgIFRyYW5zaXRpb24gdXBkYXRlIGZ1bmN0aW9uLCB3aXRoIHNpZ25hdHVyZSBgZih0LCBuZXdTY2VuZSwgb2xkU2NlbmUpYC5cbiAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIGZyYW1lIHdpdGggYHRgIGluY3JlYXNpbmcgZnJvbSAwIHRvIDEuXG4gKiAgICAgQW4gaW5pdGlhbCBjYWxsIHdpdGggYHQ9MGAgYW5kIGEgZmluYWwgY2FsbCB3aXRoIGB0PTFgIGFyZSBndWFyYW50ZWVkLlxuICogICAgIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG5ldyBzY2VuZSB0byBgdGAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlcyBvciBpc1xuICogICAgIGludGVycnVwdGVkLiBJZiB0aGUgbmV3IHNjZW5lIGlzIGVxdWFsIHRvIHRoZSBvbGQgb25lLCBubyB0cmFuc2l0aW9uXG4gKiAgICAgdGFrZXMgcGxhY2UsIGJ1dCB0aGlzIGZ1bmN0aW9uIGlzIHN0aWxsIGNhbGxlZC5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zd2l0Y2hTY2VuZSA9IGZ1bmN0aW9uIChuZXdTY2VuZSwgb3B0cywgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGRvbmUgPSBkb25lIHx8IG5vb3A7XG5cbiAgdmFyIHN0YWdlID0gdGhpcy5fc3RhZ2U7XG5cbiAgdmFyIG9sZFNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuXG4gIC8vIERvIG5vdGhpbmcgaWYgdGhlIHRhcmdldCBzY2VuZSBpcyB0aGUgY3VycmVudCBvbmUuXG4gIGlmIChvbGRTY2VuZSA9PT0gbmV3U2NlbmUpIHtcbiAgICBkb25lKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NjZW5lcy5pbmRleE9mKG5ld1NjZW5lKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggc2NlbmUgaW4gdmlld2VyJyk7XG4gIH1cblxuICAvLyBDYW5jZWwgYW4gYWxyZWFkeSBvbmdvaW5nIHRyYW5zaXRpb24uIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBzdGFnZSBjb250YWluc1xuICAvLyBsYXllcnMgZnJvbSBleGFjdGx5IG9uZSBzY2VuZSBiZWZvcmUgdGhlIHRyYW5zaXRpb24gYmVnaW5zLlxuICBpZiAodGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKSB7XG4gICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKCk7XG4gICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBvbGRTY2VuZUxheWVycyA9IG9sZFNjZW5lID8gb2xkU2NlbmUubGlzdExheWVycygpIDogW107XG4gIHZhciBuZXdTY2VuZUxheWVycyA9IG5ld1NjZW5lLmxpc3RMYXllcnMoKTtcbiAgdmFyIHN0YWdlTGF5ZXJzID0gc3RhZ2UubGlzdExheWVycygpO1xuXG4gIC8vIENoZWNrIHRoYXQgdGhlIHN0YWdlIGNvbnRhaW5zIGV4YWN0bHkgYXMgbWFueSBsYXllcnMgYXMgdGhlIGN1cnJlbnQgc2NlbmUsXG4gIC8vIGFuZCB0aGF0IHRoZSB0b3AgbGF5ZXIgaXMgdGhlIHJpZ2h0IG9uZS4gSWYgdGhpcyB0ZXN0IGZhaWxzLCBlaXRoZXIgdGhlcmVcbiAgLy8gaXMgYSBidWcgb3IgdGhlIHVzZXIgdHJpZWQgdG8gbW9kaWZ5IHRoZSBzdGFnZSBjb25jdXJyZW50bHkuXG4gIGlmIChvbGRTY2VuZSAmJiAoKHN0YWdlTGF5ZXJzLmxlbmd0aCAhPT0gb2xkU2NlbmVMYXllcnMubGVuZ3RoKSB8fFxuICAgIChzdGFnZUxheWVycy5sZW5ndGggPiAxICYmIHN0YWdlTGF5ZXJzWzBdICE9IG9sZFNjZW5lTGF5ZXJzWzBdKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIG5vdCBpbiBzeW5jIHdpdGggdmlld2VyJyk7XG4gIH1cblxuICAvLyBHZXQgdGhlIHRyYW5zaXRpb24gcGFyYW1ldGVycy5cbiAgdmFyIGR1cmF0aW9uID0gb3B0cy50cmFuc2l0aW9uRHVyYXRpb24gIT0gbnVsbCA/XG4gICAgb3B0cy50cmFuc2l0aW9uRHVyYXRpb24gOiBkZWZhdWx0U3dpdGNoRHVyYXRpb247XG4gIHZhciB1cGRhdGUgPSBvcHRzLnRyYW5zaXRpb25VcGRhdGUgIT0gbnVsbCA/XG4gICAgb3B0cy50cmFuc2l0aW9uVXBkYXRlIDogZGVmYXVsdFRyYW5zaXRpb25VcGRhdGU7XG5cbiAgLy8gQWRkIG5ldyBzY2VuZSBsYXllcnMgaW50byB0aGUgc3RhZ2UgYmVmb3JlIHN0YXJ0aW5nIHRoZSB0cmFuc2l0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1NjZW5lTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fYWRkTGF5ZXJUb1N0YWdlKG5ld1NjZW5lTGF5ZXJzW2ldKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZnJhbWUuXG4gIGZ1bmN0aW9uIHR3ZWVuVXBkYXRlKHZhbCkge1xuICAgIHVwZGF0ZSh2YWwsIG5ld1NjZW5lLCBvbGRTY2VuZSk7XG4gIH1cblxuICAvLyBPbmNlIHRoZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLCByZW1vdmUgb2xkIHNjZW5lIGxheWVycyBmcm9tIHRoZSBzdGFnZSBhbmRcbiAgLy8gcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnMuIElmIHRoZSBvbGQgc2NlbmUgd2FzIGRlc3Ryb3llZCBkdXJpbmcgdGhlXG4gIC8vIHRyYW5zaXRpb24sIHRoaXMgaGFzIGFscmVhZHkgYmVlbiB0YWtlbiBjYXJlIG9mLiBPdGhlcndpc2UsIHdlIHN0aWxsIG5lZWRcbiAgLy8gdG8gZ2V0IGEgZnJlc2ggY29weSBvZiB0aGUgc2NlbmUncyBsYXllcnMsIHNpbmNlIHRoZXkgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gIC8vIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgZnVuY3Rpb24gdHdlZW5Eb25lKCkge1xuICAgIGlmIChzZWxmLl9yZXBsYWNlZFNjZW5lKSB7XG4gICAgICBzZWxmLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHNlbGYuX3JlcGxhY2VkU2NlbmUpO1xuICAgICAgb2xkU2NlbmVMYXllcnMgPSBzZWxmLl9yZXBsYWNlZFNjZW5lLmxpc3RMYXllcnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkU2NlbmVMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2Uob2xkU2NlbmVMYXllcnNbaV0pO1xuICAgICAgfVxuICAgICAgc2VsZi5fcmVwbGFjZWRTY2VuZSA9IG51bGw7XG4gICAgfVxuICAgIHNlbGYuX2NhbmNlbEN1cnJlbnRUd2VlbiA9IG51bGw7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLy8gU3RvcmUgdGhlIGNhbmNlbGFibGUgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSB0d2VlbihkdXJhdGlvbiwgdHdlZW5VcGRhdGUsIHR3ZWVuRG9uZSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGFuZCByZXBsYWNlZCBzY2VuZS5cbiAgdGhpcy5fY3VycmVudFNjZW5lID0gbmV3U2NlbmU7XG4gIHRoaXMuX3JlcGxhY2VkU2NlbmUgPSBvbGRTY2VuZTtcblxuICAvLyBFbWl0IHNjZW5lIGFuZCB2aWV3IGNoYW5nZSBldmVudHMuXG4gIHRoaXMuZW1pdCgnc2NlbmVDaGFuZ2UnKTtcbiAgdGhpcy5lbWl0KCd2aWV3Q2hhbmdlJyk7XG5cbiAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgbmV3IHNjZW5lLlxuICAvLyBOb3RlIHRoYXQgZXZlbnQgbGlzdGVuZXJzIGNhbiBvbmx5IGJlIHJlbW92ZWQgZnJvbSB0aGUgb2xkIHNjZW5lIG9uY2UgdGhlXG4gIC8vIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHNpbmNlIGxheWVycyBtaWdodCBnZXQgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAgLy8gaW50ZXJpbS5cbiAgdGhpcy5fYWRkU2NlbmVFdmVudExpc3RlbmVycyhuZXdTY2VuZSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVmlld2VyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhdGljQXNzZXQgPSByZXF1aXJlKCcuL1N0YXRpYycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIER5bmFtaWNBc3NldFxuICogQGltcGxlbWVudHMgQXNzZXRcbiAqIEBleHRlbmRzIFN0YXRpY0Fzc2V0XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQW4ge0BsaW5rIEFzc2V0fSB3aG9zZSBwaXhlbCBjb250ZW50cyBtYXkgY2hhbmdlLlxuICpcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gZWxlbWVudCBUaGVcbiAqICAgICB1bmRlcmx5aW5nIHBpeGVsIHNvdXJjZS5cbiAqIEB0aHJvd3MgSWYgdGhlIHBpeGVsIHNvdXJjZSBpcyB1bnN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gRHluYW1pY0Fzc2V0KGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgdGhpcy5fdGltZXN0YW1wID0gMDtcbn1cblxuaW5oZXJpdHMoRHluYW1pY0Fzc2V0LCBTdGF0aWNBc3NldCk7XG5ldmVudEVtaXR0ZXIoRHluYW1pY0Fzc2V0KTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5EeW5hbWljQXNzZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbWVzdGFtcDtcbn07XG5cbkR5bmFtaWNBc3NldC5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgYXNzZXQgZGlydHksIHNpZ25hbGluZyB0aGF0IHRoZSBjb250ZW50cyBvZiB0aGUgdW5kZXJseWluZyBwaXhlbFxuICogc291cmNlIGhhdmUgY2hhbmdlZC5cbiAqXG4gKiBAdGhyb3dzIElmIHRoZSBhc3NldCBpcyBub3QgZHluYW1pYy5cbiAqL1xuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdGltZXN0YW1wKys7XG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNBc3NldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2xvYmFsJyk7XG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIHByb3BlcnR5TWFwID0ge1xuICBIVE1MSW1hZ2VFbGVtZW50OiBbJ25hdHVyYWxXaWR0aCcsICduYXR1cmFsSGVpZ2h0J10sXG4gIEhUTUxDYW52YXNFbGVtZW50OiBbJ3dpZHRoJywgJ2hlaWdodCddLFxuICBJbWFnZUJpdG1hcDogWyd3aWR0aCcsICdoZWlnaHQnXVxufTtcblxuLyoqXG4gKiBAY2xhc3MgU3RhdGljQXNzZXRcbiAqIEBpbXBsZW1lbnRzIEFzc2V0XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQW4ge0BsaW5rIEFzc2V0fSB3aG9zZSBwaXhlbCBjb250ZW50cyBuZXZlciBjaGFuZ2UuXG4gKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBlbGVtZW50IFRoZVxuICogICAgIHVuZGVybHlpbmcgcGl4ZWwgc291cmNlLlxuICogQHRocm93cyBJZiB0aGUgcGl4ZWwgc291cmNlIGlzIHVuc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBTdGF0aWNBc3NldChlbGVtZW50KSB7XG4gIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgZm9yICh2YXIgdHlwZSBpbiBwcm9wZXJ0eU1hcCkge1xuICAgIGlmIChnbG9iYWxbdHlwZV0gJiYgZWxlbWVudCBpbnN0YW5jZW9mIGdsb2JhbFt0eXBlXSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3dpZHRoUHJvcCA9IHByb3BlcnR5TWFwW3R5cGVdWzBdO1xuICAgICAgdGhpcy5faGVpZ2h0UHJvcCA9IHByb3BlcnR5TWFwW3R5cGVdWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghc3VwcG9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwaXhlbCBzb3VyY2UnKTtcbiAgfVxuXG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xufVxuXG5ldmVudEVtaXR0ZXIoU3RhdGljQXNzZXQpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50O1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50W3RoaXMuX3dpZHRoUHJvcF07XG59O1xuXG5TdGF0aWNBc3NldC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbGVtZW50W3RoaXMuX2hlaWdodFByb3BdO1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5pc0R5bmFtaWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0aWNBc3NldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyk7XG5cbnZhciBkZWZhdWx0U3BlZWQgPSAwLjE7XG52YXIgZGVmYXVsdEFjY2VsID0gMC4wMTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICB5YXdTcGVlZDogZGVmYXVsdFNwZWVkLFxuICBwaXRjaFNwZWVkOiBkZWZhdWx0U3BlZWQsXG4gIGZvdlNwZWVkOiBkZWZhdWx0U3BlZWQsXG4gIHlhd0FjY2VsOiBkZWZhdWx0QWNjZWwsXG4gIHBpdGNoQWNjZWw6IGRlZmF1bHRBY2NlbCxcbiAgZm92QWNjZWw6IGRlZmF1bHRBY2NlbCxcbiAgdGFyZ2V0UGl0Y2g6IDAsXG4gIHRhcmdldEZvdjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnlhd1NwZWVkPTAuMV0gWWF3IG1heGltdW0gc3BlZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5waXRjaFNwZWVkPTAuMV0gUGl0Y2ggbWF4aW11bSBzcGVlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmZvdlNwZWVkPTAuMV0gRm92IG1heGltdW0gc3BlZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy55YXdBY2NlbD0wLjAxXSBZYXcgYWNjZWxlcmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMucGl0Y2hBY2NlbD0wLjAxXSBQaXRjaCBhY2NlbGVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5mb3ZBY2NlbD0wLjAxXSBGb3YgYWNjZWxlcmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMudGFyZ2V0UGl0Y2g9MF0gVmFsdWUgdGhhdCBwaXRjaCBjb252ZXJnZXMgdG8uIGBudWxsYCBtZWFucyB0aGF0IHRoZSBwaXRjaCB3aWxsIG5vdCBjaGFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMudGFyZ2V0Rm92PW51bGxdIFZhbHVlIHRoYXQgZm92IGNvbnZlcmdlcyB0by4gYG51bGxgIG1lYW5zIHRoYXQgdGhlIGZvdiB3aWxsIG5vdCBjaGFuZ2UuXG4gKiBAcmV0dXJucyBNb3ZlbWVudCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIFZpZXdlciNzZXRJZGxlTW92ZW1lbnR9IG9yIHtAbGluayBTY2VuZSNzdGFydE1vdmVtZW50fVxuKi9cbmZ1bmN0aW9uIGF1dG9yb3RhdGUob3B0cykge1xuXG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdmFyIHlhd1NwZWVkID0gb3B0cy55YXdTcGVlZDtcbiAgdmFyIHBpdGNoU3BlZWQgPSBvcHRzLnBpdGNoU3BlZWQ7XG4gIHZhciBmb3ZTcGVlZCA9IG9wdHMuZm92U3BlZWQ7XG4gIHZhciB5YXdBY2NlbCA9IG9wdHMueWF3QWNjZWw7XG4gIHZhciBwaXRjaEFjY2VsID0gb3B0cy5waXRjaEFjY2VsO1xuICB2YXIgZm92QWNjZWwgPSBvcHRzLmZvdkFjY2VsO1xuICB2YXIgdGFyZ2V0UGl0Y2ggPSBvcHRzLnRhcmdldFBpdGNoO1xuICB2YXIgdGFyZ2V0Rm92ID0gb3B0cy50YXJnZXRGb3Y7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHN0YXJ0KCkge1xuXG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgbGFzdFlhd1NwZWVkID0gMDtcbiAgICB2YXIgbGFzdFBpdGNoU3BlZWQgPSAwO1xuICAgIHZhciBsYXN0Rm92U3BlZWQgPSAwO1xuXG4gICAgdmFyIGN1cnJlbnRZYXdTcGVlZCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQaXRjaFNwZWVkID0gMDtcbiAgICB2YXIgY3VycmVudEZvdlNwZWVkID0gMDtcblxuICAgIHZhciB0aW1lRGVsdGE7XG4gICAgdmFyIHlhd0RlbHRhO1xuICAgIHZhciBwaXRjaERlbHRhO1xuICAgIHZhciBmb3ZEZWx0YTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBzdGVwKHBhcmFtcywgY3VycmVudFRpbWUpIHtcblxuICAgICAgdGltZURlbHRhID0gKGN1cnJlbnRUaW1lIC0gbGFzdFRpbWUpIC8gMTAwMDtcbiAgICAgIGN1cnJlbnRZYXdTcGVlZCA9IE1hdGgubWluKGxhc3RZYXdTcGVlZCArIHRpbWVEZWx0YSAqIHlhd0FjY2VsLCB5YXdTcGVlZCk7XG4gICAgICB5YXdEZWx0YSA9IGN1cnJlbnRZYXdTcGVlZCAqIHRpbWVEZWx0YTtcbiAgICAgIHBhcmFtcy55YXcgPSBwYXJhbXMueWF3ICsgeWF3RGVsdGE7XG5cbiAgICAgIGlmICh0YXJnZXRQaXRjaCAhPSBudWxsICYmIHBhcmFtcy5waXRjaCAhPT0gdGFyZ2V0UGl0Y2gpIHtcbiAgICAgICAgdmFyIHBpdGNoVGhyZXNoID0gMC41ICogbGFzdFBpdGNoU3BlZWQgKiBsYXN0UGl0Y2hTcGVlZCAvIHBpdGNoQWNjZWw7XG4gICAgICAgIGlmIChNYXRoLmFicyh0YXJnZXRQaXRjaCAtIHBhcmFtcy5waXRjaCkgPiBwaXRjaFRocmVzaCkge1xuICAgICAgICAgIC8vIEFjY2VsZXJhdGlvbiBwaGFzZVxuICAgICAgICAgIGN1cnJlbnRQaXRjaFNwZWVkID0gTWF0aC5taW4obGFzdFBpdGNoU3BlZWQgKyB0aW1lRGVsdGEgKiBwaXRjaEFjY2VsLCBwaXRjaFNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNlbGVyYXRpb24gcGhhc2VcbiAgICAgICAgICBjdXJyZW50UGl0Y2hTcGVlZCA9IE1hdGgubWF4KGxhc3RQaXRjaFNwZWVkIC0gdGltZURlbHRhICogcGl0Y2hBY2NlbCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudFBpdGNoU3BlZWQgaXMgdGhlIGFic29sdXRlIHZhbHVlICg+PSAwKVxuICAgICAgICBwaXRjaERlbHRhID0gY3VycmVudFBpdGNoU3BlZWQgKiB0aW1lRGVsdGE7XG4gICAgICAgIGlmICh0YXJnZXRQaXRjaCA8IHBhcmFtcy5waXRjaCkge1xuICAgICAgICAgIHBhcmFtcy5waXRjaCA9IE1hdGgubWF4KHRhcmdldFBpdGNoLCBwYXJhbXMucGl0Y2ggLSBwaXRjaERlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0UGl0Y2ggPiBwYXJhbXMucGl0Y2gpIHtcbiAgICAgICAgICBwYXJhbXMucGl0Y2ggPSBNYXRoLm1pbih0YXJnZXRQaXRjaCwgcGFyYW1zLnBpdGNoICsgcGl0Y2hEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldEZvdiAhPSBudWxsICYmIHBhcmFtcy5mb3YgIT09IHRhcmdldFBpdGNoKSB7XG4gICAgICAgIHZhciBmb3ZUaHJlc2ggPSAwLjUgKiBsYXN0Rm92U3BlZWQgKiBsYXN0Rm92U3BlZWQgLyBmb3ZBY2NlbDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRhcmdldEZvdiAtIHBhcmFtcy5mb3YpID4gZm92VGhyZXNoKSB7XG4gICAgICAgICAgLy8gQWNjZWxlcmF0aW9uIHBoYXNlXG4gICAgICAgICAgY3VycmVudEZvdlNwZWVkID0gTWF0aC5taW4obGFzdEZvdlNwZWVkICsgdGltZURlbHRhICogZm92QWNjZWwsIGZvdlNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZWNlbGVyYXRpb24gcGhhc2VcbiAgICAgICAgICBjdXJyZW50Rm92U3BlZWQgPSBNYXRoLm1heChsYXN0Rm92U3BlZWQgLSB0aW1lRGVsdGEgKiBmb3ZBY2NlbCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3VycmVudEZvdlNwZWVkIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSAoPj0gMClcbiAgICAgICAgZm92RGVsdGEgPSBjdXJyZW50Rm92U3BlZWQgKiB0aW1lRGVsdGE7XG4gICAgICAgIGlmICh0YXJnZXRGb3YgPCBwYXJhbXMuZm92KSB7XG4gICAgICAgICAgcGFyYW1zLmZvdiA9IE1hdGgubWF4KHRhcmdldEZvdiwgcGFyYW1zLmZvdiAtIGZvdkRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0Rm92ID4gcGFyYW1zLmZvdikge1xuICAgICAgICAgIHBhcmFtcy5mb3YgPSBNYXRoLm1pbih0YXJnZXRGb3YsIHBhcmFtcy5mb3YgKyBmb3ZEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIGxhc3RZYXdTcGVlZCA9IGN1cnJlbnRZYXdTcGVlZDtcbiAgICAgIGxhc3RQaXRjaFNwZWVkID0gY3VycmVudFBpdGNoU3BlZWQ7XG4gICAgICBsYXN0Rm92U3BlZWQgPSBjdXJyZW50Rm92U3BlZWQ7XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG5cbiAgICB9O1xuXG4gIH07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhdXRvcm90YXRlOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cbi8vIEFuIExydU1hcCBob2xkcyB1cCB0byBhIG1heGltdW0gbnVtYmVyIG9mIGtleS12YWx1ZSBwYWlycywgb3JkZXJlZCBieSB0aGVpclxuLy8gdGltZSBvZiBpbnNlcnRpb24uIFdoZW4gdGhlIGFkZGl0aW9uIG9mIGEga2V5LXZhbHVlIHBhaXIgd291bGQgY2F1c2UgdGhlXG4vLyBjYXBhY2l0eSB0byBiZSBleGNlZWRlZCwgdGhlIG9sZGVzdCBrZXktdmFsdWUgcGFpciBpbiB0aGUgc2V0IGlzIGV2aWN0ZWQuXG4vLyBBcyBhIHNwZWNpYWwgY2FzZSwgYW4gTHJ1TWFwIHdpdGggemVybyBjYXBhY2l0eSBhbHdheXMgcmVqZWN0cyB0aGUgaW5zZXJ0aW9uXG4vLyBvZiBhIGtleS12YWx1ZSBwYWlyLlxuLy9cbi8vIEtleXMgbXVzdCBpbXBsZW1lbnQgaGFzaCgpIGFuZCBlcXVhbHMoKS4gTm90ZSB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0XG4vLyBjdXJyZW50bHkgdXNlIGhhc2goKSwgYnV0IGEgZnV0dXJlIHZlcnNpb24gbWlnaHQuXG5mdW5jdGlvbiBMcnVNYXAoY2FwYWNpdHkpIHtcbiAgaWYgKCFpc0Zpbml0ZShjYXBhY2l0eSkgfHwgTWF0aC5mbG9vcihjYXBhY2l0eSkgIT09IGNhcGFjaXR5IHx8IGNhcGFjaXR5IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTHJ1TWFwOiBpbnZhbGlkIGNhcGFjaXR5Jyk7XG4gIH1cbiAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcblxuICAvLyBLZXlzIGFuZCB2YWx1ZXMgYXJlIHN0b3JlZCBpbiBjaXJjdWxhciBhcnJheXMgb3JkZXJlZCBieSBkZWNyZWFzaW5nIGFnZS5cbiAgLy8gU3RhcnQgaXMgdGhlIGluZGV4IG9mIHRoZSBvbGRlc3Qga2V5L3ZhbHVlIGFuZCBzaXplIGlzIHRoZSBudW1iZXIgb2YgdmFsaWRcbiAgLy8ga2V5L3ZhbHVlczsgdGhlIHJlZ2lvbiBjb250YWluaW5nIHZhbGlkIGtleXMvdmFsdWVzIG1heSB3cmFwIGFyb3VuZC5cbiAgdGhpcy5fa2V5cyA9IG5ldyBBcnJheSh0aGlzLl9jYXBhY2l0eSk7XG4gIHRoaXMuX3ZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLl9jYXBhY2l0eSk7XG4gIHRoaXMuX3N0YXJ0ID0gMDtcbiAgdGhpcy5fc2l6ZSA9IDA7XG59XG5cbkxydU1hcC5wcm90b3R5cGUuX2luZGV4ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gbW9kKHRoaXMuX3N0YXJ0ICsgaSwgdGhpcy5fY2FwYWNpdHkpO1xufTtcblxuLy8gUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5McnVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0tleSA9IHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaSldO1xuICAgIGlmIChrZXkuZXF1YWxzKGV4aXN0aW5nS2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChpKV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gQXNzb2NpYXRlcyB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIHBvc3NpYmx5IHJlcGxhY2luZyB0aGVcbi8vIGN1cnJlbnRseSBhc3NvY2lhdGVkIHZhbHVlLiBUaGUga2V5LXZhbHVlIHBhaXIgYmVjb21lcyB0aGUgbmV3ZXN0LiBJZiB0aGUgbWFwXG4vLyBpcyBhdCBjYXBhY2l0eSwgdGhlIG9sZGVzdCBrZXktdmFsdWUgcGFpciBpcyByZW1vdmVkLiBSZXR1cm5zIHRoZSByZW1vdmVkXG4vLyBrZXksIG9yIG51bGwgb3RoZXJ3aXNlLiBJZiB0aGUgY2FwYWNpdHkgaXMgemVybywgZG9lcyBub3RoaW5nIGFuZCByZXR1cm5zXG4vLyB0aGUga2V5LlxuTHJ1TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIGlmICh0aGlzLl9jYXBhY2l0eSA9PT0gMCkge1xuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgdGhpcy5kZWwoa2V5KTtcbiAgdmFyIGV2aWN0ZWRLZXkgPVxuICAgICAgdGhpcy5fc2l6ZSA9PT0gdGhpcy5fY2FwYWNpdHkgPyB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KDApXSA6IG51bGw7XG4gIHRoaXMuX2tleXNbdGhpcy5faW5kZXgodGhpcy5fc2l6ZSldID0ga2V5O1xuICB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgodGhpcy5fc2l6ZSldID0gdmFsdWU7XG4gIGlmICh0aGlzLl9zaXplIDwgdGhpcy5fY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9zaXplKys7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9pbmRleCgxKTtcbiAgfVxuICByZXR1cm4gZXZpY3RlZEtleTtcbn07XG5cbi8vIFJlbW92ZXMgdGhlIGtleS12YWx1ZSBwYWlyIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cbi8vIFJldHVybnMgdGhlIHJlbW92ZWQgdmFsdWUsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuTHJ1TWFwLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihrZXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBpZiAoa2V5LmVxdWFscyh0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGkpXSkpIHtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGkpXTtcbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgdGhpcy5fc2l6ZSAtIDE7IGorKykge1xuICAgICAgICB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGopXSA9IHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaiArIDEpXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGopXSA9IHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChqICsgMSldO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuTHJ1TWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBpZiAoa2V5LmVxdWFscyh0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGkpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBtYXAuXG5McnVNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG4vLyBSZW1vdmVzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSB0aGUgbWFwLlxuTHJ1TWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oa2V5LCB2YWx1ZSkgZm9yIGVhY2ggaXRlbSBpbiB0aGUgbWFwLCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgbWFwIGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbkxydU1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgZm4odGhpcy5fa2V5c1t0aGlzLl9pbmRleChpKV0sIHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChpKV0pO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMcnVNYXA7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb2QgPSByZXF1aXJlKCcuLi91dGlsL21vZCcpO1xuXG4vLyBBbiBMcnVTZXQgaG9sZHMgdXAgdG8gYSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cywgb3JkZXJlZCBieSB0aGVpciB0aW1lIG9mXG4vLyBpbnNlcnRpb24uIFdoZW4gdGhlIGFkZGl0aW9uIG9mIGFuIGVsZW1lbnQgd291bGQgY2F1c2UgdGhlIGNhcGFjaXR5IHRvIGJlXG4vLyBleGNlZWRlZCwgdGhlIG9sZGVzdCBlbGVtZW50IGluIHRoZSBzZXQgaXMgZXZpY3RlZC4gQXMgYSBzcGVjaWFsIGNhc2UsIGFuXG4vLyBMcnVTZXQgd2l0aCB6ZXJvIGNhcGFjaXR5IGFsd2F5cyByZWplY3RzIHRoZSBpbnNlcnRpb24gb2YgYW4gZWxlbWVudC5cbi8vXG4vLyBFbGVtZW50cyBtdXN0IGltcGxlbWVudCBoYXNoKCkgYW5kIGVxdWFscygpLiBOb3RlIHRoYXQgdGhlIGltcGxlbWVudGF0aW9uXG4vLyBkb2Vzbid0IGN1cnJlbnRseSB1c2UgaGFzaCgpLCBidXQgYSBmdXR1cmUgdmVyc2lvbiBtaWdodC5cbmZ1bmN0aW9uIExydVNldChjYXBhY2l0eSkge1xuICBpZiAoIWlzRmluaXRlKGNhcGFjaXR5KSB8fCBNYXRoLmZsb29yKGNhcGFjaXR5KSAhPT0gY2FwYWNpdHkgfHwgY2FwYWNpdHkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMcnVTZXQ6IGludmFsaWQgY2FwYWNpdHknKTtcbiAgfVxuICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdG9yZWQgaW4gYSBjaXJjdWxhciBhcnJheSBvcmRlcmVkIGJ5IGRlY3JlYXNpbmcgYWdlLlxuICAvLyBTdGFydCBpcyB0aGUgaW5kZXggb2YgdGhlIG9sZGVzdCBlbGVtZW50IGFuZCBzaXplIGlzIHRoZSBudW1iZXIgb2YgdmFsaWRcbiAgLy8gZWxlbWVudHM7IHRoZSByZWdpb24gY29udGFpbmluZyB2YWxpZCBlbGVtZW50cyBtYXkgd3JhcCBhcm91bmQuXG4gIHRoaXMuX2VsZW1lbnRzID0gbmV3IEFycmF5KHRoaXMuX2NhcGFjaXR5KTtcbiAgdGhpcy5fc3RhcnQgPSAwO1xuICB0aGlzLl9zaXplID0gMDtcbn1cblxuTHJ1U2V0LnByb3RvdHlwZS5faW5kZXggPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiBtb2QodGhpcy5fc3RhcnQgKyBpLCB0aGlzLl9jYXBhY2l0eSk7XG59O1xuXG4vLyBBZGRzIGFuIGVsZW1lbnQgaW50byB0aGUgc2V0LCBwb3NzaWJseSByZXBsYWNpbmcgYW4gZXF1YWwgZWxlbWVudCBhbHJlYWR5IGluXG4vLyB0aGUgc2V0LiBUaGUgZWxlbWVudCBiZWNvbWVzIHRoZSBuZXdlc3QuIElmIHRoZSBzZXQgaXMgYXQgY2FwYWNpdHksIHRoZVxuLy8gb2xkZXN0IGVsZW1lbnQgaXMgcmVtb3ZlZC4gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbGVtZW50IGlmIGl0IGRvZXMgbm90IGVxdWFsXG4vLyB0aGUgaW5zZXJ0ZWQgZWxlbWVudCwgb3IgbnVsbCBvdGhlcndpc2UuIElmIHRoZSBjYXBhY2l0eSBpcyB6ZXJvLCBkb2VzXG4vLyBub3RoaW5nIGFuZCByZXR1cm5zIHRoZSBlbGVtZW50LlxuTHJ1U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0aGlzLl9jYXBhY2l0eSA9PT0gMCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICB2YXIgZXZpY3RlZEVsZW1lbnQgPVxuICAgICAgdGhpcy5fc2l6ZSA9PT0gdGhpcy5fY2FwYWNpdHkgPyB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleCgwKV0gOiBudWxsO1xuICB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleCh0aGlzLl9zaXplKV0gPSBlbGVtZW50O1xuICBpZiAodGhpcy5fc2l6ZSA8IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgdGhpcy5fc2l6ZSsrO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5faW5kZXgoMSk7XG4gIH1cbiAgcmV0dXJuIGV2aWN0ZWRFbGVtZW50O1xufTtcblxuLy8gUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIHNldC5cbi8vIFJldHVybnMgdGhlIHJlbW92ZWQgZWxlbWVudCwgb3IgbnVsbCBpZiB0aGUgZWxlbWVudCB3YXMgbm90IGZvdW5kLlxuTHJ1U2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGkpXTtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHMoZXhpc3RpbmdFbGVtZW50KSkge1xuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCB0aGlzLl9zaXplIC0gMTsgaisrKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGopXSA9IHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGogKyAxKV07XG4gICAgICB9XG4gICAgICB0aGlzLl9zaXplLS07XG4gICAgICByZXR1cm4gZXhpc3RpbmdFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJldHVybnMgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoZSBzZXQuXG5McnVTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHModGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaSldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2V0LlxuTHJ1U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuLy8gUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc2V0LlxuTHJ1U2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbGVtZW50cy5sZW5ndGggPSAwO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oZWxlbWVudCkgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgc2V0IGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbkxydVNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgZm4odGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaSldKTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTHJ1U2V0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxudmFyIGRlZmF1bHRDYXBhY2l0eSA9IDY0O1xuXG4vLyBBIG1hcCBkYXRhIHN0cnVjdHVyZSBmb3Iga2V5cyBpbXBsZW1lbnRpbmcgaGFzaCgpIGFuZCBlcXVhbHMoKSBhbmQgYXJiaXRyYXJ5XG4vLyB2YWx1ZXMuIFRoZSBjYXBhY2l0eSwgaWYgZ2l2ZW4sIGlzIGp1c3QgYSBoaW50OyB0aGUgbWFwIGlzIGFsbG93ZWQgdG8gZXhjZWVkXG4vLyBpdCwgYnV0IHBlcmZvcm1hbmNlIG1heSBzdWZmZXIuXG5mdW5jdGlvbiBNYXAoY2FwYWNpdHkpIHtcbiAgaWYgKGNhcGFjaXR5ICE9IG51bGwgJiZcbiAgICAgICghaXNGaW5pdGUoY2FwYWNpdHkpIHx8IE1hdGguZmxvb3IoY2FwYWNpdHkpICE9PSBjYXBhY2l0eSB8fCBjYXBhY2l0eSA8IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXA6IGludmFsaWQgY2FwYWNpdHknKTtcbiAgfVxuICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5IHx8IGRlZmF1bHRDYXBhY2l0eTtcblxuICB0aGlzLl9rZXlCdWNrZXRzID0gW107XG4gIHRoaXMuX3ZhbEJ1Y2tldHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fa2V5QnVja2V0cy5wdXNoKFtdKTtcbiAgICB0aGlzLl92YWxCdWNrZXRzLnB1c2goW10pO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufVxuXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGggPSBtb2Qoa2V5Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1toXTtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gdmFsQnVja2V0W2ldO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gQXNzb2NpYXRlcyB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIHBvc3NpYmx5IHJlcGxhY2luZyB0aGVcbi8vIGN1cnJlbnRseSBhc3NvY2lhdGVkIHZhbHVlLlxuLy8gUmV0dXJucyB0aGUgcmVwbGFjZWQgdmFsdWUsIG9yIG51bGwgaWYgbm8gdmFsdWUgd2FzIHJlcGxhY2VkLlxuTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICB2YXIgaCA9IG1vZChrZXkuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2hdO1xuICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHZhbEJ1Y2tldFtpXTtcbiAgICAgIGtleUJ1Y2tldFtpXSA9IGtleTtcbiAgICAgIHZhbEJ1Y2tldFtpXSA9IHZhbDtcbiAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlO1xuICAgIH1cbiAgfVxuICBrZXlCdWNrZXQucHVzaChrZXkpO1xuICB2YWxCdWNrZXQucHVzaCh2YWwpO1xuICB0aGlzLl9zaXplKys7XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmVtb3ZlcyB0aGUga2V5LXZhbHVlIHBhaXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuLy8gUmV0dXJucyB0aGUgcmVtb3ZlZCB2YWx1ZSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5NYXAucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaCA9IG1vZChrZXkuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2hdO1xuICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHZhbEJ1Y2tldFtpXTtcbiAgICAgIC8vIFNwbGljZSBtYW51YWxseSB0byBhdm9pZCBBcnJheSNzcGxpY2UgcmV0dXJuIHZhbHVlIGFsbG9jYXRpb24uXG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGtleUJ1Y2tldC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAga2V5QnVja2V0W2pdID0ga2V5QnVja2V0W2orMV07XG4gICAgICAgIHZhbEJ1Y2tldFtqXSA9IHZhbEJ1Y2tldFtqKzFdO1xuICAgICAgfVxuICAgICAga2V5QnVja2V0Lmxlbmd0aCA9IGtleUJ1Y2tldC5sZW5ndGggLSAxO1xuICAgICAgdmFsQnVja2V0Lmxlbmd0aCA9IHZhbEJ1Y2tldC5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGggPSBtb2Qoa2V5Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSBrZXlCdWNrZXRbaV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgbWFwLlxuTWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuLy8gUmVtb3ZlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gdGhlIG1hcC5cbk1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fa2V5QnVja2V0c1tpXS5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3ZhbEJ1Y2tldHNbaV0ubGVuZ3RoID0gMDtcbiAgfVxuICB0aGlzLl9zaXplID0gMDtcbn07XG5cbi8vIENhbGxzIGZuKGtleSwgdmFsdWUpIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluIGFuIHVuc3BlY2lmaWVkXG4vLyBvcmRlci4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIGZuIHdhcyBjYWxsZWQuXG4vLyBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIHRoZSBtYXAgaXMgbXV0YXRlZCBkdXJpbmcgaXRlcmF0aW9uLlxuTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdmFyIGtleUJ1Y2tldCA9IHRoaXMuX2tleUJ1Y2tldHNbaV07XG4gICAgdmFyIHZhbEJ1Y2tldCA9IHRoaXMuX3ZhbEJ1Y2tldHNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlCdWNrZXQubGVuZ3RoOyBqKyspIHtcbiAgICAgIGZuKGtleUJ1Y2tldFtqXSwgdmFsQnVja2V0W2pdKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxudmFyIGRlZmF1bHRDYXBhY2l0eSA9IDY0O1xuXG4vLyBBIHNldCBkYXRhIHN0cnVjdHVyZSBmb3IgZWxlbWVudHMgaW1wbGVtZW50aW5nIGhhc2goKSBhbmQgZXF1YWxzKCkuXG4vLyBUaGUgY2FwYWNpdHksIGlmIGdpdmVuLCBpcyBqdXN0IGEgaGludDsgdGhlIHNldCBpcyBhbGxvd2VkIHRvIGV4Y2VlZCBpdCwgYnV0XG4vLyBwZXJmb3JtYW5jZSBtYXkgc3VmZmVyLlxuZnVuY3Rpb24gU2V0KGNhcGFjaXR5KSB7XG4gIGlmIChjYXBhY2l0eSAhPSBudWxsICYmXG4gICAgICAoIWlzRmluaXRlKGNhcGFjaXR5KSB8fCBNYXRoLmZsb29yKGNhcGFjaXR5KSAhPT0gY2FwYWNpdHkgfHwgY2FwYWNpdHkgPCAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2V0OiBpbnZhbGlkIGNhcGFjaXR5Jyk7XG4gIH1cbiAgdGhpcy5fY2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eSB8fCBkZWZhdWx0Q2FwYWNpdHk7XG5cbiAgdGhpcy5fYnVja2V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB0aGlzLl9idWNrZXRzLnB1c2goW10pO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufVxuXG4vLyBBZGRzIGFuIGVsZW1lbnQsIHJlcGxhY2luZyBhbiBleGlzdGluZyBlbGVtZW50LlxuLy8gUmV0dXJucyB0aGUgcmVwbGFjZWQgZWxlbWVudCwgb3IgbnVsbCBpZiBubyBlbGVtZW50IHdhcyByZXBsYWNlZC5cblNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgaCA9IG1vZChlbGVtZW50Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIgYnVja2V0ID0gdGhpcy5fYnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdFbGVtZW50ID0gYnVja2V0W2ldO1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhleGlzdGluZ0VsZW1lbnQpKSB7XG4gICAgICBidWNrZXRbaV0gPSBlbGVtZW50O1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRWxlbWVudDtcbiAgICB9XG4gIH1cbiAgYnVja2V0LnB1c2goZWxlbWVudCk7XG4gIHRoaXMuX3NpemUrKztcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZW1vdmVzIGFuIGVsZW1lbnQuXG4vLyBSZXR1cm5zIHRoZSByZW1vdmVkIGVsZW1lbnQsIG9yIG51bGwgaWYgdGhlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZC5cblNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgaCA9IG1vZChlbGVtZW50Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIgYnVja2V0ID0gdGhpcy5fYnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdFbGVtZW50ID0gYnVja2V0W2ldO1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhleGlzdGluZ0VsZW1lbnQpKSB7XG4gICAgICAvLyBTcGxpY2UgbWFudWFsbHkgdG8gYXZvaWQgQXJyYXkjc3BsaWNlIHJldHVybiB2YWx1ZSBhbGxvY2F0aW9uLlxuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBidWNrZXQubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgIGJ1Y2tldFtqXSA9IGJ1Y2tldFtqKzFdO1xuICAgICAgfVxuICAgICAgYnVja2V0Lmxlbmd0aCA9IGJ1Y2tldC5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGUgc2V0LlxuU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBoID0gbW9kKGVsZW1lbnQuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBidWNrZXQgPSB0aGlzLl9idWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0VsZW1lbnQgPSBidWNrZXRbaV07XG4gICAgaWYgKGVsZW1lbnQuZXF1YWxzKGV4aXN0aW5nRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNldC5cblNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbi8vIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldC5cblNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fYnVja2V0c1tpXS5sZW5ndGggPSAwO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oZWxlbWVudCkgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgc2V0IGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cblNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHZhciBidWNrZXQgPSB0aGlzLl9idWNrZXRzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVja2V0Lmxlbmd0aDsgaisrKSB7XG4gICAgICBmbihidWNrZXRbal0pO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBXb3JrUXVldWUgPSByZXF1aXJlKCcuL1dvcmtRdWV1ZScpO1xudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cblxuZnVuY3Rpb24gV29ya1Bvb2wob3B0cykge1xuICB0aGlzLl9jb25jdXJyZW5jeSA9IG9wdHMgJiYgb3B0cy5jb25jdXJyZW5jeSB8fCAxO1xuICB0aGlzLl9wYXVzZWQgPSBvcHRzICYmICEhb3B0cy5wYXVzZWQgfHwgZmFsc2U7XG5cbiAgdGhpcy5fcG9vbCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbmN1cnJlbmN5OyBpKyspIHtcbiAgICB0aGlzLl9wb29sLnB1c2gobmV3IFdvcmtRdWV1ZShvcHRzKSk7XG4gIH1cblxuICB0aGlzLl9uZXh0ID0gMDtcbn1cblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bvb2wubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gdGhpcy5fcG9vbFtpXS5sZW5ndGgoKTtcbiAgfVxuICByZXR1cm4gbGVuO1xufTtcblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGZuLCBjYikge1xuICB2YXIgaSA9IHRoaXMuX25leHQ7XG4gIHZhciBjYW5jZWwgPSB0aGlzLl9wb29sW2ldLnB1c2goZm4sIGNiKTtcbiAgdGhpcy5fbmV4dCA9IG1vZCh0aGlzLl9uZXh0ICsgMSwgdGhpcy5fY29uY3VycmVuY3kpO1xuICByZXR1cm4gY2FuY2VsO1xufTtcblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgdGhpcy5fcG9vbFtpXS5wYXVzZSgpO1xuICAgIH1cbiAgfVxufTtcblxuXG5Xb3JrUG9vbC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgIHRoaXMuX3Bvb2xbaV0ucmVzdW1lKCk7XG4gICAgfVxuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV29ya1Bvb2w7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub3cgPSByZXF1aXJlKCcuLi91dGlsL25vdycpO1xuXG5cbmZ1bmN0aW9uIFdvcmtUYXNrKGZuLCBjYikge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5jZm4gPSBudWxsO1xufVxuXG5cbmZ1bmN0aW9uIFdvcmtRdWV1ZShvcHRzKSB7XG4gIHRoaXMuX3F1ZXVlID0gW107XG4gIHRoaXMuX2RlbGF5ID0gb3B0cyAmJiBvcHRzLmRlbGF5IHx8IDA7XG4gIHRoaXMuX3BhdXNlZCA9IG9wdHMgJiYgISFvcHRzLnBhdXNlZCB8fCBmYWxzZTtcbiAgdGhpcy5fY3VycmVudFRhc2sgPSBudWxsO1xuICB0aGlzLl9sYXN0RmluaXNoZWQgPSBudWxsO1xufVxuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGZuLCBjYikge1xuXG4gIHZhciB0YXNrID0gbmV3IFdvcmtUYXNrKGZuLCBjYik7XG5cbiAgdmFyIGNhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMsIHRhc2spO1xuXG4gIC8vIFB1c2ggdGhlIHRhc2sgaW50byB0aGUgcXVldWUuXG4gIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG5cbiAgLy8gUnVuIHRoZSB0YXNrIGlmIGlkbGUuXG4gIHRoaXMuX25leHQoKTtcblxuICByZXR1cm4gY2FuY2VsO1xuXG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICB9XG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9uZXh0KCk7XG4gIH1cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbih0YXNrKSB7XG5cbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmICh0aGlzLl9jdXJyZW50VGFzaykge1xuICAgIHRocm93IG5ldyBFcnJvcignV29ya1F1ZXVlOiBjYWxsZWQgc3RhcnQgd2hpbGUgcnVubmluZyB0YXNrJyk7XG4gIH1cblxuICAvLyBNYXJrIHF1ZXVlIGFzIGJ1c3ksIHNvIHRoYXQgY29uY3VycmVudCB0YXNrcyB3YWl0LlxuICB0aGlzLl9jdXJyZW50VGFzayA9IHRhc2s7XG5cbiAgLy8gRXhlY3V0ZSB0aGUgdGFzay5cbiAgdmFyIGZpbmlzaCA9IHRoaXMuX2ZpbmlzaC5iaW5kKHRoaXMsIHRhc2spO1xuICB0YXNrLmNmbiA9IHRhc2suZm4oZmluaXNoKTtcblxuICAvLyBEZXRlY3Qgd2hlbiBhIG5vbi1jYW5jZWxsYWJsZSBmdW5jdGlvbiBoYXMgYmVlbiBxdWV1ZWQuXG4gIGlmICh0eXBlb2YgdGFzay5jZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtRdWV1ZTogZnVuY3Rpb24gaXMgbm90IGNhbmNlbGxhYmxlJyk7XG4gIH1cblxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbih0YXNrKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAodGhpcy5fY3VycmVudFRhc2sgIT09IHRhc2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtRdWV1ZTogY2FsbGVkIGZpbmlzaCBvbiB3cm9uZyB0YXNrJyk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSB0YXNrIGNhbGxiYWNrIG9uIHRoZSByZXR1cm4gdmFsdWVzLlxuICB0YXNrLmNiLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gIC8vIE1hcmsgYXMgbm90IGJ1c3kgYW5kIHJlY29yZCB0YXNrIGZpbmlzaCB0aW1lLCB0aGVuIGFkdmFuY2UgdG8gbmV4dCB0YXNrLlxuICB0aGlzLl9jdXJyZW50VGFzayA9IG51bGw7XG4gIHRoaXMuX2xhc3RGaW5pc2hlZCA9IG5vdygpO1xuICB0aGlzLl9uZXh0KCk7XG5cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24odGFzaykge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpZiAodGhpcy5fY3VycmVudFRhc2sgPT09IHRhc2spIHtcblxuICAgIC8vIENhbmNlbCBydW5uaW5nIHRhc2suIEJlY2F1c2UgY2FuY2VsIHBhc3NlcyBjb250cm9sIHRvIHRoZSBfZmluaXNoXG4gICAgLy8gY2FsbGJhY2sgd2UgcGFzc2VkIGludG8gZm4sIHRoZSBjbGVhbnVwIGxvZ2ljIHdpbGwgYmUgaGFuZGxlZCB0aGVyZS5cbiAgICB0YXNrLmNmbi5hcHBseShudWxsLCBhcmdzKTtcblxuICB9IGVsc2Uge1xuXG4gICAgLy8gUmVtb3ZlIHRhc2sgZnJvbSBxdWV1ZS5cbiAgICB2YXIgcG9zID0gdGhpcy5fcXVldWUuaW5kZXhPZih0YXNrKTtcbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShwb3MsIDEpO1xuICAgICAgdGFzay5jYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgLy8gRG8gbm90IHN0YXJ0IHRhc2tzIHdoaWxlIHBhdXNlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgIC8vIE5vIHRhc2tzIHRvIHJ1bi5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fY3VycmVudFRhc2spIHtcbiAgICAvLyBXaWxsIGJlIGNhbGxlZCBhZ2FpbiB3aGVuIHRoZSBjdXJyZW50IHRhc2sgZmluaXNoZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xhc3RGaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgdmFyIGVsYXBzZWQgPSBub3coKSAtIHRoaXMuX2xhc3RGaW5pc2hlZDtcbiAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5fZGVsYXkgLSBlbGFwc2VkO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAvLyBUb28gc29vbi4gUnVuIGFnYWluIGFmdGVyIHRoZSBpbnRlci10YXNrIGRlbGF5LlxuICAgICAgc2V0VGltZW91dCh0aGlzLl9uZXh0LmJpbmQodGhpcyksIHJlbWFpbmluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gUnVuIHRoZSBuZXh0IHRhc2suXG4gIHZhciB0YXNrID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgdGhpcy5fc3RhcnQodGFzayk7XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrUXVldWU7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb2xvciB0cmFuc2Zvcm1hdGlvbiB7QGxpbmsgRWZmZWN0c30uXG4gKlxuICogUmVmZXJlbmNlczpcbiAqXG4gKiAgIC0gW0NvbG9yTWF0cml4IEd1aWRlXShodHRwOi8vZG9jcy5yYWlubWV0ZXIubmV0L3RpcHMvY29sb3JtYXRyaXgtZ3VpZGUpXG4gKiAgIC0gW01hdHJpeCBPcGVyYXRpb25zIGZvciBJbWFnZSBQcm9jZXNzaW5nXShodHRwOi8vd3d3LmdyYWZpY2FvYnNjdXJhLmNvbS9tYXRyaXgvaW5kZXguaHRtbClcbiAqICAgLSBbV2ViR0xJbWFnZUZpbHRlcl0oaHR0cHM6Ly9naXRodWIuY29tL3Bob2Jvc2xhYi9XZWJHTEltYWdlRmlsdGVyKVxuICogICAtIFtnbGZ4LmpzXShodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcylcbiAqXG4gKiBAbmFtZXNwYWNlIGNvbG9yRWZmZWN0c1xuICovXG5cbi8qKlxuICogQSB2ZWN0b3IgYW5kIG1hdHJpeCBjb3JyZXNwb25kaW5nIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgT2JqZWN0IHRvIHN0b3JlIHJlc3VsdFxuICogQHBhcmFtIHt2ZWM0fSByZXN1bHQuY29sb3JPZmZzZXQgQXJyYXkgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0ge21hdDR9IHJlc3VsdC5jb2xvck1hdHJpeCBJZGVudGl0eSBtYXRyaXguXG4gKlxuICogQG1lbWJlcm9mIGNvbG9yRWZmZWN0c1xuICovXG5mdW5jdGlvbiBpZGVudGl0eShyZXN1bHRBcmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlc3VsdEFyZyB8fCB7fTtcbiAgcmVzdWx0LmNvbG9yT2Zmc2V0ID0gcmVzdWx0LmNvbG9yT2Zmc2V0IHx8IHZlYzQuY3JlYXRlKCk7XG4gIHJlc3VsdC5jb2xvck1hdHJpeCA9IHJlc3VsdC5jb2xvck1hdHJpeCB8fCBtYXQ0LmNyZWF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGx5IGNvbG9yIGVmZmVjdHMgdG8gYSBzaW5nbGUgcGl4ZWxcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHBpeGVsIFZhbHVlcyBpbiByYW5nZSBbMCwxXVxuICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdFxuICogQHBhcmFtIHt2ZWM0fSBlZmZlY3QuY29sb3JPZmZzZXRcbiAqIEBwYXJhbSB7bWF0NH0gZWZmZWN0LmNvbG9yTWF0cml4XG4gKiBAcGFyYW0ge3ZlYzR9IHJlc3VsdCBPYmplY3QgdG8gc3RvcmUgcmVzdWx0XG4gKlxuICogQG1lbWJlcm9mIGNvbG9yRWZmZWN0c1xuICovXG5mdW5jdGlvbiBhcHBseVRvUGl4ZWwocGl4ZWwsIGVmZmVjdCwgcmVzdWx0KSB7XG4gIHZlYzRUcmFuc2Zvcm1NYXQ0VHJhbnNwb3NlZChyZXN1bHQsIHBpeGVsLCBlZmZlY3QuY29sb3JNYXRyaXgpO1xuICB2ZWM0LmFkZChyZXN1bHQsIHJlc3VsdCwgZWZmZWN0LmNvbG9yT2Zmc2V0KTtcbn1cblxuLy8gT2RkbHksIHRoZSBjb2xvclRyYW5zZm9ybSBtYXRyaXggbmVlZHMgdG8gYmUgdHJhbnNwb3NlZCB0byBiZSB1c2VkIHdpdGhcbi8vIHZlYzQudHJhbnNmb3JtTWF0NC4gSXQgaXMgc3RyYW5nZSB0aGF0IHRyYW5zZm9ybU1hdDQgZG9zbid0IHdvcmsgdGhlIHNhbWVcbi8vIHdheSBhcyBtdWx0aXBseWluZyBvbiB0aGUgc2hhZGVyLlxuLy8gVE9ETzogaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyXG5mdW5jdGlvbiB2ZWM0VHJhbnNmb3JtTWF0NFRyYW5zcG9zZWQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzFdICogeSArIG1bMl0gKiB6ICsgbVszXSAqIHc7XG4gIG91dFsxXSA9IG1bNF0gKiB4ICsgbVs1XSAqIHkgKyBtWzZdICogeiArIG1bN10gKiB3O1xuICBvdXRbMl0gPSBtWzhdICogeCArIG1bOV0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxMV0gKiB3O1xuICBvdXRbM10gPSBtWzEyXSAqIHggKyBtWzEzXSAqIHkgKyBtWzE0XSAqIHogKyBtWzE1XSAqIHc7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQXBwbHkgY29sb3IgZWZmZWN0cyB0byBhbiBJbWFnZURhdGFcbiAqXG4gKiBAcGFyYW0ge0ltYWdlRGF0YX0gaW1hZ2VEYXRhIFRoaXMgb2JqZWN0IHdpbGwgYmUgbXV0YXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdFxuICogQHBhcmFtIHt2ZWM0fSBlZmZlY3QuY29sb3JPZmZzZXRcbiAqIEBwYXJhbSB7bWF0NH0gZWZmZWN0LmNvbG9yTWF0cml4XG4gKlxuICogQG1lbWJlcm9mIGNvbG9yRWZmZWN0c1xuICovXG52YXIgdG1wUGl4ZWwgPSB2ZWM0LmNyZWF0ZSgpO1xuZnVuY3Rpb24gYXBwbHlUb0ltYWdlRGF0YShpbWFnZURhdGEsIGVmZmVjdCkge1xuICB2YXIgd2lkdGggPSBpbWFnZURhdGEud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB3aWR0aCAqIGhlaWdodDsgaSsrKSB7XG4gICAgdmVjNC5zZXQodG1wUGl4ZWwsIGRhdGFbaSo0KzBdLzI1NSwgZGF0YVtpKjQrMV0vMjU1LCBkYXRhW2kqNCsyXS8yNTUsIGRhdGFbaSo0KzNdLzI1NSk7XG4gICAgYXBwbHlUb1BpeGVsKHRtcFBpeGVsLCBlZmZlY3QsIHRtcFBpeGVsKTtcbiAgICBkYXRhW2kqNCswXSA9IHRtcFBpeGVsWzBdKjI1NTtcbiAgICBkYXRhW2kqNCsxXSA9IHRtcFBpeGVsWzFdKjI1NTtcbiAgICBkYXRhW2kqNCsyXSA9IHRtcFBpeGVsWzJdKjI1NTtcbiAgICBkYXRhW2kqNCszXSA9IHRtcFBpeGVsWzNdKjI1NTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaWRlbnRpdHk6IGlkZW50aXR5LFxuICBhcHBseVRvUGl4ZWw6IGFwcGx5VG9QaXhlbCxcbiAgYXBwbHlUb0ltYWdlRGF0YTogYXBwbHlUb0ltYWdlRGF0YVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIG5vdyA9IHJlcXVpcmUoJy4uL3V0aWwvbm93Jyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQ29udHJvbENvbXBvc2VyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29tYmluZXMgY2hhbmdlcyBpbiBwYXJhbWV0ZXJzIHRyaWdnZXJlZCBieSBtdWx0aXBsZSB7QGxpbmsgQ29udHJvbE1ldGhvZH1cbiAqIGluc3RhbmNlcy5cbiAqXG4gKiBAbGlzdGVucyBDb250cm9sTWV0aG9kI3BhcmFtZXRlckR5bmFtaWNzXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xDb21wb3NlcihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX21ldGhvZHMgPSBbXTtcblxuICB0aGlzLl9wYXJhbWV0ZXJzID0gWyAneCcgLCd5JywgJ2F4aXNTY2FsZWRYJywgJ2F4aXNTY2FsZWRZJywgJ3pvb20nLCAneWF3JywgJ3BpdGNoJywgJ3JvbGwnIF07XG5cbiAgdGhpcy5fbm93ID0gb3B0cy5ub3dGb3JUZXN0aW5nIHx8IG5vdztcblxuICB0aGlzLl9jb21wb3NlZE9mZnNldHMgPSB7IH07XG5cbiAgdGhpcy5fY29tcG9zZVJldHVybiA9IHsgb2Zmc2V0czogdGhpcy5fY29tcG9zZWRPZmZzZXRzLCBjaGFuZ2luZzogbnVsbCB9O1xufVxuXG5ldmVudEVtaXR0ZXIoQ29udHJvbENvbXBvc2VyKTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGlmICh0aGlzLmhhcyhpbnN0YW5jZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZHluYW1pY3MgPSB7fTtcbiAgdGhpcy5fcGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuICAgIGR5bmFtaWNzW3BhcmFtZXRlcl0gPSB7XG4gICAgICBkeW5hbWljczogbmV3IER5bmFtaWNzKCksXG4gICAgICB0aW1lOiBudWxsXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHBhcmFtZXRlckR5bmFtaWNzSGFuZGxlciA9IHRoaXMuX3VwZGF0ZUR5bmFtaWNzLmJpbmQodGhpcywgZHluYW1pY3MpO1xuXG4gIHZhciBtZXRob2QgPSB7XG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIGR5bmFtaWNzOiBkeW5hbWljcyxcbiAgICBwYXJhbWV0ZXJEeW5hbWljc0hhbmRsZXI6IHBhcmFtZXRlckR5bmFtaWNzSGFuZGxlclxuICB9O1xuXG4gIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BhcmFtZXRlckR5bmFtaWNzJywgcGFyYW1ldGVyRHluYW1pY3NIYW5kbGVyKTtcblxuICB0aGlzLl9tZXRob2RzLnB1c2gobWV0aG9kKTtcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleE9mSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgbWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhcmFtZXRlckR5bmFtaWNzJywgbWV0aG9kLnBhcmFtZXRlckR5bmFtaWNzSGFuZGxlcik7XG4gIH1cbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICByZXR1cm4gdGhpcy5faW5kZXhPZkluc3RhbmNlKGluc3RhbmNlKSA+PSAwO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLl9pbmRleE9mSW5zdGFuY2UgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5fbWV0aG9kc1tpXS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5zdGFuY2VzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RhbmNlcy5wdXNoKHRoaXMuX21ldGhvZHNbaV0uaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZXM7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuX3VwZGF0ZUR5bmFtaWNzID0gZnVuY3Rpb24oc3RvcmVkRHluYW1pY3MsIHBhcmFtZXRlciwgZHluYW1pY3MpIHtcbiAgdmFyIHBhcmFtZXRlckR5bmFtaWNzID0gc3RvcmVkRHluYW1pY3NbcGFyYW1ldGVyXTtcblxuICBpZiAoIXBhcmFtZXRlckR5bmFtaWNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb250cm9sIHBhcmFtZXRlciBcIiArIHBhcmFtZXRlcik7XG4gIH1cblxuICB2YXIgbmV3VGltZSA9IHRoaXMuX25vdygpO1xuICBwYXJhbWV0ZXJEeW5hbWljcy5keW5hbWljcy51cGRhdGUoZHluYW1pY3MsIChuZXdUaW1lIC0gcGFyYW1ldGVyRHluYW1pY3MudGltZSkvMTAwMCk7XG4gIHBhcmFtZXRlckR5bmFtaWNzLnRpbWUgPSBuZXdUaW1lO1xuXG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuX3Jlc2V0Q29tcG9zZWRPZmZzZXRzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2NvbXBvc2VkT2Zmc2V0c1t0aGlzLl9wYXJhbWV0ZXJzW2ldXSA9IDA7XG4gIH1cbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5vZmZzZXRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbWV0ZXI7XG4gIHZhciBjaGFuZ2luZyA9IGZhbHNlO1xuXG4gIHZhciBjdXJyZW50VGltZSA9IHRoaXMuX25vdygpO1xuXG4gIHRoaXMuX3Jlc2V0Q29tcG9zZWRPZmZzZXRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1ldGhvZER5bmFtaWNzID0gdGhpcy5fbWV0aG9kc1tpXS5keW5hbWljcztcblxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgdGhpcy5fcGFyYW1ldGVycy5sZW5ndGg7IHArKykge1xuICAgICAgcGFyYW1ldGVyID0gdGhpcy5fcGFyYW1ldGVyc1twXTtcbiAgICAgIHZhciBwYXJhbWV0ZXJEeW5hbWljcyA9IG1ldGhvZER5bmFtaWNzW3BhcmFtZXRlcl07XG4gICAgICB2YXIgZHluYW1pY3MgPSBwYXJhbWV0ZXJEeW5hbWljcy5keW5hbWljcztcblxuXG4gICAgICAvLyBBZGQgb2Zmc2V0IHRvIGNvbXBvc2VkIG9mZnNldFxuICAgICAgaWYgKGR5bmFtaWNzLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2VkT2Zmc2V0c1twYXJhbWV0ZXJdICs9IGR5bmFtaWNzLm9mZnNldDtcbiAgICAgICAgLy8gUmVzZXQgb2Zmc2V0XG4gICAgICAgIGR5bmFtaWNzLm9mZnNldCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgZnJvbSB2ZWxvY2l0eSBhbmQgYWRkIGl0XG4gICAgICB2YXIgZWxhcHNlZCA9IChjdXJyZW50VGltZSAtIHBhcmFtZXRlckR5bmFtaWNzLnRpbWUpLzEwMDA7XG4gICAgICB2YXIgb2Zmc2V0RnJvbVZlbG9jaXR5ID0gZHluYW1pY3Mub2Zmc2V0RnJvbVZlbG9jaXR5KGVsYXBzZWQpO1xuXG4gICAgICBpZihvZmZzZXRGcm9tVmVsb2NpdHkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zZWRPZmZzZXRzW3BhcmFtZXRlcl0gKz0gb2Zmc2V0RnJvbVZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgb24gZHluYW1pY3NcbiAgICAgIHZhciBjdXJyZW50VmVsb2NpdHkgPSBkeW5hbWljcy52ZWxvY2l0eUFmdGVyKGVsYXBzZWQpO1xuICAgICAgZHluYW1pY3MudmVsb2NpdHkgPSBjdXJyZW50VmVsb2NpdHk7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIHN0aWxsIGEgdmVsb2NpdHksIHNldCBjaGFuZ2luZ1xuICAgICAgaWYoY3VycmVudFZlbG9jaXR5KSB7XG4gICAgICAgIGNoYW5naW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFyYW1ldGVyRHluYW1pY3MudGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NvbXBvc2VSZXR1cm4uY2hhbmdpbmcgPSBjaGFuZ2luZztcbiAgcmV0dXJuIHRoaXMuX2NvbXBvc2VSZXR1cm47XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5zdGFuY2VzID0gdGhpcy5saXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5yZW1vdmUoaW5zdGFuY2VzW2ldKTtcbiAgfVxuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb250cm9sQ29tcG9zZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVmYXVsdE9wdHMgPSB7XG4gIGFjdGl2ZTogJ21vdmUnLFxuICBpbmFjdGl2ZTogJ2RlZmF1bHQnLFxuICBkaXNhYmxlZDogJ2RlZmF1bHQnXG59O1xuXG4vKipcbiAqIEBjbGFzcyBDb250cm9sQ3Vyc29yXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0cyB0aGUgQ1NTIGN1cnNvciBvbiBhIERPTSBlbGVtZW50IGFjY29yZGluZyB0byB0aGUgc3RhdGUgb2YgYVxuICoge0BsaW5rIENvbnRyb2xNZXRob2R9LlxuICpcbiAqIEBwYXJhbSB7Q29udHJvbHN9IGNvbnRyb2xzIENvbnRyb2xzIGluc3RhbmNlIGNvbnRhaW5pbmcgdGhlIGNvbnRyb2wgbWV0aG9kLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBjb250cm9sIG1ldGhvZC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBET00gZWxlbWVudCB3aGVyZSB0aGUgY3Vyc29yIHNob3VsZCBiZSBzZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgY29udHJvbCBjdXJzb3JzLiBFYWNoIGZpZWxkIG11c3QgYmUgYSB2YWxpZCB2YWx1ZVxuICogICAgIGZvciB0aGUgYGN1cnNvcmAgQ1NTIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmFjdGl2ZT0nbW92ZSddIEN1cnNvciB0byBzZXQgd2hlbiB0aGUgY29udHJvbCBtZXRob2RcbiAqICAgICBpcyBlbmFibGVkIGFuZCBhY3RpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaW5hY3RpdmU9J2RlZmF1bHQnXSBDdXJzb3IgdG8gc2V0IHdoZW4gdGhlIGNvbnRyb2xcbiAqICAgICBtZXRob2QgaXMgZW5hYmxlZCBhbmQgaW5hY3RpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZGlzYWJsZWQ9J2RlZmF1bHQnXSBDdXJzb3IgdG8gc2V0IHdoZW4gdGhlIGNvbnRyb2xcbiAqICAgICBtZXRob2QgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xDdXJzb3IoY29udHJvbHMsIGlkLCBlbGVtZW50LCBvcHRzKSB7XG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0cyk7XG5cbiAgLy8gVE9ETzogVGhpcyBjbGFzcyBtYXkgbWlzYmVoYXZlIGlmIHRoZSBjb250cm9sIG1ldGhvZCBpcyB1bnJlZ2lzdGVyZWQgYW5kIGFcbiAgLy8gZGlmZmVyZW50IGNvbnRyb2wgbWV0aG9kIGlzIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNhbWUgaWQuXG5cbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX2NvbnRyb2xzID0gY29udHJvbHM7XG4gIHRoaXMuX2lkID0gaWQ7XG5cbiAgdGhpcy5fYXR0YWNoZWQgPSBmYWxzZTtcblxuICB0aGlzLl9zZXRBY3RpdmVDdXJzb3IgPSB0aGlzLl9zZXRDdXJzb3IuYmluZCh0aGlzLCBvcHRzLmFjdGl2ZSk7XG4gIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgb3B0cy5pbmFjdGl2ZSk7XG4gIHRoaXMuX3NldERpc2FibGVkQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgb3B0cy5kaXNhYmxlZCk7XG4gIHRoaXMuX3NldE9yaWdpbmFsQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgdGhpcy5fZWxlbWVudC5zdHlsZS5jdXJzb3IpO1xuXG4gIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyID0gdGhpcy5fdXBkYXRlQXR0YWNobWVudC5iaW5kKHRoaXMpO1xuXG4gIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ21ldGhvZEVuYWJsZWQnLCB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ21ldGhvZERpc2FibGVkJywgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkJywgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdkaXNhYmxlZCcsIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcblxuICB0aGlzLl91cGRhdGVBdHRhY2htZW50KCk7XG59XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuQ29udHJvbEN1cnNvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9kZXRhY2hGcm9tQ29udHJvbE1ldGhvZCh0aGlzLl9jb250cm9scy5tZXRob2QodGhpcy5faWQpKTtcbiAgdGhpcy5fc2V0T3JpZ2luYWxDdXJzb3IoKTtcblxuICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXRob2RFbmFibGVkJyxcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWV0aG9kRGlzYWJsZWQnLFxuICAgICAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmFibGVkJyxcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzYWJsZWQnLFxuICAgICAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl91cGRhdGVBdHRhY2htZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250cm9scyA9IHRoaXMuX2NvbnRyb2xzO1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgaWYgKGNvbnRyb2xzLmVuYWJsZWQoKSAmJiBjb250cm9scy5tZXRob2QoaWQpLmVuYWJsZWQpIHtcbiAgICB0aGlzLl9hdHRhY2hUb0NvbnRyb2xNZXRob2QoY29udHJvbHMubWV0aG9kKGlkKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGV0YWNoRnJvbUNvbnRyb2xNZXRob2QoY29udHJvbHMubWV0aG9kKGlkKSk7XG4gIH1cbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl9hdHRhY2hUb0NvbnRyb2xNZXRob2QgPSBmdW5jdGlvbihjb250cm9sTWV0aG9kKSB7XG4gIGlmICghdGhpcy5fYXR0YWNoZWQpIHtcbiAgICBjb250cm9sTWV0aG9kLmluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2ZScsIHRoaXMuX3NldEFjdGl2ZUN1cnNvcik7XG4gICAgY29udHJvbE1ldGhvZC5pbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCdpbmFjdGl2ZScsIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yKTtcblxuICAgIGlmIChjb250cm9sTWV0aG9kLmFjdGl2ZSkge1xuICAgICAgdGhpcy5fc2V0QWN0aXZlQ3Vyc29yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYXR0YWNoZWQgPSB0cnVlO1xuICB9XG59O1xuXG5Db250cm9sQ3Vyc29yLnByb3RvdHlwZS5fZGV0YWNoRnJvbUNvbnRyb2xNZXRob2QgPSBmdW5jdGlvbihjb250cm9sTWV0aG9kKSB7XG4gIGlmICh0aGlzLl9hdHRhY2hlZCkge1xuICAgIGNvbnRyb2xNZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgdGhpcy5fc2V0QWN0aXZlQ3Vyc29yKTtcbiAgICBjb250cm9sTWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2luYWN0aXZlJywgdGhpcy5fc2V0SW5hY3RpdmVDdXJzb3IpO1xuXG4gICAgdGhpcy5fc2V0RGlzYWJsZWRDdXJzb3IoKTtcblxuICAgIHRoaXMuX2F0dGFjaGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl9zZXRDdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgdGhpcy5fZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbEN1cnNvcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIENvbXBvc2VyID0gcmVxdWlyZSgnLi9Db21wb3NlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBNQVJaSVBBTk9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgTUFSWklQQU5PREVCVUcuY29udHJvbHM7XG5cbi8qKlxuICogQGNsYXNzIENvbnRyb2xzXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0IG9mIGNvbnRyb2xzIHdoaWNoIGFmZmVjdCBhIHZpZXcgKGUuZy4ga2V5Ym9hcmQsIHRvdWNoKVxuICpcbiAqIHtAbGluayBDb250cm9sTWV0aG9kfSBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgb24gdGhpcyBjbGFzcy4gVGhlIG1ldGhvZHNcbiAqIGFyZSB0aGVuIGNvbWJpbmVkIHRvIGNhbGN1bGF0ZSB0aGUgZmluYWwgcGFyYW1ldGVycyB0byBjaGFuZ2UgdGhlIHtAbGluayBWaWV3fS5cbiAqXG4gKiBDb250cm9scyBpcyBhdHRhY2hlZCB0byBhIHtAbGluayBSZW5kZXJMb29wfS4gQ3VycmVudGx5IGl0IGFmZmVjdHMgdGhlXG4gKiB7QGxpbmsgdmlld30gb2YgYWxsIHtAbGluayBMYXllcn0gb24gdGhlIHtAbGluayBTdGFnZX0gb2YgdGhlXG4gKiB7QGxpbmsgUmVuZGVyTG9vcH0gaXQgaXMgYXR0YWNoZWQgdG8uIEEgbW9yZSBmbGV4aWJsZSBBUEkgbWF5IGJlIHByb3ZpZGVkXG4gKiBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIFRoZSBDb250cm9sTWV0aG9kIGluc3RhbmNlcyBhcmUgcmVnaXN0ZXJlZCB3aXRoIGFuIGlkIGFuZCBtYXkgYmUgZW5hYmxlZCxcbiAqIGRpc2FibGVkIGFuZCB1bnJlZ2lzdGVyZWQgdXNpbmcgdGhhdCBpZC4gVGhlIHdob2xlIENvbnRyb2wgY2FuIGFsc28gYmVcbiAqIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gKlxuICovXG5mdW5jdGlvbiBDb250cm9scyhvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX21ldGhvZHMgPSB7fTtcbiAgdGhpcy5fbWV0aG9kR3JvdXBzID0ge307XG4gIHRoaXMuX2NvbXBvc2VyID0gbmV3IENvbXBvc2VyKCk7XG5cbiAgLy8gV2hldGhlciB0aGUgY29udHJvbHMgYXJlIGVuYWJsZWQuXG4gIHRoaXMuX2VuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZWQpID8gISFvcHRzLmVuYWJsZWQgOiB0cnVlO1xuXG4gIC8vIEhvdyBtYW55IGNvbnRyb2wgbWV0aG9kcyBhcmUgZW5hYmxlZCBhbmQgaW4gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgdGhpcy5fYWN0aXZlQ291bnQgPSAwO1xuXG4gIHRoaXMudXBkYXRlZFZpZXdzXyA9IFtdO1xuXG4gIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCA9IG51bGw7XG59XG5cbmV2ZW50RW1pdHRlcihDb250cm9scyk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2goKTtcbiAgdGhpcy5fY29tcG9zZXIuZGVzdHJveSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Q29udHJvbE1ldGhvZFtdfSBMaXN0IG9mIHJlZ2lzdGVyZWQgQHtsaW5rIENvbnRyb2xNZXRob2QgaW5zdGFuY2VzfVxuICovXG5Db250cm9scy5wcm90b3R5cGUubWV0aG9kcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGlkIGluIHRoaXMuX21ldGhvZHMpIHtcbiAgICBvYmpbaWRdID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtDb250cm9sTWV0aG9kfVxuICovXG5Db250cm9scy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIHRoaXMuX21ldGhvZHNbaWRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7Q29udHJvbE1ldGhvZH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VuYWJsZT1mYWxzZV1cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLnJlZ2lzdGVyTWV0aG9kID0gZnVuY3Rpb24oaWQsIGluc3RhbmNlLCBlbmFibGUpIHtcbiAgaWYgKHRoaXMuX21ldGhvZHNbaWRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb250cm9sIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBpZCAnICsgaWQpO1xuICB9XG5cbiAgdGhpcy5fbWV0aG9kc1tpZF0gPSB7XG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgYWN0aXZlSGFuZGxlcjogdGhpcy5faGFuZGxlQWN0aXZlLmJpbmQodGhpcywgaWQpLFxuICAgIGluYWN0aXZlSGFuZGxlcjogdGhpcy5faGFuZGxlSW5hY3RpdmUuYmluZCh0aGlzLCBpZClcbiAgfTtcblxuICBpZihlbmFibGUpIHtcbiAgICB0aGlzLmVuYWJsZU1ldGhvZChpZCwgaW5zdGFuY2UpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS51bnJlZ2lzdGVyTWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udHJvbCBtZXRob2QgcmVnaXN0ZXJlZCB3aXRoIGlkICcgKyBpZCk7XG4gIH1cbiAgaWYgKG1ldGhvZC5lbmFibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlTWV0aG9kKGlkKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fbWV0aG9kc1tpZF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5Db250cm9scy5wcm90b3R5cGUuZW5hYmxlTWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udHJvbCBtZXRob2QgcmVnaXN0ZXJlZCB3aXRoIGlkICcgKyBpZCk7XG4gIH1cbiAgaWYgKG1ldGhvZC5lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1ldGhvZC5lbmFibGVkID0gdHJ1ZTtcbiAgaWYgKG1ldGhvZC5hY3RpdmUpIHtcbiAgICB0aGlzLl9pbmNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG4gIHRoaXMuX2xpc3RlbihpZCk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG4gIHRoaXMuZW1pdCgnbWV0aG9kRW5hYmxlZCcsIGlkKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRpc2FibGVNZXRob2QgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250cm9sIG1ldGhvZCByZWdpc3RlcmVkIHdpdGggaWQgJyArIGlkKTtcbiAgfVxuICBpZiAoIW1ldGhvZC5lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1ldGhvZC5lbmFibGVkID0gZmFsc2U7XG4gIGlmIChtZXRob2QuYWN0aXZlKSB7XG4gICAgdGhpcy5fZGVjcmVtZW50QWN0aXZlQ291bnQoKTtcbiAgfVxuICB0aGlzLl91bmxpc3RlbihpZCk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG4gIHRoaXMuZW1pdCgnbWV0aG9kRGlzYWJsZWQnLCBpZCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWV0aG9kIGdyb3VwLCB3aGljaCBjYW4gYmUgdXNlZCB0byBtb3JlIGNvbnZlbmllbnRseSBlbmFibGUgb3JcbiAqIGRpc2FibGUgc2V2ZXJhbCBjb250cm9sIG1ldGhvZHMgYXQgb25jZVxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqIEBwYXJhbSB7U3RyaW5nW119IG1ldGhvZElkc1xuICovXG5Db250cm9scy5wcm90b3R5cGUuYWRkTWV0aG9kR3JvdXAgPSBmdW5jdGlvbihncm91cElkLCBtZXRob2RJZHMpIHtcbiAgdGhpcy5fbWV0aG9kR3JvdXBzW2dyb3VwSWRdID0gbWV0aG9kSWRzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5yZW1vdmVNZXRob2RHcm91cCA9IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSB0aGlzLl9tZXRob2RHcm91cHNbaWRdO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge0NvbnRyb2xNZXRob2RHcm91cFtdfSBMaXN0IG9mIGNvbnRyb2wgbWV0aG9kIGdyb3Vwc1xuICovXG5Db250cm9scy5wcm90b3R5cGUubWV0aG9kR3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kR3JvdXBzKSB7XG4gICAgb2JqW2lkXSA9IHRoaXMuX21ldGhvZEdyb3Vwc1tpZF07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGFsbCB0aGUgY29udHJvbCBtZXRob2RzIGluIHRoZSBncm91cFxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmVuYWJsZU1ldGhvZEdyb3VwID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9tZXRob2RHcm91cHNbaWRdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kSWQpIHtcbiAgICBzZWxmLmVuYWJsZU1ldGhvZChtZXRob2RJZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIERpc2FibGVzIGFsbCB0aGUgY29udHJvbCBtZXRob2RzIGluIHRoZSBncm91cFxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRpc2FibGVNZXRob2RHcm91cCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fbWV0aG9kR3JvdXBzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZElkKSB7XG4gICAgc2VsZi5kaXNhYmxlTWV0aG9kKG1ldGhvZElkKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbmFibGVkO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIHRoZSBjb250cm9sc1xuICovXG5Db250cm9scy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICBpZiAodGhpcy5fYWN0aXZlQ291bnQgPiAwKSB7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2VuYWJsZWQnKTtcbiAgdGhpcy5fdXBkYXRlQ29tcG9zZXIoKTtcbn07XG5cblxuLyoqXG4gKiBEaXNhYmxlcyB0aGUgY29udHJvbHNcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMuX2FjdGl2ZUNvdW50ID4gMCkge1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Rpc2FibGVkJyk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG59O1xuXG5cblxuLyoqXG4gKiBBdHRhY2hlcyB0aGUgY29udHJvbHMgdG8gYSB7QGxpbmsgUmVuZGVyTG9vcH0uIFRoZSBSZW5kZXJMb29wIHdpbGwgYmUgd29rZW5cbiAqIHVwIHdoZW4gdGhlIGNvbnRyb2xzIGFyZSBhY3RpdmF0ZWRcbiAqXG4gKiBAcGFyYW0ge1JlbmRlckxvb3B9XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihyZW5kZXJMb29wKSB7XG4gIGlmICh0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3ApIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICB9XG5cbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcbiAgdGhpcy5fYmVmb3JlUmVuZGVySGFuZGxlciA9IHRoaXMuX3VwZGF0ZVZpZXdzV2l0aENvbnRyb2xzLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NoYW5nZUhhbmRsZXIgPSByZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lLmJpbmQocmVuZGVyTG9vcCk7XG5cbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZVJlbmRlcicsIHRoaXMuX2JlZm9yZVJlbmRlckhhbmRsZXIpO1xuICB0aGlzLl9jb21wb3Nlci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9jaGFuZ2VIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogRGV0YWNoZXMgdGhlIGNvbnRyb2xzXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlUmVuZGVyJywgdGhpcy5fYmVmb3JlUmVuZGVySGFuZGxlcik7XG4gIHRoaXMuX2NvbXBvc2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2NoYW5nZUhhbmRsZXIpO1xuXG4gIHRoaXMuX2JlZm9yZVJlbmRlckhhbmRsZXIgPSBudWxsO1xuICB0aGlzLl9jaGFuZ2VIYW5kbGVyID0gbnVsbDtcbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtCb29sZWFufVxuICovXG5Db250cm9scy5wcm90b3R5cGUuYXR0YWNoZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCAhPSBudWxsO1xufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2xpc3RlbiA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtZXRob2QgaWQnKTtcbiAgfVxuICBtZXRob2QuaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgbWV0aG9kLmFjdGl2ZUhhbmRsZXIpO1xuICBtZXRob2QuaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCBtZXRob2QuaW5hY3RpdmVIYW5kbGVyKTtcbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl91bmxpc3RlbiA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtZXRob2QgaWQnKTtcbiAgfVxuICBtZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgbWV0aG9kLmFjdGl2ZUhhbmRsZXIpO1xuICBtZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCBtZXRob2QuaW5hY3RpdmVIYW5kbGVyKTtcbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9oYW5kbGVBY3RpdmUgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbWV0aG9kIGlkJyk7XG4gIH1cbiAgaWYgKCFtZXRob2QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCByZWNlaXZlIGV2ZW50IGZyb20gZGlzYWJsZWQgY29udHJvbCBtZXRob2QnKTtcbiAgfVxuICBpZiAoIW1ldGhvZC5hY3RpdmUpIHtcbiAgICBtZXRob2QuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9pbmNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5faGFuZGxlSW5hY3RpdmUgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbWV0aG9kIGlkJyk7XG4gIH1cbiAgaWYgKCFtZXRob2QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCByZWNlaXZlIGV2ZW50IGZyb20gZGlzYWJsZWQgY29udHJvbCBtZXRob2QnKTtcbiAgfVxuICBpZiAobWV0aG9kLmFjdGl2ZSkge1xuICAgIG1ldGhvZC5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5faW5jcmVtZW50QWN0aXZlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYWN0aXZlQ291bnQrKztcbiAgaWYgKGRlYnVnKSB7XG4gICAgdGhpcy5fY2hlY2tBY3RpdmVDb3VudCgpO1xuICB9XG4gIGlmICh0aGlzLl9lbmFibGVkICYmIHRoaXMuX2FjdGl2ZUNvdW50ID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2RlY3JlbWVudEFjdGl2ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2FjdGl2ZUNvdW50LS07XG4gIGlmIChkZWJ1Zykge1xuICAgIHRoaXMuX2NoZWNrQWN0aXZlQ291bnQoKTtcbiAgfVxuICBpZiAodGhpcy5fZW5hYmxlZCAmJiB0aGlzLl9hY3RpdmVDb3VudCA9PT0gMCkge1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2NoZWNrQWN0aXZlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kcykge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgICBpZiAobWV0aG9kLmVuYWJsZWQgJiYgbWV0aG9kLmFjdGl2ZSkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgaWYgKGNvdW50ICE9IHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgY29udHJvbCBzdGF0ZScpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fdXBkYXRlQ29tcG9zZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbXBvc2VyID0gdGhpcy5fY29tcG9zZXI7XG5cbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kcykge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgICB2YXIgZW5hYmxlZCA9IHRoaXMuX2VuYWJsZWQgJiYgbWV0aG9kLmVuYWJsZWQ7XG5cbiAgICBpZiAoZW5hYmxlZCAmJiAhY29tcG9zZXIuaGFzKG1ldGhvZC5pbnN0YW5jZSkpIHtcbiAgICAgIGNvbXBvc2VyLmFkZChtZXRob2QuaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQgJiYgY29tcG9zZXIuaGFzKG1ldGhvZC5pbnN0YW5jZSkpIHtcbiAgICAgIGNvbXBvc2VyLnJlbW92ZShtZXRob2QuaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX3VwZGF0ZVZpZXdzV2l0aENvbnRyb2xzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250cm9sRGF0YSA9IHRoaXMuX2NvbXBvc2VyLm9mZnNldHMoKTtcbiAgaWYgKGNvbnRyb2xEYXRhLmNoYW5naW5nKSB7XG4gICAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lKCk7XG4gIH1cblxuICAvLyBVcGRhdGUgZWFjaCB2aWV3IGF0IG1vc3Qgb25jZSwgZXZlbiB3aGVuIHNoYXJlZCBieSBtdWx0aXBsZSBsYXllcnMuXG4gIC8vIFRoZSBudW1iZXIgb2Ygdmlld3MgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwsIHNvIHVzZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrLlxuICB0aGlzLnVwZGF0ZWRWaWV3c18ubGVuZ3RoID0gMDtcblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLnN0YWdlKCkubGlzdExheWVycygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2aWV3ID0gbGF5ZXJzW2ldLnZpZXcoKTtcbiAgICBpZiAodGhpcy51cGRhdGVkVmlld3NfLmluZGV4T2YodmlldykgPCAwKSB7XG4gICAgICBsYXllcnNbaV0udmlldygpLnVwZGF0ZVdpdGhDb250cm9sUGFyYW1ldGVycyhjb250cm9sRGF0YS5vZmZzZXRzKTtcbiAgICAgIHRoaXMudXBkYXRlZFZpZXdzXy5wdXNoKHZpZXcpO1xuICAgIH1cbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2xzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL0hhbW1lckdlc3R1cmVzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgbWF4RnJpY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwnKS5tYXhGcmljdGlvbjtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZyaWN0aW9uOiA2LFxuICBtYXhGcmljdGlvblRpbWU6IDAuMyxcbiAgaGFtbWVyRXZlbnQ6ICdwYW4nXG59O1xuXG52YXIgZGVidWcgPSB0eXBlb2YgTUFSWklQQU5PREVCVUcgIT09ICd1bmRlZmluZWQnICYmIE1BUlpJUEFOT0RFQlVHLmNvbnRyb2xzO1xuXG4vKipcbiAqIEBjbGFzcyBEcmFnQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2xzIHRoZSB2aWV3IGJ5IGNsaWNraW5nL3RhcHBpbmcgYW5kIGRyYWdnaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBmb3IgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJUeXBlIFdoaWNoIEhhbW1lci5qcyBwb2ludGVyIHR5cGUgdG8gdXNlIChlLmcuXG4gKiBgbW91c2VgIG9yIGB0b3VjaGApLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmZyaWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5tYXhGcmljdGlvblRpbWVcbiAqIEBwYXJhbSB7J3Bhbid8J3BpbmNoJ30gb3B0cy5oYW1tZXJFdmVudFxuICovXG5mdW5jdGlvbiBEcmFnQ29udHJvbE1ldGhvZChlbGVtZW50LCBwb2ludGVyVHlwZSwgb3B0cykge1xuICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICB0aGlzLl9vcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuX3N0YXJ0RXZlbnQgPSBudWxsO1xuICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gIHRoaXMuX2R5bmFtaWNzID0ge1xuICAgIHg6IG5ldyBEeW5hbWljcygpLFxuICAgIHk6IG5ldyBEeW5hbWljcygpXG4gIH07XG5cbiAgdGhpcy5faGFtbWVyID0gSGFtbWVyR2VzdHVyZXMuZ2V0KGVsZW1lbnQsIHBvaW50ZXJUeXBlKTtcblxuICB0aGlzLl9oYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgdGhpcy5faGFuZGxlSGFtbWVyRXZlbnQuYmluZCh0aGlzKSk7XG5cbiAgaWYgKHRoaXMuX29wdHMuaGFtbWVyRXZlbnQgIT0gJ3BhbicgJiYgdGhpcy5fb3B0cy5oYW1tZXJFdmVudCAhPSAncGluY2gnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX29wdHMuaGFtbWVyRXZlbnQgKyAnIGlzIG5vdCBhIGhhbW1lckV2ZW50IG1hbmFnZWQgaW4gRHJhZ0NvbnRyb2xNZXRob2QnKTtcbiAgfVxuXG4gIHRoaXMuX2hhbW1lci5vbih0aGlzLl9vcHRzLmhhbW1lckV2ZW50ICsgJ3N0YXJ0JywgdGhpcy5faGFuZGxlU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbih0aGlzLl9vcHRzLmhhbW1lckV2ZW50ICsgJ21vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24odGhpcy5fb3B0cy5oYW1tZXJFdmVudCArICdlbmQnLCB0aGlzLl9oYW5kbGVFbmQuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbih0aGlzLl9vcHRzLmhhbW1lckV2ZW50ICsgJ2NhbmNlbCcsIHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZXZlbnRFbWl0dGVyKERyYWdDb250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUhhbW1lckV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICBpZiAoZS5pc0ZpcnN0KSB7XG4gICAgaWYgKGRlYnVnICYmIHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnQ29udHJvbE1ldGhvZCBhY3RpdmUgZGV0ZWN0ZWQgd2hlbiBhbHJlYWR5IGFjdGl2ZScpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIH1cbiAgaWYgKGUuaXNGaW5hbCkge1xuICAgIGlmIChkZWJ1ZyAmJiAhdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdDb250cm9sTWV0aG9kIGluYWN0aXZlIGRldGVjdGVkIHdoZW4gYWxyZWFkeSBpbmFjdGl2ZScpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgdGhpcyBldmVudCBmcm9tIGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cywgY2F1c2luZ1xuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yIG9uIENocm9tZS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuX3N0YXJ0RXZlbnQgPSBlO1xufTtcblxuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgdGhpcyBldmVudCBmcm9tIGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cywgY2F1c2luZ1xuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yIG9uIENocm9tZS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGlmICh0aGlzLl9zdGFydEV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlRHluYW1pY3NNb3ZlKGUpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFgnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ2F4aXNTY2FsZWRZJywgdGhpcy5fZHluYW1pY3MueSk7XG4gIH1cbn07XG5cblxuRHJhZ0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVFbmQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgdGhpcyBldmVudCBmcm9tIGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cywgY2F1c2luZ1xuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yIG9uIENocm9tZS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGlmICh0aGlzLl9zdGFydEV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlRHluYW1pY3NSZWxlYXNlKGUpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFgnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ2F4aXNTY2FsZWRZJywgdGhpcy5fZHluYW1pY3MueSk7XG4gIH1cblxuICB0aGlzLl9zdGFydEV2ZW50ID0gZmFsc2U7XG4gIHRoaXMuX2xhc3RFdmVudCA9IGZhbHNlO1xufTtcblxuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZUR5bmFtaWNzTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHggPSBlLmRlbHRhWDtcbiAgdmFyIHkgPSBlLmRlbHRhWTtcblxuICAvLyBXaGVuIGEgc2Vjb25kIGZpbmdlciB0b3VjaGVzIHRoZSBzY3JlZW4sIHBhbnN0YXJ0IHNvbWV0aW1lcyBoYXMgYSBsYXJnZVxuICAvLyBvZmZzZXQgYXQgc3RhcnQ7IHN1YnRyYWN0IHRoYXQgb2Zmc2V0IHRvIHByZXZlbnQgYSBzdWRkZW4ganVtcC5cbiAgdmFyIGV2ZW50VG9TdWJ0cmFjdCA9IHRoaXMuX2xhc3RFdmVudCB8fCB0aGlzLl9zdGFydEV2ZW50O1xuXG4gIGlmIChldmVudFRvU3VidHJhY3QpIHtcbiAgICB4IC09IGV2ZW50VG9TdWJ0cmFjdC5kZWx0YVg7XG4gICAgeSAtPSBldmVudFRvU3VidHJhY3QuZGVsdGFZO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRSZWN0ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHdpZHRoID0gZWxlbWVudFJlY3QucmlnaHQgLSBlbGVtZW50UmVjdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudFJlY3QudG9wO1xuXG4gIHggLz0gd2lkdGg7XG4gIHkgLz0gaGVpZ2h0O1xuXG4gIHRoaXMuX2R5bmFtaWNzLngucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueS5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy54Lm9mZnNldCA9IC14O1xuICB0aGlzLl9keW5hbWljcy55Lm9mZnNldCA9IC15O1xuXG4gIHRoaXMuX2xhc3RFdmVudCA9IGU7XG59O1xuXG5cbnZhciB0bXBSZWxlYXNlRnJpY3Rpb24gPSBbIG51bGwsIG51bGwgXTtcbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRHluYW1pY3NSZWxlYXNlID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZWxlbWVudFJlY3QgPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgd2lkdGggPSBlbGVtZW50UmVjdC5yaWdodCAtIGVsZW1lbnRSZWN0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50UmVjdC5ib3R0b20gLSBlbGVtZW50UmVjdC50b3A7XG5cbiAgdmFyIHggPSAxMDAwICogZS52ZWxvY2l0eVggLyB3aWR0aDtcbiAgdmFyIHkgPSAxMDAwICogZS52ZWxvY2l0eVkgLyBoZWlnaHQ7XG5cbiAgdGhpcy5fZHluYW1pY3MueC5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy55LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLngudmVsb2NpdHkgPSB4O1xuICB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5ID0geTtcblxuICBtYXhGcmljdGlvbih0aGlzLl9vcHRzLmZyaWN0aW9uLCB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5LCB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5LCB0aGlzLl9vcHRzLm1heEZyaWN0aW9uVGltZSwgdG1wUmVsZWFzZUZyaWN0aW9uKTtcbiAgdGhpcy5fZHluYW1pY3MueC5mcmljdGlvbiA9IHRtcFJlbGVhc2VGcmljdGlvblswXTtcbiAgdGhpcy5fZHluYW1pY3MueS5mcmljdGlvbiA9IHRtcFJlbGVhc2VGcmljdGlvblsxXTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnQ29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgRHluYW1pY3NcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBSZXByZXNlbnRzIGhvdyBhIGNvbnRyb2wgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZWQgaW4gdGhlIGV2ZW50cyBlbWl0dGVkIGJ5XG4gKiB7QGxpbmsgQ29udHJvbE1ldGhvZH0uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCBQYXJhbWV0ZXIgY2hhbmdlZCBieSBhIGZpeGVkIHZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVsb2NpdHkgUGFyYW1ldGVyIGlzIGNoYW5naW5nIGF0IHRoaXMgdmVsb2NpdHlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmljdGlvbiBUaGUgdmVsb2NpdHkgd2lsbCBkZWNyZWFzZSBhdCB0aGlzIHJhdGVcbiAqL1xuZnVuY3Rpb24gRHluYW1pY3MoKSB7XG4gIHRoaXMudmVsb2NpdHkgPSBudWxsO1xuICB0aGlzLmZyaWN0aW9uID0gbnVsbDtcbiAgdGhpcy5vZmZzZXQgPSBudWxsO1xufVxuXG5EeW5hbWljcy5lcXVhbHMgPSBmdW5jdGlvbihkMSwgZDIpIHtcbiAgcmV0dXJuIGQxLnZlbG9jaXR5ID09PSBkMi52ZWxvY2l0eSAmJiBkMS5mcmljdGlvbiA9PT0gZDIuZnJpY3Rpb24gJiYgZDEub2Zmc2V0ID09PSBkMi5vZmZzZXQ7XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuIER5bmFtaWNzLmVxdWFscyh0aGlzLCBvdGhlcik7XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3RoZXIsIGVsYXBzZWQpIHtcbiAgaWYgKG90aGVyLm9mZnNldCkge1xuICAgIC8vIElmIG90aGVyIGhhcyBhbiBvZmZzZXQsIG1ha2UgdGhpcy5vZmZzZXQgYSBudW1iZXIgaW5zdGVhZCBvZiBudWxsXG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldCB8fCAwO1xuICAgIHRoaXMub2Zmc2V0ICs9IG90aGVyLm9mZnNldDtcbiAgfVxuXG4gIHZhciBvZmZzZXRGcm9tVmVsb2NpdHkgPSB0aGlzLm9mZnNldEZyb21WZWxvY2l0eShlbGFwc2VkKTtcbiAgaWYgKG9mZnNldEZyb21WZWxvY2l0eSkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIG9mZnNldCB0byBhZGQgZnJvbSB0aGUgdmVsb2NpdHksIG1ha2UgdGhpcyBvZmZzZXQgYSBudW1iZXIgaW5zdGVhZCBvZiBudWxsXG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldCB8fCAwO1xuICAgIHRoaXMub2Zmc2V0ICs9IG9mZnNldEZyb21WZWxvY2l0eTtcbiAgfVxuXG4gIHRoaXMudmVsb2NpdHkgPSBvdGhlci52ZWxvY2l0eTtcbiAgdGhpcy5mcmljdGlvbiA9IG90aGVyLmZyaWN0aW9uO1xufTtcblxuRHluYW1pY3MucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVsb2NpdHkgPSBudWxsO1xuICB0aGlzLmZyaWN0aW9uID0gbnVsbDtcbiAgdGhpcy5vZmZzZXQgPSBudWxsO1xufTtcblxuXG5EeW5hbWljcy5wcm90b3R5cGUudmVsb2NpdHlBZnRlciA9IGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgaWYgKCF0aGlzLnZlbG9jaXR5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuZnJpY3Rpb24pIHtcbiAgICByZXR1cm4gZGVjcmVhc2VBYnModGhpcy52ZWxvY2l0eSwgdGhpcy5mcmljdGlvbiAqZWxhcHNlZCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUub2Zmc2V0RnJvbVZlbG9jaXR5ID0gZnVuY3Rpb24oZWxhcHNlZCkge1xuICBlbGFwc2VkID0gTWF0aC5taW4oZWxhcHNlZCwgdGhpcy5udWxsVmVsb2NpdHlUaW1lKCkpO1xuXG4gIHZhciB2ZWxvY2l0eUVuZCA9IHRoaXMudmVsb2NpdHlBZnRlcihlbGFwc2VkKTtcbiAgdmFyIGF2ZXJhZ2VWZWxvY2l0eSA9ICh0aGlzLnZlbG9jaXR5ICsgdmVsb2NpdHlFbmQpIC8gMjtcblxuICByZXR1cm4gYXZlcmFnZVZlbG9jaXR5ICogZWxhcHNlZDtcbn07XG5cblxuRHluYW1pY3MucHJvdG90eXBlLm51bGxWZWxvY2l0eVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudmVsb2NpdHkgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0aGlzLnZlbG9jaXR5ICYmICF0aGlzLmZyaWN0aW9uKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIHJldHVybiBNYXRoLmFicyh0aGlzLnZlbG9jaXR5IC8gdGhpcy5mcmljdGlvbik7XG59O1xuXG5mdW5jdGlvbiBkZWNyZWFzZUFicyhudW0sIGRlYykge1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiBNYXRoLm1pbigwLCBudW0gKyBkZWMpO1xuICB9XG4gIGlmIChudW0gPiAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG51bSAtIGRlYyk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY3M7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0cyB0aGUgdmVsb2NpdHkgYW5kIGZyaWN0aW9uIG9mIGEgc2luZ2xlIHBhcmFtZXRlciBieSBwcmVzc2luZyBhbmRcbiAqIHVucHJlc3NpbmcgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBhY3RpdmF0ZXMgdGhlIG1ldGhvZCB3aGVuIHByZXNzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0byBiZSBjb250cm9sbGVkIChlLmcuIGB4YCwgYHlgIG9yIGB6b29tYClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eSBWZWxvY2l0eSBhdCB3aGljaCB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZSBhXG4gKiBuZWdhdGl2ZSBudW1iZXIgZm9yIG9wcG9zaXRlIGRpcmVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZyaWN0aW9uIEZyaWN0aW9uIGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgc3RvcHNcbiovXG5mdW5jdGlvbiBFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kKGVsZW1lbnQsIHBhcmFtZXRlciwgdmVsb2NpdHksIGZyaWN0aW9uKSB7XG4gIGlmKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogZWxlbWVudCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q6IHBhcmFtZXRlciBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXZlbG9jaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogdmVsb2NpdHkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCFmcmljdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q6IGZyaWN0aW9uIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX3ByZXNzSGFuZGxlciA9IHRoaXMuX2hhbmRsZVByZXNzLmJpbmQodGhpcyk7XG4gIHRoaXMuX3JlbGVhc2VIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpO1xuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fcHJlc3NIYW5kbGVyKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3ByZXNzSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuXG4gIHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgdGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgdGhpcy5fZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufVxuZXZlbnRFbWl0dGVyKEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wcmVzc0hhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcHJlc3NIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVQcmVzcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wcmVzc2luZyA9IHRydWU7XG5cbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB0aGlzLl92ZWxvY2l0eTtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSAwO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG59O1xuXG5FbGVtZW50UHJlc3NDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLl9wcmVzc2luZykge1xuICAgIHRoaXMuX2R5bmFtaWNzLmZyaWN0aW9uID0gdGhpcy5fZnJpY3Rpb247XG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxuXG4gIHRoaXMuX3ByZXNzaW5nID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBIYW1tZXIgPSByZXF1aXJlKCdoYW1tZXJqcycpO1xuXG52YXIgbmV4dElkID0gMTtcbnZhciBpZFByb3BlcnR5ID0gJ01hcnppcGFub0hhbW1lckVsZW1lbnRJZCc7XG5mdW5jdGlvbiBnZXRLZXlGb3JFbGVtZW50QW5kVHlwZShlbGVtZW50LCB0eXBlKSB7XG4gIGlmICghZWxlbWVudFtpZFByb3BlcnR5XSkge1xuICAgIGVsZW1lbnRbaWRQcm9wZXJ0eV0gPSBuZXh0SWQrKztcbiAgfVxuICByZXR1cm4gdHlwZSArIGVsZW1lbnRbaWRQcm9wZXJ0eV07XG59XG5cblxuLyoqXG4gKiBAY2xhc3MgSGFtbWVyR2VzdHVyZXNcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBNYW5hZ2VzIEhhbW1lci5qcyBpbnN0YW5jZXMuIE9uZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGZvciBlYWNoIGNvbWJpbmF0aW9uIG9mXG4gKiBET00gZWxlbWVudCBhbmQgcG9pbnRlciB0eXBlLlxuICovXG5mdW5jdGlvbiBIYW1tZXJHZXN0dXJlcygpIHtcbiAgdGhpcy5fbWFuYWdlcnMgPSB7fTtcbiAgdGhpcy5fcmVmQ291bnQgPSB7fTtcbn1cblxuXG5IYW1tZXJHZXN0dXJlcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICB2YXIga2V5ID0gZ2V0S2V5Rm9yRWxlbWVudEFuZFR5cGUoZWxlbWVudCwgdHlwZSk7XG4gIGlmICghdGhpcy5fbWFuYWdlcnNba2V5XSkge1xuICAgIHRoaXMuX21hbmFnZXJzW2tleV0gPSB0aGlzLl9jcmVhdGVNYW5hZ2VyKGVsZW1lbnQsIHR5cGUpO1xuICAgIHRoaXMuX3JlZkNvdW50W2tleV0gPSAwO1xuICB9XG4gIHRoaXMuX3JlZkNvdW50W2tleV0rKztcbiAgcmV0dXJuIG5ldyBIYW1tZXJHZXN0dXJlc0hhbmRsZSh0aGlzLCB0aGlzLl9tYW5hZ2Vyc1trZXldLCBlbGVtZW50LCB0eXBlKTtcbn07XG5cblxuSGFtbWVyR2VzdHVyZXMucHJvdG90eXBlLl9jcmVhdGVNYW5hZ2VyID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICB2YXIgbWFuYWdlciA9IG5ldyBIYW1tZXIuTWFuYWdlcihlbGVtZW50KTtcblxuICAvLyBNYW5hZ2VycyBhcmUgY3JlYXRlZCB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIGZvciBkaWZmZXJlbnQgcG9pbnRlclxuICAvLyB0eXBlcy5cbiAgaWYgKHR5cGUgPT09ICdtb3VzZScpIHtcbiAgICBtYW5hZ2VyLmFkZChuZXcgSGFtbWVyLlBhbih7IGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTEwsIHRocmVzaG9sZDogMCB9KSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoJyB8fCB0eXBlID09PSAncGVuJyB8fCB0eXBlID09PSAna2luZWN0Jykge1xuICAgIC8vIE9uIHRvdWNoIG9uZSB3YW50cyB0byBoYXZlIGJvdGggcGFubmluZyBhbmQgcGluY2hpbmcuIFRoZSBwYW5uaW5nXG4gICAgLy8gcmVjb2duaXplciBuZWVkcyBhIHRocmVzaG9sZCB0byBhbGxvdyB0aGUgcGluY2ggdG8gYmUgcmVjb2duaXplZC5cbiAgICBtYW5hZ2VyLmFkZChuZXcgSGFtbWVyLlBhbih7IGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTEwsIHRocmVzaG9sZDogMjAsIHBvaW50ZXJzOiAxIH0pKTtcbiAgICBtYW5hZ2VyLmFkZChuZXcgSGFtbWVyLlBpbmNoKCkpO1xuICB9XG5cbiAgcmV0dXJuIG1hbmFnZXI7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzLnByb3RvdHlwZS5fcmVsZWFzZUhhbmRsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIGtleSA9IGdldEtleUZvckVsZW1lbnRBbmRUeXBlKGVsZW1lbnQsIHR5cGUpO1xuICBpZiAodGhpcy5fcmVmQ291bnRba2V5XSkge1xuICAgIHRoaXMuX3JlZkNvdW50W2tleV0tLTtcbiAgICBpZiAoIXRoaXMuX3JlZkNvdW50W2tleV0pIHtcbiAgICAgIHRoaXMuX21hbmFnZXJzW2tleV0uZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX21hbmFnZXJzW2tleV07XG4gICAgICBkZWxldGUgdGhpcy5fcmVmQ291bnRba2V5XTtcbiAgICB9XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gSGFtbWVyR2VzdHVyZXNIYW5kbGUoaGFtbWVyR2VzdHVyZXMsIG1hbmFnZXIsIGVsZW1lbnQsIHR5cGUpIHtcbiAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90eXBlID0gdHlwZTtcbiAgdGhpcy5faGFtbWVyR2VzdHVyZXMgPSBoYW1tZXJHZXN0dXJlcztcbiAgdGhpcy5fZXZlbnRIYW5kbGVycyA9IFtdO1xufVxuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gIHZhciBoYW5kbGVyRmlsdGVyZWRFdmVudHMgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHR5cGUgPT09IGUucG9pbnRlclR5cGUpIHtcbiAgICAgIGhhbmRsZXIoZSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2V2ZW50SGFuZGxlcnMucHVzaCh7IGV2ZW50czogZXZlbnRzLCBoYW5kbGVyOiBoYW5kbGVyRmlsdGVyZWRFdmVudHMgfSk7XG4gIHRoaXMuX21hbmFnZXIub24oZXZlbnRzLCBoYW5kbGVyRmlsdGVyZWRFdmVudHMpO1xufTtcblxuXG5IYW1tZXJHZXN0dXJlc0hhbmRsZS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50SGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZlbnRIYW5kbGVyID0gdGhpcy5fZXZlbnRIYW5kbGVyc1tpXTtcbiAgICB0aGlzLl9tYW5hZ2VyLm9mZihldmVudEhhbmRsZXIuZXZlbnRzLCBldmVudEhhbmRsZXIuaGFuZGxlcik7XG4gIH1cblxuICB0aGlzLl9oYW1tZXJHZXN0dXJlcy5fcmVsZWFzZUhhbmRsZSh0aGlzLl9lbGVtZW50LCB0aGlzLl90eXBlKTtcbiAgdGhpcy5fbWFuYWdlciA9IG51bGw7XG4gIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB0aGlzLl90eXBlID0gbnVsbDtcbiAgdGhpcy5faGFtbWVyR2VzdHVyZXMgPSBudWxsO1xufTtcblxuXG5IYW1tZXJHZXN0dXJlc0hhbmRsZS5wcm90b3R5cGUubWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbWFuYWdlcjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgSGFtbWVyR2VzdHVyZXMoKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIEtleUNvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXRzIHRoZSB2ZWxvY2l0eSBhbmQgZnJpY3Rpb24gb2YgYSBzaW5nbGUgcGFyYW1ldGVyIGJ5IHByZXNzaW5nIGFuZFxuICogdW5wcmVzc2luZyBhIGtleS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0ga2V5Q29kZSBLZXkgd2hpY2ggYWN0aXZhdGVzIHRoZSBtZXRob2Qgd2hlbiBwcmVzc2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gYmUgY29udHJvbGxlZCAoZS5nLiBgeGAsIGB5YCBvciBgem9vbWApXG4gKiBAcGFyYW0ge251bWJlcn0gdmVsb2NpdHkgVmVsb2NpdHkgYXQgd2hpY2ggdGhlIHBhcmFtZXRlciBjaGFuZ2VzLiBVc2UgYVxuICogbmVnYXRpdmUgbnVtYmVyIGZvciBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcmljdGlvbiBGcmljdGlvbiBhdCB3aGljaCB0aGUgcGFyYW1ldGVyIHN0b3BzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtlbGVtZW50PWRvY3VtZW50XSBET00gZWxlbWVudCB3aGVyZSB0aGUga2V5IGV2ZW50cyBhcmUgbGlzdGVuZWQgdG9cbiAqL1xuZnVuY3Rpb24gS2V5Q29udHJvbE1ldGhvZChrZXlDb2RlLCBwYXJhbWV0ZXIsIHZlbG9jaXR5LCBmcmljdGlvbiwgZWxlbWVudCkge1xuICBpZigha2V5Q29kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IGtleUNvZGUgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCFwYXJhbWV0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlDb250cm9sTWV0aG9kOiBwYXJhbWV0ZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCF2ZWxvY2l0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IHZlbG9jaXR5IG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBpZighZnJpY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlDb250cm9sTWV0aG9kOiBmcmljdGlvbiBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cblxuICBlbGVtZW50ID0gZWxlbWVudCB8fCBkb2N1bWVudDtcblxuICB0aGlzLl9rZXlDb2RlID0ga2V5Q29kZTtcbiAgdGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICB0aGlzLl92ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB0aGlzLl9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZVByZXNzLmJpbmQodGhpcyk7XG4gIHRoaXMuX2tleXVwSGFuZGxlciA9IHRoaXMuX2hhbmRsZVJlbGVhc2UuYmluZCh0aGlzKTtcbiAgdGhpcy5fYmx1ckhhbmRsZXIgPSB0aGlzLl9oYW5kbGVCbHVyLmJpbmQodGhpcyk7XG5cbiAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5dXBIYW5kbGVyKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ibHVySGFuZGxlcik7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcbiAgdGhpcy5fcHJlc3NpbmcgPSBmYWxzZTtcbn1cbmV2ZW50RW1pdHRlcihLZXlDb250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5LZXlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25IYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX2tleXVwSGFuZGxlcik7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYmx1ckhhbmRsZXIpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5LZXlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUHJlc3MgPSBmdW5jdGlvbihlKSB7XG4gIGlmKGUua2V5Q29kZSAhPT0gdGhpcy5fa2V5Q29kZSkgeyByZXR1cm47IH1cblxuICB0aGlzLl9wcmVzc2luZyA9IHRydWU7XG5cbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB0aGlzLl92ZWxvY2l0eTtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSAwO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG59O1xuXG5LZXlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYoZS5rZXlDb2RlICE9PSB0aGlzLl9rZXlDb2RlKSB7IHJldHVybjsgfVxuXG4gIGlmKHRoaXMuX3ByZXNzaW5nKSB7XG4gICAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSB0aGlzLl9mcmljdGlvbjtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gICAgdGhpcy5lbWl0KCdpbmFjdGl2ZScpO1xuICB9XG5cbiAgdGhpcy5fcHJlc3NpbmcgPSBmYWxzZTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVCbHVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2R5bmFtaWNzLnZlbG9jaXR5ID0gMDtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xuICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG5cbiAgdGhpcy5fcHJlc3NpbmcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Q29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIEhhbW1lckdlc3R1cmVzID0gcmVxdWlyZSgnLi9IYW1tZXJHZXN0dXJlcycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIFBpbmNoWm9vbUNvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDb250cm9sIHRoZSB2aWV3IGZvdi96b29tIGJ5IHBpbmNoaW5nIHdpdGggdHdvIGZpbmdlcnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbGlzdGVuIGZvciBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlclR5cGUgV2hpY2ggSGFtbWVyLmpzIHBvaW50ZXIgdHlwZSB0byB1c2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFBpbmNoWm9vbUNvbnRyb2xNZXRob2QoZWxlbWVudCwgcG9pbnRlclR5cGUsIG9wdHMpIHtcbiAgdGhpcy5faGFtbWVyID0gSGFtbWVyR2VzdHVyZXMuZ2V0KGVsZW1lbnQsIHBvaW50ZXJUeXBlKTtcblxuICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gIHRoaXMuX2R5bmFtaWNzID0gbmV3IER5bmFtaWNzKCk7XG5cbiAgdGhpcy5faGFtbWVyLm9uKCdwaW5jaHN0YXJ0JywgdGhpcy5faGFuZGxlU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbigncGluY2gnLCB0aGlzLl9oYW5kbGVFdmVudC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwaW5jaGVuZCcsIHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwaW5jaGNhbmNlbCcsIHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZXZlbnRFbWl0dGVyKFBpbmNoWm9vbUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblBpbmNoWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFtbWVyLnJlbGVhc2UoKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIH1cbn07XG5cblxuUGluY2hab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cblxuUGluY2hab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgc2NhbGUgPSBlLnNjYWxlO1xuXG4gIGlmICh0aGlzLl9sYXN0RXZlbnQpIHtcbiAgICBzY2FsZSAvPSB0aGlzLl9sYXN0RXZlbnQuc2NhbGU7XG4gIH1cblxuICB0aGlzLl9keW5hbWljcy5vZmZzZXQgPSAoc2NhbGUgLSAxKSAqIC0xO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3pvb20nLCB0aGlzLl9keW5hbWljcyk7XG5cbiAgdGhpcy5fbGFzdEV2ZW50ID0gZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQaW5jaFpvb21Db250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL0hhbW1lckdlc3R1cmVzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgbWF4RnJpY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwnKS5tYXhGcmljdGlvbjtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3BlZWQ6IDgsXG4gIGZyaWN0aW9uOiA2LFxuICBtYXhGcmljdGlvblRpbWU6IDAuM1xufTtcblxuXG4vKipcbiAqIEBjbGFzcyBRdHZyQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2xzIHRoZSB2aWV3IGJ5IGhvbGRpbmcgdGhlIG1vdXNlIGJ1dHRvbiBkb3duIGFuZCBtb3ZpbmcgaXQuXG4gKiBBbHNvIGtub3duIGFzIFwiUVRWUlwiIGNvbnRyb2wgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyVHlwZSBXaGljaCBIYW1tZXIuanMgcG9pbnRlciB0eXBlIHRvIHVzZSAoZS5nLlxuICogYG1vdXNlYCBvciBgdG91Y2hgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zcGVlZFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZnJpY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLm1heEZyaWN0aW9uVGltZVxuICovXG4vLyBUT0RPOiBhbGxvdyBzcGVlZCBub3QgY2hhbmdlIGxpbmVhcmx5IHdpdGggZGlzdGFuY2UgdG8gY2xpY2sgc3BvdC5cbi8vIFF1YWRyYXRpYyBvciBvdGhlciB3b3VsZCBhbGxvdyBhIGxhcmdlciBzcGVlZCByYW5nZS5cbmZ1bmN0aW9uIFF0dnJDb250cm9sTWV0aG9kKGVsZW1lbnQsIHBvaW50ZXJUeXBlLCBvcHRzKSB7XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX29wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5faGFtbWVyID0gSGFtbWVyR2VzdHVyZXMuZ2V0KGVsZW1lbnQsIHBvaW50ZXJUeXBlKTtcblxuICB0aGlzLl9keW5hbWljcyA9IHtcbiAgICB4OiBuZXcgRHluYW1pY3MoKSxcbiAgICB5OiBuZXcgRHluYW1pY3MoKVxuICB9O1xuXG4gIHRoaXMuX2hhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9oYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5tb3ZlJywgdGhpcy5faGFuZGxlTW92ZS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5lbmQnLCB0aGlzLl9oYW5kbGVSZWxlYXNlLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BhbmNhbmNlbCcsIHRoaXMuX2hhbmRsZVJlbGVhc2UuYmluZCh0aGlzKSk7XG59XG5cbmV2ZW50RW1pdHRlcihRdHZyQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUXR2ckNvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFtbWVyLnJlbGVhc2UoKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAvLyBQcmV2ZW50IGV2ZW50IGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cyBhbmQgY2F1c2luZyBzdHJhbmdlIGJlaGF2aW9yIG9uIENocm9tZVxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIH1cbn07XG5cblxuUXR2ckNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAvLyBQcmV2ZW50IGV2ZW50IGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cyBhbmQgY2F1c2luZyBzdHJhbmdlIGJlaGF2aW9yIG9uIENocm9tZVxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdGhpcy5fdXBkYXRlRHluYW1pY3MoZSwgZmFsc2UpO1xufTtcblxuXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZVJlbGVhc2UgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLl91cGRhdGVEeW5hbWljcyhlLCB0cnVlKTtcblxuICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdpbmFjdGl2ZScpO1xuICB9XG59O1xuXG5cbnZhciB0bXBSZWxlYXNlRnJpY3Rpb24gPSBbIG51bGwsIG51bGwgXTtcblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRHluYW1pY3MgPSBmdW5jdGlvbihlLCByZWxlYXNlKSB7XG4gIHZhciBlbGVtZW50UmVjdCA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB3aWR0aCA9IGVsZW1lbnRSZWN0LnJpZ2h0IC0gZWxlbWVudFJlY3QubGVmdDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnRSZWN0LmJvdHRvbSAtIGVsZW1lbnRSZWN0LnRvcDtcbiAgdmFyIG1heERpbSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gIHZhciB4ID0gZS5kZWx0YVggLyBtYXhEaW0gKiB0aGlzLl9vcHRzLnNwZWVkO1xuICB2YXIgeSA9IGUuZGVsdGFZIC8gbWF4RGltICogdGhpcy5fb3B0cy5zcGVlZDtcblxuICB0aGlzLl9keW5hbWljcy54LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLnkucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueC52ZWxvY2l0eSA9IHg7XG4gIHRoaXMuX2R5bmFtaWNzLnkudmVsb2NpdHkgPSB5O1xuXG4gIGlmIChyZWxlYXNlKSB7XG4gICAgbWF4RnJpY3Rpb24odGhpcy5fb3B0cy5mcmljdGlvbiwgdGhpcy5fZHluYW1pY3MueC52ZWxvY2l0eSwgdGhpcy5fZHluYW1pY3MueS52ZWxvY2l0eSwgdGhpcy5fb3B0cy5tYXhGcmljdGlvblRpbWUsIHRtcFJlbGVhc2VGcmljdGlvbik7XG4gICAgdGhpcy5fZHluYW1pY3MueC5mcmljdGlvbiA9IHRtcFJlbGVhc2VGcmljdGlvblswXTtcbiAgICB0aGlzLl9keW5hbWljcy55LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzFdO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd4JywgdGhpcy5fZHluYW1pY3MueCk7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAneScsIHRoaXMuX2R5bmFtaWNzLnkpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFF0dnJDb250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmcmljdGlvblRpbWU6IDAuMixcbiAgem9vbURlbHRhOiAwLjAwMVxufTtcblxuLyoqXG4gKiBAY2xhc3MgU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDb250cm9scyB0aGUgZm92L3pvb20gdGhyb3VnaCB0aGUgbW91c2Ugd2hlZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbGlzdGVuIGZvciBldmVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmZyaWN0aW9uVGltZT0wLjJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuem9vbURlbHRhPTAuMDAxXVxuICovXG5mdW5jdGlvbiBTY3JvbGxab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCBvcHRzKSB7XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl9vcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xuICB0aGlzLl9ldmVudExpc3QgPSBbXTtcblxuICB2YXIgZm4gPSB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZSA/IHRoaXMud2l0aFNtb290aGluZyA6IHRoaXMud2l0aG91dFNtb290aGluZztcbiAgdGhpcy5fd2hlZWxMaXN0ZW5lciA9IGZuLmJpbmQodGhpcyk7XG4gIFxuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fd2hlZWxMaXN0ZW5lcik7XG59XG5cbmV2ZW50RW1pdHRlcihTY3JvbGxab29tQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX3doZWVsTGlzdGVuZXIpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblNjcm9sbFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS53aXRob3V0U21vb3RoaW5nID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLl9keW5hbWljcy5vZmZzZXQgPSB3aGVlbEV2ZW50RGVsdGEoZSkgKiB0aGlzLl9vcHRzLnpvb21EZWx0YTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd6b29tJywgdGhpcy5fZHluYW1pY3MpO1xuXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG59O1xuXG5cblNjcm9sbFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS53aXRoU21vb3RoaW5nID0gZnVuY3Rpb24oZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBlLnRpbWVTdGFtcDtcblxuICAvLyBSZWNvcmQgZXZlbnQuXG4gIHRoaXMuX2V2ZW50TGlzdC5wdXNoKGUpO1xuXG4gIC8vIFJlbW92ZSBldmVudHMgd2hvc2Ugc21vb3RoaW5nIGhhcyBhbHJlYWR5IGV4cGlyZWQuXG4gIHdoaWxlICh0aGlzLl9ldmVudExpc3RbMF0udGltZVN0YW1wIDwgY3VycmVudFRpbWUgLSB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZSoxMDAwKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0LnNoaWZ0KDApO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBjdXJyZW50IHZlbG9jaXR5IGZyb20gdGhlIHJlY29yZGVkIGV2ZW50cy5cbiAgLy8gRWFjaCB3aGVlbCBtb3ZlbWVudCBjYXVzZXMgYSB2ZWxvY2l0eSBvZiBjaGFuZ2UvZnJpY3Rpb25UaW1lIGR1cmluZyBmcmljdGlvblRpbWUuXG4gIHZhciB2ZWxvY2l0eSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHpvb21DaGFuZ2VGcm9tRXZlbnQgPSB3aGVlbEV2ZW50RGVsdGEodGhpcy5fZXZlbnRMaXN0W2ldKSAqIHRoaXMuX29wdHMuem9vbURlbHRhO1xuICAgIHZlbG9jaXR5ICs9IHpvb21DaGFuZ2VGcm9tRXZlbnQgLyB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZTtcbiAgfVxuXG4gIHRoaXMuX2R5bmFtaWNzLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuX2R5bmFtaWNzLmZyaWN0aW9uID0gTWF0aC5hYnModmVsb2NpdHkpIC8gdGhpcy5fb3B0cy5mcmljdGlvblRpbWU7XG5cbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd6b29tJywgdGhpcy5fZHluYW1pY3MpO1xuXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG59O1xuXG5cbmZ1bmN0aW9uIHdoZWVsRXZlbnREZWx0YShlKSB7XG4gIHZhciBtdWx0aXBsaWVyID0gZS5kZWx0YU1vZGUgPT0gMSA/IDIwIDogMTtcbiAgcmV0dXJuIGUuZGVsdGFZICogbXVsdGlwbGllcjtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjcm9sbFpvb21Db250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgVmVsb2NpdHlDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0cyB0aGUgdmVsb2NpdHkgYW5kIGZyaWN0aW9uIG9mIGEgc2luZ2xlIHBhcmFtZXRlci5cbiAqXG4gKiBUaGUgdXNlciBzaG91bGQgZW1pdCAnYWN0aXZlJyBhbmQgJ2luYWN0aXZlJyBldmVudHMgaWYgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtZXRlciBUaGUgcGFyYW1ldGVyIHRvIGJlIGNvbnRyb2xsZWQgKGUuZy4gYHhgLCBgeWAgb3IgYHpvb21gKVxuKi9cbmZ1bmN0aW9uIFZlbG9jaXR5Q29udHJvbE1ldGhvZChwYXJhbWV0ZXIpIHtcbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZlbG9jaXR5Q29udHJvbE1ldGhvZDogcGFyYW1ldGVyIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcbn1cbmV2ZW50RW1pdHRlcihWZWxvY2l0eUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblZlbG9jaXR5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcGFyYW1ldGVyJ3MgdmVsb2NpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gdmVsb2NpdHlcbiAqL1xuVmVsb2NpdHlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5zZXRWZWxvY2l0eSA9IGZ1bmN0aW9uKHZlbG9jaXR5KSB7XG4gIHRoaXMuX2R5bmFtaWNzLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwYXJhbWV0ZXIncyBmcmljdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmljdGlvblxuICovXG5WZWxvY2l0eUNvbnRyb2xNZXRob2QucHJvdG90eXBlLnNldEZyaWN0aW9uID0gZnVuY3Rpb24oZnJpY3Rpb24pIHtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWxvY2l0eUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBEcmFnQ29udHJvbE1ldGhvZCA9IHJlcXVpcmUoJy4vRHJhZycpO1xudmFyIFF0dnJDb250cm9sTWV0aG9kID0gcmVxdWlyZSgnLi9RdHZyJyk7XG52YXIgU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL1Njcm9sbFpvb20nKTtcbnZhciBQaW5jaFpvb21Db250cm9sTWV0aG9kID0gcmVxdWlyZSgnLi9QaW5jaFpvb20nKTtcbnZhciBLZXlDb250cm9sTWV0aG9kID0gcmVxdWlyZSgnLi9LZXknKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBtb3VzZVZpZXdNb2RlOiAnZHJhZycsXG4gIGRyYWdNb2RlOiAncGFuJ1xufTtcblxuLyoqXG4gKiBJbnN0YW50aWF0ZSBhbmQgcmVnaXN0ZXIgc29tZSBjb21tb25seSB1c2VkIHtAbGluayBDb250cm9sTWV0aG9kfSBpbnN0YW5jZXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBpbnN0YW5jZXMgYXJlIHJlZ2lzdGVyZWQ6XG4gKiAgIC0gbW91c2VWaWV3RHJhZ1xuICogICAtIG1vdXNlVmlld1F0dnJcbiAqICAgLSB0b3VjaFZpZXdcbiAqICAgLSBwaW5jaFxuICogICAtIGFycm93S2V5c1xuICogICAtIHBsdXNNaW51c0tleXNcbiAqICAgLSB3YXNkS2V5c1xuICogICAtIHFlS2V5c1xuICpcbiAqIEBwYXJhbSB7Q29udHJvbHN9IGNvbnRyb2xzIFdoZXJlIHRvIHJlZ2lzdGVyIHRoZSBpbnN0YW5jZXMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7J2RyYWcnfCdxdHZyJ30gb3B0cy5tb3VzZVZpZXdNb2RlXG4gKiBAcGFyYW0geydwYW4nfCdwaW5jaCd9IG9wdHMuZHJhZ01vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5zY3JvbGxab29tXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdENvbnRyb2xzKGNvbnRyb2xzLCBlbGVtZW50LCBvcHRzKSB7XG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdmFyIGNvbnRyb2xNZXRob2RzID0ge1xuICAgIG1vdXNlVmlld0RyYWc6IG5ldyBEcmFnQ29udHJvbE1ldGhvZChlbGVtZW50LCAnbW91c2UnKSxcbiAgICBtb3VzZVZpZXdRdHZyOiBuZXcgUXR2ckNvbnRyb2xNZXRob2QoZWxlbWVudCwgJ21vdXNlJyksXG5cbiAgICBsZWZ0QXJyb3dLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDM3LCAneCcsIC0wLjcsIDMpLFxuICAgIHJpZ2h0QXJyb3dLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDM5LCAneCcsIDAuNywgMyksXG4gICAgdXBBcnJvd0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMzgsICd5JywgLTAuNywgMyksXG4gICAgZG93bkFycm93S2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg0MCwgJ3knLCAwLjcsIDMpLFxuICAgIHBsdXNLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDEwNywgJ3pvb20nLCAtMC43LCAzKSxcbiAgICBtaW51c0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMTA5LCAnem9vbScsIDAuNywgMyksXG5cbiAgICB3S2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg4NywgJ3knLCAtMC43LCAzKSxcbiAgICBhS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg2NSwgJ3gnLCAtMC43LCAzKSxcbiAgICBzS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg4MywgJ3knLCAwLjcsIDMpLFxuICAgIGRLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDY4LCAneCcsIDAuNywgMyksXG4gICAgcUtleTogbmV3IEtleUNvbnRyb2xNZXRob2QoODEsICdyb2xsJywgMC43LCAzKSxcbiAgICBlS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg2OSwgJ3JvbGwnLCAtMC43LCAzKVxuICB9O1xuXG4gIHZhciBlbmFibGVkQ29udHJvbHMgPSBbJ3Njcm9sbFpvb20nLCAndG91Y2hWaWV3JywgJ3BpbmNoJyBdO1xuXG4gIGlmIChvcHRzLnNjcm9sbFpvb20gIT09IGZhbHNlKSB7XG4gICAgY29udHJvbE1ldGhvZHMuc2Nyb2xsWm9vbSA9IG5ldyBTY3JvbGxab29tQ29udHJvbE1ldGhvZChlbGVtZW50KTsgLy97IGZyaWN0aW9uVGltZTogMCB9XG4gIH1cblxuICB2YXIgY29udHJvbE1ldGhvZEdyb3VwcyA9IHtcbiAgICBhcnJvd0tleXM6IFsgJ2xlZnRBcnJvd0tleScsICdyaWdodEFycm93S2V5JywgJ3VwQXJyb3dLZXknLCAnZG93bkFycm93S2V5JyBdLFxuICAgIHBsdXNNaW51c0tleXM6IFsgJ3BsdXNLZXknLCAnbWludXNLZXknIF0sXG4gICAgd2FzZEtleXM6IFsgJ3dLZXknLCAnYUtleScsICdzS2V5JywgJ2RLZXknIF0sXG4gICAgcWVLZXlzOiBbICdxS2V5JywgJ2VLZXknIF1cbiAgfTtcblxuXG4gIHN3aXRjaCAob3B0cy5kcmFnTW9kZSkge1xuICAgIGNhc2UgJ3BpbmNoJzpcbiAgICAgICBjb250cm9sTWV0aG9kcy5waW5jaCA9IG5ldyBEcmFnQ29udHJvbE1ldGhvZChlbGVtZW50LCAndG91Y2gnLCB7IGhhbW1lckV2ZW50OiAncGluY2gnIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncGFuJzpcbiAgICAgIGNvbnRyb2xNZXRob2RzLnRvdWNoVmlldyA9IG5ldyBEcmFnQ29udHJvbE1ldGhvZChlbGVtZW50LCAndG91Y2gnKTtcbiAgICAgIGNvbnRyb2xNZXRob2RzLnBpbmNoID0gbmV3IFBpbmNoWm9vbUNvbnRyb2xNZXRob2QoZWxlbWVudCwgJ3RvdWNoJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkcmFnIG1vZGU6IFwiICsgb3B0cy5kcmFnTW9kZSk7XG4gIH1cblxuICBzd2l0Y2ggKG9wdHMubW91c2VWaWV3TW9kZSkge1xuICAgIGNhc2UgJ2RyYWcnOlxuICAgICAgZW5hYmxlZENvbnRyb2xzLnB1c2goJ21vdXNlVmlld0RyYWcnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3F0dnInOlxuICAgICAgZW5hYmxlZENvbnRyb2xzLnB1c2goJ21vdXNlVmlld1F0dnInKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vdXNlIHZpZXcgbW9kZTogXCIgKyBvcHRzLm1vdXNlVmlld01vZGUpO1xuICB9XG5cbiAgZm9yICh2YXIgaWQgaW4gY29udHJvbE1ldGhvZHMpIHtcbiAgICB2YXIgbWV0aG9kID0gY29udHJvbE1ldGhvZHNbaWRdO1xuICAgIGNvbnRyb2xzLnJlZ2lzdGVyTWV0aG9kKGlkLCBtZXRob2QpO1xuICAgIGlmIChlbmFibGVkQ29udHJvbHMuaW5kZXhPZihpZCkgPj0gMCkge1xuICAgICAgY29udHJvbHMuZW5hYmxlTWV0aG9kKGlkKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBncm91cElkIGluIGNvbnRyb2xNZXRob2RHcm91cHMpIHtcbiAgICB2YXIgbWV0aG9kR3JvdXAgPSBjb250cm9sTWV0aG9kR3JvdXBzW2dyb3VwSWRdO1xuICAgIGNvbnRyb2xzLmFkZE1ldGhvZEdyb3VwKGdyb3VwSWQsIG1ldGhvZEdyb3VwKTtcbiAgfVxuXG4gIHJldHVybiBjb250cm9sTWV0aG9kcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckRlZmF1bHRDb250cm9scztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWF4RnJpY3Rpb24oZnJpY3Rpb24sIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBtYXhGcmljdGlvblRpbWUsIHJlc3VsdCkge1xuICB2YXIgdmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHlYLDIpICsgTWF0aC5wb3codmVsb2NpdHlZLDIpKTtcbiAgZnJpY3Rpb24gPSBNYXRoLm1heChmcmljdGlvbiwgdmVsb2NpdHkvbWF4RnJpY3Rpb25UaW1lKTtcbiAgY2hhbmdlVmVjdG9yTm9ybSh2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZnJpY3Rpb24sIHJlc3VsdCk7XG4gIHJlc3VsdFswXSA9IE1hdGguYWJzKHJlc3VsdFswXSk7XG4gIHJlc3VsdFsxXSA9IE1hdGguYWJzKHJlc3VsdFsxXSk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVZlY3Rvck5vcm0oeCwgeSwgbiwgcmVzdWx0KSB7XG4gIHZhciB0aGV0YSA9IE1hdGguYXRhbih5L3gpO1xuICByZXN1bHRbMF0gPSBuICogTWF0aC5jb3ModGhldGEpO1xuICByZXN1bHRbMV0gPSBuICogTWF0aC5zaW4odGhldGEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4RnJpY3Rpb246IG1heEZyaWN0aW9uLFxuICBjaGFuZ2VWZWN0b3JOb3JtOiBjaGFuZ2VWZWN0b3JOb3JtXG59OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKTtcbnZhciBUaWxlU2VhcmNoZXIgPSByZXF1aXJlKCcuLi9UaWxlU2VhcmNoZXInKTtcbnZhciBMcnVNYXAgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9McnVNYXAnKTtcbnZhciBMZXZlbCA9IHJlcXVpcmUoJy4vTGV2ZWwnKTtcbnZhciBtYWtlTGV2ZWxMaXN0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5tYWtlTGV2ZWxMaXN0O1xudmFyIG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5tYWtlU2VsZWN0YWJsZUxldmVsTGlzdDtcbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3R5cGUnKTtcbnZhciB2ZWMzID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMztcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxudmFyIG5laWdoYm9yc0NhY2hlU2l6ZSA9IDY0O1xuXG4vLyBJbml0aWFscyBmb3IgY3ViZSBmYWNlcy5cbnZhciBmYWNlTGlzdCA9ICdmdWRscmInO1xuXG4vLyBSb3RhdGlvbiBvZiBlYWNoIGZhY2UsIHJlbGF0aXZlIHRvIHRoZSBmcm9udCBmYWNlLlxudmFyIGZhY2VSb3RhdGlvbiA9IHtcbiAgZjogeyB4OiAwLCB5OiAwIH0sXG4gIGI6IHsgeDogMCwgeTogTWF0aC5QSSB9LFxuICBsOiB7IHg6IDAsIHk6IE1hdGguUEkvMiB9LFxuICByOiB7IHg6IDAsIHk6IC1NYXRoLlBJLzIgfSxcbiAgdTogeyB4OiBNYXRoLlBJLzIsIHk6IDAgfSxcbiAgZDogeyB4OiAtTWF0aC5QSS8yLCB5OiAwIH1cbn07XG5cbi8vIFplcm8gdmVjdG9yLlxudmFyIG9yaWdpbiA9IHZlYzMuY3JlYXRlKCk7XG5cbi8vIFJvdGF0ZSBhIHZlY3RvciBpbiBaWFkgb3JkZXIuXG5mdW5jdGlvbiByb3RhdGVWZWN0b3IodmVjLCB6LCB4LCB5KSB7XG4gIGlmICh6KSB7XG4gICAgdmVjMy5yb3RhdGVaKHZlYywgdmVjLCBvcmlnaW4sIHopO1xuICB9XG4gIGlmICh4KSB7XG4gICAgdmVjMy5yb3RhdGVYKHZlYywgdmVjLCBvcmlnaW4sIHgpO1xuICB9XG4gIGlmICh5KSB7XG4gICAgdmVjMy5yb3RhdGVZKHZlYywgdmVjLCBvcmlnaW4sIHkpO1xuICB9XG59XG5cbi8vIE5vcm1hbGl6ZWQgdmVjdG9ycyBwb2ludGluZyB0byB0aGUgY2VudGVyIG9mIGVhY2ggZmFjZS5cbnZhciBmYWNlVmVjdG9ycyA9IHt9O1xuZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlTGlzdC5sZW5ndGg7IGkrKykge1xuICB2YXIgZmFjZSA9IGZhY2VMaXN0W2ldO1xuICB2YXIgcm90YXRpb24gPSBmYWNlUm90YXRpb25bZmFjZV07XG4gIHZhciB2ID0gdmVjMy5mcm9tVmFsdWVzKDAsICAwLCAtMSk7XG4gIHJvdGF0ZVZlY3Rvcih2LCAwLCByb3RhdGlvbi54LCByb3RhdGlvbi55KTtcbiAgZmFjZVZlY3RvcnNbZmFjZV0gPSB2O1xufVxuXG4vLyBNYXAgZWFjaCBmYWNlIHRvIGl0cyBhZGphY2VudCBmYWNlcy5cbi8vIFRoZSBvcmRlciBpcyBhcyBzdWdnZXN0ZWQgYnkgdGhlIGZyb250IGZhY2UuXG52YXIgYWRqYWNlbnRGYWNlID0ge1xuICBmOiBbICdsJywgJ3InLCAndScsICdkJyBdLFxuICBiOiBbICdyJywgJ2wnLCAndScsICdkJyBdLFxuICBsOiBbICdiJywgJ2YnLCAndScsICdkJyBdLFxuICByOiBbICdmJywgJ2InLCAndScsICdkJyBdLFxuICB1OiBbICdsJywgJ3InLCAnYicsICdmJyBdLFxuICBkOiBbICdsJywgJ3InLCAnZicsICdiJyBdXG59O1xuXG4vLyBPZmZzZXRzIHRvIGFwcGx5IHRvIHRoZSAoeCx5KSBjb29yZGluYXRlcyBvZiBhIHRpbGUgdG8gZ2V0IGl0cyBuZWlnaGJvcnMuXG52YXIgbmVpZ2hib3JPZmZzZXRzID0gW1xuICBbICAwLCAgMSBdLCAvLyB0b3BcbiAgWyAgMSwgIDAgXSwgLy8gcmlnaHRcbiAgWyAgMCwgLTEgXSwgLy8gYm90dG9tXG4gIFsgLTEsICAwIF0gIC8vIGxlZnRcbl07XG5cblxuLyoqXG4gKiBAY2xhc3MgQ3ViZVRpbGVcbiAqIEBpbXBsZW1lbnRzIFRpbGVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHRpbGUgaW4gYSBAe0N1YmVHZW9tZXRyeX0uXG4gKi9cbmZ1bmN0aW9uIEN1YmVUaWxlKGZhY2UsIHgsIHksIHosIGdlb21ldHJ5KSB7XG4gIHRoaXMuZmFjZSA9IGZhY2U7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMueiA9IHo7XG4gIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gIHRoaXMuX2xldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3pdO1xufVxuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5yb3RYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWNlUm90YXRpb25bdGhpcy5mYWNlXS54O1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUucm90WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFjZVJvdGF0aW9uW3RoaXMuZmFjZV0ueTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLnggKyAwLjUpIC8gdGhpcy5fbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAwLjU7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jZW50ZXJZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwLjUgLSAodGhpcy55ICsgMC41KSAvIHRoaXMuX2xldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMSAvIHRoaXMuX2xldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuc2NhbGVZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxIC8gdGhpcy5fbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUudmVydGljZXMgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBbdmVjMy5jcmVhdGUoKSwgdmVjMy5jcmVhdGUoKSwgdmVjMy5jcmVhdGUoKSwgdmVjMy5jcmVhdGUoKV07XG4gIH1cblxuICB2YXIgcm90ID0gZmFjZVJvdGF0aW9uW3RoaXMuZmFjZV07XG5cbiAgZnVuY3Rpb24gbWFrZVZlcnRleCh2ZWMsIHgsIHkpIHtcbiAgICB2ZWMzLnNldCh2ZWMsIHgsIHksIC0wLjUpO1xuICAgIHJvdGF0ZVZlY3Rvcih2ZWMsIDAsIHJvdC54LCByb3QueSk7XG4gIH1cblxuICB2YXIgbGVmdCA9IHRoaXMuY2VudGVyWCgpIC0gdGhpcy5zY2FsZVgoKSAvIDI7XG4gIHZhciByaWdodCA9IHRoaXMuY2VudGVyWCgpICsgdGhpcy5zY2FsZVgoKSAvIDI7XG4gIHZhciBib3R0b20gPSB0aGlzLmNlbnRlclkoKSAtIHRoaXMuc2NhbGVZKCkgLyAyO1xuICB2YXIgdG9wID0gdGhpcy5jZW50ZXJZKCkgKyB0aGlzLnNjYWxlWSgpIC8gMjtcblxuICBtYWtlVmVydGV4KHJlc3VsdFswXSwgbGVmdCwgdG9wKTtcbiAgbWFrZVZlcnRleChyZXN1bHRbMV0sIHJpZ2h0LCB0b3ApO1xuICBtYWtlVmVydGV4KHJlc3VsdFsyXSwgcmlnaHQsIGJvdHRvbSk7XG4gIG1ha2VWZXJ0ZXgocmVzdWx0WzNdLCBsZWZ0LCBib3R0b20pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy56ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmFjZSA9IHRoaXMuZmFjZTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIGxldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3pdO1xuICB2YXIgcGFyZW50TGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbei0xXTtcblxuICB2YXIgdGlsZVggPSBNYXRoLmZsb29yKHggLyBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAqIHBhcmVudExldmVsLm51bUhvcml6b250YWxUaWxlcygpKTtcbiAgdmFyIHRpbGVZID0gTWF0aC5mbG9vcih5IC8gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpICogcGFyZW50TGV2ZWwubnVtVmVydGljYWxUaWxlcygpKTtcbiAgdmFyIHRpbGVaID0gei0xO1xuXG4gIHJldHVybiBuZXcgQ3ViZVRpbGUoZmFjZSwgdGlsZVgsIHRpbGVZLCB0aWxlWiwgZ2VvbWV0cnkpO1xuXG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gIGlmICh0aGlzLnogPT09IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdC5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmFjZSA9IHRoaXMuZmFjZTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIGxldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3pdO1xuICB2YXIgY2hpbGRMZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6KzFdO1xuXG4gIHZhciBuSG9yaXogPSBjaGlsZExldmVsLm51bUhvcml6b250YWxUaWxlcygpIC8gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBuVmVydCA9IGNoaWxkTGV2ZWwubnVtVmVydGljYWxUaWxlcygpIC8gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICBmb3IgKHZhciBoID0gMDsgaCA8IG5Ib3JpejsgaCsrKSB7XG4gICAgZm9yICh2YXIgdiA9IDA7IHYgPCBuVmVydDsgdisrKSB7XG4gICAgICB2YXIgdGlsZVggPSBuSG9yaXogKiB4ICsgaDtcbiAgICAgIHZhciB0aWxlWSA9IG5WZXJ0ICogeSArIHY7XG4gICAgICB2YXIgdGlsZVogPSB6KzE7XG4gICAgICByZXN1bHQucHVzaChuZXcgQ3ViZVRpbGUoZmFjZSwgdGlsZVgsIHRpbGVZLCB0aWxlWiwgZ2VvbWV0cnkpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIGNhY2hlID0gZ2VvbWV0cnkuX25laWdoYm9yc0NhY2hlO1xuXG4gIC8vIFNhdGlzZnkgZnJvbSBjYWNoZSB3aGVuIGF2YWlsYWJsZS5cbiAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldCh0aGlzKTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cblxuICB2YXIgdmVjID0gZ2VvbWV0cnkuX3ZlYztcblxuICB2YXIgZmFjZSA9IHRoaXMuZmFjZTtcbiAgdmFyIHggPSB0aGlzLng7XG4gIHZhciB5ID0gdGhpcy55O1xuICB2YXIgeiA9IHRoaXMuejtcbiAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWw7XG5cbiAgdmFyIG51bVggPSBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIG51bVkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JPZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHhPZmZzZXQgPSBuZWlnaGJvck9mZnNldHNbaV1bMF07XG4gICAgdmFyIHlPZmZzZXQgPSBuZWlnaGJvck9mZnNldHNbaV1bMV07XG5cbiAgICB2YXIgbmV3WCA9IHggKyB4T2Zmc2V0O1xuICAgIHZhciBuZXdZID0geSArIHlPZmZzZXQ7XG4gICAgdmFyIG5ld1ogPSB6O1xuICAgIHZhciBuZXdGYWNlID0gZmFjZTtcblxuICAgIGlmIChuZXdYIDwgMCB8fCBuZXdYID49IG51bVggfHwgbmV3WSA8IDAgfHwgbmV3WSA+PSBudW1ZKSB7XG5cbiAgICAgIC8vIElmIHRoZSBuZWlnaGJvcmluZyB0aWxlIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgZmFjZSwgY2FsY3VsYXRlIGFcbiAgICAgIC8vIHZlY3RvciBwb2ludGluZyB0byB0aGUgZWRnZSBiZXR3ZWVuIHRoZSB0d28gZmFjZXMgYXQgdGhlIHBvaW50IHRoZVxuICAgICAgLy8gdGlsZSBhbmQgaXRzIG5laWdoYm9yIG1lZXQsIGFuZCBjb252ZXJ0IGl0IGludG8gdGlsZSBjb29yZGluYXRlcyBmb3JcbiAgICAgIC8vIHRoZSBuZWlnaGJvcmluZyBmYWNlLlxuXG4gICAgICB2YXIgeENvb3JkID0gdGhpcy5jZW50ZXJYKCk7XG4gICAgICB2YXIgeUNvb3JkID0gdGhpcy5jZW50ZXJZKCk7XG5cbiAgICAgIC8vIEZpcnN0LCBjYWxjdWxhdGUgdGhlIHZlY3RvciBhcyBpZiB0aGUgaW5pdGlhbCB0aWxlIGJlbG9uZ3MgdG8gdGhlXG4gICAgICAvLyBmcm9udCBmYWNlLCBzbyB0aGF0IHRoZSB0aWxlIHgseSBjb29yZGluYXRlcyBtYXAgZGlyZWN0bHkgaW50byB0aGVcbiAgICAgIC8vIHgseSBheGVzLlxuXG4gICAgICBpZiAobmV3WCA8IDApIHtcbiAgICAgICAgdmVjMy5zZXQodmVjLCAtMC41LCB5Q29vcmQsIC0wLjUpO1xuICAgICAgICBuZXdGYWNlID0gYWRqYWNlbnRGYWNlW2ZhY2VdWzBdO1xuICAgICAgfSBlbHNlIGlmIChuZXdYID49IG51bVgpIHtcbiAgICAgICAgdmVjMy5zZXQodmVjLCAwLjUsIHlDb29yZCwgLTAuNSk7XG4gICAgICAgIG5ld0ZhY2UgPSBhZGphY2VudEZhY2VbZmFjZV1bMV07XG4gICAgICB9IGVsc2UgaWYgKG5ld1kgPCAwKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgeENvb3JkLCAwLjUsIC0wLjUpO1xuICAgICAgICBuZXdGYWNlID0gYWRqYWNlbnRGYWNlW2ZhY2VdWzJdO1xuICAgICAgfSBlbHNlIGlmIChuZXdZID49IG51bVkpIHtcbiAgICAgICAgdmVjMy5zZXQodmVjLCB4Q29vcmQsIC0wLjUsIC0wLjUpO1xuICAgICAgICBuZXdGYWNlID0gYWRqYWNlbnRGYWNlW2ZhY2VdWzNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm90O1xuXG4gICAgICAvLyBUaGVuLCByb3RhdGUgdGhlIHZlY3RvciBpbnRvIHRoZSBhY3R1YWwgZmFjZSB0aGUgaW5pdGlhbCB0aWxlXG4gICAgICAvLyBiZWxvbmdzIHRvLlxuXG4gICAgICByb3QgPSBmYWNlUm90YXRpb25bZmFjZV07XG4gICAgICByb3RhdGVWZWN0b3IodmVjLCAwLCByb3QueCwgcm90LnkpO1xuXG4gICAgICAvLyBGaW5hbGx5LCByb3RhdGUgdGhlIHZlY3RvciBmcm9tIHRoZSBuZWlnaGJvcmluZyBmYWNlIGludG8gdGhlIGZyb250XG4gICAgICAvLyBmYWNlLiBBZ2FpbiwgdGhpcyBpcyBzbyB0aGF0IHRoZSBuZWlnaGJvcmluZyB0aWxlIHgseSBjb29yZGluYXRlc1xuICAgICAgLy8gbWFwIGRpcmVjdGx5IGludG8gdGhlIHgseSBheGVzLlxuXG4gICAgICByb3QgPSBmYWNlUm90YXRpb25bbmV3RmFjZV07XG4gICAgICByb3RhdGVWZWN0b3IodmVjLCAwLCAtcm90LngsIC1yb3QueSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmVpZ2hib3JpbmcgdGlsZSBjb29yZGluYXRlcy5cblxuICAgICAgbmV3WCA9IGNsYW1wKE1hdGguZmxvb3IoKDAuNSArIHZlY1swXSkgKiBudW1YKSwgMCwgbnVtWCAtIDEpO1xuICAgICAgbmV3WSA9IGNsYW1wKE1hdGguZmxvb3IoKDAuNSAtIHZlY1sxXSkgKiBudW1ZKSwgMCwgbnVtWSAtIDEpO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKG5ldyBDdWJlVGlsZShuZXdGYWNlLCBuZXdYLCBuZXdZLCBuZXdaLCBnZW9tZXRyeSkpO1xuICB9XG5cbiAgLy8gU3RvcmUgaW50byBjYWNoZSB0byBzYXRpc2Z5IGZ1dHVyZSByZXF1ZXN0cy5cbiAgY2FjaGUuc2V0KHRoaXMsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaGFzaChmYWNlTGlzdC5pbmRleE9mKHRoaXMuZmFjZSksIHRoaXMueiwgdGhpcy55LCB0aGlzLngpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gKHRoaXMuX2dlb21ldHJ5ID09PSB0aGF0Ll9nZW9tZXRyeSAmJlxuICAgICAgdGhpcy5mYWNlID09PSB0aGF0LmZhY2UgJiZcbiAgICAgIHRoaXMueiA9PT0gdGhhdC56ICYmXG4gICAgICB0aGlzLnkgPT09IHRoYXQueSAmJlxuICAgICAgdGhpcy54ID09PSB0aGF0LngpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gKGNtcCh0aGlzLnosIHRoYXQueikgfHxcbiAgY21wKGZhY2VMaXN0LmluZGV4T2YodGhpcy5mYWNlKSwgZmFjZUxpc3QuaW5kZXhPZih0aGF0LmZhY2UpKSB8fFxuICBjbXAodGhpcy55LCB0aGF0LnkpIHx8IGNtcCh0aGlzLngsIHRoYXQueCkpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnQ3ViZVRpbGUoJyArIHRpbGUuZmFjZSArICcsICcgKyB0aWxlLnggKyAnLCAnICsgdGlsZS55ICsgJywgJyArIHRpbGUueiArICcpJztcbn07XG5cblxuZnVuY3Rpb24gQ3ViZUxldmVsKGxldmVsUHJvcGVydGllcykge1xuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5jYWxsKHRoaXMsIGxldmVsUHJvcGVydGllcyk7XG5cbiAgdGhpcy5fc2l6ZSA9IGxldmVsUHJvcGVydGllcy5zaXplO1xuICB0aGlzLl90aWxlU2l6ZSA9IGxldmVsUHJvcGVydGllcy50aWxlU2l6ZTtcblxuICBpZiAodGhpcy5fc2l6ZSAlIHRoaXMuX3RpbGVTaXplICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCBzaXplIGlzIG5vdCBtdWx0aXBsZSBvZiB0aWxlIHNpemU6ICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaXplICsgJyAnICsgdGhpcy5fdGlsZVNpemUpO1xuICB9XG59XG5cbmluaGVyaXRzKEN1YmVMZXZlbCwgTGV2ZWwpO1xuXG5cbkN1YmVMZXZlbC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG5cbkN1YmVMZXZlbC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuXG5DdWJlTGV2ZWwucHJvdG90eXBlLnRpbGVXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGlsZVNpemU7XG59O1xuXG5cbkN1YmVMZXZlbC5wcm90b3R5cGUudGlsZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGlsZVNpemU7XG59O1xuXG5cbkN1YmVMZXZlbC5wcm90b3R5cGUuX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsID0gZnVuY3Rpb24ocGFyZW50TGV2ZWwpIHtcblxuICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICB2YXIgdGlsZVdpZHRoID0gdGhpcy50aWxlV2lkdGgoKTtcbiAgdmFyIHRpbGVIZWlnaHQgPSB0aGlzLnRpbGVIZWlnaHQoKTtcbiAgdmFyIG51bUhvcml6b250YWwgPSB0aGlzLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgbnVtVmVydGljYWwgPSB0aGlzLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICB2YXIgcGFyZW50V2lkdGggPSBwYXJlbnRMZXZlbC53aWR0aCgpO1xuICB2YXIgcGFyZW50SGVpZ2h0ID0gcGFyZW50TGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciBwYXJlbnRUaWxlV2lkdGggPSBwYXJlbnRMZXZlbC50aWxlV2lkdGgoKTtcbiAgdmFyIHBhcmVudFRpbGVIZWlnaHQgPSBwYXJlbnRMZXZlbC50aWxlSGVpZ2h0KCk7XG4gIHZhciBwYXJlbnROdW1Ib3Jpem9udGFsID0gcGFyZW50TGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBwYXJlbnROdW1WZXJ0aWNhbCA9IHBhcmVudExldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICBpZiAod2lkdGggJSBwYXJlbnRXaWR0aCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTGV2ZWwgd2lkdGggbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCArICcgdnMuICcgKyBwYXJlbnRXaWR0aCk7XG4gIH1cblxuICBpZiAoaGVpZ2h0ICUgcGFyZW50SGVpZ2h0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCBoZWlnaHQgbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKyAnIHZzLiAnICsgcGFyZW50SGVpZ2h0KTtcbiAgfVxuXG4gIGlmIChudW1Ib3Jpem9udGFsICUgcGFyZW50TnVtSG9yaXpvbnRhbCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIGhvcml6b250YWwgdGlsZXMgbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgbnVtSG9yaXpvbnRhbCArIFwiIChcIiArIHdpZHRoICsgJy8nICsgdGlsZVdpZHRoICsgJyknICsgXCIgdnMuIFwiICtcbiAgICAgIHBhcmVudE51bUhvcml6b250YWwgKyBcIiAoXCIgKyBwYXJlbnRXaWR0aCArICcvJyArIHBhcmVudFRpbGVXaWR0aCArICcpJyk7XG4gIH1cblxuICBpZiAobnVtVmVydGljYWwgJSBwYXJlbnROdW1WZXJ0aWNhbCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG9mIHZlcnRpY2FsIHRpbGVzIG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgIG51bVZlcnRpY2FsICsgXCIgKFwiICsgaGVpZ2h0ICsgJy8nICsgdGlsZUhlaWdodCArICcpJyArIFwiIHZzLiBcIiArXG4gICAgICBwYXJlbnROdW1WZXJ0aWNhbCArIFwiIChcIiArIHBhcmVudEhlaWdodCArICcvJyArIHBhcmVudFRpbGVIZWlnaHQgKyAnKScpO1xuICB9XG5cbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgQ3ViZUdlb21ldHJ5XG4gKiBAaW1wbGVtZW50cyBHZW9tZXRyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIEdlb21ldHJ5fSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgdGlsZWQgY3ViZSBpbWFnZXMgd2l0aFxuICogbXVsdGlwbGUgcmVzb2x1dGlvbiBsZXZlbHMuXG4gKlxuICogVGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnMgYXBwbHk6XG4gKiAgIC0gQWxsIHRpbGVzIGluIGEgbGV2ZWwgbXVzdCBiZSBzcXVhcmUgYW5kIGZvcm0gYSByZWN0YW5ndWxhciBncmlkO1xuICogICAtIFRoZSBzaXplIG9mIGEgbGV2ZWwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSB0aWxlIHNpemU7XG4gKiAgIC0gVGhlIHNpemUgb2YgYSBsZXZlbCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIHBhcmVudCBsZXZlbCBzaXplO1xuICogICAtIFRoZSBudW1iZXIgb2YgdGlsZXMgaW4gYSBsZXZlbCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIG51bWJlciBvZiB0aWxlc1xuICogICAgIGluIHRoZSBwYXJlbnQgbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gbGV2ZWxQcm9wZXJ0aWVzTGlzdCBMZXZlbCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS5zaXplIEN1YmUgZmFjZSBzaXplIGluIHBpeGVsc1xuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS50aWxlU2l6ZSBUaWxlIHNpemUgaW4gcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIEN1YmVHZW9tZXRyeShsZXZlbFByb3BlcnRpZXNMaXN0KSB7XG4gIGlmICh0eXBlKGxldmVsUHJvcGVydGllc0xpc3QpICE9PSAnYXJyYXknKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCBsaXN0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWxMaXN0ID0gbWFrZUxldmVsTGlzdChsZXZlbFByb3BlcnRpZXNMaXN0LCBDdWJlTGV2ZWwpO1xuICB0aGlzLnNlbGVjdGFibGVMZXZlbExpc3QgPSBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdCh0aGlzLmxldmVsTGlzdCk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMubGV2ZWxMaXN0W2ldLl92YWxpZGF0ZVdpdGhQYXJlbnRMZXZlbCh0aGlzLmxldmVsTGlzdFtpLTFdKTtcbiAgfVxuXG4gIHRoaXMuX3RpbGVTZWFyY2hlciA9IG5ldyBUaWxlU2VhcmNoZXIodGhpcyk7XG5cbiAgdGhpcy5fbmVpZ2hib3JzQ2FjaGUgPSBuZXcgTHJ1TWFwKG5laWdoYm9yc0NhY2hlU2l6ZSk7XG5cbiAgdGhpcy5fdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICB0aGlzLl92aWV3U2l6ZSA9IHt9O1xufVxuXG5cbkN1YmVHZW9tZXRyeS5wcm90b3R5cGUubWF4VGlsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1heFRpbGVTaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxMaXN0W2ldO1xuICAgIG1heFRpbGVTaXplID0gTWF0aC5tYXgobWF4VGlsZVNpemUsIGxldmVsLnRpbGVXaWR0aCwgbGV2ZWwudGlsZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIG1heFRpbGVTaXplO1xufTtcblxuXG5DdWJlR2VvbWV0cnkucHJvdG90eXBlLmxldmVsVGlsZXMgPSBmdW5jdGlvbihsZXZlbCwgcmVzdWx0KSB7XG5cbiAgdmFyIGxldmVsSW5kZXggPSB0aGlzLmxldmVsTGlzdC5pbmRleE9mKGxldmVsKTtcbiAgdmFyIG1heFggPSBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAtIDE7XG4gIHZhciBtYXhZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpIC0gMTtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgZm9yICh2YXIgZiA9IDA7IGYgPCBmYWNlTGlzdC5sZW5ndGg7IGYrKykge1xuICAgIHZhciBmYWNlID0gZmFjZUxpc3RbZl07XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPD0gbWF4WDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IEN1YmVUaWxlKGZhY2UsIHgsIHksIGxldmVsSW5kZXgsIHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cbkN1YmVHZW9tZXRyeS5wcm90b3R5cGUuX2Nsb3Nlc3RUaWxlID0gZnVuY3Rpb24odmlldywgbGV2ZWwpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3ZlYztcblxuICAvLyBDb21wdXRlIGEgdmlldyByYXkgaW50byB0aGUgY2VudHJhbCBzY3JlZW4gcG9pbnQuXG4gIHZlYzQuc2V0KHJheSwgMCwgMCwgMCwgMSk7XG4gIHZhciBtYXRyaXggPSBtYXQ0LmNyZWF0ZSgpXG4gIG1hdDQubXVsdGlwbHkobWF0cml4LCB2aWV3LmludmVyc2VWaWV3TWF0cml4KCksIHZpZXcuaW52ZXJzZVByb2plY3Rpb24oKSk7XG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgbWF0cml4KTtcblxuICB2YXIgbWluQW5nbGUgPSBJbmZpbml0eTtcbiAgdmFyIGNsb3Nlc3RGYWNlID0gbnVsbDtcblxuICAvLyBGaW5kIHRoZSBmYWNlIHdob3NlIHZlY3RvciBtYWtlcyBhIG1pbmltYWwgYW5nbGUgd2l0aCB0aGUgdmlldyByYXkuXG4gIC8vIFRoaXMgaXMgdGhlIGZhY2UgaW50byB3aGljaCB0aGUgdmlldyByYXkgcG9pbnRzLlxuICBmb3IgKHZhciBmYWNlIGluIGZhY2VWZWN0b3JzKSB7XG4gICAgdmFyIHZlY3RvciA9IGZhY2VWZWN0b3JzW2ZhY2VdO1xuICAgIC8vIEZvciBhIHNtYWxsIGFuZ2xlIGJldHdlZW4gdHdvIG5vcm1hbGl6ZWQgdmVjdG9ycywgYW5nbGUgfiAxLWNvcyhhbmdsZSkuXG4gICAgdmFyIGFuZ2xlID0gMSAtIHZlYzMuZG90KHZlY3RvciwgcmF5KTtcbiAgICBpZiAoYW5nbGUgPCBtaW5BbmdsZSkge1xuICAgICAgbWluQW5nbGUgPSBhbmdsZTtcbiAgICAgIGNsb3Nlc3RGYWNlID0gZmFjZTtcbiAgICB9XG4gIH1cblxuICAvLyBQcm9qZWN0IHZpZXcgcmF5IG9udG8gY3ViZSwgaS5lLiwgbm9ybWFsaXplIHRoZSBjb29yZGluYXRlIHdpdGhcbiAgLy8gbGFyZ2VzdCBhYnNvbHV0ZSB2YWx1ZSB0byDCsTAuNS5cbiAgdmFyIG1heCA9IE1hdGgubWF4KE1hdGguYWJzKHJheVswXSksIE1hdGguYWJzKHJheVsxXSksIE1hdGguYWJzKHJheVsyXSkpIC8gMC41O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJheVtpXSA9IHJheVtpXSAvIG1heDtcbiAgfVxuXG4gIC8vIFJvdGF0ZSB2aWV3IHJheSBpbnRvIGZyb250IGZhY2UuXG4gIHZhciByb3QgPSBmYWNlUm90YXRpb25bY2xvc2VzdEZhY2VdO1xuICByb3RhdGVWZWN0b3IocmF5LCAwLCAtcm90LngsIC1yb3QueSk7XG5cbiAgLy8gR2V0IHRoZSBkZXNpcmVkIHpvb20gbGV2ZWwuXG4gIHZhciB0aWxlWiA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICB2YXIgbnVtWCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgbnVtWSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICAvLyBGaW5kIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdGlsZSB0aGF0IHRoZSB2aWV3IHJheSBwb2ludHMgaW50by5cbiAgdmFyIHRpbGVYID0gY2xhbXAoTWF0aC5mbG9vcigoMC41ICsgcmF5WzBdKSAqIG51bVgpLCAwLCBudW1YIC0gMSk7XG4gIHZhciB0aWxlWSA9IGNsYW1wKE1hdGguZmxvb3IoKDAuNSAtIHJheVsxXSkgKiBudW1ZKSwgMCwgbnVtWSAtIDEpO1xuXG4gIHJldHVybiBuZXcgQ3ViZVRpbGUoY2xvc2VzdEZhY2UsIHRpbGVYLCB0aWxlWSwgdGlsZVosIHRoaXMpO1xufTtcblxuXG5DdWJlR2VvbWV0cnkucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsLCByZXN1bHQpIHtcbiAgdmFyIHZpZXdTaXplID0gdGhpcy5fdmlld1NpemU7XG4gIHZhciB0aWxlU2VhcmNoZXIgPSB0aGlzLl90aWxlU2VhcmNoZXI7XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gIHZpZXcuc2l6ZSh2aWV3U2l6ZSk7XG4gIGlmICh2aWV3U2l6ZS53aWR0aCA9PT0gMCB8fCB2aWV3U2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAvLyBObyB0aWxlcyBhcmUgdmlzaWJsZSBpZiB0aGUgdmlld3BvcnQgaXMgZW1wdHkuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBzdGFydGluZ1RpbGUgPSB0aGlzLl9jbG9zZXN0VGlsZSh2aWV3LCBsZXZlbCk7XG4gIHZhciBjb3VudCA9IHRpbGVTZWFyY2hlci5zZWFyY2godmlldywgc3RhcnRpbmdUaWxlLCByZXN1bHQpO1xuICBpZiAoIWNvdW50KSB7XG4gICAgLy90aHJvdyBuZXcgRXJyb3IoJ1N0YXJ0aW5nIHRpbGUgaXMgbm90IHZpc2libGUnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkN1YmVHZW9tZXRyeS5UaWxlID0gQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5UaWxlID0gQ3ViZVRpbGU7XG5DdWJlR2VvbWV0cnkudHlwZSA9IEN1YmVHZW9tZXRyeS5wcm90b3R5cGUudHlwZSA9ICdjdWJlJztcbkN1YmVUaWxlLnR5cGUgPSBDdWJlVGlsZS5wcm90b3R5cGUudHlwZSA9ICdjdWJlJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEN1YmVHZW9tZXRyeTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgTGV2ZWwgPSByZXF1aXJlKCcuL0xldmVsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvdHlwZScpO1xuXG5cbi8qKlxuICogQGNsYXNzIEVxdWlyZWN0VGlsZVxuICogQGltcGxlbWVudHMgVGlsZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgdGlsZSBpbiBhbiBAe0VxdWlyZWN0R2VvbWV0cnl9LlxuICovXG5mdW5jdGlvbiBFcXVpcmVjdFRpbGUoeiwgZ2VvbWV0cnkpIHtcbiAgdGhpcy56ID0gejtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG59XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5yb3RYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnJvdFkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMC41O1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDAuNTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zY2FsZVggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDE7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuc2NhbGVZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy56ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBFcXVpcmVjdFRpbGUodGhpcy56IC0gMSwgdGhpcy5fZ2VvbWV0cnkpO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICh0aGlzLnogPT09IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdC5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICByZXN1bHQucHVzaChuZXcgRXF1aXJlY3RUaWxlKHRoaXMueiArIDEsIHRoaXMuX2dlb21ldHJ5KSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBoYXNoKHRoaXMueik7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkgPT09IHRoYXQuX2dlb21ldHJ5ICYmIHRoaXMueiA9PT0gdGhhdC56O1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIGNtcCh0aGlzLnosIHRoYXQueik7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnRXF1aXJlY3RUaWxlKCcgKyB0aWxlLnogKyAnKSc7XG59O1xuXG5cbmZ1bmN0aW9uIEVxdWlyZWN0TGV2ZWwobGV2ZWxQcm9wZXJ0aWVzKSB7XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmNhbGwodGhpcywgbGV2ZWxQcm9wZXJ0aWVzKTtcbiAgdGhpcy5fd2lkdGggPSBsZXZlbFByb3BlcnRpZXMud2lkdGg7XG59XG5cbmluaGVyaXRzKEVxdWlyZWN0TGV2ZWwsIExldmVsKTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbkVxdWlyZWN0TGV2ZWwucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGgvMjtcbn07XG5cblxuRXF1aXJlY3RMZXZlbC5wcm90b3R5cGUudGlsZVdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuRXF1aXJlY3RMZXZlbC5wcm90b3R5cGUudGlsZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGgvMjtcbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgRXF1aXJlY3RHZW9tZXRyeVxuICogQGltcGxlbWVudHMgR2VvbWV0cnlcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBHZW9tZXRyeX0gaW1wbGVtZW50YXRpb24gc3VpdGFibGUgZm9yIGVxdWlyZWN0YW5ndWxhciBpbWFnZXMgd2l0aCBhXG4gKiAyOjEgYXNwZWN0IHJhdGlvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IGxldmVsUHJvcGVydGllc0xpc3QgTGV2ZWwgZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10ud2lkdGggTGV2ZWwgd2lkdGggaW4gcGl4ZWxzXG4qL1xuZnVuY3Rpb24gRXF1aXJlY3RHZW9tZXRyeShsZXZlbFByb3BlcnRpZXNMaXN0KSB7XG4gIGlmICh0eXBlKGxldmVsUHJvcGVydGllc0xpc3QpICE9PSAnYXJyYXknKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCBsaXN0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWxMaXN0ID0gY29tbW9uLm1ha2VMZXZlbExpc3QobGV2ZWxQcm9wZXJ0aWVzTGlzdCwgRXF1aXJlY3RMZXZlbCk7XG4gIHRoaXMuc2VsZWN0YWJsZUxldmVsTGlzdCA9IGNvbW1vbi5tYWtlU2VsZWN0YWJsZUxldmVsTGlzdCh0aGlzLmxldmVsTGlzdCk7XG59XG5cblxuRXF1aXJlY3RHZW9tZXRyeS5wcm90b3R5cGUubWF4VGlsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1heFRpbGVTaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxMaXN0W2ldO1xuICAgIG1heFRpbGVTaXplID0gTWF0aC5tYXgobWF4VGlsZVNpemUsIGxldmVsLnRpbGVXaWR0aCwgbGV2ZWwudGlsZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIG1heFRpbGVTaXplO1xufTtcblxuXG5FcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS5sZXZlbFRpbGVzID0gZnVuY3Rpb24obGV2ZWwsIHJlc3VsdCkge1xuICB2YXIgbGV2ZWxJbmRleCA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gIHJlc3VsdC5wdXNoKG5ldyBFcXVpcmVjdFRpbGUobGV2ZWxJbmRleCwgdGhpcykpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5FcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS52aXNpYmxlVGlsZXMgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciB0aWxlID0gbmV3IEVxdWlyZWN0VGlsZSh0aGlzLmxldmVsTGlzdC5pbmRleE9mKGxldmVsKSwgdGhpcyk7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgcmVzdWx0Lmxlbmd0aCA9IDA7XG4gIHJlc3VsdC5wdXNoKHRpbGUpO1xufTtcblxuXG5FcXVpcmVjdEdlb21ldHJ5LlRpbGUgPSBFcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS5UaWxlID0gRXF1aXJlY3RUaWxlO1xuRXF1aXJlY3RHZW9tZXRyeS50eXBlID0gRXF1aXJlY3RHZW9tZXRyeS5wcm90b3R5cGUudHlwZSA9ICdlcXVpcmVjdCc7XG5FcXVpcmVjdFRpbGUudHlwZSA9IEVxdWlyZWN0VGlsZS5wcm90b3R5cGUudHlwZSA9ICdlcXVpcmVjdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBFcXVpcmVjdEdlb21ldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL3V0aWwvaGFzaCcpO1xudmFyIFRpbGVTZWFyY2hlciA9IHJlcXVpcmUoJy4uL1RpbGVTZWFyY2hlcicpO1xudmFyIExydU1hcCA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL0xydU1hcCcpO1xudmFyIExldmVsID0gcmVxdWlyZSgnLi9MZXZlbCcpO1xudmFyIG1ha2VMZXZlbExpc3QgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1ha2VMZXZlbExpc3Q7XG52YXIgbWFrZVNlbGVjdGFibGVMZXZlbExpc3QgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0O1xudmFyIGNsYW1wID0gcmVxdWlyZSgnLi4vdXRpbC9jbGFtcCcpO1xudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG52YXIgY21wID0gcmVxdWlyZSgnLi4vdXRpbC9jbXAnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vdXRpbC90eXBlJyk7XG52YXIgdmVjMiA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzI7XG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG5cbnZhciBuZWlnaGJvcnNDYWNoZVNpemUgPSA2NDtcblxuLy8gT2Zmc2V0cyB0byBhcHBseSB0byB0aGUgKHgseSkgY29vcmRpbmF0ZXMgb2YgYSB0aWxlIHRvIGdldCBpdHMgbmVpZ2hib3JzLlxudmFyIG5laWdoYm9yT2Zmc2V0cyA9IFtcbiAgWyAgMCwgIDEgXSwgLy8gdG9wXG4gIFsgIDEsICAwIF0sIC8vIHJpZ2h0XG4gIFsgIDAsIC0xIF0sIC8vIGJvdHRvbVxuICBbIC0xLCAgMCBdICAvLyBsZWZ0XG5dO1xuXG5cbi8qKlxuICogQGNsYXNzIEZsYXRUaWxlXG4gKiBAaW1wbGVtZW50cyBUaWxlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB0aWxlIGluIGEge0BsaW5rIEZsYXRHZW9tZXRyeX0uXG4gKi9cbmZ1bmN0aW9uIEZsYXRUaWxlKHgsIHksIHosIGdlb21ldHJ5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMueiA9IHo7XG4gIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gIHRoaXMuX2xldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3pdO1xufVxuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5yb3RYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUucm90WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsV2lkdGggPSB0aGlzLl9sZXZlbC53aWR0aCgpO1xuICB2YXIgdGlsZVdpZHRoID0gdGhpcy5fbGV2ZWwudGlsZVdpZHRoKCk7XG4gIHJldHVybiAodGhpcy54ICogdGlsZVdpZHRoICsgMC41ICogdGhpcy53aWR0aCgpKSAvIGxldmVsV2lkdGggLSAwLjU7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5jZW50ZXJZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbEhlaWdodCA9IHRoaXMuX2xldmVsLmhlaWdodCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IHRoaXMuX2xldmVsLnRpbGVIZWlnaHQoKTtcbiAgcmV0dXJuIDAuNSAtICh0aGlzLnkgKiB0aWxlSGVpZ2h0ICsgMC41ICogdGhpcy5oZWlnaHQoKSkgLyBsZXZlbEhlaWdodDtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHJldHVybiB0aGlzLndpZHRoKCkgLyBsZXZlbFdpZHRoO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuc2NhbGVZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbEhlaWdodCA9IHRoaXMuX2xldmVsLmhlaWdodCgpO1xuICByZXR1cm4gdGhpcy5oZWlnaHQoKSAvIGxldmVsSGVpZ2h0O1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsV2lkdGggPSB0aGlzLl9sZXZlbC53aWR0aCgpO1xuICB2YXIgdGlsZVdpZHRoID0gdGhpcy5fbGV2ZWwudGlsZVdpZHRoKCk7XG4gIGlmICh0aGlzLnggPT09IHRoaXMuX2xldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMSkge1xuICAgIHZhciB3aWR0aFJlbWFpbmRlciA9IG1vZChsZXZlbFdpZHRoLCB0aWxlV2lkdGgpO1xuICAgIHJldHVybiB3aWR0aFJlbWFpbmRlciB8fCB0aWxlV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVXaWR0aDtcbiAgfVxufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbEhlaWdodCA9IHRoaXMuX2xldmVsLmhlaWdodCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IHRoaXMuX2xldmVsLnRpbGVIZWlnaHQoKTtcbiAgaWYgKHRoaXMueSA9PT0gdGhpcy5fbGV2ZWwubnVtVmVydGljYWxUaWxlcygpIC0gMSkge1xuICAgIHZhciBoZWlnaHRSZW1haW5kZXIgPSBtb2QobGV2ZWxIZWlnaHQsIHRpbGVIZWlnaHQpO1xuICAgIHJldHVybiBoZWlnaHRSZW1haW5kZXIgfHwgdGlsZUhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGlsZUhlaWdodDtcbiAgfVxufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUubGV2ZWxXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGV2ZWwud2lkdGgoKTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmxldmVsSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC5oZWlnaHQoKTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnZlcnRpY2VzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gW3ZlYzIuY3JlYXRlKCksIHZlYzIuY3JlYXRlKCksIHZlYzIuY3JlYXRlKCksIHZlYzIuY3JlYXRlKCldO1xuICB9XG5cbiAgdmFyIGxlZnQgPSB0aGlzLmNlbnRlclgoKSAtIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgcmlnaHQgPSB0aGlzLmNlbnRlclgoKSArIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgYm90dG9tID0gdGhpcy5jZW50ZXJZKCkgLSB0aGlzLnNjYWxlWSgpIC8gMjtcbiAgdmFyIHRvcCA9IHRoaXMuY2VudGVyWSgpICsgdGhpcy5zY2FsZVkoKSAvIDI7XG5cbiAgdmVjMi5zZXQocmVzdWx0WzBdLCBsZWZ0LCB0b3ApO1xuICB2ZWMyLnNldChyZXN1bHRbMV0sIHJpZ2h0LCB0b3ApO1xuICB2ZWMyLnNldChyZXN1bHRbMl0sIHJpZ2h0LCBib3R0b20pO1xuICB2ZWMyLnNldChyZXN1bHRbM10sIGxlZnQsIGJvdHRvbSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuXG5cbiAgaWYgKHRoaXMueiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgdmFyIHogPSB0aGlzLnogLSAxO1xuICAvLyBUT0RPOiBDdXJyZW50bHkgYXNzdW1pbmcgZWFjaCBsZXZlbCBpcyBkb3VibGUgdGhlIHNpemUgb2YgcHJldmlvdXMgb25lLlxuICAvLyBGaXggdG8gc3VwcG9ydCBvdGhlciBtdWx0aXBsZXMuXG4gIHZhciB4ID0gTWF0aC5mbG9vcih0aGlzLnggLyAyKTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHRoaXMueSAvIDIpO1xuXG4gIHJldHVybiBuZXcgRmxhdFRpbGUoeCwgeSwgeiwgZ2VvbWV0cnkpO1xuXG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICBpZiAodGhpcy56ID09PSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3QubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciB6ID0gdGhpcy56ICsgMTtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgLy8gVE9ETzogQ3VycmVudGx5IGFzc3VtaW5nIGVhY2ggbGV2ZWwgaXMgZG91YmxlIHRoZSBzaXplIG9mIHByZXZpb3VzIG9uZS5cbiAgLy8gRml4IHRvIHN1cHBvcnQgb3RoZXIgbXVsdGlwbGVzLlxuICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoMip0aGlzLnggICwgMip0aGlzLnkgICwgeiwgZ2VvbWV0cnkpKTtcbiAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKDIqdGhpcy54ICAsIDIqdGhpcy55KzEsIHosIGdlb21ldHJ5KSk7XG4gIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSgyKnRoaXMueCsxLCAyKnRoaXMueSAgLCB6LCBnZW9tZXRyeSkpO1xuICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoMip0aGlzLngrMSwgMip0aGlzLnkrMSwgeiwgZ2VvbWV0cnkpKTtcblxuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIGNhY2hlID0gZ2VvbWV0cnkuX25laWdoYm9yc0NhY2hlO1xuXG4gIC8vIFNhdGlzZnkgZnJvbSBjYWNoZSB3aGVuIGF2YWlsYWJsZS5cbiAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldCh0aGlzKTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cblxuICB2YXIgeCA9IHRoaXMueDtcbiAgdmFyIHkgPSB0aGlzLnk7XG4gIHZhciB6ID0gdGhpcy56O1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbDtcblxuICB2YXIgbnVtWCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbiAgdmFyIG51bVkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yT2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzBdO1xuICAgIHZhciB5T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzFdO1xuXG4gICAgdmFyIG5ld1ggPSB4ICsgeE9mZnNldDtcbiAgICB2YXIgbmV3WSA9IHkgKyB5T2Zmc2V0O1xuICAgIHZhciBuZXdaID0gejtcblxuICAgIGlmICgwIDw9IG5ld1ggJiYgbmV3WCA8PSBudW1YICYmIDAgPD0gbmV3WSAmJiBuZXdZIDw9IG51bVkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZShuZXdYLCBuZXdZLCBuZXdaLCBnZW9tZXRyeSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0b3JlIGludG8gY2FjaGUgdG8gc2F0aXNmeSBmdXR1cmUgcmVxdWVzdHMuXG4gIGNhY2hlLnNldCh0aGlzLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGhhc2godGhpcy56LCB0aGlzLnksIHRoaXMueCk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiAodGhpcy5fZ2VvbWV0cnkgPT09IHRoYXQuX2dlb21ldHJ5ICYmXG4gICAgICB0aGlzLnogPT09IHRoYXQueiAmJiB0aGlzLnkgPT09IHRoYXQueSAmJiB0aGlzLnggPT09IHRoYXQueCk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiAoY21wKHRoaXMueiwgdGhhdC56KSB8fCBjbXAodGhpcy55LCB0aGF0LnkpIHx8IGNtcCh0aGlzLngsIHRoYXQueCkpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnRmxhdFRpbGUoJyArIHRpbGUueCArICcsICcgKyB0aWxlLnkgKyAnLCAnICsgdGlsZS56ICsgJyknO1xufTtcblxuXG5mdW5jdGlvbiBGbGF0TGV2ZWwobGV2ZWxQcm9wZXJ0aWVzKSB7XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmNhbGwodGhpcywgbGV2ZWxQcm9wZXJ0aWVzKTtcblxuICB0aGlzLl93aWR0aCA9IGxldmVsUHJvcGVydGllcy53aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gbGV2ZWxQcm9wZXJ0aWVzLmhlaWdodDtcbiAgdGhpcy5fdGlsZVdpZHRoID0gbGV2ZWxQcm9wZXJ0aWVzLnRpbGVXaWR0aDtcbiAgdGhpcy5fdGlsZUhlaWdodCA9IGxldmVsUHJvcGVydGllcy50aWxlSGVpZ2h0O1xufVxuXG5pbmhlcml0cyhGbGF0TGV2ZWwsIExldmVsKTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuRmxhdExldmVsLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuRmxhdExldmVsLnByb3RvdHlwZS50aWxlV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbGVXaWR0aDtcbn07XG5cblxuRmxhdExldmVsLnByb3RvdHlwZS50aWxlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aWxlSGVpZ2h0O1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLl92YWxpZGF0ZVdpdGhQYXJlbnRMZXZlbCA9IGZ1bmN0aW9uKHBhcmVudExldmVsKSB7XG5cbiAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgdmFyIHRpbGVXaWR0aCA9IHRoaXMudGlsZVdpZHRoKCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy50aWxlSGVpZ2h0KCk7XG5cbiAgdmFyIHBhcmVudFdpZHRoID0gcGFyZW50TGV2ZWwud2lkdGgoKTtcbiAgdmFyIHBhcmVudEhlaWdodCA9IHBhcmVudExldmVsLmhlaWdodCgpO1xuICB2YXIgcGFyZW50VGlsZVdpZHRoID0gcGFyZW50TGV2ZWwudGlsZVdpZHRoKCk7XG4gIHZhciBwYXJlbnRUaWxlSGVpZ2h0ID0gcGFyZW50TGV2ZWwudGlsZUhlaWdodCgpO1xuXG4gIGlmICh3aWR0aCAlIHBhcmVudFdpZHRoICE9PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignTGV2ZWwgd2lkdGggbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgd2lkdGggKyAnIHZzLiAnICsgcGFyZW50V2lkdGgpO1xuICB9XG5cbiAgaWYgKGhlaWdodCAlIHBhcmVudEhlaWdodCAhPT0gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0xldmVsIGhlaWdodCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKyAnIHZzLiAnICsgcGFyZW50SGVpZ2h0KTtcbiAgfVxuXG4gIGlmICh0aWxlV2lkdGggJSBwYXJlbnRUaWxlV2lkdGggIT09IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdMZXZlbCB0aWxlIHdpZHRoIG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgIHRpbGVXaWR0aCArICcgdnMuICcgKyBwYXJlbnRUaWxlV2lkdGgpO1xuICB9XG5cbiAgaWYgKHRpbGVIZWlnaHQgJSBwYXJlbnRUaWxlSGVpZ2h0ICE9PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignTGV2ZWwgdGlsZSBoZWlnaHQgbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgdGlsZUhlaWdodCArICcgdnMuICcgKyBwYXJlbnRUaWxlSGVpZ2h0KTtcbiAgfVxuXG59O1xuXG5cbi8qKlxuICogQGNsYXNzIEZsYXRHZW9tZXRyeVxuICogQGltcGxlbWVudHMgR2VvbWV0cnlcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBHZW9tZXRyeX0gaW1wbGVtZW50YXRpb24gc3VpdGFibGUgZm9yIHRpbGVkIGZsYXQgaW1hZ2VzIHdpdGhcbiAqIG11bHRpcGxlIHJlc29sdXRpb24gbGV2ZWxzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zIGFwcGx5OlxuICogICAtIEFsbCB0aWxlcyBtdXN0IGJlIHNxdWFyZSwgZXhjZXB0IHdoZW4gaW4gdGhlIGxhc3Qgcm93IG9yIGNvbHVtbiBwb3NpdGlvbixcbiAqICAgICBhbmQgbXVzdCBmb3JtIGEgcmVjdGFuZ3VsYXIgZ3JpZDtcbiAqICAgLSBUaGUgd2lkdGggYW5kIGhlaWdodCBvZiBhIGxldmVsIG11c3QgYmUgbXVsdGlwbGVzIG9mIHRoZSBwYXJlbnQgbGV2ZWxcbiAqICAgICB3aWR0aCBhbmQgaGVpZ2h0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IGxldmVsUHJvcGVydGllc0xpc3QgTGV2ZWwgZGVzY3JpcHRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10ud2lkdGggTGV2ZWwgd2lkdGggaW4gcGl4ZWxzXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLnRpbGVXaWR0aCBUaWxlIHdpZHRoIGluIHBpeGVscyBmb3JcbiAqICAgICAgICAgICAgICAgICBzcXVhcmUgdGlsZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10uaGVpZ2h0IExldmVsIGhlaWdodCBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10udGlsZUhlaWdodCBUaWxlIGhlaWdodCBpbiBwaXhlbHMgZm9yXG4gKiAgICAgICAgICAgICAgICAgc3F1YXJlIHRpbGVzXG4gKi9cbmZ1bmN0aW9uIEZsYXRHZW9tZXRyeShsZXZlbFByb3BlcnRpZXNMaXN0KSB7XG4gIGlmICh0eXBlKGxldmVsUHJvcGVydGllc0xpc3QpICE9PSAnYXJyYXknKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCBsaXN0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWxMaXN0ID0gbWFrZUxldmVsTGlzdChsZXZlbFByb3BlcnRpZXNMaXN0LCBGbGF0TGV2ZWwpO1xuICB0aGlzLnNlbGVjdGFibGVMZXZlbExpc3QgPSBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdCh0aGlzLmxldmVsTGlzdCk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMubGV2ZWxMaXN0W2ldLl92YWxpZGF0ZVdpdGhQYXJlbnRMZXZlbCh0aGlzLmxldmVsTGlzdFtpLTFdKTtcbiAgfVxuXG4gIHRoaXMuX3RpbGVTZWFyY2hlciA9IG5ldyBUaWxlU2VhcmNoZXIodGhpcyk7XG5cbiAgdGhpcy5fbmVpZ2hib3JzQ2FjaGUgPSBuZXcgTHJ1TWFwKG5laWdoYm9yc0NhY2hlU2l6ZSk7XG5cbiAgdGhpcy5fdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICB0aGlzLl92aWV3U2l6ZSA9IHt9O1xufVxuXG5cbkZsYXRHZW9tZXRyeS5wcm90b3R5cGUubWF4VGlsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1heFRpbGVTaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxMaXN0W2ldO1xuICAgIG1heFRpbGVTaXplID0gTWF0aC5tYXgobWF4VGlsZVNpemUsIGxldmVsLnRpbGVXaWR0aCwgbGV2ZWwudGlsZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIG1heFRpbGVTaXplO1xufTtcblxuXG5GbGF0R2VvbWV0cnkucHJvdG90eXBlLmxldmVsVGlsZXMgPSBmdW5jdGlvbihsZXZlbCwgcmVzdWx0KSB7XG5cbiAgdmFyIGxldmVsSW5kZXggPSB0aGlzLmxldmVsTGlzdC5pbmRleE9mKGxldmVsKTtcbiAgdmFyIG1heFggPSBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAtIDE7XG4gIHZhciBtYXhZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpIC0gMTtcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IFtdO1xuICB9XG5cbiAgZm9yICh2YXIgeCA9IDA7IHggPD0gbWF4WDsgeCsrKSB7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoeCwgeSwgbGV2ZWxJbmRleCwgdGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuRmxhdEdlb21ldHJ5LnByb3RvdHlwZS5fY2xvc2VzdFRpbGUgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdmVjO1xuXG4gIC8vIENvbXB1dGUgYSB2aWV3IHJheSBpbnRvIHRoZSBjZW50cmFsIHNjcmVlbiBwb2ludC5cbiAgdmVjNC5zZXQocmF5LCAwLCAwLCAxLCAxKTtcbiAgdmVjNC50cmFuc2Zvcm1NYXQ0KHJheSwgcmF5LCB2aWV3LmludmVyc2VQcm9qZWN0aW9uKCkpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGltYWdlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHZpZXcgcmF5IHBvaW50cyBpbnRvLlxuICB2YXIgeCA9IDAuNSArIHJheVswXTtcbiAgdmFyIHkgPSAwLjUgLSByYXlbMV07XG5cbiAgLy8gR2V0IHRoZSBkZXNpcmVkIHpvb20gbGV2ZWwuXG4gIHZhciB0aWxlWiA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICB2YXIgbGV2ZWxXaWR0aCA9IGxldmVsLndpZHRoKCk7XG4gIHZhciBsZXZlbEhlaWdodCA9IGxldmVsLmhlaWdodCgpO1xuICB2YXIgdGlsZVdpZHRoID0gbGV2ZWwudGlsZVdpZHRoKCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gbGV2ZWwudGlsZUhlaWdodCgpO1xuICB2YXIgbnVtWCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgbnVtWSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICAvLyBGaW5kIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdGlsZSB0aGF0IHRoZSB2aWV3IHJheSBwb2ludHMgaW50by5cbiAgdmFyIHRpbGVYID0gY2xhbXAoTWF0aC5mbG9vcih4ICogbGV2ZWxXaWR0aCAvIHRpbGVXaWR0aCksIDAsIG51bVggLSAxKTtcbiAgdmFyIHRpbGVZID0gY2xhbXAoTWF0aC5mbG9vcih5ICogbGV2ZWxIZWlnaHQgLyB0aWxlSGVpZ2h0KSwgMCwgbnVtWSAtIDEpO1xuXG4gIHJldHVybiBuZXcgRmxhdFRpbGUodGlsZVgsIHRpbGVZLCB0aWxlWiwgdGhpcyk7XG59O1xuXG5cbkZsYXRHZW9tZXRyeS5wcm90b3R5cGUudmlzaWJsZVRpbGVzID0gZnVuY3Rpb24odmlldywgbGV2ZWwsIHJlc3VsdCkge1xuICB2YXIgdmlld1NpemUgPSB0aGlzLl92aWV3U2l6ZTtcbiAgdmFyIHRpbGVTZWFyY2hlciA9IHRoaXMuX3RpbGVTZWFyY2hlcjtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgdmlldy5zaXplKHZpZXdTaXplKTtcbiAgaWYgKHZpZXdTaXplLndpZHRoID09PSAwIHx8IHZpZXdTaXplLmhlaWdodCA9PT0gMCkge1xuICAgIC8vIE5vIHRpbGVzIGFyZSB2aXNpYmxlIGlmIHRoZSB2aWV3cG9ydCBpcyBlbXB0eS5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHN0YXJ0aW5nVGlsZSA9IHRoaXMuX2Nsb3Nlc3RUaWxlKHZpZXcsIGxldmVsKTtcbiAgdmFyIGNvdW50ID0gdGlsZVNlYXJjaGVyLnNlYXJjaCh2aWV3LCBzdGFydGluZ1RpbGUsIHJlc3VsdCk7XG4gIGlmICghY291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXJ0aW5nIHRpbGUgaXMgbm90IHZpc2libGUnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkZsYXRHZW9tZXRyeS5UaWxlID0gRmxhdEdlb21ldHJ5LnByb3RvdHlwZS5UaWxlID0gRmxhdFRpbGU7XG5GbGF0R2VvbWV0cnkudHlwZSA9IEZsYXRHZW9tZXRyeS5wcm90b3R5cGUudHlwZSA9ICdmbGF0JztcbkZsYXRUaWxlLnR5cGUgPSBGbGF0VGlsZS5wcm90b3R5cGUudHlwZSA9ICdmbGF0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZsYXRHZW9tZXRyeTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gTGV2ZWwobGV2ZWxQcm9wZXJ0aWVzKSB7XG4gIHRoaXMuX2ZhbGxiYWNrT25seSA9ICEhbGV2ZWxQcm9wZXJ0aWVzLmZhbGxiYWNrT25seTtcbn1cblxuTGV2ZWwucHJvdG90eXBlLm51bUhvcml6b250YWxUaWxlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5jZWlsKHRoaXMud2lkdGgoKSAvIHRoaXMudGlsZVdpZHRoKCkpO1xufTtcblxuTGV2ZWwucHJvdG90eXBlLm51bVZlcnRpY2FsVGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmhlaWdodCgpIC8gdGhpcy50aWxlSGVpZ2h0KCkpO1xufTtcblxuTGV2ZWwucHJvdG90eXBlLmZhbGxiYWNrT25seSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZmFsbGJhY2tPbmx5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXZlbDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xuXG5mdW5jdGlvbiBtYWtlTGV2ZWxMaXN0KGxldmVsUHJvcGVydGllc0xpc3QsIExldmVsQ2xhc3MpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsUHJvcGVydGllc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0LnB1c2gobmV3IExldmVsQ2xhc3MobGV2ZWxQcm9wZXJ0aWVzTGlzdFtpXSkpO1xuICB9XG5cbiAgbGlzdC5zb3J0KGZ1bmN0aW9uKGxldmVsMSwgbGV2ZWwyKSB7XG4gICAgcmV0dXJuIGNtcChsZXZlbDEud2lkdGgoKSwgbGV2ZWwyLndpZHRoKCkpO1xuICB9KTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gbWFrZVNlbGVjdGFibGVMZXZlbExpc3QobGV2ZWxMaXN0KSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWxldmVsTGlzdFtpXS5fZmFsbGJhY2tPbmx5KSB7XG4gICAgICBsaXN0LnB1c2gobGV2ZWxMaXN0W2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzZWxlY3RhYmxlIGxldmVscyBpbiBsaXN0Jyk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1ha2VMZXZlbExpc3Q6IG1ha2VMZXZlbExpc3QsXG4gIG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0OiBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLy8gU3RhZ2VzLlxuICBXZWJHbFN0YWdlOiByZXF1aXJlKCcuL3N0YWdlcy9XZWJHbCcpLFxuXG4gIC8vIFJlbmRlcmVycy5cbiAgV2ViR2xDdWJlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXJzL1dlYkdsQ3ViZScpLFxuICBXZWJHbEZsYXRSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcnMvV2ViR2xGbGF0JyksXG4gIFdlYkdsRXF1aXJlY3RSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcnMvV2ViR2xFcXVpcmVjdCcpLFxuICByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnM6IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3JlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycycpLFxuXG4gIC8vIEdlb21ldHJpZXMuXG4gIEN1YmVHZW9tZXRyeTogcmVxdWlyZSgnLi9nZW9tZXRyaWVzL0N1YmUnKSxcbiAgRmxhdEdlb21ldHJ5OiByZXF1aXJlKCcuL2dlb21ldHJpZXMvRmxhdCcpLFxuICBFcXVpcmVjdEdlb21ldHJ5OiByZXF1aXJlKCcuL2dlb21ldHJpZXMvRXF1aXJlY3QnKSxcblxuICAvLyBWaWV3cy5cbiAgUmVjdGlsaW5lYXJWaWV3OiByZXF1aXJlKCcuL3ZpZXdzL1JlY3RpbGluZWFyJyksXG4gIEZsYXRWaWV3OiByZXF1aXJlKCcuL3ZpZXdzL0ZsYXQnKSxcblxuICAvLyBTb3VyY2VzLlxuICBJbWFnZVVybFNvdXJjZTogcmVxdWlyZSgnLi9zb3VyY2VzL0ltYWdlVXJsJyksXG4gIFNpbmdsZUFzc2V0U291cmNlOiByZXF1aXJlKCcuL3NvdXJjZXMvU2luZ2xlQXNzZXQnKSxcblxuICAvLyBBc3NldHMuXG4gIFN0YXRpY0Fzc2V0OiByZXF1aXJlKCcuL2Fzc2V0cy9TdGF0aWMnKSxcbiAgRHluYW1pY0Fzc2V0OiByZXF1aXJlKCcuL2Fzc2V0cy9EeW5hbWljJyksXG5cbiAgLy8gVGV4dHVyZSBzdG9yZS5cbiAgVGV4dHVyZVN0b3JlOiByZXF1aXJlKCcuL1RleHR1cmVTdG9yZScpLFxuXG4gIC8vIExheWVyLlxuICBMYXllcjogcmVxdWlyZSgnLi9MYXllcicpLFxuXG4gIC8vIFJlbmRlciBsb29wLlxuICBSZW5kZXJMb29wOiByZXF1aXJlKCcuL1JlbmRlckxvb3AnKSxcblxuICAvLyBDb250cm9scy5cbiAgS2V5Q29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9LZXknKSxcbiAgRHJhZ0NvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvRHJhZycpLFxuICBRdHZyQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9RdHZyJyksXG4gIFNjcm9sbFpvb21Db250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1Njcm9sbFpvb20nKSxcbiAgUGluY2hab29tQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9QaW5jaFpvb20nKSxcbiAgVmVsb2NpdHlDb250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1ZlbG9jaXR5JyksXG4gIEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvRWxlbWVudFByZXNzJyksXG4gIENvbnRyb2xzOiByZXF1aXJlKCcuL2NvbnRyb2xzL0NvbnRyb2xzJyksXG4gIER5bmFtaWNzOiByZXF1aXJlKCcuL2NvbnRyb2xzL0R5bmFtaWNzJyksXG5cbiAgLy8gSGlnaC1sZXZlbCBBUEkuXG4gIFZpZXdlcjogcmVxdWlyZSgnLi9WaWV3ZXInKSxcbiAgU2NlbmU6IHJlcXVpcmUoJy4vU2NlbmUnKSxcblxuICAvLyBIb3RzcG90cy5cbiAgSG90c3BvdDogcmVxdWlyZSgnLi9Ib3RzcG90JyksXG4gIEhvdHNwb3RDb250YWluZXI6IHJlcXVpcmUoJy4vSG90c3BvdENvbnRhaW5lcicpLFxuXG4gIC8vIEVmZmVjdHMuXG4gIGNvbG9yRWZmZWN0czogcmVxdWlyZSgnLi9jb2xvckVmZmVjdHMnKSxcblxuICAvLyBNaXNjZWxsYW5lb3VzIGZ1bmN0aW9ucy5cbiAgcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHM6IHJlcXVpcmUoJy4vY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMnKSxcbiAgYXV0b3JvdGF0ZTogcmVxdWlyZSgnLi9hdXRvcm90YXRlJyksXG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnMuXG4gIHV0aWw6IHtcbiAgICBhc3luYzogcmVxdWlyZSgnLi91dGlsL2FzeW5jJyksXG4gICAgY2FuY2VsaXplOiByZXF1aXJlKCcuL3V0aWwvY2FuY2VsaXplJyksXG4gICAgY2hhaW46IHJlcXVpcmUoJy4vdXRpbC9jaGFpbicpLFxuICAgIGNsYW1wOiByZXF1aXJlKCcuL3V0aWwvY2xhbXAnKSxcbiAgICBjbGVhck93blByb3BlcnRpZXM6IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKSxcbiAgICBjbXA6IHJlcXVpcmUoJy4vdXRpbC9jbXAnKSxcbiAgICBjb21wb3NlOiByZXF1aXJlKCcuL3V0aWwvY29tcG9zZScpLFxuICAgIGNvbnZlcnRGb3Y6IHJlcXVpcmUoJy4vdXRpbC9jb252ZXJ0Rm92JyksXG4gICAgZGVjaW1hbDogcmVxdWlyZSgnLi91dGlsL2RlY2ltYWwnKSxcbiAgICBkZWZhdWx0czogcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyksXG4gICAgZGVmZXI6IHJlcXVpcmUoJy4vdXRpbC9kZWZlcicpLFxuICAgIGRlZ1RvUmFkOiByZXF1aXJlKCcuL3V0aWwvZGVnVG9SYWQnKSxcbiAgICBkZWxheTogcmVxdWlyZSgnLi91dGlsL2RlbGF5JyksXG4gICAgZG9tOiByZXF1aXJlKCcuL3V0aWwvZG9tJyksXG4gICAgZXh0ZW5kOiByZXF1aXJlKCcuL3V0aWwvZXh0ZW5kJyksXG4gICAgaGFzaDogcmVxdWlyZSgnLi91dGlsL2hhc2gnKSxcbiAgICBpbmhlcml0czogcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyksXG4gICAgbW9kOiByZXF1aXJlKCcuL3V0aWwvbW9kJyksXG4gICAgbm9vcDogcmVxdWlyZSgnLi91dGlsL25vb3AnKSxcbiAgICBub3c6IHJlcXVpcmUoJy4vdXRpbC9ub3cnKSxcbiAgICBvbmNlOiByZXF1aXJlKCcuL3V0aWwvb25jZScpLFxuICAgIHBpeGVsUmF0aW86IHJlcXVpcmUoJy4vdXRpbC9waXhlbFJhdGlvJyksXG4gICAgcmFkVG9EZWc6IHJlcXVpcmUoJy4vdXRpbC9yYWRUb0RlZycpLFxuICAgIHJlYWw6IHJlcXVpcmUoJy4vdXRpbC9yZWFsJyksXG4gICAgcmV0cnk6IHJlcXVpcmUoJy4vdXRpbC9yZXRyeScpLFxuICAgIHR3ZWVuOiByZXF1aXJlKCcuL3V0aWwvdHdlZW4nKSxcbiAgICB0eXBlOiByZXF1aXJlKCcuL3V0aWwvdHlwZScpXG4gIH0sXG5cbiAgLy8gRXhwb3NlIGRlcGVuZGVuY2llcyBmb3IgY2xpZW50cyB0byB1c2UuXG4gIGRlcGVuZGVuY2llczoge1xuICAgIGJvd3NlcjogcmVxdWlyZSgnYm93c2VyJyksXG4gICAgZ2xNYXRyaXg6IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLFxuICAgIGV2ZW50RW1pdHRlcjogcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyksXG4gICAgaGFtbWVyanM6IHJlcXVpcmUoJ2hhbW1lcmpzJylcbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0YXRpY0Fzc2V0ID0gcmVxdWlyZSgnLi4vYXNzZXRzL1N0YXRpYycpO1xudmFyIE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJy4uL05ldHdvcmtFcnJvcicpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCdib3dzZXInKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi91dGlsL2dsb2JhbCcpO1xudmFyIG9uY2UgPSByZXF1aXJlKCcuLi91dGlsL29uY2UnKTtcblxuLy8gVE9ETzogTW92ZSB0aGUgbG9hZCBxdWV1ZSBpbnRvIHRoZSBsb2FkZXIuXG5cbi8vIFdoZXRoZXIgdG8gdXNlIGNyZWF0ZUltYWdlQml0bWFwIGluc3RlYWQgb2YgYSBjYW52YXMgZm9yIGNyb3BwaW5nLlxuLy8gU2VlIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD1jcmVhdGVpbWFnZWJpdG1hcFxudmFyIHVzZUNyZWF0ZUltYWdlQml0bWFwID1cbiAgISFnbG9iYWwuY3JlYXRlSW1hZ2VCaXRtYXAgJiZcbiAgIWJyb3dzZXIuZmlyZWZveCAmJlxuICAhYnJvd3Nlci5zYWZhcmkgJiZcbiAgIS9pUGhvbmV8aVBhZHxpUG9kfFNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIHZhciB1c2VDcmVhdGVJbWFnZUJpdG1hcCA9XG4vLyAgICEhZ2xvYmFsLmNyZWF0ZUltYWdlQml0bWFwICYmXG4vLyAgICFicm93c2VyLmZpcmVmb3ggJiZcbi8vICAgIS9pUGhvbmV8aVBhZHxpUG9kfFNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgLy8gdmFyIHVzZUNyZWF0ZUltYWdlQml0bWFwID0gZmFsc2U7XG5cbiAgLy8gT3B0aW9ucyBmb3IgY3JlYXRlSW1hZ2VCaXRtYXAuXG4gIHZhciBjcmVhdGVJbWFnZUJpdG1hcE9wdHMgPSB7XG4gICAgaW1hZ2VPcmllbnRhdGlvbjogJ2ZsaXBZJyxcbiAgICBwcmVtdWx0aXBseUFscGhhOiAncHJlbXVsdGlwbHknXG4gIH07XG5cbi8qKlxuICogQGNsYXNzIEh0bWxJbWFnZUxvYWRlclxuICogQGltcGxlbWVudHMgSW1hZ2VMb2FkZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBMb2FkZXJ9IGZvciBIVE1MIGltYWdlcy5cbiAqXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgc3RhZ2Ugd2hpY2ggaXMgZ29pbmcgdG8gcmVxdWVzdCBpbWFnZXMgdG8gYmUgbG9hZGVkLlxuICovXG5mdW5jdGlvbiBIdG1sSW1hZ2VMb2FkZXIoc3RhZ2UpIHtcbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhbiB7QGxpbmsgQXNzZXR9IGZyb20gYW4gaW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBpbWFnZSBVUkwuXG4gKiBAcGFyYW0gez9SZWN0fSByZWN0IEEge0BsaW5rIFJlY3R9IGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSwgb3IgbnVsbFxuICogICAgIHRvIHVzZSB0aGUgZnVsbCBpbWFnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCBBc3NldCl9IGRvbmUgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBmdW5jdGlvbiB0byBjYW5jZWwgbG9hZGluZy5cbiAqL1xuSHRtbEltYWdlTG9hZGVyLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAodXJsLCByZWN0LCBkb25lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgLy8gQWxsb3cgY3Jvc3MtZG9tYWluIGltYWdlIGxvYWRpbmcuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYmUgYWJsZSB0byBjcmVhdGUgV2ViR0wgdGV4dHVyZXMgZnJvbSBpbWFnZXMgZmV0Y2hlZFxuICAvLyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbi4gTm90ZSB0aGF0IHNldHRpbmcgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSB0b1xuICAvLyAnYW5vbnltb3VzJyB3aWxsIHRyaWdnZXIgYSBDT1JTIHByZWZsaWdodCBmb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBidXQgbm9cbiAgLy8gY3JlZGVudGlhbHMgKGNvb2tpZXMgb3IgSFRUUCBhdXRoKSB3aWxsIGJlIHNlbnQ7IHRvIGRvIHNvLCB0aGUgYXR0cmlidXRlXG4gIC8vIHdvdWxkIGhhdmUgdG8gYmUgc2V0IHRvICd1c2UtY3JlZGVudGlhbHMnIGluc3RlYWQuIFVuZm9ydHVuYXRlbHksIHRoaXMgaXNcbiAgLy8gbm90IGEgc2FmZSBjaG9pY2UsIGFzIGl0IGNhdXNlcyByZXF1ZXN0cyB0byBmYWlsIHdoZW4gdGhlIHJlc3BvbnNlIGNvbnRhaW5zXG4gIC8vIGFuIEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiBoZWFkZXIgd2l0aCBhIHdpbGRjYXJkLiBTZWUgdGhlIHNlY3Rpb25cbiAgLy8gXCJDcmVkZW50aWFsZWQgcmVxdWVzdHMgYW5kIHdpbGRjYXJkc1wiIG9uOlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0NPUlNcbiAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG5cbiAgdmFyIHggPSByZWN0ICYmIHJlY3QueCB8fCAwO1xuICB2YXIgeSA9IHJlY3QgJiYgcmVjdC55IHx8IDA7XG4gIHZhciB3aWR0aCA9IHJlY3QgJiYgcmVjdC53aWR0aCB8fCAxO1xuICB2YXIgaGVpZ2h0ID0gcmVjdCAmJiByZWN0LmhlaWdodCB8fCAxO1xuXG4gIGRvbmUgPSBvbmNlKGRvbmUpO1xuXG4gIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5faGFuZGxlTG9hZChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGRvbmUpO1xuICB9O1xuXG4gIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2hhbmRsZUVycm9yKHVybCwgZG9uZSk7XG4gIH07XG5cbiAgaW1nLnNyYyA9IHVybDtcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICBpbWcuc3JjID0gJyc7XG4gICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGNhbmNlbDtcbn07XG5cbkh0bWxJbWFnZUxvYWRlci5wcm90b3R5cGUuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkb25lKSB7XG4gIGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgd2lkdGggPT09IDEgJiYgaGVpZ2h0ID09PSAxKSB7XG4gICAgLy8gRmFzdCBwYXRoIGZvciB3aGVuIGNyb3BwaW5nIGlzIG5vdCBuZWVkZWQuXG4gICAgZG9uZShudWxsLCBuZXcgU3RhdGljQXNzZXQoaW1nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgeCAqPSBpbWcubmF0dXJhbFdpZHRoO1xuICB5ICo9IGltZy5uYXR1cmFsSGVpZ2h0O1xuICB3aWR0aCAqPSBpbWcubmF0dXJhbFdpZHRoO1xuICBoZWlnaHQgKj0gaW1nLm5hdHVyYWxIZWlnaHQ7XG5cbiAgaWYgKHVzZUNyZWF0ZUltYWdlQml0bWFwKSB7XG4gICAgLy8gUHJlZmVyIHRvIGNyb3AgdXNpbmcgY3JlYXRlSW1hZ2VCaXRtYXAsIHdoaWNoIGNhbiBwb3RlbnRpYWxseSBvZmZsb2FkXG4gICAgLy8gd29yayB0byBhbm90aGVyIHRocmVhZCBhbmQgYXZvaWQgYmxvY2tpbmcgdGhlIHVzZXIgaW50ZXJmYWNlLlxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBwcm9taXNlIGlzIG5ldmVyIHJlamVjdGVkLlxuICAgIGdsb2JhbC5jcmVhdGVJbWFnZUJpdG1hcChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNyZWF0ZUltYWdlQml0bWFwT3B0cylcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgICAgZG9uZShudWxsLCBuZXcgU3RhdGljQXNzZXQoYml0bWFwKSk7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gY3JvcHBpbmcgdXNpbmcgYSBjYW52YXMsIHdoaWNoIGNhbiBwb3RlbnRpYWxseSBibG9jayB0aGVcbiAgICAvLyB1c2VyIGludGVyZmFjZSwgYnV0IGlzIHRoZSBiZXN0IHdlIGNhbiBkby5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZG9uZShudWxsLCBuZXcgU3RhdGljQXNzZXQoY2FudmFzKSk7XG4gIH1cbn07XG5cbkh0bWxJbWFnZUxvYWRlci5wcm90b3R5cGUuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKHVybCwgZG9uZSkge1xuICAvLyBUT0RPOiBpcyB0aGVyZSBhbnkgd2F5IHRvIGRpc3Rpbmd1aXNoIGEgbmV0d29yayBlcnJvciBmcm9tIG90aGVyXG4gIC8vIGtpbmRzIG9mIGVycm9ycz8gRm9yIG5vdyB3ZSBhbHdheXMgcmV0dXJuIE5ldHdvcmtFcnJvciBzaW5jZSB0aGlzXG4gIC8vIHByZXZlbnRzIGltYWdlcyB0byBiZSByZXRyaWVkIGNvbnRpbnVvdXNseSB3aGlsZSB3ZSBhcmUgb2ZmbGluZS5cbiAgZG9uZShuZXcgTmV0d29ya0Vycm9yKCdOZXR3b3JrIGVycm9yOiAnICsgdXJsKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxJbWFnZUxvYWRlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcblxudmFyIHZlcnRleFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4Tm9ybWFsJyk7XG52YXIgZnJhZ21lbnRTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2ZyYWdtZW50Tm9ybWFsJyk7XG5cbnZhciB2ZXJ0ZXhJbmRpY2VzID0gWzAsIDEsIDIsIDAsIDIsIDNdO1xudmFyIHZlcnRleFBvc2l0aW9ucyA9IFstMC41LCAtMC41LCAwLjAsIDAuNSwgLTAuNSwgMC4wLCAwLjUsIDAuNSwgMC4wLCAtMC41LCAwLjUsIDAuMF07XG52YXIgdGV4dHVyZUNvb3JkcyA9IFswLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMF07XG5cbnZhciBhdHRyaWJMaXN0ID0gWydhVmVydGV4UG9zaXRpb24nLCAnYVRleHR1cmVDb29yZCddO1xudmFyIHVuaWZvcm1MaXN0ID0gW1xuICAndURlcHRoJywgJ3VPcGFjaXR5JywgJ3VTYW1wbGVyJywgJ3VQcm9qTWF0cml4JywgJ3VWaWV3TWF0cml4JywgJ3VNb2RlbE1hdHJpeCcsICd1Vmlld3BvcnRNYXRyaXgnLFxuICAndUNvbG9yT2Zmc2V0JywgJ3VDb2xvck1hdHJpeCdcbl07XG5cblxuZnVuY3Rpb24gV2ViR2xCYXNlUmVuZGVyZXIoZ2wpIHtcbiAgdGhpcy5nbCA9IGdsO1xuXG4gIC8vIFRoZSBwcm9qZWN0aW9uIG1hdHJpeCBwb3NpdGlvbnMgdGhlIHRpbGVzIGluIHdvcmxkIHNwYWNlLlxuICAvLyBXZSBjb21wdXRlIGl0IGluIEphdmFzY3JpcHQgYmVjYXVzZSBsYWNrIG9mIHByZWNpc2lvbiBpbiB0aGUgdmVydGV4IHNoYWRlclxuICAvLyBjYXVzZXMgc2VhbXMgdG8gYXBwZWFyIGJldHdlZW4gYWRqYWNlbnQgdGlsZXMgYXQgbGFyZ2Ugem9vbSBsZXZlbHMuXG4gIHRoaXMucHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVE9ETyBXaHkgc2F2ZSB0aGlzIHZhbHVlIGhlcmU/IHRoZSBzYW1lIHF1ZXN0aW9uIHRvIHRoZSBwcm9qTWF0cml4LlxuICB0aGlzLnZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSB2aWV3cG9ydCBtYXRyaXggcmVzcG9uc2libGUgZm9yIHZpZXdwb3J0IGNsYW1waW5nLlxuICAvLyBTZWUgc2V0Vmlld3BvcnQoKSBmb3IgYW4gZXhwbGFuYXRpb24gb2YgaG93IGl0IHdvcmtzLlxuICB0aGlzLnZpZXdwb3J0TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUcmFuc2xhdGlvbiBhbmQgc2NhbGUgdmVjdG9ycyBmb3IgdGlsZXMuXG4gIHRoaXMudHJhbnNsYXRlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcbiAgdGhpcy5zY2FsZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgdGhpcy5jb25zdGFudEJ1ZmZlcnMgPSBjcmVhdGVDb25zdGFudEJ1ZmZlcnMoZ2wsIHZlcnRleEluZGljZXMsIHZlcnRleFBvc2l0aW9ucywgdGV4dHVyZUNvb3Jkcyk7XG5cbiAgdGhpcy5zaGFkZXJQcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmliTGlzdCwgdW5pZm9ybUxpc3QpO1xufVxuXG5XZWJHbEJhc2VSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBkZXN0cm95Q29uc3RhbnRCdWZmZXJzKHRoaXMuZ2wsIHRoaXMuY29uc3RhbnRCdWZmZXJzKTtcbiAgZGVzdHJveVNoYWRlclByb2dyYW0odGhpcy5nbCwgdGhpcy5zaGFkZXJQcm9ncmFtKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuV2ViR2xCYXNlUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgcmVjdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuICB2YXIgdmlld3BvcnRNYXRyaXggPSB0aGlzLnZpZXdwb3J0TWF0cml4O1xuXG4gIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgZW5hYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG5cbiAgc2V0Vmlld3BvcnQoZ2wsIGxheWVyLCByZWN0LCB2aWV3cG9ydE1hdHJpeCk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51Vmlld3BvcnRNYXRyaXgsIGZhbHNlLCB2aWV3cG9ydE1hdHJpeCk7XG5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhQb3NpdGlvbnMpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclByb2dyYW0uYVZlcnRleFBvc2l0aW9uLCAzLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDApO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnRleHR1cmVDb29yZHMpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclByb2dyYW0uYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGdsLkZBTFNFLCAwLCAwKTtcblxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMoZ2wsIGxheWVyLmVmZmVjdHMoKSwge1xuICAgIG9wYWNpdHk6IHNoYWRlclByb2dyYW0udU9wYWNpdHksXG4gICAgY29sb3JPZmZzZXQ6IHNoYWRlclByb2dyYW0udUNvbG9yT2Zmc2V0LFxuICAgIGNvbG9yTWF0cml4OiBzaGFkZXJQcm9ncmFtLnVDb2xvck1hdHJpeFxuICB9KTtcbn07XG5cblxuV2ViR2xCYXNlUmVuZGVyZXIucHJvdG90eXBlLmVuZExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIGRpc2FibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKTtcbn07XG5cblxuV2ViR2xCYXNlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRpbGUgPSBmdW5jdGlvbih0aWxlLCB0ZXh0dXJlLCBsYXllciwgbGF5ZXJaKSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICB2YXIgY29uc3RhbnRCdWZmZXJzID0gdGhpcy5jb25zdGFudEJ1ZmZlcnM7XG4gIHZhciBwcm9qTWF0cml4ID0gdGhpcy5wcm9qTWF0cml4O1xuICB2YXIgdmlld01hdHJpeCA9IHRoaXMudmlld01hdHJpeDtcbiAgdmFyIHRyYW5zbGF0ZVZlY3RvciA9IHRoaXMudHJhbnNsYXRlVmVjdG9yO1xuICB2YXIgc2NhbGVWZWN0b3IgPSB0aGlzLnNjYWxlVmVjdG9yO1xuXG4gIG1hdDQuY29weShwcm9qTWF0cml4LCBsYXllci52aWV3KCkucHJvamVjdGlvbigpKTtcbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVQcm9qTWF0cml4LCBmYWxzZSwgcHJvak1hdHJpeCk7XG5cbiAgbWF0NC5jb3B5KHZpZXdNYXRyaXgsIGxheWVyLnZpZXcoKS52aWV3TWF0cml4KCkpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVZpZXdNYXRyaXgsIGZhbHNlLCB2aWV3TWF0cml4KTtcbiAgXG4gIC8vIEdlbmVyYXRlIE1vZGVsTWF0cml4LlxuICAvLyBUT0RPIENhY2hlIHRoZSBtYXRyaXggaW4gdGhlIHRpbGUgb2JqZWN0P1xuICB0cmFuc2xhdGVWZWN0b3JbMF0gPSB0aWxlLmNlbnRlclgoKTtcbiAgdHJhbnNsYXRlVmVjdG9yWzFdID0gdGlsZS5jZW50ZXJZKCk7XG4gIHRyYW5zbGF0ZVZlY3RvclsyXSA9IC0wLjU7XG5cbiAgc2NhbGVWZWN0b3JbMF0gPSB0aWxlLnNjYWxlWCgpO1xuICBzY2FsZVZlY3RvclsxXSA9IHRpbGUuc2NhbGVZKCk7XG4gIHNjYWxlVmVjdG9yWzJdID0gMS4wO1xuXG4gIHZhciBtb2RlbE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIG1hdDQucm90YXRlWChtb2RlbE1hdHJpeCwgbW9kZWxNYXRyaXgsIHRpbGUucm90WCgpKTtcbiAgbWF0NC5yb3RhdGVZKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgdGlsZS5yb3RZKCkpO1xuICBtYXQ0LnRyYW5zbGF0ZShtb2RlbE1hdHJpeCwgbW9kZWxNYXRyaXgsIHRyYW5zbGF0ZVZlY3Rvcik7XG4gIG1hdDQuc2NhbGUobW9kZWxNYXRyaXgsIG1vZGVsTWF0cml4LCBzY2FsZVZlY3Rvcik7XG5cbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVNb2RlbE1hdHJpeCwgZmFsc2UsIG1vZGVsTWF0cml4KTtcblxuICBzZXREZXB0aChnbCwgc2hhZGVyUHJvZ3JhbSwgbGF5ZXJaLCB0aWxlLnopO1xuICBzZXRUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKTtcblxuICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudmVydGV4SW5kaWNlcyk7XG4gIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHZlcnRleEluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR2xCYXNlUmVuZGVyZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHRvIHNldCB0aGUgV2ViR2wgZGVwdGggZm9yIGEgdGlsZS5cbnZhciBNQVhfTEFZRVJTID0gMjU2OyAvLyBNYXggbnVtYmVyIG9mIGxheWVycyBwZXIgc3RhZ2UuXG52YXIgTUFYX0xFVkVMUyA9IDI1NjsgLy8gTWF4IG51bWJlciBvZiBsZXZlbHMgcGVyIGxheWVyLlxuXG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG52YXIgdmVjMyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzM7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG5cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCBzcmMpIHtcbiAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHRocm93IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgfVxuICByZXR1cm4gc2hhZGVyO1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYkxpc3QsIHVuaWZvcm1MaXN0KSB7XG5cbiAgdmFyIHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U3JjKTtcbiAgdmFyIGZyYWdtZW50U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U3JjKTtcblxuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wubGlua1Byb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIHRocm93IGdsLmdldFByb2dyYW1JbmZvTG9nKHNoYWRlclByb2dyYW0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHJpYiA9IGF0dHJpYkxpc3RbaV07XG4gICAgc2hhZGVyUHJvZ3JhbVthdHRyaWJdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgYXR0cmliKTtcbiAgICBpZiAoc2hhZGVyUHJvZ3JhbVthdHRyaWJdID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgcHJvZ3JhbSBoYXMgbm8gJyArIGF0dHJpYiArICcgYXR0cmlidXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCB1bmlmb3JtTGlzdC5sZW5ndGg7IGorKykge1xuICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybUxpc3Rbal07XG4gICAgc2hhZGVyUHJvZ3JhbVt1bmlmb3JtXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCB1bmlmb3JtKTtcbiAgICBpZiAoc2hhZGVyUHJvZ3JhbVt1bmlmb3JtXSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZGVyIHByb2dyYW0gaGFzIG5vICcgKyB1bmlmb3JtICsgJyB1bmlmb3JtJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNoYWRlclByb2dyYW07XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveVNoYWRlclByb2dyYW0oZ2wsIHNoYWRlclByb2dyYW0pIHtcbiAgdmFyIHNoYWRlckxpc3QgPSBnbC5nZXRBdHRhY2hlZFNoYWRlcnMoc2hhZGVyUHJvZ3JhbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhZGVyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGFkZXIgPSBzaGFkZXJMaXN0W2ldO1xuICAgIGdsLmRldGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBzaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICB9XG4gIGdsLmRlbGV0ZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIHRhcmdldCwgdXNhZ2UsIHZhbHVlKSB7XG4gIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgZ2wuYmluZEJ1ZmZlcih0YXJnZXQsIGJ1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEodGFyZ2V0LCB2YWx1ZSwgdXNhZ2UpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN0YW50QnVmZmVycyhnbCwgdmVydGV4SW5kaWNlcywgdmVydGV4UG9zaXRpb25zLCB0ZXh0dXJlQ29vcmRzKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGV4SW5kaWNlczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnbC5TVEFUSUNfRFJBVywgbmV3IFVpbnQxNkFycmF5KHZlcnRleEluZGljZXMpKSxcbiAgICB2ZXJ0ZXhQb3NpdGlvbnM6IGNyZWF0ZUNvbnN0YW50QnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBuZXcgRmxvYXQzMkFycmF5KHZlcnRleFBvc2l0aW9ucykpLFxuICAgIHRleHR1cmVDb29yZHM6IGNyZWF0ZUNvbnN0YW50QnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBuZXcgRmxvYXQzMkFycmF5KHRleHR1cmVDb29yZHMpKVxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnMoZ2wsIGNvbnN0YW50QnVmZmVycykge1xuICBnbC5kZWxldGVCdWZmZXIoY29uc3RhbnRCdWZmZXJzLnZlcnRleEluZGljZXMpO1xuICBnbC5kZWxldGVCdWZmZXIoY29uc3RhbnRCdWZmZXJzLnZlcnRleFBvc2l0aW9ucyk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudGV4dHVyZUNvb3Jkcyk7XG59XG5cblxuZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSkge1xuICB2YXIgbnVtQXR0cnMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BdHRyczsgaSsrKSB7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBkaXNhYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSkge1xuICB2YXIgbnVtQXR0cnMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BdHRyczsgaSsrKSB7XG4gICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2V0VGV4dHVyZShnbCwgc2hhZGVyUHJvZ3JhbSwgdGV4dHVyZSkge1xuICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fdGV4dHVyZSk7XG4gIGdsLnVuaWZvcm0xaShzaGFkZXJQcm9ncmFtLnVTYW1wbGVyLCAwKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVwdGhtYXBUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl90ZXh0dXJlKTtcbiAgZ2wudW5pZm9ybTFpKHNoYWRlclByb2dyYW0udURlcHRobWFwLCAxKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVwdGgoZ2wsIHNoYWRlclByb2dyYW0sIGxheWVyWiwgdGlsZVopIHtcbiAgdmFyIGRlcHRoID0gKCgobGF5ZXJaICsgMSkgKiBNQVhfTEVWRUxTKSAtIHRpbGVaKSAvIChNQVhfTEVWRUxTICogTUFYX0xBWUVSUyk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVEZXB0aCwgZGVwdGgpO1xufVxuXG5cbnZhciBkZWZhdWx0T3BhY2l0eSA9IDEuMDtcbnZhciBkZWZhdWx0Q29sb3JPZmZzZXQgPSB2ZWM0LmNyZWF0ZSgpO1xudmFyIGRlZmF1bHRDb2xvck1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5tYXQ0LmlkZW50aXR5KGRlZmF1bHRDb2xvck1hdHJpeCk7XG5cbmZ1bmN0aW9uIHNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcyhnbCwgZWZmZWN0cywgdW5pZm9ybXMpIHtcbiAgdmFyIG9wYWNpdHkgPSBkZWZhdWx0T3BhY2l0eTtcbiAgaWYgKGVmZmVjdHMgJiYgZWZmZWN0cy5vcGFjaXR5ICE9IG51bGwpIHtcbiAgICBvcGFjaXR5ID0gZWZmZWN0cy5vcGFjaXR5O1xuICB9XG4gIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5vcGFjaXR5LCBvcGFjaXR5KTtcblxuICB2YXIgY29sb3JPZmZzZXQgPSBkZWZhdWx0Q29sb3JPZmZzZXQ7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMuY29sb3JPZmZzZXQpIHtcbiAgICBjb2xvck9mZnNldCA9IGVmZmVjdHMuY29sb3JPZmZzZXQ7XG4gIH1cbiAgZ2wudW5pZm9ybTRmdih1bmlmb3Jtcy5jb2xvck9mZnNldCwgY29sb3JPZmZzZXQpO1xuXG4gIHZhciBjb2xvck1hdHJpeCA9IGRlZmF1bHRDb2xvck1hdHJpeDtcbiAgaWYgKGVmZmVjdHMgJiYgZWZmZWN0cy5jb2xvck1hdHJpeCkge1xuICAgIGNvbG9yTWF0cml4ID0gZWZmZWN0cy5jb2xvck1hdHJpeDtcbiAgfVxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1zLmNvbG9yTWF0cml4LCBmYWxzZSwgY29sb3JNYXRyaXgpO1xufVxuXG5cbi8vIFRlbXBvcmFyeSB2ZWN0b3JzIGZvciBzZXRWaWV3cG9ydC5cbnZhciB0cmFuc2xhdGVWZWN0b3IgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyIHNjYWxlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcblxuXG4vLyBTZXRzIHRoZSBXZWJHTCB2aWV3cG9ydCBhbmQgcmV0dXJucyBhIHZpZXdwb3J0IGNsYW1waW5nIGNvbXBlbnNhdGlvbiBtYXRyaXguXG4vL1xuLy8gTmVnYXRpdmUgdmlld3BvcnQgb3JpZ2luIGNvb3JkaW5hdGVzIGNhdXNlIHJlbmRlcmluZyBpc3N1ZXMuIExldHRpbmcgdGhlXG4vLyB2aWV3cG9ydCBkaW1lbnNpb25zIGV4dGVuZCBiZXlvbmQgdGhlIHZpc2libGUgYXJlYSBkbyBub3Qgc2VlbSB0byBjYXVzZVxuLy8gcmVuZGVyaW5nIGlzc3VlcywgYnV0IHRoZXkgbWF5IHN0aWxsIGhhdmUgYW4gaW1wYWN0IG9uIHBlcmZvcm1hbmNlLlxuLy8gVGhlcmVmb3JlLCB3aGVuIHRoZSBzY2VuZSdzIHJlY3QgaXMgbm90IGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgcmVuZGVyaW5nXG4vLyBhcmVhLCB3ZSBjbGFtcCB0aGUgdmlld3BvcnQgdG8gdGhlIHJlbmRlcmluZyBhcmVhLCBhbmQgcmV0dXJuIGEgY29tcGVuc2F0aW9uXG4vLyBtYXRyaXggdG8gc2NhbGUgYW5kIHRyYW5zbGF0ZSB2ZXJ0aWNlcyBhY2NvcmRpbmdseS5cbmZ1bmN0aW9uIHNldFZpZXdwb3J0KGdsLCBsYXllciwgcmVjdCwgdmlld3BvcnRNYXRyaXgpIHtcbiAgaWYgKHJlY3QueCA9PT0gMCAmJiByZWN0LndpZHRoID09PSAxICYmIHJlY3QueSA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMSkge1xuICAgIC8vIEZhc3QgcGF0aCBmb3IgZnVsbCByZWN0LlxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgbWF0NC5pZGVudGl0eSh2aWV3cG9ydE1hdHJpeCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9mZnNldFggPSByZWN0Lng7XG4gIHZhciBjbGFtcGVkT2Zmc2V0WCA9IGNsYW1wKG9mZnNldFgsIDAsIDEpO1xuICB2YXIgbGVmdEV4Y2VzcyA9IGNsYW1wZWRPZmZzZXRYIC0gb2Zmc2V0WDtcbiAgdmFyIG1heENsYW1wZWRXaWR0aCA9IDEgLSBjbGFtcGVkT2Zmc2V0WDtcbiAgdmFyIGNsYW1wZWRXaWR0aCA9IGNsYW1wKHJlY3Qud2lkdGggLSBsZWZ0RXhjZXNzLCAwLCBtYXhDbGFtcGVkV2lkdGgpO1xuICB2YXIgcmlnaHRFeGNlc3MgPSByZWN0LndpZHRoIC0gY2xhbXBlZFdpZHRoO1xuXG4gIHZhciBvZmZzZXRZID0gMSAtIHJlY3QuaGVpZ2h0IC0gcmVjdC55O1xuICB2YXIgY2xhbXBlZE9mZnNldFkgPSBjbGFtcChvZmZzZXRZLCAwLCAxKTtcbiAgdmFyIGJvdHRvbUV4Y2VzcyA9IGNsYW1wZWRPZmZzZXRZIC0gb2Zmc2V0WTtcbiAgdmFyIG1heENsYW1wZWRIZWlnaHQgPSAxIC0gY2xhbXBlZE9mZnNldFk7XG4gIHZhciBjbGFtcGVkSGVpZ2h0ID0gY2xhbXAocmVjdC5oZWlnaHQgLSBib3R0b21FeGNlc3MsIDAsIG1heENsYW1wZWRIZWlnaHQpO1xuICB2YXIgdG9wRXhjZXNzID0gcmVjdC5oZWlnaHQgLSBjbGFtcGVkSGVpZ2h0O1xuXG4gIHZlYzMuc2V0KFxuICAgIHNjYWxlVmVjdG9yLFxuICAgIHJlY3Qud2lkdGggLyBjbGFtcGVkV2lkdGgsXG4gICAgcmVjdC5oZWlnaHQgLyBjbGFtcGVkSGVpZ2h0LFxuICAgIDEpO1xuXG4gIHZlYzMuc2V0KFxuICAgIHRyYW5zbGF0ZVZlY3RvcixcbiAgICAocmlnaHRFeGNlc3MgLSBsZWZ0RXhjZXNzKSAvIGNsYW1wZWRXaWR0aCxcbiAgICAodG9wRXhjZXNzIC0gYm90dG9tRXhjZXNzKSAvIGNsYW1wZWRIZWlnaHQsXG4gICAgMCk7XG5cbiAgbWF0NC5pZGVudGl0eSh2aWV3cG9ydE1hdHJpeCk7XG4gIG1hdDQudHJhbnNsYXRlKHZpZXdwb3J0TWF0cml4LCB2aWV3cG9ydE1hdHJpeCwgdHJhbnNsYXRlVmVjdG9yKTtcbiAgbWF0NC5zY2FsZSh2aWV3cG9ydE1hdHJpeCwgdmlld3BvcnRNYXRyaXgsIHNjYWxlVmVjdG9yKTtcblxuICBnbC52aWV3cG9ydChnbC5kcmF3aW5nQnVmZmVyV2lkdGggKiBjbGFtcGVkT2Zmc2V0WCxcbiAgICAgICAgICAgICAgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAqIGNsYW1wZWRPZmZzZXRZLFxuICAgICAgICAgICAgICBnbC5kcmF3aW5nQnVmZmVyV2lkdGggKiBjbGFtcGVkV2lkdGgsXG4gICAgICAgICAgICAgIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgKiBjbGFtcGVkSGVpZ2h0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVNoYWRlclByb2dyYW06IGNyZWF0ZVNoYWRlclByb2dyYW0sXG4gIGRlc3Ryb3lTaGFkZXJQcm9ncmFtOiBkZXN0cm95U2hhZGVyUHJvZ3JhbSxcbiAgY3JlYXRlQ29uc3RhbnRCdWZmZXJzOiBjcmVhdGVDb25zdGFudEJ1ZmZlcnMsXG4gIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM6IGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnMsXG4gIGVuYWJsZUF0dHJpYnV0ZXM6IGVuYWJsZUF0dHJpYnV0ZXMsXG4gIGRpc2FibGVBdHRyaWJ1dGVzOiBkaXNhYmxlQXR0cmlidXRlcyxcbiAgc2V0VGV4dHVyZTogc2V0VGV4dHVyZSxcbiAgc2V0RGVwdGhtYXBUZXh0dXJlOiBzZXREZXB0aG1hcFRleHR1cmUsXG4gIHNldERlcHRoOiBzZXREZXB0aCxcbiAgc2V0Vmlld3BvcnQ6IHNldFZpZXdwb3J0LFxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXM6IHNldHVwUGl4ZWxFZmZlY3RVbmlmb3Jtc1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQmFzZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9XZWJHbEJhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xDdWJlUmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEN1YmVHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9LCBhcHByb3ByaWF0ZVxuICogZm9yIGEge0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEN1YmVSZW5kZXJlcigpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoV2ViR2xDdWJlUmVuZGVyZXIsIFdlYkdsQmFzZVJlbmRlcmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEN1YmVSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcbnZhciBzZXREZXB0aG1hcFRleHR1cmUgPSBXZWJHbENvbW1vbi5zZXREZXB0aG1hcFRleHR1cmVcblxudmFyIHZlcnRleFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4Q3ViZURlcHRoJyk7XG52YXIgZnJhZ21lbnRTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2ZyYWdtZW50Q3ViZURlcHRoJyk7XG5cbi8vIEluaXRpYWxpemUgYXJyYXlzIGZvciB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIGFuZCB0ZXh0dXJlQ29vcmRzXG52YXIgdmVydGV4SW5kaWNlcyA9IFtdO1xudmFyIHZlcnRleFBvc2l0aW9ucyA9IFtdO1xudmFyIHRleHR1cmVDb29yZHMgPSBbXTtcblxudmFyIGRlZmF1bHRXaWR0aFNlZ21lbnRzID0gNDA7XG52YXIgZGVmYXVsdEhlaWdodFNlZ21lbnRzID0gNDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleERhdGFzKHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzKSB7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcm93IGFuZCBjb2x1bW4gdG8gZ2VuZXJhdGUgdmVydGljZXMsIHRleHR1cmUgY29vcmRpbmF0ZXMsIGFuZCBpbmRpY2VzXG4gIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8PSBoZWlnaHRTZWdtZW50czsgcm93KyspIHtcbiAgICB2YXIgdiA9IHJvdyAvIGhlaWdodFNlZ21lbnRzO1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8PSB3aWR0aFNlZ21lbnRzOyBjb2wrKykge1xuICAgICAgdmFyIHUgPSBjb2wgLyB3aWR0aFNlZ21lbnRzO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdmVydGV4IHBvc2l0aW9uc1xuICAgICAgdmFyIHggPSB1IC0gMC41O1xuICAgICAgdmFyIHkgPSB2IC0gMC41O1xuICAgICAgdmFyIHogPSAwLjA7XG4gICAgICB2ZXJ0ZXhQb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAgICAgIHRleHR1cmVDb29yZHMucHVzaCh1LCB2KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHZlcnRleCBpbmRpY2VzXG4gICAgICBpZiAocm93IDwgaGVpZ2h0U2VnbWVudHMgJiYgY29sIDwgd2lkdGhTZWdtZW50cykge1xuICAgICAgICB2YXIgYSA9IHJvdyAqICh3aWR0aFNlZ21lbnRzICsgMSkgKyBjb2w7XG4gICAgICAgIHZhciBiID0gYSArIDE7XG4gICAgICAgIHZhciBjID0gKHJvdyArIDEpICogKHdpZHRoU2VnbWVudHMgKyAxKSArIGNvbDtcbiAgICAgICAgdmFyIGQgPSBjICsgMTtcbiAgICAgICAgdmVydGV4SW5kaWNlcy5wdXNoKGEsIGIsIGMsIGIsIGQsIGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cmliTGlzdCA9IFsnYVZlcnRleFBvc2l0aW9uJywgJ2FUZXh0dXJlQ29vcmQnXTtcbnZhciB1bmlmb3JtTGlzdCA9IFtcbiAgJ3VEZXB0aCcsICd1T3BhY2l0eScsICd1U2FtcGxlcicsICd1RGVwdGhtYXAnLCAndVByb2pNYXRyaXgnLCAndVZpZXdNYXRyaXgnLFxuICAndU1vZGVsTWF0cml4JywgJ3VWaWV3cG9ydE1hdHJpeCcsICd1Q29sb3JPZmZzZXQnLCAndUNvbG9yTWF0cml4J1xuXTtcblxuXG5cbi8qKlxuICogQGNsYXNzIFdlYkdsQ3ViZURlcHRoUmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEN1YmVHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9IHdpdGggZGVwdGhtYXAsIGFwcHJvcHJpYXRlXG4gKiBmb3IgYSB7QGxpbmsgV2ViR2xTdGFnZX0uXG4gKlxuICogTW9zdCB1c2VycyBkbyBub3QgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLiBSZW5kZXJlcnMgYXJlIGNyZWF0ZWQgYW5kXG4gKiBkZXN0cm95ZWQgYnkge0BsaW5rIFN0YWdlfSBhcyBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIFdlYkdsQ3ViZURlcHRoUmVuZGVyZXIoZ2wsIG9wdHMpIHtcbiAgdGhpcy5nbCA9IGdsO1xuXG4gIC8vIFRoZSBwcm9qZWN0aW9uIG1hdHJpeCBwb3NpdGlvbnMgdGhlIHRpbGVzIGluIHdvcmxkIHNwYWNlLlxuICAvLyBXZSBjb21wdXRlIGl0IGluIEphdmFzY3JpcHQgYmVjYXVzZSBsYWNrIG9mIHByZWNpc2lvbiBpbiB0aGUgdmVydGV4IHNoYWRlclxuICAvLyBjYXVzZXMgc2VhbXMgdG8gYXBwZWFyIGJldHdlZW4gYWRqYWNlbnQgdGlsZXMgYXQgbGFyZ2Ugem9vbSBsZXZlbHMuXG4gIHRoaXMucHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVE9ETyBXaHkgc2F2ZSB0aGlzIHZhbHVlIGhlcmU/IHRoZSBzYW1lIHF1ZXN0aW9uIHRvIHRoZSBwcm9qTWF0cml4LlxuICB0aGlzLnZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSB2aWV3cG9ydCBtYXRyaXggcmVzcG9uc2libGUgZm9yIHZpZXdwb3J0IGNsYW1waW5nLlxuICAvLyBTZWUgc2V0Vmlld3BvcnQoKSBmb3IgYW4gZXhwbGFuYXRpb24gb2YgaG93IGl0IHdvcmtzLlxuICB0aGlzLnZpZXdwb3J0TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUcmFuc2xhdGlvbiBhbmQgc2NhbGUgdmVjdG9ycyBmb3IgdGlsZXMuXG4gIHRoaXMudHJhbnNsYXRlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcbiAgdGhpcy5zY2FsZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgdmFyIHdpZHRoU2VnbWVudHMgPSBvcHRzICYmIG9wdHMud2lkdGhTZWdtZW50cyA/IG9wdHMud2lkdGhTZWdtZW50cyA6IGRlZmF1bHRXaWR0aFNlZ21lbnRzO1xuICB2YXIgaGVpZ2h0U2VnbWVudHMgPSBvcHRzICYmIG9wdHMuaGVpZ2h0U2VnbWVudHMgPyBvcHRzLmhlaWdodFNlZ21lbnRzIDogZGVmYXVsdEhlaWdodFNlZ21lbnRzO1xuICBjcmVhdGVWZXJ0ZXhEYXRhcyh3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyk7XG4gIFxuICB0aGlzLmNvbnN0YW50QnVmZmVycyA9IGNyZWF0ZUNvbnN0YW50QnVmZmVycyhnbCwgdmVydGV4SW5kaWNlcywgdmVydGV4UG9zaXRpb25zLCB0ZXh0dXJlQ29vcmRzKTtcblxuICB0aGlzLnNoYWRlclByb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJMaXN0LCB1bmlmb3JtTGlzdCk7XG59XG5cbldlYkdsQ3ViZURlcHRoUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnModGhpcy5nbCwgdGhpcy5jb25zdGFudEJ1ZmZlcnMpO1xuICBkZXN0cm95U2hhZGVyUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnNoYWRlclByb2dyYW0pO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5XZWJHbEN1YmVEZXB0aFJlbmRlcmVyLnByb3RvdHlwZS5zdGFydExheWVyID0gZnVuY3Rpb24gKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICB2YXIgY29uc3RhbnRCdWZmZXJzID0gdGhpcy5jb25zdGFudEJ1ZmZlcnM7XG4gIHZhciB2aWV3cG9ydE1hdHJpeCA9IHRoaXMudmlld3BvcnRNYXRyaXg7XG5cbiAgZ2wudXNlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICBlbmFibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKTtcblxuICBzZXRWaWV3cG9ydChnbCwgbGF5ZXIsIHJlY3QsIHZpZXdwb3J0TWF0cml4KTtcbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVWaWV3cG9ydE1hdHJpeCwgZmFsc2UsIHZpZXdwb3J0TWF0cml4KTtcblxuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnZlcnRleFBvc2l0aW9ucyk7XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbS5hVmVydGV4UG9zaXRpb24sIDMsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgMCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudGV4dHVyZUNvb3Jkcyk7XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbS5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDApO1xuXG4gIHNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcyhnbCwgbGF5ZXIuZWZmZWN0cygpLCB7XG4gICAgb3BhY2l0eTogc2hhZGVyUHJvZ3JhbS51T3BhY2l0eSxcbiAgICBjb2xvck9mZnNldDogc2hhZGVyUHJvZ3JhbS51Q29sb3JPZmZzZXQsXG4gICAgY29sb3JNYXRyaXg6IHNoYWRlclByb2dyYW0udUNvbG9yTWF0cml4XG4gIH0pO1xufTtcblxuV2ViR2xDdWJlRGVwdGhSZW5kZXJlci5wcm90b3R5cGUuZW5kTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIHJlY3QpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIGRpc2FibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKTtcbn07XG5cbldlYkdsQ3ViZURlcHRoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRpbGUgPSBmdW5jdGlvbiAodGlsZSwgdGV4dHVyZSwgbGF5ZXIsIGxheWVyWikge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuICB2YXIgcHJvak1hdHJpeCA9IHRoaXMucHJvak1hdHJpeDtcbiAgdmFyIHZpZXdNYXRyaXggPSB0aGlzLnZpZXdNYXRyaXg7XG4gIHZhciB0cmFuc2xhdGVWZWN0b3IgPSB0aGlzLnRyYW5zbGF0ZVZlY3RvcjtcbiAgdmFyIHNjYWxlVmVjdG9yID0gdGhpcy5zY2FsZVZlY3RvcjtcblxuICBtYXQ0LmNvcHkocHJvak1hdHJpeCwgbGF5ZXIudmlldygpLnByb2plY3Rpb24oKSk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51UHJvak1hdHJpeCwgZmFsc2UsIHByb2pNYXRyaXgpO1xuXG4gIG1hdDQuY29weSh2aWV3TWF0cml4LCBsYXllci52aWV3KCkudmlld01hdHJpeCgpKTtcbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVWaWV3TWF0cml4LCBmYWxzZSwgdmlld01hdHJpeCk7XG5cbiAgLy8gR2VuZXJhdGUgTW9kZWxNYXRyaXguXG4gIC8vIFRPRE8gQ2FjaGUgdGhlIG1hdHJpeCBpbiB0aGUgdGlsZSBvYmplY3Q/XG4gIHRyYW5zbGF0ZVZlY3RvclswXSA9IHRpbGUuY2VudGVyWCgpO1xuICB0cmFuc2xhdGVWZWN0b3JbMV0gPSB0aWxlLmNlbnRlclkoKTtcbiAgdHJhbnNsYXRlVmVjdG9yWzJdID0gLTAuNTtcblxuICBzY2FsZVZlY3RvclswXSA9IHRpbGUuc2NhbGVYKCk7XG4gIHNjYWxlVmVjdG9yWzFdID0gdGlsZS5zY2FsZVkoKTtcbiAgc2NhbGVWZWN0b3JbMl0gPSAxLjA7XG5cbiAgdmFyIG1vZGVsTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgbWF0NC5yb3RhdGVZKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgLU1hdGguUEkgLyAyKTtcbiAgbWF0NC5yb3RhdGVYKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgdGlsZS5yb3RYKCkpO1xuICBtYXQ0LnJvdGF0ZVkobW9kZWxNYXRyaXgsIG1vZGVsTWF0cml4LCB0aWxlLnJvdFkoKSk7XG4gIG1hdDQudHJhbnNsYXRlKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgdHJhbnNsYXRlVmVjdG9yKTtcbiAgbWF0NC5zY2FsZShtb2RlbE1hdHJpeCwgbW9kZWxNYXRyaXgsIHNjYWxlVmVjdG9yKTtcblxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udU1vZGVsTWF0cml4LCBmYWxzZSwgbW9kZWxNYXRyaXgpO1xuXG4gIC8vIERlcHRoLCBUZXh0dXJlLCBEZXB0aG1hcFRleHR1cmUuXG4gIHNldERlcHRoKGdsLCBzaGFkZXJQcm9ncmFtLCBsYXllclosIHRpbGUueik7XG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuICBzZXREZXB0aG1hcFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIGxheWVyLmRlcHRobWFwU3RvcmUoKS50ZXh0dXJlKCkpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhJbmRpY2VzKTtcbiAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGV4SW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR2xDdWJlRGVwdGhSZW5kZXJlcjsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgV2ViR2xDb21tb24gPSByZXF1aXJlKCcuL1dlYkdsQ29tbW9uJyk7XG52YXIgY3JlYXRlQ29uc3RhbnRCdWZmZXJzID0gV2ViR2xDb21tb24uY3JlYXRlQ29uc3RhbnRCdWZmZXJzO1xudmFyIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5kZXN0cm95Q29uc3RhbnRCdWZmZXJzO1xudmFyIGNyZWF0ZVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5jcmVhdGVTaGFkZXJQcm9ncmFtO1xudmFyIGRlc3Ryb3lTaGFkZXJQcm9ncmFtID0gV2ViR2xDb21tb24uZGVzdHJveVNoYWRlclByb2dyYW07XG52YXIgZW5hYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmVuYWJsZUF0dHJpYnV0ZXM7XG52YXIgZGlzYWJsZUF0dHJpYnV0ZXMgPSBXZWJHbENvbW1vbi5kaXNhYmxlQXR0cmlidXRlcztcbnZhciBzZXRWaWV3cG9ydCA9IFdlYkdsQ29tbW9uLnNldFZpZXdwb3J0O1xudmFyIHNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcyA9IFdlYkdsQ29tbW9uLnNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcztcblxudmFyIHNldERlcHRoID0gV2ViR2xDb21tb24uc2V0RGVwdGg7XG52YXIgc2V0VGV4dHVyZSA9IFdlYkdsQ29tbW9uLnNldFRleHR1cmU7XG5cbnZhciB2ZXJ0ZXhTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3ZlcnRleEVxdWlyZWN0Jyk7XG52YXIgZnJhZ21lbnRTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2ZyYWdtZW50RXF1aXJlY3QnKTtcblxudmFyIHZlcnRleEluZGljZXMgPSBbMCwgMSwgMiwgMCwgMiwgM107XG52YXIgdmVydGV4UG9zaXRpb25zID0gWy0xLjAsIC0xLjAsIDAuMCwgMS4wLCAtMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIC0xLjAsIDEuMCwgMC4wXTtcbnZhciB0ZXh0dXJlQ29vcmRzID0gWzAuMCwgMC4wLCAxLjAsIDAuMCwgMS4wLCAxLjAsIDAuMCwgMS4wXTtcblxudmFyIGF0dHJpYkxpc3QgPSBbJ2FWZXJ0ZXhQb3NpdGlvbiddO1xudmFyIHVuaWZvcm1MaXN0ID0gW1xuICAndURlcHRoJywgJ3VPcGFjaXR5JywgJ3VTYW1wbGVyJywgJ3VJbnZQcm9qTWF0cml4JywgJ3VWaWV3cG9ydE1hdHJpeCcsXG4gICd1Q29sb3JPZmZzZXQnLCAndUNvbG9yTWF0cml4JywgJ3VUZXh0dXJlWCcsICd1VGV4dHVyZVknLCAndVRleHR1cmVXaWR0aCcsXG4gICd1VGV4dHVyZUhlaWdodCdcbl07XG5cblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xFcXVpcmVjdFJlbmRlcmVyXG4gKiBAaW1wbGVtZW50cyBSZW5kZXJlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgcmVuZGVyZXIgZm9yIHtAbGluayBFcXVpcmVjdEdlb21ldHJ5fSBhbmQge0BsaW5rIFJlY3RpbGluZWFyVmlld30sXG4gKiBhcHByb3ByaWF0ZSBmb3Ige0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEVxdWlyZWN0UmVuZGVyZXIoZ2wpIHtcbiAgdGhpcy5nbCA9IGdsO1xuXG4gIC8vIFRoZSBpbnZlcnNlIHByb2plY3Rpb24gbWF0cml4LlxuICB0aGlzLmludlByb2pNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSB2aWV3cG9ydCBtYXRyaXggcmVzcG9uc2libGUgZm9yIHZpZXdwb3J0IGNsYW1waW5nLlxuICAvLyBTZWUgc2V0Vmlld3BvcnQoKSBmb3IgYW4gZXhwbGFuYXRpb24gb2YgaG93IGl0IHdvcmtzLlxuICB0aGlzLnZpZXdwb3J0TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICB0aGlzLmNvbnN0YW50QnVmZmVycyA9IGNyZWF0ZUNvbnN0YW50QnVmZmVycyhnbCwgdmVydGV4SW5kaWNlcywgdmVydGV4UG9zaXRpb25zLCB0ZXh0dXJlQ29vcmRzKTtcblxuICB0aGlzLnNoYWRlclByb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJMaXN0LCB1bmlmb3JtTGlzdCk7XG59XG5cbldlYkdsRXF1aXJlY3RSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBkZXN0cm95Q29uc3RhbnRCdWZmZXJzKHRoaXMuZ2wsIHRoaXMuY29uc3RhbnRCdWZmZXJzKTtcbiAgZGVzdHJveVNoYWRlclByb2dyYW0odGhpcy5nbCwgdGhpcy5zaGFkZXJQcm9ncmFtKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5XZWJHbEVxdWlyZWN0UmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgcmVjdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuICB2YXIgaW52UHJvak1hdHJpeCA9IHRoaXMuaW52UHJvak1hdHJpeDtcbiAgdmFyIHZpZXdwb3J0TWF0cml4ID0gdGhpcy52aWV3cG9ydE1hdHJpeDtcblxuICBnbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuXG4gIGVuYWJsZUF0dHJpYnV0ZXMoZ2wsIHNoYWRlclByb2dyYW0pO1xuXG4gIHNldFZpZXdwb3J0KGdsLCBsYXllciwgcmVjdCwgdmlld3BvcnRNYXRyaXgpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVZpZXdwb3J0TWF0cml4LCBmYWxzZSwgdmlld3BvcnRNYXRyaXgpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudmVydGV4UG9zaXRpb25zKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtLmFWZXJ0ZXhQb3NpdGlvbiwgMywgZ2wuRkxPQVQsIGdsLkZBTFNFLCAwLCAwKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy50ZXh0dXJlQ29vcmRzKTtcblxuICAvLyBDb21wdXRlIGFuZCBzZXQgdGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXG4gIG1hdDQuY29weShpbnZQcm9qTWF0cml4LCBsYXllci52aWV3KCkucHJvamVjdGlvbigpKTtcbiAgbWF0NC5pbnZlcnQoaW52UHJvak1hdHJpeCwgaW52UHJvak1hdHJpeCk7XG5cbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVJbnZQcm9qTWF0cml4LCBmYWxzZSwgaW52UHJvak1hdHJpeCk7XG5cbiAgLy8gQ29tcHV0ZSBhbmQgc2V0IHRoZSB0ZXh0dXJlIHNjYWxlIGFuZCBjcm9wIG9mZnNldHMuXG4gIHZhciB0ZXh0dXJlQ3JvcCA9IGxheWVyLmVmZmVjdHMoKS50ZXh0dXJlQ3JvcCB8fCB7fTtcbiAgdmFyIHRleHR1cmVYID0gdGV4dHVyZUNyb3AueCAhPSBudWxsID8gdGV4dHVyZUNyb3AueCA6IDA7XG4gIHZhciB0ZXh0dXJlWSA9IHRleHR1cmVDcm9wLnkgIT0gbnVsbCA/IHRleHR1cmVDcm9wLnkgOiAwO1xuICB2YXIgdGV4dHVyZVdpZHRoID0gdGV4dHVyZUNyb3Aud2lkdGggIT0gbnVsbCA/IHRleHR1cmVDcm9wLndpZHRoIDogMTtcbiAgdmFyIHRleHR1cmVIZWlnaHQgPSB0ZXh0dXJlQ3JvcC5oZWlnaHQgIT0gbnVsbCA/IHRleHR1cmVDcm9wLmhlaWdodCA6IDE7XG5cbiAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW0udVRleHR1cmVYLCB0ZXh0dXJlWCk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVUZXh0dXJlWSwgdGV4dHVyZVkpO1xuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51VGV4dHVyZVdpZHRoLCB0ZXh0dXJlV2lkdGgpO1xuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51VGV4dHVyZUhlaWdodCwgdGV4dHVyZUhlaWdodCk7XG5cbiAgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zKGdsLCBsYXllci5lZmZlY3RzKCksIHtcbiAgICBvcGFjaXR5OiBzaGFkZXJQcm9ncmFtLnVPcGFjaXR5LFxuICAgIGNvbG9yT2Zmc2V0OiBzaGFkZXJQcm9ncmFtLnVDb2xvck9mZnNldCxcbiAgICBjb2xvck1hdHJpeDogc2hhZGVyUHJvZ3JhbS51Q29sb3JNYXRyaXhcbiAgfSk7XG59O1xuXG5cbldlYkdsRXF1aXJlY3RSZW5kZXJlci5wcm90b3R5cGUuZW5kTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgcmVjdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgZGlzYWJsZUF0dHJpYnV0ZXMoZ2wsIHNoYWRlclByb2dyYW0pO1xufTtcblxuXG5XZWJHbEVxdWlyZWN0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRpbGUgPSBmdW5jdGlvbih0aWxlLCB0ZXh0dXJlLCBsYXllciwgbGF5ZXJaKSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICB2YXIgY29uc3RhbnRCdWZmZXJzID0gdGhpcy5jb25zdGFudEJ1ZmZlcnM7XG5cbiAgc2V0RGVwdGgoZ2wsIHNoYWRlclByb2dyYW0sIGxheWVyWiwgdGlsZS56KTtcblxuICBzZXRUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKTtcblxuICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudmVydGV4SW5kaWNlcyk7XG4gIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHZlcnRleEluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR2xFcXVpcmVjdFJlbmRlcmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgV2ViR2xCYXNlUmVuZGVyZXIgPSByZXF1aXJlKCcuL1dlYkdsQmFzZScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xuXG4vKipcbiAqIEBjbGFzcyBXZWJHbEZsYXRSZW5kZXJlclxuICogQGltcGxlbWVudHMgUmVuZGVyZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHJlbmRlcmVyIGZvciB7QGxpbmsgRmxhdEdlb21ldHJ5fSBhbmQge0BsaW5rIEZsYXRWaWV3fSwgYXBwcm9wcmlhdGUgZm9yIGFcbiAqIHtAbGluayBXZWJHbFN0YWdlfS5cbiAqXG4gKiBNb3N0IHVzZXJzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MuIFJlbmRlcmVycyBhcmUgY3JlYXRlZCBhbmRcbiAqIGRlc3Ryb3llZCBieSB7QGxpbmsgU3RhZ2V9IGFzIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gV2ViR2xGbGF0UmVuZGVyZXIoKSB7XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXRzKFdlYkdsRmxhdFJlbmRlcmVyLCBXZWJHbEJhc2VSZW5kZXJlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR2xGbGF0UmVuZGVyZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBXZWJHbEZsYXQgPSByZXF1aXJlKCcuL1dlYkdsRmxhdCcpO1xudmFyIFdlYkdsQ3ViZSA9IHJlcXVpcmUoJy4vV2ViR2xDdWJlJyk7XG52YXIgV2ViR2xDdWJlRGVwdGggPSByZXF1aXJlKCcuL1dlYkdsQ3ViZURlcHRoJyk7XG52YXIgV2ViR2xFcXVpcmVjdCA9IHJlcXVpcmUoJy4vV2ViR2xFcXVpcmVjdCcpO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbGwga25vd24gcmVuZGVyZXJzIGZvciB0aGUgZ2l2ZW4gc3RhZ2UgdHlwZSBpbnRvIHRoYXQgc3RhZ2UuXG4gKiBNb3N0IHVzZXJzIHdpbGwgbm90IG5lZWQgdG8gcmVnaXN0ZXIgcmVuZGVyZXJzLCBhcyB7QGxpbmsgVmlld2VyfSBkb2VzIGl0IGZvclxuICogdGhlbS5cbiAqXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgc3RhZ2Ugd2hlcmUgdGhlIHJlbmRlcmVycyBhcmUgdG8gYmUgcmVnaXN0ZXJlZC5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHN0YWdlIHR5cGUgaXMgdW5rbm93bi5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzKHN0YWdlKSB7XG4gIHN3aXRjaCAoc3RhZ2UudHlwZSkge1xuICAgIGNhc2UgJ3dlYmdsJzpcbiAgICAgIHN0YWdlLnJlZ2lzdGVyUmVuZGVyZXIoJ2ZsYXQnLCAnZmxhdCcsIFdlYkdsRmxhdCk7XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdjdWJlJywgJ3JlY3RpbGluZWFyJywgV2ViR2xDdWJlKTtcbiAgICAgIHN0YWdlLnJlZ2lzdGVyUmVuZGVyZXIoJ2N1YmUrZGVwdGgnLCAncmVjdGlsaW5lYXInLCBXZWJHbEN1YmVEZXB0aCk7XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdlcXVpcmVjdCcsICdyZWN0aWxpbmVhcicsIFdlYkdsRXF1aXJlY3QpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzdGFnZSB0eXBlOiAnICsgc3RhZ2UudHlwZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIJyxcbiAgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDsnLFxuICAnI2Vsc2UnLFxuICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgJyNlbmRpZicsXG5cbiAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICd1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OycsXG4gICd1bmlmb3JtIHZlYzQgdUNvbG9yT2Zmc2V0OycsXG4gICd1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4OycsXG5cbiAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG5cbiAgYFxuICB2b2lkIG1haW4odm9pZCkge1xuICAgIGlmICghZ2xfRnJvbnRGYWNpbmcpIHtcbiAgICAgIGRpc2NhcmQ7IC8vIERpc2NhcmQgdGhlIGZyb250LWZhY2luZyB0cmlhbmdsZXNcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3JNYXRyaXggKyB1Q29sb3JPZmZzZXQ7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYmEgKiB1T3BhY2l0eSk7XG4gICAgfVxuICB9XG4gIGBcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJyNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSCcsXG4ncHJlY2lzaW9uIGhpZ2hwIGZsb2F0OycsXG4nI2Vsc2UnLFxuJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0JyxcbicjZW5kaWYnLFxuXG4ndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7Jyxcbid1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OycsXG4ndW5pZm9ybSBmbG9hdCB1VGV4dHVyZVg7Jyxcbid1bmlmb3JtIGZsb2F0IHVUZXh0dXJlWTsnLFxuJ3VuaWZvcm0gZmxvYXQgdVRleHR1cmVXaWR0aDsnLFxuJ3VuaWZvcm0gZmxvYXQgdVRleHR1cmVIZWlnaHQ7Jyxcbid1bmlmb3JtIHZlYzQgdUNvbG9yT2Zmc2V0OycsXG4ndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDsnLFxuXG4ndmFyeWluZyB2ZWM0IHZSYXk7JyxcblxuJ2NvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDsnLFxuXG4ndm9pZCBtYWluKHZvaWQpIHsnLFxuJyAgZmxvYXQgciA9IGludmVyc2VzcXJ0KHZSYXkueCAqIHZSYXkueCArIHZSYXkueSAqIHZSYXkueSArIHZSYXkueiAqIHZSYXkueik7JyxcbicgIGZsb2F0IHBoaSAgPSBhY29zKHZSYXkueSAqIHIpOycsXG4nICBmbG9hdCB0aGV0YSA9IGF0YW4odlJheS54LCAtMS4wKnZSYXkueik7JyxcbicgIGZsb2F0IHMgPSAwLjUgKyAwLjUgKiB0aGV0YSAvIFBJOycsXG4nICBmbG9hdCB0ID0gMS4wIC0gcGhpIC8gUEk7JyxcblxuJyAgcyA9IHMgKiB1VGV4dHVyZVdpZHRoICsgdVRleHR1cmVYOycsXG4nICB0ID0gdCAqIHVUZXh0dXJlSGVpZ2h0ICsgdVRleHR1cmVZOycsXG5cbicgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIocywgdCkpICogdUNvbG9yTWF0cml4ICsgdUNvbG9yT2Zmc2V0OycsXG4nICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYmEgKiB1T3BhY2l0eSk7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4nI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIJyxcbidwcmVjaXNpb24gaGlnaHAgZmxvYXQ7JyxcbicjZWxzZScsXG4ncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbicjZW5kaWYnLFxuXG4ndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7Jyxcbid1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OycsXG4ndW5pZm9ybSB2ZWM0IHVDb2xvck9mZnNldDsnLFxuJ3VuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG5cbmBcbmlmICghZ2xfRnJvbnRGYWNpbmcpIHtcbiAgZGlzY2FyZDsgLy8gRGlzY2FyZCB0aGUgZnJvbnQtZmFjaW5nIHRyaWFuZ2xlc1xufSBlbHNlIHtcbiAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3JNYXRyaXggKyB1Q29sb3JPZmZzZXQ7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiYSAqIHVPcGFjaXR5KTtcbn1cbmAsXG5cbi8vICcgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yTWF0cml4ICsgdUNvbG9yT2Zmc2V0OycsXG4vLyAnICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYmEgKiB1T3BhY2l0eSk7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247JyxcbiAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcblxuICAndW5pZm9ybSBzYW1wbGVyMkQgdURlcHRobWFwOycsXG4gICd1bmlmb3JtIGZsb2F0IHVEZXB0aDsnLFxuICAndW5pZm9ybSBtYXQ0IHVWaWV3cG9ydE1hdHJpeDsnLFxuICAndW5pZm9ybSBtYXQ0IHVQcm9qTWF0cml4OycsXG4gICd1bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7JyxcbiAgJ3VuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7JyxcblxuICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcblxuICBgXG4gIGZsb2F0IGkoaW4gZmxvYXQgYSwgaW4gZmxvYXQgYikge1xuICAgIHJldHVybiBiID09IDAuMCA/IHNpZ24oYSkqMS41NzA3OTYgOiBhdGFuKGEsIGIpO1xuICB9XG5cbiAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICB2ZWMzIGMgPSBub3JtYWxpemUodmVjMyh1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkpO1xuXG4gICAgZmxvYXQgeCA9ICgxLjAgLSBpKC1jLnosIGMueCkvMy4xNDE1OTMpKjAuNTtcbiAgICBmbG9hdCB5ID0gMC41IC0gaSgtYy55LCBzcXJ0KGMueCpjLnggKyBjLnoqYy56KSkvMy4xNDE1OTM7XG4gICAgdmVjNCBmID0gdGV4dHVyZTJEKHVEZXB0aG1hcCwgdmVjMih4LCB5KSk7XG5cbiAgICBmbG9hdCBqID0gKGYucio2NTUzNi4wICsgZi5nKjI1Ni4wICsgZi5iKS82NTc5My4wO1xuICAgIHZlYzMgYiA9IGMqKDEuMCAtIGopO1xuICAgIHZlYzMgYSA9IHZlYzModVZpZXdNYXRyaXggKiB2ZWM0KGIueiwgYi55LCAtYi54LCAxKSk7XG5cbiAgICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHVQcm9qTWF0cml4ICogdmVjNChhLCAxLjApO1xuICAgIGdsX1Bvc2l0aW9uLnogPSB1RGVwdGggKiBnbF9Qb3NpdGlvbi53O1xuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICB9XG4gIGBcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJ2F0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuXG4ndW5pZm9ybSBmbG9hdCB1RGVwdGg7Jyxcbid1bmlmb3JtIG1hdDQgdVZpZXdwb3J0TWF0cml4OycsXG4ndW5pZm9ybSBtYXQ0IHVJbnZQcm9qTWF0cml4OycsXG5cbid2YXJ5aW5nIHZlYzQgdlJheTsnLFxuXG4ndm9pZCBtYWluKHZvaWQpIHsnLFxuJyAgdlJheSA9IHVJbnZQcm9qTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24ueHksIDEuMCwgMS4wKTsnLFxuJyAgZ2xfUG9zaXRpb24gPSB1Vmlld3BvcnRNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54eSwgdURlcHRoLCAxLjApOycsXG4nfSdcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJ2F0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcblxuJ3VuaWZvcm0gZmxvYXQgdURlcHRoOycsXG4ndW5pZm9ybSBtYXQ0IHVWaWV3cG9ydE1hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1UHJvak1hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG4nICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHVQcm9qTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTsnLFxuJyAgZ2xfUG9zaXRpb24ueiA9IHVEZXB0aCAqIGdsX1Bvc2l0aW9uLnc7JyxcbicgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4nfSdcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCcuLi9OZXR3b3JrRXJyb3InKTtcbnZhciBXb3JrUG9vbCA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL1dvcmtQb29sJyk7XG52YXIgY2hhaW4gPSByZXF1aXJlKCcuLi91dGlsL2NoYWluJyk7XG52YXIgZGVsYXkgPSByZXF1aXJlKCcuLi91dGlsL2RlbGF5Jyk7XG52YXIgbm93ID0gcmVxdWlyZSgnLi4vdXRpbC9ub3cnKTtcblxuXG4vLyBNYXAgdGVtcGxhdGUgcHJvcGVydGllcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHRpbGUgcHJvcGVydGllcy5cbnZhciB0ZW1wbGF0ZVByb3BlcnRpZXMgPSB7XG4gIHg6ICd4JyxcbiAgeTogJ3knLFxuICB6OiAneicsXG4gIGY6ICdmYWNlJ1xufTtcblxuLy8gRGVmYXVsdCBmYWNlIG9yZGVyIGZvciBjdWJlIG1hcHMuXG52YXIgZGVmYXVsdEN1YmVNYXBGYWNlT3JkZXIgPSAnYmRmbHJ1JztcblxuLy8gRGVmYXVsdCBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzLlxudmFyIGRlZmF1bHRDb25jdXJyZW5jeSA9IDQ7XG5cbi8vIERlZmF1bHQgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIGZhaWxlZCByZXF1ZXN0cy5cbnZhciBkZWZhdWx0UmV0cnlEZWxheSA9IDEwMDAwO1xuXG5cbi8qKlxuICogQGNsYXNzIEltYWdlVXJsU291cmNlXG4gKiBAaW1wbGVtZW50cyBTb3VyY2VcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBTb3VyY2V9IHRoYXQgbG9hZHMge0BsaW5rIEFzc2V0IGFzc2V0c30gZnJvbSBpbWFnZXMgZ2l2ZW4gYSBVUkwgYW5kXG4gKiBhIGNyb3AgcmVjdGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvdXJjZUZyb21UaWxlIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB0aWxlIGFuZCByZXR1cm5zXG4gKiBhIGB7IHVybCwgcmVjdCB9YCBvYmplY3QsIHdoZXJlIGB1cmxgIGlzIGFuIGltYWdlIFVSTCBhbmQgYHJlY3RgLCB3aGVuXG4gKiBwcmVzZW50LCBpcyBhbiBgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH1gIG9iamVjdCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzXG4gKiBkZW5vdGluZyB0aGUgcG9ydGlvbiBvZiB0aGUgaW1hZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5jb25jdXJyZW5jeT00XSBNYXhpbXVtIG51bWJlciBvZiB0aWxlcyB0byByZXF1ZXN0IGF0XG4gKiAgICAgdGhlIHNhbWUgdGltZS4gVGhlIGxpbWl0IGlzIHBlciB7QGxpbmsgSW1hZ2VTb3VyY2VVcmx9IGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJldHJ5RGVsYXk9MTAwMDBdIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gKiAgICAgcmV0cnlpbmcgYSBmYWlsZWQgcmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gSW1hZ2VVcmxTb3VyY2Uoc291cmNlRnJvbVRpbGUsIG9wdHMpIHtcblxuICBvcHRzID0gb3B0cyA/IG9wdHMgOiB7fTtcblxuICB0aGlzLl9sb2FkUG9vbCA9IG5ldyBXb3JrUG9vbCh7XG4gICAgY29uY3VycmVuY3k6IG9wdHMuY29uY3VycmVuY3kgfHwgZGVmYXVsdENvbmN1cnJlbmN5XG4gIH0pO1xuXG4gIHRoaXMuX3JldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZGVmYXVsdFJldHJ5RGVsYXk7XG4gIHRoaXMuX3JldHJ5TWFwID0ge307XG5cbiAgdGhpcy5fc291cmNlRnJvbVRpbGUgPSBzb3VyY2VGcm9tVGlsZTtcbn1cblxuZXZlbnRFbWl0dGVyKEltYWdlVXJsU291cmNlKTtcblxuXG5JbWFnZVVybFNvdXJjZS5wcm90b3R5cGUubG9hZEFzc2V0ID0gZnVuY3Rpb24oc3RhZ2UsIHRpbGUsIGRvbmUpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHJldHJ5RGVsYXkgPSB0aGlzLl9yZXRyeURlbGF5O1xuICB2YXIgcmV0cnlNYXAgPSB0aGlzLl9yZXRyeU1hcDtcblxuICB2YXIgdGlsZVNvdXJjZSA9IHRoaXMuX3NvdXJjZUZyb21UaWxlKHRpbGUpO1xuICB2YXIgdXJsID0gdGlsZVNvdXJjZS51cmw7XG4gIHZhciByZWN0ID0gdGlsZVNvdXJjZS5yZWN0O1xuXG4gIHZhciBsb2FkSW1hZ2UgPSBzdGFnZS5sb2FkSW1hZ2UuYmluZChzdGFnZSwgdXJsLCByZWN0KTtcblxuICB2YXIgbG9hZEZuID0gZnVuY3Rpb24oZG9uZSkge1xuICAgIC8vIFRPRE86IERlZHVwbGljYXRlIGxvYWQgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIFVSTC4gQWx0aG91Z2ggdGhlIGJyb3dzZXJcbiAgICAvLyBtaWdodCBiZSBzbWFydCBlbm91Z2ggdG8gYXZvaWQgZHVwbGljYXRlIHJlcXVlc3RzLCB0aGV5IGFyZSBzdGlsbCB1bmR1bHlcbiAgICAvLyBpbXBhY3RlZCBieSB0aGUgY29uY3VycmVuY3kgcGFyYW1ldGVyLlxuICAgIHJldHVybiBzZWxmLl9sb2FkUG9vbC5wdXNoKGxvYWRJbWFnZSwgZnVuY3Rpb24oZXJyLCBhc3NldCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSBuZXR3b3JrIGVycm9yIG9jY3VycmVkLCB3YWl0IGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICByZXRyeU1hcFt1cmxdID0gbm93KCk7XG4gICAgICAgICAgc2VsZi5lbWl0KCduZXR3b3JrRXJyb3InLCBlcnIsIHRpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoZXJyLCB0aWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBmZXRjaCwgZm9yZ2V0IHRoZSBwcmV2aW91cyB0aW1lb3V0LlxuICAgICAgICBkZWxldGUgcmV0cnlNYXBbdXJsXTtcbiAgICAgICAgZG9uZShudWxsLCB0aWxlLCBhc3NldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBhcmUgcmV0cnlpbmcgYSBmYWlsZWQgcmVxdWVzdC5cbiAgdmFyIGRlbGF5QW1vdW50O1xuICB2YXIgbGFzdFRpbWUgPSByZXRyeU1hcFt1cmxdO1xuICBpZiAobGFzdFRpbWUgIT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIHZhciBlbGFwc2VkID0gY3VycmVudFRpbWUgLSBsYXN0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA8IHJldHJ5RGVsYXkpIHtcbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nLlxuICAgICAgZGVsYXlBbW91bnQgPSByZXRyeURlbGF5IC0gZWxhcHNlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cnkgdGltZW91dCBleHBpcmVkOyBwZXJmb3JtIHRoZSByZXF1ZXN0IGF0IG9uY2UuXG4gICAgICBkZWxheUFtb3VudCA9IDA7XG4gICAgICBkZWxldGUgcmV0cnlNYXBbdXJsXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsYXlGbiA9IGRlbGF5LmJpbmQobnVsbCwgZGVsYXlBbW91bnQpO1xuXG4gIHJldHVybiBjaGFpbihkZWxheUZuLCBsb2FkRm4pKGRvbmUpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSW1hZ2VVcmxTb3VyY2UgZnJvbSBhIHN0cmluZyB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRpbGUgVVJMIHRlbXBsYXRlLCB3aGljaCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nXG4gKiAgICBwbGFjZWhvbGRlcnM6XG4gKiAgICAtIGB7Zn1gIDogdGlsZSBmYWNlIChvbmUgb2YgYGJgLCBgZGAsIGBmYCwgYGxgLCBgcmAsIGB1YClcbiAqICAgIC0gYHt6fWAgOiB0aWxlIGxldmVsIGluZGV4ICgwIGlzIHRoZSBzbWFsbGVzdCBsZXZlbClcbiAqICAgIC0gYHt4fWAgOiB0aWxlIGhvcml6b250YWwgaW5kZXhcbiAqICAgIC0gYHt5fWAgOiB0aWxlIHZlcnRpY2FsIGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBJbiBhZGRpdGlvbiB0byB0aGUgb3B0aW9ucyBhbHJlYWR5IHN1cHBvcnRlZCBieSB0aGVcbiAqICAgICB7QGxpbmsgSW1hZ2VVcmxTb3VyY2V9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwgVVJMIHRvIHVzZSBhcyB0aGUgcHJldmlldyBsZXZlbC5cbiAqICAgICBUaGlzIG11c3QgYmUgYSBzaW5nbGUgaW1hZ2UgY29udGFpbmluZyBzaXggY3ViZSBmYWNlcyBsYWlkIG91dFxuICogICAgIHZlcnRpY2FsbHkgYWNjb3JkaW5nIHRvIHRoZSBmYWNlIG9yZGVyIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5jdWJlTWFwUHJldmlld0ZhY2VPcmRlcj0nYmRmbHJ1J10gRmFjZSBvcmRlciB3aXRoaW5cbiAqICAgICB0aGUgcHJldmlldyBpbWFnZS5cbiAqL1xuSW1hZ2VVcmxTb3VyY2UuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHVybCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgZmFjZU9yZGVyID0gb3B0cyAmJiBvcHRzLmN1YmVNYXBQcmV2aWV3RmFjZU9yZGVyIHx8IGRlZmF1bHRDdWJlTWFwRmFjZU9yZGVyO1xuXG4gIHZhciB1cmxGbiA9IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwgPyB3aXRoUHJldmlldyA6IHdpdGhvdXRQcmV2aWV3O1xuXG4gIHJldHVybiBuZXcgSW1hZ2VVcmxTb3VyY2UodXJsRm4sIG9wdHMpO1xuXG4gIGZ1bmN0aW9uIHdpdGhvdXRQcmV2aWV3KHRpbGUpIHtcbiAgICB2YXIgdGlsZVVybCA9IHVybDtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRlbXBsYXRlUHJvcGVydGllcykge1xuICAgICAgdmFyIHRlbXBsYXRlUHJvcGVydHkgPSB0ZW1wbGF0ZVByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgdmFyIHJlZ0V4cCA9IHByb3BlcnR5UmVnRXhwKHByb3BlcnR5KTtcbiAgICAgIHZhciB2YWx1ZUZyb21UaWxlID0gdGlsZS5oYXNPd25Qcm9wZXJ0eSh0ZW1wbGF0ZVByb3BlcnR5KSA/IHRpbGVbdGVtcGxhdGVQcm9wZXJ0eV0gOiAnJztcbiAgICAgIHRpbGVVcmwgPSB0aWxlVXJsLnJlcGxhY2UocmVnRXhwLCB2YWx1ZUZyb21UaWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB1cmw6IHRpbGVVcmwgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhQcmV2aWV3KHRpbGUpIHtcbiAgICBpZiAodGlsZS56ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3ViZU1hcFVybCh0aWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gd2l0aG91dFByZXZpZXcodGlsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3ViZU1hcFVybCh0aWxlKSB7XG4gICAgdmFyIHkgPSBmYWNlT3JkZXIuaW5kZXhPZih0aWxlLmZhY2UpIC8gNjtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiBvcHRzLmN1YmVNYXBQcmV2aWV3VXJsLFxuICAgICAgcmVjdDogeyB4OiAwLCB5OiB5LCB3aWR0aDogMSwgaGVpZ2h0OiAxLzYgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByb3BlcnR5UmVnRXhwKHByb3BlcnR5KSB7XG4gIHZhciByZWdFeHBTdHIgPSAnXFxcXHsoJyArIHByb3BlcnR5ICsgJylcXFxcfSc7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ0V4cFN0ciwgJ2cnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVVybFNvdXJjZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgU2luZ2xlQXNzZXRTb3VyY2VcbiAqIEBpbXBsZW1lbnRzIFNvdXJjZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIFNvdXJjZX0gdGhhdCBhbHdheXMgcHJvdmlkZXMgdGhlIHNhbWUge0BsaW5rIEFzc2V0fS5cbiAqXG4gKiBAcGFyYW0ge0Fzc2V0fSBhc3NldCBUaGUgYXNzZXQuXG4qL1xuZnVuY3Rpb24gU2luZ2xlQXNzZXRTb3VyY2UoYXNzZXQpIHtcbiAgdGhpcy5fYXNzZXQgPSBhc3NldDtcbn1cblxuU2luZ2xlQXNzZXRTb3VyY2UucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hc3NldDtcbn07XG5cblNpbmdsZUFzc2V0U291cmNlLnByb3RvdHlwZS5sb2FkQXNzZXQgPSBmdW5jdGlvbihzdGFnZSwgdGlsZSwgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRvbmUobnVsbCwgdGlsZSwgc2VsZi5fYXNzZXQpO1xuICB9LCAwKTtcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbmdsZUFzc2V0U291cmNlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBSZW5kZXJlclJlZ2lzdHJ5XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBSZW5kZXJlclJlZ2lzdHJ5IG1hcHMgcGFpcnMgb2Yge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9IHR5cGUgaW50b1xuICogdGhlIGFwcHJvcHJpYXRlIHtAbGluayBSZW5kZXJlcn0gY2xhc3MuIEl0IGlzIHVzZWQgYnkgYSB7QGxpbmsgU3RhZ2V9IHRvXG4gKiBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHJlbmRlcmVyIGZvciBhIHtAbGluayBMYXllcn0uXG4gKlxuICogU2VlIGFsc28ge0BsaW5rIFN0YWdlI3JlZ2lzdGVyUmVuZGVyZXJ9LlxuICovXG5mdW5jdGlvbiBSZW5kZXJlclJlZ2lzdHJ5KCkge1xuICB0aGlzLl9yZW5kZXJlcnMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSByZW5kZXJlciBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCB2aWV3IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLlxuICovXG5SZW5kZXJlclJlZ2lzdHJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcikge1xuICBpZiAoIXRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdKSB7XG4gICAgdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV0gPSB7fTtcbiAgfVxuICB0aGlzLl9yZW5kZXJlcnNbZ2VvbWV0cnlUeXBlXVt2aWV3VHlwZV0gPSBSZW5kZXJlcjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSByZW5kZXJlciBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCB2aWV3IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLCBvciBudWxsIGlmIG5vIHN1Y2ggcmVuZGVyZXIgaGFzIGJlZW5cbiAqIHJlZ2lzdGVyZWQuXG4gKi9cblJlbmRlcmVyUmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGdlb21ldHJ5VHlwZSwgdmlld1R5cGUpIHtcbiAgdmFyIFJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV0gJiZcbiAgICAgIHRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdW3ZpZXdUeXBlXTtcbiAgcmV0dXJuIFJlbmRlcmVyIHx8IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyUmVnaXN0cnk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBXb3JrUXVldWUgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9Xb3JrUXVldWUnKTtcbnZhciBjYWxjUmVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvY2FsY1JlY3QnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvYXN5bmMnKTtcbnZhciBjYW5jZWxpemUgPSByZXF1aXJlKCcuLi91dGlsL2NhbmNlbGl6ZScpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBSZW5kZXJlclJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZW5kZXJlclJlZ2lzdHJ5Jyk7XG5cbmZ1bmN0aW9uIGZvcndhcmRUaWxlQ21wKHQxLCB0Mikge1xuICByZXR1cm4gdDEuY21wKHQyKTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVRpbGVDbXAodDEsIHQyKSB7XG4gIHJldHVybiAtdDEuY21wKHQyKTtcbn1cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIHN0YWdlIGhhcyBiZWVuIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhYmxlIFdoZXRoZXIgYWxsIHRpbGVzIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHdpdGhvdXRcbiAqICAgICBtaXNzaW5nIHRleHR1cmVzIG9yIHJlc29ydGluZyB0byBmYWxsYmFja3MuXG4gKiBAZXZlbnQgU3RhZ2UjcmVuZGVyQ29tcGxldGVcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgY29udGVudHMgb2YgdGhlIHN0YWdlIGhhdmUgYmVlbiBpbnZhbGlkYXRlZCBhbmQgbXVzdCBiZVxuICogcmVuZGVyZWQgYWdhaW4uXG4gKlxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSB7QGxpbmsgUmVuZGVyTG9vcH0gaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV2ZW50IFN0YWdlI3JlbmRlckludmFsaWRcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgU3RhZ2VcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFN0YWdlIGlzIGEgY29udGFpbmVyIHdpdGggdGhlIGFiaWxpdHkgdG8gcmVuZGVyIGEgc3RhY2sgb2ZcbiAqIHtAbGluayBMYXllciBsYXllcnN9LlxuICpcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gVXNlIHtAbGluayBXZWJHbFN0YWdlfVxuICogaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wcm9ncmVzc2l2ZT1mYWxzZV1cbiAqXG4gKiBPcHRpb25zIGxpc3RlZCBoZXJlIG1heSBiZSBwYXNzZWQgaW50byB0aGUgYG9wdHNgIGNvbnN0cnVjdG9yIGFyZ3VtZW50IG9mXG4gKiBzdWJjbGFzc2VzLlxuICpcbiAqIFRoZSBgcHJvZ3Jlc3NpdmVgIG9wdGlvbiBjb250cm9scyB3aGV0aGVyIHJlc29sdXRpb24gbGV2ZWxzIGFyZSBsb2FkZWQgaW5cbiAqIG9yZGVyLCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LiBUaGlzIHJlc3VsdHMgaW4gYSBtb3JlIHBsZWFzaW5nIGVmZmVjdCB3aGVuXG4gKiB6b29taW5nIHBhc3Qgc2V2ZXJhbCBsZXZlbHMgaW4gYSBsYXJnZSBwYW5vcmFtYXMsIGJ1dCBjb25zdW1lcyBhZGRpdGlvbmFsXG4gKiBiYW5kd2lkdGguXG4gKi9cbmZ1bmN0aW9uIFN0YWdlKG9wdHMpIHtcbiAgdGhpcy5fcHJvZ3Jlc3NpdmUgPSAhIShvcHRzICYmIG9wdHMucHJvZ3Jlc3NpdmUpO1xuXG4gIC8vIFRoZSBsaXN0IG9mIGxheWVycyBpbiBkaXNwbGF5IG9yZGVyIChiYWNrZ3JvdW5kIHRvIGZvcmVncm91bmQpLlxuICB0aGlzLl9sYXllcnMgPSBbXTtcblxuICAvLyBUaGUgbGlzdCBvZiByZW5kZXJlcnM7IHRoZSBpLXRoIHJlbmRlcmVyIGlzIGZvciB0aGUgaS10aCBsYXllci5cbiAgdGhpcy5fcmVuZGVyZXJzID0gW107XG5cbiAgLy8gVGhlIGxpc3RzIG9mIHRpbGVzIHRvIGxvYWQgYW5kIHJlbmRlciwgcG9wdWxhdGVkIGR1cmluZyByZW5kZXIoKS5cbiAgdGhpcy5fdGlsZXNUb0xvYWQgPSBbXTtcbiAgdGhpcy5fdGlsZXNUb1JlbmRlciA9IFtdO1xuXG4gIC8vIFRlbXBvcmFyeSB0aWxlIGxpc3RzLlxuICB0aGlzLl90bXBWaXNpYmxlID0gW107XG4gIHRoaXMuX3RtcENoaWxkcmVuID0gW107XG5cbiAgLy8gQ2FjaGVkIHN0YWdlIGRpbWVuc2lvbnMuXG4gIC8vIFN0YXJ0IHdpdGggemVybywgd2hpY2ggaW5oaWJpdHMgcmVuZGVyaW5nIHVudGlsIHNldFNpemUoKSBpcyBjYWxsZWQuXG4gIHRoaXMuX3dpZHRoID0gMDtcbiAgdGhpcy5faGVpZ2h0ID0gMDtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHJlY3QuXG4gIHRoaXMuX3RtcFJlY3QgPSB7fTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHNpemUuXG4gIHRoaXMuX3RtcFNpemUgPSB7fTtcblxuICAvLyBXb3JrIHF1ZXVlIGZvciBjcmVhdGVUZXh0dXJlLlxuICB0aGlzLl9jcmVhdGVUZXh0dXJlV29ya1F1ZXVlID0gbmV3IFdvcmtRdWV1ZSgpO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGVtaXQgZXZlbnQgd2hlbiByZW5kZXIgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkID0gdGhpcy5fZW1pdFJlbmRlckludmFsaWQuYmluZCh0aGlzKTtcblxuICAvLyBUaGUgcmVuZGVyZXIgcmVnaXN0cnkgbWFwcyBlYWNoIGdlb21ldHJ5L3ZpZXcgcGFpciBpbnRvIHRoZSByZXNwZWN0aXZlXG4gIC8vIFJlbmRlcmVyIGNsYXNzLlxuICB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5ID0gbmV3IFJlbmRlcmVyUmVnaXN0cnkoKTtcbn1cblxuZXZlbnRFbWl0dGVyKFN0YWdlKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGF5ZXJzKCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB7QGxpbmsgUmVuZGVyZXJ9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9XG4gKiB0eXBlLlxuICpcbiAqIFRoZSB7QGxpbmsgcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzfSB1dGlsaXR5IGZ1bmN0aW9uIG1heSBiZSB1c2VkIHRvXG4gKiByZWdpc3RlciBhbGwga25vd24gcmVuZGVyZXJzIGZvciBhIHN0YWdlIHR5cGUgaW50byB0aGF0IHN0YWdlLiBNb3N0IHVzZXJzXG4gKiB3aWxsIG5vdCBuZWVkIHRvIHJlZ2lzdGVyIHJlbmRlcmVycywgYXMge0BsaW5rIFZpZXdlcn0gZG9lcyBpdCBmb3IgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLlxuICovXG5TdGFnZS5wcm90b3R5cGUucmVnaXN0ZXJSZW5kZXJlciA9IGZ1bmN0aW9uKGdlb21ldHJ5VHlwZSwgdmlld1R5cGUsIFJlbmRlcmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5LnNldChnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqXG4gKiBNdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5TdGFnZS5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgZG9tRWxlbWVudCcpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgc3RhZ2Ugd2lkdGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblN0YWdlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBzdGFnZSBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblN0YWdlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHN0YWdlIGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1NpemU9fSBzaXplXG4gKi9cblN0YWdlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICBzaXplID0gc2l6ZSB8fCB7fTtcbiAgc2l6ZS53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICBzaXplLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzdGFnZSBkaW1lbnNpb25zLlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHNpemUgdXBkYXRlIGxvZ2ljIGNvbW1vbiB0byBhbGwgc3RhZ2UgdHlwZXMuIFN1YmNsYXNzZXNcbiAqIG11c3QgZGVmaW5lIHRoZSB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZUZvclR5cGV9IG1ldGhvZCB0byBwZXJmb3JtIHRoZWlyIG93blxuICogbG9naWMuXG4gKlxuICogQHBhcmFtIHtTaXplfSBzaXplXG4gKi9cblN0YWdlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aGlzLl93aWR0aCA9IHNpemUud2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gIHRoaXMuc2V0U2l6ZUZvclR5cGUoKTsgLy8gbXVzdCBiZSBkZWZpbmVkIGJ5IHN1YmNsYXNzZXMuXG5cbiAgdGhpcy5lbWl0KCdyZXNpemUnKTtcbiAgdGhpcy5fZW1pdFJlbmRlckludmFsaWQoKTtcbn07XG5cblxuLyoqXG4gKiBDYWxsIHtAbGluayBTdGFnZSNzZXRTaXplfSBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHNpemUgdXBkYXRlIGxvZ2ljIHNwZWNpZmljIHRvIGEgc3RhZ2UgdHlwZS4gSXQgaXMgY2FsbGVkIGJ5XG4gKiB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZX0gYWZ0ZXIgdGhlIGJhc2UgY2xhc3MgaGFzIGJlZW4gdXBkYXRlZCB0byByZWZsZWN0IHRoZVxuICogbmV3IHNpemUsIGJ1dCBiZWZvcmUgYW55IGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge1NpemV9IHNpemVcbiAqL1xuU3RhZ2UucHJvdG90eXBlLnNldFNpemVGb3JUeXBlID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgc2V0U2l6ZUZvclR5cGUnKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkcyBhbiB7QGxpbmsgQXNzZXR9IGZyb20gYW4gaW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBpbWFnZSBVUkwuXG4gKiBAcGFyYW0gez9SZWN0fSByZWN0IEEge0BsaW5rIFJlY3R9IGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSwgb3IgbnVsbFxuICogICAgIHRvIHVzZSB0aGUgZnVsbCBpbWFnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCBBc3NldCl9IGRvbmUgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBmdW5jdGlvbiB0byBjYW5jZWwgbG9hZGluZy5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgbG9hZEltYWdlJyk7XG59O1xuXG5cblN0YWdlLnByb3RvdHlwZS5fZW1pdFJlbmRlckludmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdyZW5kZXJJbnZhbGlkJyk7XG59O1xuXG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCB0aGUgbGF5ZXIgaXMgdmFsaWQgZm9yIHRoaXMgc3RhZ2UsIHRocm93aW5nIGFuIGV4Y2VwdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxheWVyIGlzIG5vdCB2YWxpZCBmb3IgdGhpcyBzdGFnZS5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgdmFsaWRhdGVMYXllcicpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBiZWxvbmdpbmcgdG8gdGhlIHN0YWdlLiBUaGVcbiAqIHJldHVybmVkIGxpc3QgaXMgaW4gZGlzcGxheSBvcmRlciwgYmFja2dyb3VuZCB0byBmb3JlZ3JvdW5kLlxuICogQHJldHVybiB7TGF5ZXJbXX1cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmxpc3RMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IHVuaW50ZW5kZWQgbXV0YXRpb24gYnkgdGhlIGNhbGxlci5cbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9sYXllcnMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEge0BsaW5rIExheWVyIGxheWVyfSBiZWxvbmdzIHRvIHRoZSBzdGFnZS5cbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5TdGFnZS5wcm90b3R5cGUuaGFzTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICByZXR1cm4gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpID49IDA7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIHtAbGluayBMYXllciBsYXllcn0gaW50byB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gYWRkLlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBpIFRoZSBvcHRpb25hbCBwb3NpdGlvbiwgd2hlcmUgMCDiiaQgaSDiiaQgbiBhbmQgbiBpc1xuICogICAgIHRoZSBjdXJyZW50IG51bWJlciBvZiBsYXllcnMuIFRoZSBkZWZhdWx0IGlzIG4sIHdoaWNoIGluc2VydHMgYXQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBkaXNwbGF5IHN0YWNrLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgYWxyZWFkeSBiZWxvbmdzIHRvIHRoZSBzdGFnZSBvciBpZiB0aGUgcG9zaXRpb25cbiAqICAgICBpcyBpbnZhbGlkLlxuICovXG5TdGFnZS5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgaSkge1xuICBpZiAodGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheWVyIGFscmVhZHkgaW4gc3RhZ2UnKTtcbiAgfVxuXG4gIGlmIChpID09IG51bGwpIHtcbiAgICBpID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcbiAgfVxuICBpZiAoaSA8IDAgfHwgaSA+IHRoaXMuX2xheWVycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGF5ZXIgcG9zaXRpb24nKTtcbiAgfVxuXG4gIHRoaXMudmFsaWRhdGVMYXllcihsYXllcik7IC8vIG11c3QgYmUgZGVmaW5lZCBieSBzdWJjbGFzc2VzLlxuXG4gIHZhciBnZW9tZXRyeVR5cGUgPSBsYXllci5nZW9tZXRyeSgpLnR5cGU7XG4gIGlmIChsYXllci5kZXB0aG1hcCgpKSB7XG4gICAgZ2VvbWV0cnlUeXBlICs9ICcrZGVwdGgnO1xuICB9XG4gIHZhciB2aWV3VHlwZSA9IGxheWVyLnZpZXcoKS50eXBlO1xuICB2YXIgcmVuZGVyZXJDbGFzcyA9IHRoaXMuX3JlbmRlcmVyUmVnaXN0cnkuZ2V0KGdlb21ldHJ5VHlwZSwgdmlld1R5cGUpO1xuICBpZiAoIXJlbmRlcmVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vICcgKyB0aGlzLnR5cGUgKyAnIHJlbmRlcmVyIGF2YWlhYmxlIGZvciAnICtcbiAgICAgICAgZ2VvbWV0cnlUeXBlICsgJyBnZW9tZXRyeSBhbmQgJyArIHZpZXdUeXBlICsgJyB2aWV3Jyk7XG4gIH1cbiAgdmFyIHJlbmRlcmVyID0gdGhpcy5jcmVhdGVSZW5kZXJlcihyZW5kZXJlckNsYXNzKTtcblxuICB0aGlzLl9sYXllcnMuc3BsaWNlKGksIDAsIGxheWVyKTtcbiAgdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpLCAwLCByZW5kZXJlcik7XG5cbiAgLy8gTGlzdGVuZXJzIGZvciByZW5kZXIgaW52YWxpZC5cbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZWZmZWN0c0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZml4ZWRMZXZlbENoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogTW92ZXMgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGludG8gYSBkaWZmZXJlbnQgcG9zaXRpb24gaW4gdGhlIGRpc3BsYXkgc3RhY2suXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW92ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGlvbiwgd2hlcmUgMCDiiaQgaSDiiaQgbi0xIGFuZCBuIGlzIHRoZSBjdXJyZW50IG51bWJlclxuICogICAgIG9mIGxheWVycy5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxheWVyIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgc3RhZ2Ugb3IgaWYgdGhlIHBvc2l0aW9uXG4gKiAgICAgaXMgaW52YWxpZC5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLm1vdmVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYXllciBpbiBzdGFnZScpO1xuICB9XG5cbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fbGF5ZXJzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsYXllciBwb3NpdGlvbicpO1xuICB9XG5cbiAgbGF5ZXIgPSB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG5cbiAgdGhpcy5fbGF5ZXJzLnNwbGljZShpLCAwLCBsYXllcik7XG4gIHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaSwgMCwgcmVuZGVyZXIpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIHtAbGluayBMYXllcn0gZnJvbSB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gcmVtb3ZlLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzdGFnZS5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGxheWVyIGluIHN0YWdlJyk7XG4gIH1cblxuICB2YXIgcmVtb3ZlZExheWVyID0gdGhpcy5fbGF5ZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG4gIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuXG4gIHRoaXMuZGVzdHJveVJlbmRlcmVyKHJlbmRlcmVyKTtcblxuICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgcmVtb3ZlZExheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lbWl0UmVuZGVySW52YWxpZCk7XG4gIHJlbW92ZWRMYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdmaXhlZExldmVsQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwge0BsaW5rIExheWVyIGxheWVyc30gZnJvbSB0aGUgc3RhZ2UuXG4gKi9cblN0YWdlLnByb3RvdHlwZS5yZW1vdmVBbGxMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuX2xheWVycy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FsbGVkIGJlZm9yZSBhIGZyYW1lIGlzIHJlbmRlcmVkLlxuICpcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICovXG5TdGFnZS5wcm90b3R5cGUuc3RhcnRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgc3RhcnRGcmFtZScpO1xufTtcblxuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIGZyYW1lIGlzIHJlbmRlcmVkLlxuICpcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICovXG5TdGFnZS5wcm90b3R5cGUuZW5kRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIGVuZEZyYW1lJyk7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyIHRoZSBjdXJyZW50IGZyYW1lLiBVc3VhbGx5IGNhbGxlZCBmcm9tIGEge0BsaW5rIFJlbmRlckxvb3B9LlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHJlbmRlcmluZyBsb2dpYyBjb21tb24gdG8gYWxsIHN0YWdlIHR5cGVzLiBTdWJjbGFzc2VzXG4gKiBkZWZpbmUgdGhlIHN0YXJ0RnJhbWUoKSBhbmQgZW5kRnJhbWUoKSBtZXRob2RzIHRvIHBlcmZvcm0gdGhlaXIgb3duIGxvZ2ljLlxuICovXG5TdGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpLCBqO1xuXG4gIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xuICB2YXIgdGlsZXNUb1JlbmRlciA9IHRoaXMuX3RpbGVzVG9SZW5kZXI7XG5cbiAgdmFyIHN0YWJsZVN0YWdlID0gdHJ1ZTtcbiAgdmFyIHN0YWJsZUxheWVyO1xuXG4gIC8vIEdldCB0aGUgc3RhZ2UgZGltZW5zaW9ucy5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgdmFyIHJlY3QgPSB0aGlzLl90bXBSZWN0O1xuICB2YXIgc2l6ZSA9IHRoaXMuX3RtcFNpemU7XG5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXJ0RnJhbWUoKTsgLy8gZGVmaW5lZCBieSBzdWJjbGFzc2VzXG5cbiAgLy8gU2lnbmFsIHN0YXJ0IG9mIGZyYW1lIHRvIHRoZSB0ZXh0dXJlIHN0b3Jlcy5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5zdGFydEZyYW1lKCk7XG4gIH1cblxuICAvLyBSZW5kZXIgbGF5ZXJzLlxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xuICAgIHZhciBlZmZlY3RzID0gbGF5ZXIuZWZmZWN0cygpO1xuICAgIHZhciB2aWV3ID0gbGF5ZXIudmlldygpO1xuICAgIHZhciB0ZXh0dXJlU3RvcmUgPSBsYXllci50ZXh0dXJlU3RvcmUoKTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcnNbaV07XG4gICAgdmFyIGRlcHRoID0gdGhpcy5fbGF5ZXJzLmxlbmd0aCAtIGk7XG4gICAgdmFyIHRpbGUsIHRleHR1cmU7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSByZWN0IGVmZmVjdCBpbnRvIGEgbm9ybWFsaXplZCByZWN0LlxuICAgIC8vIFRPRE86IGF2b2lkIGRvaW5nIHRoaXMgb24gZXZlcnkgZnJhbWUuXG4gICAgY2FsY1JlY3Qod2lkdGgsIGhlaWdodCwgZWZmZWN0cyAmJiBlZmZlY3RzLnJlY3QsIHJlY3QpO1xuXG4gICAgaWYgKHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XG4gICAgICAvLyBTa2lwIHJlbmRlcmluZyBvbiBhIG51bGwgdmlld3BvcnQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgc2l6ZS5cbiAgICBzaXplLndpZHRoID0gcmVjdC53aWR0aCAqIHRoaXMuX3dpZHRoO1xuICAgIHNpemUuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiB0aGlzLl9oZWlnaHQ7XG4gICAgdmlldy5zZXRTaXplKHNpemUpO1xuXG4gICAgLy8gU2lnbmFsIHN0YXJ0IG9mIGxheWVyIHRvIHRoZSByZW5kZXJlci5cbiAgICByZW5kZXJlci5zdGFydExheWVyKGxheWVyLCByZWN0KTtcblxuICAgIC8vIFdlIHJlbmRlciB3aXRoIGJvdGggYWxwaGEgYmxlbmRpbmcgYW5kIGRlcHRoIHRlc3RpbmcgZW5hYmxlZC4gVGh1cywgd2hlblxuICAgIC8vIHJlbmRlcmluZyBhIHN1YnNlcXVlbnQgcGl4ZWwgYXQgdGhlIHNhbWUgbG9jYXRpb24gdGhhbiBhbiBleGlzdGluZyBvbmUsXG4gICAgLy8gdGhlIHN1YnNlcXVlbnQgcGl4ZWwgZ2V0cyBkaXNjYXJkZWQgdW5sZXNzIGl0IGhhcyBzbWFsbGVyIGRlcHRoLCBhbmQgaXNcbiAgICAvLyBvdGhlcndpc2UgY29tcG9zaXRlZCB3aXRoIHRoZSBleGlzdGluZyBwaXhlbC5cbiAgICAvL1xuICAgIC8vIFdoZW4gdXNpbmcgZmFsbGJhY2sgdGlsZXMgdG8gZmlsbCBhIGdhcCBpbiB0aGUgcHJlZmVycmVkIHJlc29sdXRpb25cbiAgICAvLyBsZXZlbCwgd2UgcHJlZmVyIGhpZ2hlciByZXNvbHV0aW9uIGZhbGxiYWNrcyB0byBsb3dlciByZXNvbHV0aW9uIG9uZXMuXG4gICAgLy8gSG93ZXZlciwgd2hlcmUgZmFsbGJhY2tzIG92ZXJsYXAsIHdlIHdhbnQgaGlnaGVyIHJlc29sdXRpb24gb25lcyB0b1xuICAgIC8vIHByZXZhaWwsIGFuZCB3ZSBkb24ndCB3YW50IG11bHRpcGxlIGZhbGxiYWNrcyB0byBiZSBjb21wb3NpdGVkIHdpdGggZWFjaFxuICAgIC8vIG90aGVyLCBhcyB0aGF0IHdvdWxkIHByb2R1Y2UgYSBiYWQgcmVzdWx0IHdoZW4gc2VtaXRyYW5zcGFyZW50IHRleHR1cmVzXG4gICAgLy8gYXJlIGludm9sdmVkLlxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYWNoaWV2ZSB0aGlzIHdpdGhpbiB0aGUgY29uc3RyYWludHMgb2YgYWxwaGEgYmxlbmRpbmcgYW5kXG4gICAgLy8gZGVwdGggdGVzdGluZywgdGhlIGRlcHRoIG9mIGEgdGlsZSBtdXN0IGJlIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gaXRzXG4gICAgLy8gcmVzb2x1dGlvbiwgYW5kIGhpZ2hlci1yZXNvbHV0aW9uIHRpbGVzIG11c3QgYmUgcmVuZGVyZWQgYmVmb3JlIGxvd2VyLVxuICAgIC8vIHJlc29sdXRpb24gb25lcy5cblxuICAgIC8vIENvbGxlY3QgdGhlIGxpc3RzIG9mIHRpbGVzIHRvIGxvYWQgYW5kIHJlbmRlci5cbiAgICBzdGFibGVMYXllciA9IHRoaXMuX2NvbGxlY3RUaWxlcyhsYXllciwgdGV4dHVyZVN0b3JlKTtcblxuICAgIC8vIE1hcmsgYWxsIHRoZSB0aWxlcyB3aG9zZSB0ZXh0dXJlcyBtdXN0IGJlIGxvYWRlZC5cbiAgICAvLyBUaGlzIHdpbGwgZWl0aGVyIHRyaWdnZXIgbG9hZGluZyAoZm9yIHRleHR1cmVzIG5vdCB5ZXQgbG9hZGVkKSBvclxuICAgIC8vIHByZXZlbnQgdW5sb2FkaW5nIChmb3IgdGV4dHVyZXMgYWxyZWFkeSBsb2FkZWQpLlxuICAgIGZvciAoaiA9IDA7IGogPCB0aWxlc1RvTG9hZC5sZW5ndGg7IGorKykge1xuICAgICAgdGlsZSA9IHRpbGVzVG9Mb2FkW2pdO1xuICAgICAgdGV4dHVyZVN0b3JlLm1hcmtUaWxlKHRpbGUpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB0aWxlcy5cbiAgICBmb3IgKGogPSAwOyBqIDwgdGlsZXNUb1JlbmRlci5sZW5ndGg7IGorKykge1xuICAgICAgdGlsZSA9IHRpbGVzVG9SZW5kZXJbal07XG4gICAgICB0ZXh0dXJlID0gdGV4dHVyZVN0b3JlLnRleHR1cmUodGlsZSk7XG4gICAgICByZW5kZXJlci5yZW5kZXJUaWxlKHRpbGUsIHRleHR1cmUsIGxheWVyLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgbGF5ZXIuZW1pdCgncmVuZGVyQ29tcGxldGUnLCBzdGFibGVMYXllcik7XG4gICAgaWYgKCFzdGFibGVMYXllcikge1xuICAgICAgc3RhYmxlU3RhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTaWduYWwgZW5kIG9mIGxheWVyIHRvIHRoZSByZW5kZXJlci5cbiAgICByZW5kZXJlci5lbmRMYXllcihsYXllciwgcmVjdCk7XG4gIH1cblxuICAvLyBTaWduYWwgZW5kIG9mIGZyYW1lIHRvIHRoZSB0ZXh0dXJlIHN0b3Jlcy5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5lbmRGcmFtZSgpO1xuICB9XG5cbiAgdGhpcy5lbmRGcmFtZSgpOyAvLyBkZWZpbmVkIGJ5IHN1YmNsYXNzZXNcblxuICB0aGlzLmVtaXQoJ3JlbmRlckNvbXBsZXRlJywgc3RhYmxlU3RhZ2UpO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0VGlsZXMgPSBmdW5jdGlvbihsYXllciwgdGV4dHVyZVN0b3JlKSB7XG4gIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xuICB2YXIgdGlsZXNUb1JlbmRlciA9IHRoaXMuX3RpbGVzVG9SZW5kZXI7XG4gIHZhciB0bXBWaXNpYmxlID0gdGhpcy5fdG1wVmlzaWJsZTtcblxuICB0aWxlc1RvTG9hZC5sZW5ndGggPSAwO1xuICB0aWxlc1RvUmVuZGVyLmxlbmd0aCA9IDA7XG4gIHRtcFZpc2libGUubGVuZ3RoID0gMDtcblxuICBsYXllci52aXNpYmxlVGlsZXModG1wVmlzaWJsZSk7XG5cbiAgdmFyIGlzU3RhYmxlID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcFZpc2libGUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGlsZSA9IHRtcFZpc2libGVbaV07XG4gICAgdmFyIG5lZWRzRmFsbGJhY2s7XG4gICAgdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSk7XG4gICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XG4gICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgYXZhaWxhYmxlLlxuICAgICAgLy8gTm8gZmFsbGJhY2sgaXMgcmVxdWlyZWQuXG4gICAgICBuZWVkc0ZhbGxiYWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9jb2xsZWN0VGlsZVRvUmVuZGVyKHRpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgdW5hdmFpbGFibGUuXG4gICAgICAvLyBDb2xsZWN0IGNoaWxkcmVuIGZvciByZW5kZXJpbmcgYXMgYSBmYWxsYmFjay5cbiAgICAgIG5lZWRzRmFsbGJhY2sgPSB0aGlzLl9jb2xsZWN0Q2hpbGRyZW4odGlsZSwgdGV4dHVyZVN0b3JlKTtcbiAgICAgIGlzU3RhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENvbGxlY3QgYWxsIHBhcmVudHMgZm9yIGxvYWRpbmcsIGFuZCB0aGUgY2xvc2VzdCBwYXJlbnQgZm9yIHJlbmRlcmluZyBpZlxuICAgIC8vIGEgZmFsbGJhY2sgaXMgcmVxdWlyZWQuXG4gICAgdGhpcy5fY29sbGVjdFBhcmVudHModGlsZSwgdGV4dHVyZVN0b3JlLCBuZWVkc0ZhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNvcnQgdGlsZXMgdG8gbG9hZCBpbiBhc2NlbmRpbmcgcmVzb2x1dGlvbiBvcmRlci5cbiAgdGlsZXNUb0xvYWQuc29ydChmb3J3YXJkVGlsZUNtcCk7XG5cbiAgLy8gU29ydCB0aWxlcyB0byByZW5kZXIgaW4gZGVzY2VuZGluZyByZXNvbHV0aW9uIG9yZGVyLlxuICB0aWxlc1RvUmVuZGVyLnNvcnQocmV2ZXJzZVRpbGVDbXApO1xuXG4gIHJldHVybiBpc1N0YWJsZTtcbn07XG5cblN0YWdlLnByb3RvdHlwZS5fY29sbGVjdENoaWxkcmVuID0gZnVuY3Rpb24odGlsZSwgdGV4dHVyZVN0b3JlKSB7XG4gIHZhciB0bXBDaGlsZHJlbiA9IHRoaXMuX3RtcENoaWxkcmVuO1xuXG4gIHZhciBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcblxuICAvLyBGYWxsIGJhY2sgYXMgbWFueSBsZXZlbHMgYXMgbmVjZXNzYXJ5IG9uIHNpbmdsZS1jaGlsZCBnZW9tZXRyaWVzLCBidXQgZG9cbiAgLy8gbm90IGdvIGJleW9uZCBpbW1lZGlhdGUgY2hpbGRyZW4gb24gbXVsdGlwbGUtY2hpbGQgZ2VvbWV0cmllcywgdG8gYXZvaWRcbiAgLy8gZXhwbG9yaW5nIGFuIGV4cG9uZW50aWFsIG51bWJlciBvZiB0aWxlcy5cbiAgZG8ge1xuICAgIHRtcENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaWYgKCF0aWxlLmNoaWxkcmVuKHRtcENoaWxkcmVuKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aWxlID0gdG1wQ2hpbGRyZW5baV07XG4gICAgICBpZiAodGV4dHVyZVN0b3JlLnRleHR1cmUodGlsZSkpIHtcbiAgICAgICAgdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSk7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5lZWRzRmFsbGJhY2sgJiYgdG1wQ2hpbGRyZW4ubGVuZ3RoID09PSAxKVxuXG4gIHJldHVybiBuZWVkc0ZhbGxiYWNrO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0UGFyZW50cyA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmVTdG9yZSwgbmVlZHNGYWxsYmFjaykge1xuICAvLyBSZWN1cnNpdmVseSB2aXNpdCBwYXJlbnQgdGlsZXMgdW50aWw6XG4gIC8vICAgLSBhbGwgcGFyZW50cyBoYXZlIGJlZW4gbWFya2VkIGZvciBsb2FkaW5nLCBpZiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXNcbiAgLy8gICAgIGVuYWJsZWQ7IGFuZFxuICAvLyAgIC0gYXQgbGVhc3Qgb25lIHBhcmVudCBoYXMgYmVlbiBtYXJrZWQgZm9yIGJvdGggbG9hZGluZyBhbmQgcmVuZGVyaW5nLCBpZlxuICAvLyAgICAgYSBmYWxsYmFjayBpcyByZXF1aXJlZC5cbiAgdmFyIG5lZWRzTG9hZGluZyA9IHRoaXMuX3Byb2dyZXNzaXZlO1xuICB3aGlsZSAoKG5lZWRzTG9hZGluZyB8fCBuZWVkc0ZhbGxiYWNrKSAmJiAodGlsZSA9IHRpbGUucGFyZW50KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmVlZHNGYWxsYmFjaykge1xuICAgICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XG4gICAgICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3Byb2dyZXNzaXZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2NvbGxlY3RUaWxlVG9Mb2FkKHRpbGUpKSB7XG4gICAgICBuZWVkc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWRzRmFsbGJhY2s7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9Mb2FkID0gZnVuY3Rpb24odGlsZSkge1xuICByZXR1cm4gdGhpcy5fY29sbGVjdFRpbGVJbnRvTGlzdCh0aWxlLCB0aGlzLl90aWxlc1RvTG9hZCk7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9SZW5kZXIgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHJldHVybiB0aGlzLl9jb2xsZWN0VGlsZUludG9MaXN0KHRpbGUsIHRoaXMuX3RpbGVzVG9SZW5kZXIpO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0VGlsZUludG9MaXN0ID0gZnVuY3Rpb24odGlsZSwgdGlsZUxpc3QpIHtcbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2hldGhlciBpdCdzIHdvcnRoIGl0IHRvIG1ha2UgdGhpcyBiZXR0ZXIgdGhhbiBPKG7CsikuXG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRpbGUuZXF1YWxzKHRpbGVMaXN0W2ldKSkge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghZm91bmQpIHtcbiAgICB0aWxlTGlzdC5wdXNoKHRpbGUpO1xuICB9XG4gIHJldHVybiAhZm91bmQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgZm9yIHRoZSBnaXZlbiB0aWxlIGFuZCBhc3NldC4gQ2FsbGVkIGJ5IHtAbGluayBUZXh0dXJlU3RvcmV9LlxuICogQHBhcmFtIHtUaWxlfSB0aWxlXG4gKiBAcGFyYW0ge0Fzc2V0fSBhc3NldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5TdGFnZS5wcm90b3R5cGUuY3JlYXRlVGV4dHVyZSA9IGZ1bmN0aW9uKHRpbGUsIGFzc2V0LCBkb25lKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG1ha2VUZXh0dXJlKCkge1xuICAgIHJldHVybiBuZXcgc2VsZi5UZXh0dXJlQ2xhc3Moc2VsZiwgdGlsZSwgYXNzZXQpO1xuICB9XG5cbiAgdmFyIGZuID0gY2FuY2VsaXplKGFzeW5jKG1ha2VUZXh0dXJlKSk7XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVRleHR1cmVXb3JrUXVldWUucHVzaChmbiwgZnVuY3Rpb24oZXJyLCB0ZXh0dXJlKSB7XG4gICAgZG9uZShlcnIsIHRpbGUsIGFzc2V0LCB0ZXh0dXJlKTtcbiAgfSk7XG5cbn07XG5cbi8qKlxuICogVGhlIHN0YWdlIHR5cGUsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJlciBmb3IgYSBnaXZlblxuICogZ2VvbWV0cnkgYW5kIHZpZXcuXG4gKlxuICogVGhlIHNvbGUga25vd24gdmFsdWUgaXMgYFwid2ViZ2xcIi5cbiAqXG4gKiBTZWUgYWxzbyB7QGxpbmsgU3RhZ2UjcmVnaXN0ZXJSZW5kZXJlcn0uXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9XG4gKiBAbmFtZSBTdGFnZSN0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGFnZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0YWdlID0gcmVxdWlyZSgnLi9TdGFnZScpO1xudmFyIEh0bWxJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uL2xvYWRlcnMvSHRtbEltYWdlJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcbnZhciBpc3BvdCA9IHJlcXVpcmUoJy4uL3V0aWwvaXNwb3QnKTtcbnZhciBzZXRBYnNvbHV0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0QWJzb2x1dGU7XG52YXIgc2V0RnVsbFNpemUgPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldEZ1bGxTaXplO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8vIFRPRE8odGpncSk6IFVuaWZ5IFN0YWdlIGFuZCBXZWJHbFN0YWdlLlxuXG4vLyBCcm93c2VyLXNwZWNpZmljIHdvcmthcm91bmRzLlxudmFyIGJyb3dzZXJRdWlya3MgPSB7XG4gIC8vIFdoZXRoZXIgdG8gdXNlIHRleEltYWdlMkQgaW5zdGVhZCBvZiB0ZXhTdWJJbWFnZTJEIHdoZW4gcmVwYWludGluZyBhblxuICAvLyBleGlzdGluZyB0ZXh0dXJlIGZyb20gYSB2aWRlbyBlbGVtZW50LiBPbiBtb3N0IGJyb3dzZXJzIHRleFN1YkltYWdlMkQgaXNcbiAgLy8gZmFzdGVyLCBidXQgb24gQ2hyb21lIHRoZSBwZXJmb3JtYW5jZSBkZWdyYWRlcyBzaWduaWZpY2FudGx5LiBTZWU6XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYxMjU0MlxuICB2aWRlb1VzZVRleEltYWdlMkQ6IGJyb3dzZXIuY2hyb21lXG59O1xuXG5cbmZ1bmN0aW9uIGluaXRXZWJHbENvbnRleHQoY2FudmFzLCBvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIGFscGhhOiB0cnVlLFxuICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgICBhbnRpYWxpYXM6ICEhKG9wdHMgJiYgb3B0cy5hbnRpYWxpYXMpLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogISEob3B0cyAmJiBvcHRzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcilcbiAgfTtcblxuICB2YXIgZ2wgPSAoY2FudmFzLmdldENvbnRleHQpICYmIChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucykpO1xuXG4gIGlmICghZ2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgV2ViR0wgY29udGV4dCcpO1xuICB9XG5cbiAgaWYgKG9wdHMud3JhcENvbnRleHQpIHtcbiAgICBnbCA9IG9wdHMud3JhcENvbnRleHQoZ2wpO1xuICB9XG5cbiAgcmV0dXJuIGdsO1xufVxuXG4vKipcbiAqIEBjbGFzcyBXZWJHbFN0YWdlXG4gKiBAZXh0ZW5kcyBTdGFnZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIFN0YWdlfSBpbXBsZW1lbnRhdGlvbiB1c2luZyBXZWJHbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5hbnRpYWxpYXM9ZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZ2VuZXJhdGVNaXBtYXBzPWZhbHNlXVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdHMud3JhcENvbnRleHRdXG4gKlxuICogVGhlIGBhbnRpYWxpYXNgIGFuZCBgcHJlc2VydmVEcmF3aW5nQnVmZmVyYCBvcHRpb25zIGNvbnRyb2wgdGhlIFdlYkdMXG4gKiBjb250ZXh0IGF0dHJpYnV0ZXMgb2YgdGhlIHNhbWUgbmFtZS4gVGhlIGBhbHBoYWAgYW5kIGBwcmVtdWx0aXBsaWVkQWxwaGFgXG4gKiBXZWJHTCBjb250ZXh0IGF0dHJpYnV0ZXMgYXJlIHNldCB0byB0aGVpciBkZWZhdWx0IHRydWUgdmFsdWUgYW5kIGNhbm5vdFxuICogYmUgb3ZlcnJpZGVuOyB0aGlzIGFsbG93cyBzZW1pdHJhbnNwYXJlbnQgdGV4dHVyZXMgdG8gYmUgY29tcG9zaXRlZCB3aXRoXG4gKiB0aGUgcGFnZS4gU2VlOlxuICogaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvMS4wLyNXRUJHTENPTlRFWFRBVFRSSUJVVEVTXG4gKlxuICogVGhlIGBnZW5lcmF0ZU1pcG1hcHNgIG9wdGlvbiBjb250cm9scyB0ZXh0dXJlIG1pcG1hcCBnZW5lcmF0aW9uLiBNaXBtYXBzXG4gKiBtYXkgaW1wcm92ZSByZW5kZXJpbmcgcXVhbGl0eSwgYXQgdGhlIGNvc3Qgb2YgaW5jcmVhc2VkIG1lbW9yeSB1c2FnZS5cbiAqIER1ZSB0byB0ZWNobmljYWwgbGltaXRhdGlvbnMsIHRoZXkgYXJlIG9ubHkgZ2VuZXJhdGVkIGZvciB0ZXh0dXJlcyB3aG9zZVxuICogZGltZW5zaW9ucyBhcmUgYSBwb3dlciBvZiB0d28uIFNlZTpcbiAqIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3dlYmdsL3dpa2kvV2ViR0xfYW5kX09wZW5HTF9EaWZmZXJlbmNlcyNOb24tUG93ZXJfb2ZfVHdvX1RleHR1cmVfU3VwcG9ydFxuICpcbiAqIFRoZSBgd3JhcENvbnRleHRgIG9wdGlvbiBpcyBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYW5kIHJldHVybnMgYVxuICogV2ViR0xSZW5kZXJpbmdDb250ZXh0LiBUaGUgc3RhZ2Ugd2lsbCB1c2UgaXRzIHJldHVybiB2YWx1ZSBhcyB0aGUgY29udGV4dC5cbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNlZCB0b2dldGhlciB3aXRoIFdlYkdMRGVidWdVdGlscyB0byBkZWJ1ZyBXZWJHTCBpc3N1ZXMuXG4gKiBTZWUgaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvd2ViZ2wvd2lraS9EZWJ1Z2dpbmcuXG4gKlxuICogQWxzbyBzZWUgdGhlIGF2YWlsYWJsZSB7QGxpbmsgU3RhZ2V9IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIFdlYkdsU3RhZ2Uob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLl9nZW5lcmF0ZU1pcG1hcHMgPSBvcHRzLmdlbmVyYXRlTWlwbWFwcyAhPSBudWxsID9cbiAgICBvcHRzLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuXG4gIHRoaXMuX2xvYWRlciA9IG5ldyBIdG1sSW1hZ2VMb2FkZXIodGhpcyk7XG5cbiAgdGhpcy5fZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gIHNldEFic29sdXRlKHRoaXMuX2RvbUVsZW1lbnQpO1xuICBzZXRGdWxsU2l6ZSh0aGlzLl9kb21FbGVtZW50KTtcblxuICB0aGlzLl9nbCA9IGluaXRXZWJHbENvbnRleHQodGhpcy5fZG9tRWxlbWVudCwgb3B0cyk7XG5cbiAgdGhpcy5faGFuZGxlQ29udGV4dExvc3MgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ3dlYmdsY29udGV4dGxvc3QnKTtcbiAgICBzZWxmLl9nbCA9IG51bGw7XG4gIH07XG5cbiAgLy8gSGFuZGxlIFdlYkdsIGNvbnRleHQgbG9zcy5cbiAgdGhpcy5fZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5faGFuZGxlQ29udGV4dExvc3MpO1xuXG4gIC8vIFdlYkdsIHJlbmRlcmVycyBhcmUgc2luZ2xldG9ucyBmb3IgYSBnaXZlbiBzdGFnZS4gVGhpcyBsaXN0IHN0b3JlcyB0aGVcbiAgLy8gZXhpc3RpbmcgcmVuZGVyZXJzIHNvIHRoZXkgY2FuIGJlIHJldXNlZCBhY3Jvc3MgbGF5ZXJzIHdpdGggdGhlIHNhbWVcbiAgLy8gZ2VvbWV0cnkgYW5kIHZpZXcgdHlwZS5cbiAgdGhpcy5fcmVuZGVyZXJJbnN0YW5jZXMgPSBbXTtcblxuICAvLyBXaWR0aCBhbmQgSGVpZ2h0IHNlZ21lbnRzIGZvciBkZXB0aG1hcCBtZXNoLlxuICB0aGlzLl93aWR0aFNlZ21lbnRzID0gb3B0cy53aWR0aFNlZ21lbnRzID8gb3B0cy53aWR0aFNlZ21lbnRzIDogdW5kZWZpbmVkO1xuICB0aGlzLl9oZWlnaHRTZWdtZW50cyA9IG9wdHMuaGVpZ2h0U2VnbWVudHMgPyBvcHRzLmhlaWdodFNlZ21lbnRzIDogdW5kZWZpbmVkO1xufVxuXG5pbmhlcml0cyhXZWJHbFN0YWdlLCBTdGFnZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2hhbmRsZUNvbnRleHRMb3NzKTtcbiAgLy8gRGVsZWdhdGUgY2xlYXJpbmcgb3duIHByb3BlcnRpZXMgdG8gdGhlIFN0YWdlIGRlc3RydWN0b3IuXG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5kb21FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kb21FbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0IH1cbiAqL1xuV2ViR2xTdGFnZS5wcm90b3R5cGUud2ViR2xDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nbDtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUuc2V0U2l6ZUZvclR5cGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZS5cbiAgLy9cbiAgLy8gVGhlIHNpemUgaXMgb2J0YWluZWQgYnkgdGFraW5nIHRoZSBzdGFnZSBkaW1lbnNpb25zLCB3aGljaCBhcmUgc2V0IGluIENTU1xuICAvLyBwaXhlbHMsIGFuZCBtdWx0aXBseWluZyB0aGVtIGJ5IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uIENydWNpYWxseSwgdGhpc1xuICAvLyBtdXN0IGJlIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHRoZSBXZWJHTCByZW5kZXJpbmcgcGlwZWxpbmUgYWNjZXNzZXMgdGhlXG4gIC8vIHBpeGVsIHJhdGlvOyBzdWJzZXF1ZW50IHVzZXMgc2hvdWxkIHJlZmVyZW5jZSB0aGUgYGRyYXdpbmdCdWZmZXJXaWR0aGAgYW5kXG4gIC8vIGBkcmF3aW5nQnVmZmVySGVpZ2h0YCBwcm9wZXJ0aWVzIG9uIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuIEZhaWxpbmcgdG9cbiAgLy8gZG8gc28gd2lsbCBicmVhayB0aGUgcmVuZGVyaW5nIGlmIHRoZSBwaXhlbCByYXRpbyBjaGFuZ2VzIGJ1dCB0aGUgc3RhZ2VcbiAgLy8gc2l6ZSBkb2VzIG5vdCwgZS5nLiB3aGVuIG1vdmluZyB0aGUgd2luZG93IGFjcm9zcyBzY3JlZW5zLlxuICB2YXIgcmF0aW8gPSBwaXhlbFJhdGlvKCk7XG4gIHRoaXMuX2RvbUVsZW1lbnQud2lkdGggPSByYXRpbyAqIHRoaXMuX3dpZHRoO1xuICB0aGlzLl9kb21FbGVtZW50LmhlaWdodCA9IHJhdGlvICogdGhpcy5faGVpZ2h0O1xufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIHJlY3QsIGRvbmUpIHtcbiAgcmV0dXJuIHRoaXMuX2xvYWRlci5sb2FkSW1hZ2UodXJsLCByZWN0LCBkb25lKTtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUubWF4VGV4dHVyZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVEVYVFVSRV9TSVpFKTtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUudmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHZhciB0aWxlU2l6ZSA9IGxheWVyLmdlb21ldHJ5KCkubWF4VGlsZVNpemUoKTtcbiAgdmFyIG1heFRleHR1cmVTaXplID0gdGhpcy5tYXhUZXh0dXJlU2l6ZSgpO1xuICBpZiAodGlsZVNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTGF5ZXIgaGFzIGxldmVsIHdpdGggdGlsZSBzaXplIGxhcmdlciB0aGFuIG1heGltdW0gdGV4dHVyZSBzaXplICgnICsgdGlsZVNpemUgKyAnIHZzLiAnICsgbWF4VGV4dHVyZVNpemUgKyAnKScpO1xuICB9XG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24oUmVuZGVyZXIpIHtcbiAgdmFyIHJlbmRlcmVySW5zdGFuY2VzID0gdGhpcy5fcmVuZGVyZXJJbnN0YW5jZXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVuZGVyZXJJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVuZGVyZXJJbnN0YW5jZXNbaV0gaW5zdGFuY2VvZiBSZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHJlbmRlcmVySW5zdGFuY2VzW2ldO1xuICAgIH1cbiAgfVxuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIodGhpcy5fZ2wsIHtcbiAgICB3aWR0aFNlZ21lbnRzOiB0aGlzLl93aWR0aFNlZ21lbnRzLFxuICAgIGhlaWdodFNlZ21lbnRzOiB0aGlzLl9oZWlnaHRTZWdtZW50c1xuICB9KTtcbiAgcmVuZGVyZXJJbnN0YW5jZXMucHVzaChyZW5kZXJlcik7XG4gIHJldHVybiByZW5kZXJlcjtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUuZGVzdHJveVJlbmRlcmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgdmFyIHJlbmRlcmVySW5zdGFuY2VzID0gdGhpcy5fcmVuZGVyZXJJbnN0YW5jZXM7XG4gIGlmICh0aGlzLl9yZW5kZXJlcnMuaW5kZXhPZihyZW5kZXJlcikgPCAwKSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIHZhciBpbmRleCA9IHJlbmRlcmVySW5zdGFuY2VzLmluZGV4T2YocmVuZGVyZXIpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZW5kZXJlckluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5zdGFydEZyYW1lID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdsID0gdGhpcy5fZ2w7XG5cbiAgaWYgKCFnbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIFdlYkdMIGNvbnRleHQgLSBtYXliZSBjb250ZXh0IHdhcyBsb3N0PycpO1xuICB9XG5cbiAgLy8gU2V0IHRoZSBXZWJHTCB2aWV3cG9ydC5cbiAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblxuICAvLyBDbGVhciBmcmFtZWJ1ZmZlci5cbiAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgLy8gRW5hYmxlIGRlcHRoIHRlc3RpbmcuXG4gIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcblxuICAvLyBFbmFibGUgYmxlbmRpbmcuIE9ORSBhbmQgT05FX01JTlVTX1NSQ19BTFBIQSBhcmUgdGhlIHJpZ2h0IGNob2ljZXMgZm9yXG4gIC8vIHByZW11bHRpcGxpZWQgdGV4dHVyZXMuXG4gIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24oKSB7fTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS50YWtlU25hcHNob3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgLy8gVmFsaWRhdGUgcGFzc2VkIGFyZ3VtZW50XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHk7XG5cbiAgLy8gU2V0IGRlZmF1bHQgcXVhbGl0eSBpZiBpdCBpcyBub3QgcGFzc2VkXG4gIGlmICh0eXBlb2YgcXVhbGl0eSA9PSAndW5kZWZpbmVkJykge1xuICAgIHF1YWxpdHkgPSA3NTtcbiAgfVxuXG4gIC8vIFRocm93IGlmIHF1YWxpdHkgaXMgb2YgaW52bGlkIHR5cGUgb3Igb3V0IG9mIGJvdW5kc1xuICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICdudW1iZXInIHx8IHF1YWxpdHkgPCAwIHx8IHF1YWxpdHkgPiAxMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMU3RhZ2U6IFNuYXBzaG90IHF1YWxpdHkgbmVlZHMgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAnKTtcbiAgfVxuXG4gIC8vIENhbnZhcyBtZXRob2QgXCJ0b0RhdGFVUkxcIiBuZWVkcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNhbWVcbiAgLy8gY29udGV4dCBhcyB3aGVyZSB0aGUgYWN0dWFsIHJlbmRlcmluZyBpcyBkb25lLiBIZW5jZSB0aGlzLlxuICB0aGlzLnJlbmRlcigpO1xuXG4gIC8vIFJldHVybiB0aGUgc25hcHNob3RcbiAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSAvIDEwMCk7XG59XG5cblxuV2ViR2xTdGFnZS50eXBlID0gV2ViR2xTdGFnZS5wcm90b3R5cGUudHlwZSA9ICd3ZWJnbCc7XG5cblxuZnVuY3Rpb24gV2ViR2xUZXh0dXJlKHN0YWdlLCB0aWxlLCBhc3NldCkge1xuICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuICB0aGlzLl9nbCA9IHN0YWdlLl9nbDtcbiAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gIHRoaXMuX3RpbWVzdGFtcCA9IG51bGw7XG4gIHRoaXMuX3dpZHRoID0gdGhpcy5faGVpZ2h0ID0gbnVsbDtcbiAgdGhpcy5yZWZyZXNoKHRpbGUsIGFzc2V0KTtcbn1cblxuXG5XZWJHbFRleHR1cmUucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbih0aWxlLCBhc3NldCkge1xuXG4gIHZhciBnbCA9IHRoaXMuX2dsO1xuICB2YXIgc3RhZ2UgPSB0aGlzLl9zdGFnZTtcbiAgdmFyIHRleHR1cmU7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgdGV4dHVyZSBuZWVkcyB0byBiZSB1cGRhdGVkLlxuICB2YXIgdGltZXN0YW1wID0gYXNzZXQudGltZXN0YW1wKCk7XG4gIGlmICh0aW1lc3RhbXAgPT09IHRoaXMuX3RpbWVzdGFtcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEdldCBhc3NldCBlbGVtZW50LlxuICB2YXIgZWxlbWVudCA9IGFzc2V0LmVsZW1lbnQoKTtcblxuICAvLyBHZXQgYXNzZXQgZGltZW5zaW9ucy5cbiAgdmFyIHdpZHRoID0gYXNzZXQud2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IGFzc2V0LmhlaWdodCgpO1xuXG4gIGlmICh3aWR0aCAhPT0gdGhpcy5fd2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpIHtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlZnJlc2gsIGNyZWF0ZVxuICAgIC8vIGEgbmV3IHRleHR1cmUgd2l0aCB0aGUgY29ycmVjdCBzaXplLlxuXG4gICAgLy8gQ2hlY2sgaWYgdGV4dHVyZSBkaW1lbnNpb25zIHdvdWxkIGV4Y2VlZCB0aGUgbWF4aW11bSB0ZXh0dXJlIHNpemUuXG4gICAgdmFyIG1heFNpemUgPSBzdGFnZS5tYXhUZXh0dXJlU2l6ZSgpO1xuICAgIGlmICh3aWR0aCA+IG1heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSB3aWR0aCBsYXJnZXIgdGhhbiBtYXggc2l6ZSAoJyArIHdpZHRoICsgJyB2cy4gJyArIG1heFNpemUgKyAnKScpO1xuICAgIH1cbiAgICBpZiAoaGVpZ2h0ID4gbWF4U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIGhlaWdodCBsYXJnZXIgdGhhbiBtYXggc2l6ZSAoJyArIGhlaWdodCArICcgdnMuICcgKyBtYXhTaXplICsgJyknKTtcbiAgICB9XG5cbiAgICAvLyBEZWxldGUgdGhlIGN1cnJlbnQgdGV4dHVyZSBpZiBpdCBleGlzdHMuXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIENocm9tZSBvbiBBbmRyb2lkLiBJZiBpdCBpc24ndCBkb25lIHRoZSB0ZXh0dXJlc1xuICAgIC8vIGRvIG5vdCByZW5kZXIgd2hlbiB0aGUgc2l6ZSBjaGFuZ2VzLlxuICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cblxuICAgIC8vIFRoZSB0ZXh0dXJlIG11c3QgYmUgcHJlbXVsdGlwbGllZCBieSBhbHBoYSB0byBlbnN1cmUgY29ycmVjdCBibGVuZGluZyBvZlxuICAgIC8vIHNlbWl0cmFuc3BhcmVudCB0ZXh0dXJlcy4gRm9yIGRldGFpbHMsIHNlZTpcbiAgICAvLyBodHRwOi8vd3d3LnJlYWx0aW1lcmVuZGVyaW5nLmNvbS9ibG9nL2dwdXMtcHJlZmVyLXByZW11bHRpcGxpY2F0aW9uL1xuICAgIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcblxuICB9IGVsc2Uge1xuXG4gICAgLy8gSWYgdGhlIHRleHR1cmUgZGltZW5zaW9ucyByZW1haW4gdGhlIHNhbWUsIHJlcGFpbnQgdGhlIGV4aXN0aW5nIHRleHR1cmUuXG4gICAgLy8gUmVwYWludGluZyB3aXRoIHRleFN1YkltYWdlMkQgaXMgdXN1YWxseSBmYXN0ZXIgdGhhbiB3aXRoIHRleEltYWdlMkQsXG4gICAgLy8gZXhjZXB0IGluIHRoZSBjYXNlIG5vdGVkIGluIGJyb3dzZXJRdWlya3MuXG5cbiAgICB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIGJyb3dzZXJRdWlya3MudmlkZW9Vc2VUZXhJbWFnZTJEKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGVsZW1lbnQpO1xuICAgIH1cblxuICB9XG5cbiAgLy8gR2VuZXJhdGUgbWlwbWFwIGlmIHRoZSBjb3JyZXNwb25kaW5nIHN0YWdlIG9wdGlvbiBpcyBzZXQgYW5kIHRoZSB0ZXh0dXJlXG4gIC8vIGRpbWVuc2lvbnMgYXJlIHBvd2VycyBvZiB0d28uXG4gIGlmIChzdGFnZS5fZ2VuZXJhdGVNaXBtYXBzICYmIGlzcG90KHdpZHRoKSAmJiBpc3BvdChoZWlnaHQpKSB7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKTtcbiAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgfSBlbHNlIHtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgfVxuXG4gIC8vIENsYW1wIHRleHR1cmUgdG8gZWRnZXMuXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAvLyBVbmJpbmQgdGV4dHVyZS5cbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cbiAgLy8gVXBkYXRlIHRleHR1cmUgZGltZW5zaW9ucyBhbmQgdGltZXN0YW1wLlxuICB0aGlzLl90aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxufTtcblxuXG5XZWJHbFRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICB0aGlzLl9nbC5kZWxldGVUZXh0dXJlKHRoaXMuX3RleHR1cmUpO1xuICB9XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuV2ViR2xTdGFnZS5UZXh0dXJlQ2xhc3MgPSBXZWJHbFN0YWdlLnByb3RvdHlwZS5UZXh0dXJlQ2xhc3MgPSBXZWJHbFRleHR1cmU7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbFN0YWdlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUcmFuc2Zvcm0gYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIGFuIGFzeW5jaHJvbm91cyBvbmUuXG5mdW5jdGlvbiBhc3luYyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gYXN5bmNlZChkb25lKSB7XG4gICAgdmFyIGVyciwgcmV0O1xuICAgIHRyeSB7XG4gICAgICByZXQgPSBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZG9uZShlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZShudWxsLCByZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBSZWN0U3BlY30gaW50byBhbiBlcXVpdmFsZW50IHtAbGluayBSZWN0fS5cbiAqXG4gKiBBIHtAbGluayBSZWN0U3BlY30gaXMgYSBjb252ZW5pZW50IHVzZXIgQVBJIGZvcm1hdCwgcHJvdmlkaW5nIGRlZmF1bHQgdmFsdWVzXG4gKiBhbmQgdGhlIGZsZXhpYmlsaXR5IG9mIHNwZWNpZnlpbmcgYWJzb2x1dGUsIHJlbGF0aXZlIG9yIG1peGVkIGRpbWVuc2lvbnMuXG4gKlxuICogQSB7QGxpbmsgUmVjdH0gaXMgYSBtb3JlIGNvbnZlbmllbnQgZm9ybWF0IGZvciB0aGUgcmVuZGVyaW5nIHBpcGVsaW5lLiBJdCBpc1xuICogYWx3YXlzIGV4cHJlc3NlZCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzLCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzIGFyZVxuICogZ3VhcmFudGVlZCB0byBiZSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFdpZHRoIFRoZSB0b3RhbCB3aWR0aCBvZiB0aGUgcmVuZGVyaW5nIGFyZWEgaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsSGVpZ2h0IFRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIHJlbmRlcmluZyBhcmVhIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7UmVjdFNwZWN9IHNwZWMgVGhlIGlucHV0IHNwZWMsIGRlZmF1bHRpbmcgdG8gdGhlIGZ1bGwgcmVuZGVyaW5nIGFyZWFcbiAqICAgICBpZiBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7UmVjdH0gcmVzdWx0IFRoZSBvdXRwdXQgc3BlYy4gSWYgdGhlIGFyZ3VtZW50IGlzIHByZXNlbnQsIGl0IGlzXG4gKiAgICAgZmlsbGVkIGluIGFuZCByZXR1cm5lZDsgb3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gY2FsY1JlY3QodG90YWxXaWR0aCwgdG90YWxIZWlnaHQsIHNwZWMsIHJlc3VsdCkge1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcblxuICB2YXIgd2lkdGg7XG4gIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5hYnNvbHV0ZVdpZHRoICE9IG51bGwpIHtcbiAgICB3aWR0aCA9IHNwZWMuYWJzb2x1dGVXaWR0aCAvIHRvdGFsV2lkdGg7XG4gIH0gZWxzZSBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMucmVsYXRpdmVXaWR0aCAhPSBudWxsKSB7XG4gICAgd2lkdGggPSBzcGVjLnJlbGF0aXZlV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSAxO1xuICB9XG5cbiAgdmFyIGhlaWdodDtcbiAgaWYgKHNwZWMgJiYgc3BlYy5hYnNvbHV0ZUhlaWdodCAhPSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gc3BlYy5hYnNvbHV0ZUhlaWdodCAvIHRvdGFsSGVpZ2h0O1xuICB9IGVsc2UgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLnJlbGF0aXZlSGVpZ2h0ICE9IG51bGwpIHtcbiAgICBoZWlnaHQgPSBzcGVjLnJlbGF0aXZlSGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGhlaWdodCA9IDE7XG4gIH1cblxuICB2YXIgeDtcbiAgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLmFic29sdXRlWCAhPSBudWxsKSB7XG4gICAgeCA9IHNwZWMuYWJzb2x1dGVYIC8gdG90YWxXaWR0aDtcbiAgfSBlbHNlIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5yZWxhdGl2ZVggIT0gbnVsbCkge1xuICAgIHggPSBzcGVjLnJlbGF0aXZlWDtcbiAgfSBlbHNlIHtcbiAgICB4ID0gMDtcbiAgfVxuXG4gIHZhciB5O1xuICBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMuYWJzb2x1dGVZICE9IG51bGwpIHtcbiAgICB5ID0gc3BlYy5hYnNvbHV0ZVkgLyB0b3RhbEhlaWdodDtcbiAgfSBlbHNlIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5yZWxhdGl2ZVkgIT0gbnVsbCkge1xuICAgIHkgPSBzcGVjLnJlbGF0aXZlWTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIHJlc3VsdC54ID0geDtcbiAgcmVzdWx0LnkgPSB5O1xuICByZXN1bHQud2lkdGggPSB3aWR0aDtcbiAgcmVzdWx0LmhlaWdodCA9IGhlaWdodDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbGNSZWN0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgb25jZSA9IHJlcXVpcmUoJy4vb25jZScpO1xuXG4vLyBBIGNhbmNlbGFibGUgZnVuY3Rpb24gaXMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIChpLmUuLCBvbmUgd2hvc2UgbGFzdFxuLy8gYXJndW1lbnQgaXMgYSBjYWxsYmFjayByZWNlaXZpbmcgYW4gZXJyb3IgcGx1cyB6ZXJvIG9yIG1vcmUgcmV0dXJuIHZhbHVlcylcbi8vIHRoYXQgKHN5bmNocm9ub3VzbHkpIHJldHVybnMgYSBjYW5jZWwoKSBmdW5jdGlvbi4gQ2FsbGluZyBjYW5jZWwoKSBzaG91bGRcbi8vIGFib3J0IHRoZSBhc3luY2hyb25vdXMgb3BlcmF0aW9uIGFuZCBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBhcmd1bWVudHNcbi8vIHRoYXQgd2VyZSBwYXNzZWQgaW50byBjYW5jZWwoKS4gQ2FsbGluZyBjYW5jZWwoKSB0d2ljZSwgYXMgd2l0aCBjYWxsYmFja3MsXG4vLyBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzYWZlLlxuXG4vLyBXcmFwIGEgbm9uLWNhbmNlbGxhYmxlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIGEgY2FuY2VsYWJsZSBvbmUuXG4vL1xuLy8gQ2FsbGluZyBjYW5jZWwoKSBvbiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBub3QgaW50ZXJydXB0IHRoZSBleGVjdXRpb25cbi8vIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbjsgaXQgd2lsbCBtZXJlbHkgaWdub3JlIGl0cyByZXR1cm4gdmFsdWUuXG4vL1xuLy8gVXN1YWxseSwgaW5zdGVhZCBvZiB3cmFwcGluZyB5b3VyIGZ1bmN0aW9uLCB5b3Ugd2FudCB0byBpbXBsZW1lbnQgY2FuY2VsKClcbi8vIHlvdXJzZWxmIGluIG9yZGVyIHRvIGhhdmUgc29tZSBhYm9ydCBsb2dpYy4gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIHByb3ZpZGVzIGFcbi8vIHN0cmFpZ2hmb3J3YXJkIHNvbHV0aW9uIGZvciBjYXNlcyBpbiB3aGljaCBubyBjdXN0b20gYWJvcnQgbG9naWMgaXMgcmVxdWlyZWQuXG5mdW5jdGlvbiBjYW5jZWxpemUoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbGl6ZWQoKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbmNlbGl6ZWQ6IGV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgdmFyIGRvbmUgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBvbmNlKGFyZ3NbYXJncy5sZW5ndGggLSAxXSk7XG5cbiAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICByZXR1cm4gY2FuY2VsO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbmNlbGl6ZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyBpdHMgYXJndW1lbnRzICh3aGljaCBzaG91bGQgYmUgY2FuY2VsYWJsZXMpXG4vLyBpbiBzZXF1ZW5jZSwgc28gdGhhdCBlYWNoIG9mIHRoZW0gcGFzc2VzIGl0cyByZXR1cm4gdmFsdWVzIHRvIHRoZSBuZXh0LlxuLy8gRXhlY3V0aW9uIGlzIGFib3J0ZWQgaWYgb25lIG9mIHRoZSBmdW5jdGlvbnMgcmV0dXJucyBhbiBlcnJvcjsgaW4gdGhhdCBjYXNlXG4vLyB0aGUgbGFzdCBmdW5jdGlvbiBpbiB0aGUgc2VxdWVuY2UgaXMgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuLy8gU2VlIHV0aWwvY2FuY2VsaXplLmpzIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aGF0IGNhbmNlbGFibGVzIGFyZS5cbmZ1bmN0aW9uIGNoYWluKCkge1xuXG4gIC8vIFRoZSBsaXN0IG9mIGZ1bmN0aW9ucyB0byBjaGFpbiB0b2dldGhlci5cbiAgdmFyIGFyZ0xpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkKCkge1xuXG4gICAgLy8gTGlzdCBvZiByZW1haW5pbmcgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkLlxuICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBsaXN0IHNvIHdlIGNhbiBtdXRhdGUgdGhlIGZvcm1lciB3aGlsZVxuICAgIC8vIHByZXNlcnZpbmcgdGhlIGxhdHRlciBpbnRhY3QgZm9yIGZ1dHVyZSBpbnZvY2F0aW9ucyBvZiB0aGUgY2hhaW4uXG4gICAgdmFyIGZuTGlzdCA9IGFyZ0xpc3Quc2xpY2UoMCk7XG5cbiAgICAvLyBDdXJyZW50bHkgZXhlY3V0aW5nIGZ1bmN0aW9uLlxuICAgIHZhciBmbiA9IG51bGw7XG5cbiAgICAvLyBDYW5jZWwgbWV0aG9kIGZvciB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBmdW5jdGlvbi5cbiAgICB2YXIgY2ZuID0gbnVsbDtcblxuICAgIC8vIEFyZ3VtZW50cyBmb3IgdGhlIGZpcnN0IGZ1bmN0aW9uLlxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgYXJndW1lbnRzLmxlbmd0aCAtIDEpIDogW107XG5cbiAgICAvLyBDYWxsYmFjayBmb3IgdGhlIGNoYWluLlxuICAgIHZhciBkb25lID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gOiBub29wO1xuXG4gICAgLy8gRXhlY3V0ZSB0aGUgbmV4dCBmdW5jdGlvbiBpbiB0aGUgY2hhaW4uXG4gICAgLy8gUmVjZWl2ZXMgdGhlIGVycm9yIGFuZCByZXR1cm4gdmFsdWVzIGZyb20gdGhlIHByZXZpb3VzIGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG5cbiAgICAgIC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBhcmd1bWVudHMuXG4gICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICAvLyBBYm9ydCBjaGFpbiBvbiBlcnJvci5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZm4gPSBjZm4gPSBudWxsO1xuICAgICAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGVybWluYXRlIGlmIHRoZXJlIGFyZSBubyBmdW5jdGlvbnMgbGVmdCBpbiB0aGUgY2hhaW4uXG4gICAgICBpZiAoIWZuTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgZm4gPSBjZm4gPSBudWxsO1xuICAgICAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBmdW5jdGlvbiBpbiB0aGUgY2hhaW4uXG4gICAgICBmbiA9IGZuTGlzdC5zaGlmdCgpO1xuICAgICAgdmFyIF9mbiA9IGZuO1xuXG4gICAgICAvLyBFeHRyYWN0IGFyZ3VtZW50cyB0byBwYXNzIGludG8gdGhlIG5leHQgZnVuY3Rpb24uXG4gICAgICB2YXIgcmV0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgLy8gQ2FsbCBuZXh0IGZ1bmN0aW9uIHdpdGggcHJldmlvdXMgcmV0dXJuIHZhbHVlIGFuZCBjYWxsIGJhY2sgZXhlYy5cbiAgICAgIHJldC5wdXNoKGV4ZWMpO1xuICAgICAgdmFyIF9jZm4gPSBmbi5hcHBseShudWxsLCByZXQpOyAvLyBmbihudWxsLCByZXQuLi4sIGV4ZWMpXG5cbiAgICAgIC8vIERldGVjdCB3aGVuIGZuIGhhcyBjb21wbGV0ZWQgc3luY2hyb25vdXNseSBhbmQgZG8gbm90IGNsb2JiZXIgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBzdGF0ZSBpbiB0aGF0IGNhc2UuIFlvdSdyZSBub3QgZXhwZWN0ZWQgdG8gdW5kZXJzdGFuZCB0aGlzLlxuICAgICAgaWYgKF9mbiAhPT0gZm4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1lbWJlciB0aGUgY2FuY2VsIG1ldGhvZCBmb3IgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgZnVuY3Rpb24uXG4gICAgICAvLyBEZXRlY3QgY2hhaW5pbmcgb24gbm9uLWNhbmNlbGxhYmxlIGZ1bmN0aW9uLlxuICAgICAgaWYgKHR5cGVvZiBfY2ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW46IGNoYWluaW5nIG9uIG5vbi1jYW5jZWxsYWJsZSBmdW5jdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2ZuID0gX2NmbjtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIENhbmNlbCBjaGFpbiBleGVjdXRpb24uXG4gICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgaWYgKGNmbikge1xuICAgICAgICBjZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGFydCBjaGFpbiBleGVjdXRpb24uXG4gICAgLy8gV2UgY2FsbCBleGVjIGFzIGlmIGxpbmtpbmcgZnJvbSBhIHByZXZpb3VzIGZ1bmN0aW9uIGluIHRoZSBjaGFpbixcbiAgICAvLyBleGNlcHQgdGhhdCB0aGUgZXJyb3IgaXMgYWx3YXlzIG51bGwuIEFzIGEgY29uc2VxdWVuY2UsIGNoYWluaW5nIG9uIGFuXG4gICAgLy8gZW1wdHkgbGlzdCB5aWVsZHMgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuICAgIGFyZ3MudW5zaGlmdChudWxsKTtcbiAgICBleGVjLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBleGVjKG51bGwsIGFyZ3MuLi4pXG5cbiAgICByZXR1cm4gY2FuY2VsO1xuXG4gIH07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGFpbjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFtcDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNldHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgdG8gdW5kZWZpbmVkLiBUaGlzIG1heSBiZSBjYWxsZWQgYnlcbi8vIGRlc3RydWN0b3JzIHRvIGF2b2lkIHJldGFpbmluZyByZWZlcmVuY2VzIGFuZCBoZWxwIGRldGVjdCBpbmNvcnJlY3QgdXNlIG9mXG4vLyBkZXN0cm95ZWQgaW5zdGFuY2VzLlxuZnVuY3Rpb24gY2xlYXJPd25Qcm9wZXJ0aWVzKG9iaikge1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIG9ialtwcm9wXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGVhck93blByb3BlcnRpZXM7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNtcCh4LCB5KSB7XG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeCA+IHkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbXA7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAgKiBDb21wb3NlIG11bHRpcGxlIGZ1bmN0aW9uc1xuICAqXG4gICogYGNvbXBvc2UoZiwgZylgIHJldHVybnMgYGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoZyh4KSk7IH1gXG4gICpcbiAgKiBAbWVtYmVyb2YgdXRpbFxuICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqL1xuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgdmFyIGZuTGlzdCA9IGFyZ3VtZW50cztcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBvc2VkKGluaXRpYWxBcmcpIHtcbiAgICB2YXIgcmV0ID0gaW5pdGlhbEFyZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZuTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gZm5MaXN0W2ldO1xuICAgICAgcmV0ID0gZm4uY2FsbChudWxsLCByZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvc2U7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnZlcnQgZm92XG4gKlxuICogRm9yIGV4YW1wbGUsIHRvIGNvbnZlcnQgZnJvbSBoZm92IHRvIHZmb3Ygb25lIHdvdWxkIGNhbGwgXG4gKiBgY29udmVydChoZm92LCB3aWR0aCwgaGVpZ2h0KWBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnQoZm92LCBmcm9tRGltZW5zaW9uLCB0b0RpbWVuc2lvbikge1xuICByZXR1cm4gMiAqIE1hdGguYXRhbih0b0RpbWVuc2lvbiAqIE1hdGgudGFuKGZvdiAvIDIpIC8gZnJvbURpbWVuc2lvbik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBodG92KGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIHdpZHRoLCBoZWlnaHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gaHRvZChmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCB3aWR0aCwgTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIHZ0b2goZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgaGVpZ2h0LCB3aWR0aCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiB2dG9kKGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIGhlaWdodCwgTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIGR0b2goZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpLCB3aWR0aCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBkdG92KGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSwgaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIHV0aWwuY29udmVydEZvdlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udmVydDogY29udmVydCxcbiAgaHRvdjogaHRvdixcbiAgaHRvZDogaHRvZCxcbiAgdnRvaDogdnRvaCxcbiAgdnRvZDogdnRvZCxcbiAgZHRvaDogZHRvaCxcbiAgZHRvdjogZHRvdlxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gQ29udmVydCBhIG51bWJlciB0byBhIHN0cmluZyBpbiBkZWNpbWFsIG5vdGF0aW9uLlxuZnVuY3Rpb24gZGVjaW1hbCh4KSB7XG4gIC8vIERvdWJsZS1wcmVjaXNpb24gZmxvYXRzIGhhdmUgMTUgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdHMuXG4gIHJldHVybiB4LnRvUHJlY2lzaW9uKDE1KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNpbWFsOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZGVmYXVsdHMob2JqLCBkZWZhdWx0c09iaikge1xuICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHNPYmopIHtcbiAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgb2JqW2tleV0gPSBkZWZhdWx0c09ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZGVmZXIoZm4sIGFyZ3MpIHtcbiAgZnVuY3Rpb24gZGVmZXJyZWQoKSB7XG4gICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbiAgc2V0VGltZW91dChkZWZlcnJlZCwgMCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmZXI7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlZ1RvUmFkKGRlZykge1xuICByZXR1cm4gZGVnICogTWF0aC5QSSAvIDE4MDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWdUb1JhZDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFBlcmZvcm0gYSBjYW5jZWxhYmxlIGRlbGF5LlxuLy8gU2VlIHV0aWwvY2FuY2VsaXplLmpzIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aGF0IGNhbmNlbGFibGVzIGFyZS5cbmZ1bmN0aW9uIGRlbGF5KG1zLCBkb25lKSB7XG5cbiAgLy8gV29yayBhcm91bmQgSUU4IGJ1ZyB3aGVyZWJ5IGEgc2V0VGltZW91dCBjYWxsYmFjayBtYXkgc3RpbGwgYmUgY2FsbGVkXG4gIC8vIGFmdGVyIHRoZSBjb3JyZXNwb25kaW5nIGNsZWFyVGltZW91dCBpcyBpbnZva2VkLlxuICB2YXIgdGltZXIgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICBpZiAodGltZXIgIT0gbnVsbCkge1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgZG9uZShudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVyICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGltZXIgPSBzZXRUaW1lb3V0KGZpbmlzaCwgbXMpO1xuXG4gIHJldHVybiBjYW5jZWw7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWxheTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBwcmVmaXhQcm9wZXJ0eShwcm9wZXJ0eSkge1xuXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbiAgdmFyIHByZWZpeExpc3QgPSBbJ01veicsICdXZWJraXQnLCAnS2h0bWwnLCAnTycsICdtcyddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhMaXN0W2ldO1xuICAgIHZhciBjYXBpdGFsaXplZFByb3BlcnR5ID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuICAgIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gcHJlZml4ICsgY2FwaXRhbGl6ZWRQcm9wZXJ0eTtcblxuICAgIGlmIChwcmVmaXhlZFByb3BlcnR5IGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRQcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcGVydHk7XG5cbn1cblxuXG5mdW5jdGlvbiBnZXRXaXRoVmVuZG9yUHJlZml4KHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gcHJlZml4UHJvcGVydHkocHJvcGVydHkpO1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvcGVydHlXaXRoVmVuZG9yUHJlZml4KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtwcmVmaXhlZFByb3BlcnR5XTtcbiAgfTtcblxufVxuXG5cbmZ1bmN0aW9uIHNldFdpdGhWZW5kb3JQcmVmaXgocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBwcmVmaXhQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm9wZXJ0eVdpdGhWZW5kb3JQcmVmaXgoZWxlbWVudCwgdmFsKSB7XG4gICAgcmV0dXJuIChlbGVtZW50LnN0eWxlW3ByZWZpeGVkUHJvcGVydHldID0gdmFsKTtcbiAgfTtcbn1cblxuXG52YXIgc2V0VHJhbnNmb3JtID0gc2V0V2l0aFZlbmRvclByZWZpeCgndHJhbnNmb3JtJyk7XG52YXIgc2V0VHJhbnNmb3JtT3JpZ2luID0gc2V0V2l0aFZlbmRvclByZWZpeCgndHJhbnNmb3JtT3JpZ2luJyk7XG5cblxuZnVuY3Rpb24gc2V0TnVsbFRyYW5zZm9ybShlbGVtZW50KSB7XG4gIHNldFRyYW5zZm9ybShlbGVtZW50LCAndHJhbnNsYXRlWigwKScpO1xufVxuXG5cbmZ1bmN0aW9uIHNldE51bGxUcmFuc2Zvcm1PcmlnaW4oZWxlbWVudCkge1xuICBzZXRUcmFuc2Zvcm1PcmlnaW4oZWxlbWVudCwgJzAgMCAwJyk7XG59XG5cblxuZnVuY3Rpb24gc2V0QWJzb2x1dGUoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbn1cblxuXG5mdW5jdGlvbiBzZXRQaXhlbFBvc2l0aW9uKGVsZW1lbnQsIHgsIHkpIHtcbiAgZWxlbWVudC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gIGVsZW1lbnQuc3R5bGUudG9wID0geSArICdweCc7XG59XG5cblxuZnVuY3Rpb24gc2V0UGl4ZWxTaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufVxuXG5cbmZ1bmN0aW9uIHNldE51bGxTaXplKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gMDtcbn1cblxuXG5mdW5jdGlvbiBzZXRGdWxsU2l6ZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbn1cblxuXG5mdW5jdGlvbiBzZXRPdmVyZmxvd0hpZGRlbihlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbn1cblxuXG5mdW5jdGlvbiBzZXRPdmVyZmxvd1Zpc2libGUoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xufVxuXG5cbmZ1bmN0aW9uIHNldE5vUG9pbnRlckV2ZW50cyhlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJlZml4UHJvcGVydHk6IHByZWZpeFByb3BlcnR5LFxuICBnZXRXaXRoVmVuZG9yUHJlZml4OiBnZXRXaXRoVmVuZG9yUHJlZml4LFxuICBzZXRXaXRoVmVuZG9yUHJlZml4OiBzZXRXaXRoVmVuZG9yUHJlZml4LFxuICBzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybSxcbiAgc2V0VHJhbnNmb3JtT3JpZ2luOiBzZXRUcmFuc2Zvcm1PcmlnaW4sXG4gIHNldE51bGxUcmFuc2Zvcm06IHNldE51bGxUcmFuc2Zvcm0sXG4gIHNldE51bGxUcmFuc2Zvcm1PcmlnaW46IHNldE51bGxUcmFuc2Zvcm1PcmlnaW4sXG4gIHNldEFic29sdXRlOiBzZXRBYnNvbHV0ZSxcbiAgc2V0UGl4ZWxQb3NpdGlvbjogc2V0UGl4ZWxQb3NpdGlvbixcbiAgc2V0UGl4ZWxTaXplOiBzZXRQaXhlbFNpemUsXG4gIHNldE51bGxTaXplOiBzZXROdWxsU2l6ZSxcbiAgc2V0RnVsbFNpemU6IHNldEZ1bGxTaXplLFxuICBzZXRPdmVyZmxvd0hpZGRlbjogc2V0T3ZlcmZsb3dIaWRkZW4sXG4gIHNldE92ZXJmbG93VmlzaWJsZTogc2V0T3ZlcmZsb3dWaXNpYmxlLFxuICBzZXROb1BvaW50ZXJFdmVudHM6IHNldE5vUG9pbnRlckV2ZW50c1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgc291cmNlT2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2VPYmopIHtcbiAgICBvYmpba2V5XSA9IHNvdXJjZU9ialtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIGdsb2JhbCBvYmplY3QuXG52YXIgZ2xvYmFsT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHJldHVybiBudWxsO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxPYmplY3Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIEplbmtpbnMgb25lLWF0LWEtdGltZSBoYXNoXG4vLyBodHRwOi8vd3d3LmJ1cnRsZWJ1cnRsZS5uZXQvYm9iL2hhc2gvZG9vYnMuaHRtbFxuLy8gSW5wdXQ6IGFuIGFycmF5IG9mIGludGVnZXJzXG4vLyBPdXRwdXQ6IGFuIGludGVnZXJcblxuZnVuY3Rpb24gaGFzaCgpIHtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrID0gYXJndW1lbnRzW2ldO1xuICAgIGggKz0gaztcbiAgICBoICs9IGsgPDwgMTA7XG4gICAgaCBePSBrID4+IDY7XG4gIH1cbiAgaCArPSBoIDw8IDM7XG4gIGggXj0gaCA+PiAxMTtcbiAgaCArPSBoIDw8IDE1O1xuICByZXR1cm4gaCA+PSAwID8gaCA6IC1oO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2g7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNYWtlIGN0b3IgYSBzdWJjbGFzcyBvZiBzdXBlckN0b3IuXG4vLyBEbyBub3QgZGVwZW5kIG9uIEVTNSBPYmplY3QuY3JlYXRlIHNlbWFudGljcyBiZWNhdXNlIG9mIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbigpIHt9O1xuICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5oZXJpdHM7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgbiBpcyBhIHBvd2VyIG9mIHR3by5cbmZ1bmN0aW9uIGlzcG90KG4pIHtcbiAgcmV0dXJuIChuICYgKG4gLSAxKSkgPT0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc3BvdDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxvIG9wZXJhdGlvblxuICpcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge051bWJlcn0gZGl2aWRlbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXZpc29yXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBWYWx1ZSBpbiByYW5nZSBgWzAsZGl2aXNvcltgXG4gKi9cbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gIHJldHVybiAoK2EgJSAoYiA9ICtiKSArIGIpICUgYjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb2Q7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBub29wOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gZGF0ZU5vdygpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb3coKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb25jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHZhciB2YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VkKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgdmFsdWUgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25jZTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0UGl4ZWxSYXRpbyA9IDE7XG5cbmZ1bmN0aW9uIHBpeGVsUmF0aW8oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzY3JlZW4gPSB3aW5kb3cuc2NyZWVuO1xuICAgICAgaWYgKHNjcmVlbiAmJiBzY3JlZW4uZGV2aWNlWERQSSAmJiBzY3JlZW4ubG9naWNhbFhEUEkpIHtcbiAgICAgICAgcmV0dXJuIHNjcmVlbi5kZXZpY2VYRFBJIC8gc2NyZWVuLmxvZ2ljYWxYRFBJO1xuICAgICAgfSBlbHNlIGlmIChzY3JlZW4gJiYgc2NyZWVuLnN5c3RlbVhEUEkgJiYgc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJldHVybiBzY3JlZW4uc3lzdGVtWERQSSAvIHNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRQaXhlbFJhdGlvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpeGVsUmF0aW87XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2RvbScpLnNldFRyYW5zZm9ybTtcbnZhciBkZWNpbWFsID0gcmVxdWlyZSgnLi9kZWNpbWFsJyk7XG5cbmZ1bmN0aW9uIHBvc2l0aW9uQWJzb2x1dGVseShlbGVtZW50LCB4LCB5LCBleHRyYVRyYW5zZm9ybXMpIHtcbiAgZXh0cmFUcmFuc2Zvcm1zID0gZXh0cmFUcmFuc2Zvcm1zIHx8ICcnO1xuICAvLyBBIHRyYW5zbGF0ZVooMCkgdHJhbnNmb3JtIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIENocm9tZSBieSBjcmVhdGluZyBhXG4gIC8vIG5ldyBsYXllciBmb3IgdGhlIGVsZW1lbnQsIHdoaWNoIHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlcGFpbnRzLlxuICB2YXIgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIGRlY2ltYWwoeCkgKyAncHgpIHRyYW5zbGF0ZVkoJyArIGRlY2ltYWwoeSkgKyAncHgpIHRyYW5zbGF0ZVooMCkgJyArIGV4dHJhVHJhbnNmb3JtcztcbiAgc2V0VHJhbnNmb3JtKGVsZW1lbnQsIHRyYW5zZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXRpb25BYnNvbHV0ZWx5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICByZXR1cm4gcmFkICogMTgwIC8gTWF0aC5QSTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByYWRUb0RlZzsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJlYWwoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWw7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vLyBSZXR1cm4gYSBjYW5jZWxhYmxlIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgZm4gaW4gYSBsb29wIHVudGlsIGl0IHJldHVybnNcbi8vIHN1Y2Nlc3NmdWxseS5cbmZ1bmN0aW9uIHJldHJ5KGZuKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJldHJpZWQoKSB7XG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IFtdO1xuICAgIHZhciBkb25lID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gOiBub29wO1xuXG4gICAgdmFyIGNmbiA9IG51bGw7XG4gICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICghZXJyIHx8IGNhbmNlbGVkKSB7XG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNmbiA9IGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyZ3MucHVzaChleGVjKTtcbiAgICBleGVjKHRydWUpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIGNmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgfTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm93ID0gcmVxdWlyZSgnLi9ub3cnKTtcblxuZnVuY3Rpb24gdHdlZW4oZHVyYXRpb24sIHVwZGF0ZSwgZG9uZSkge1xuICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gIGZ1bmN0aW9uIHJ1blVwZGF0ZSgpIHtcbiAgICBpZihjYW5jZWxsZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHR3ZWVuVmFsID0gKG5vdygpIC0gc3RhcnRUaW1lKS9kdXJhdGlvbjtcbiAgICBpZih0d2VlblZhbCA8IDEpIHtcbiAgICAgIHVwZGF0ZSh0d2VlblZhbCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuVXBkYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoMSk7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKDApO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuVXBkYXRlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHdlZW47IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB0eXBlKHgpIHtcbiAgdmFyIHR5cCA9IHR5cGVvZiB4O1xuICBpZiAodHlwID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR5cDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG52YXIgcGl4ZWxSYXRpbyA9IHJlcXVpcmUoJy4uL3V0aWwvcGl4ZWxSYXRpbycpO1xudmFyIHJlYWwgPSByZXF1aXJlKCcuLi91dGlsL3JlYWwnKTtcbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBEZWZhdWx0IHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4vLyBTdGFydCB3aXRoIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhvc2UgdmFsdWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbnZhciBkZWZhdWx0V2lkdGggPSAwO1xudmFyIGRlZmF1bHRIZWlnaHQgPSAwO1xuXG4vLyBEZWZhdWx0IHZpZXcgcGFyYW1ldGVycy5cbnZhciBkZWZhdWx0WCA9IDAuNTtcbnZhciBkZWZhdWx0WSA9IDAuNTtcbnZhciBkZWZhdWx0Wm9vbSA9IDE7XG5cbi8vIENvbnN0YW50IHZhbHVlcyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBmcnVzdHVtIGN1bGxpbmcgbG9naWMuXG4vLyBwbGFuZUF4ZXNbaV0gaW5kaWNhdGVzIHRoZSBjb29yZGluYXRlIHZhbHVlIHRoYXQgZGVmaW5lcyBhIGZydXN0dW0gcGxhbmUuXG4vLyBwbGFuZUNtcFtpXSBpbmRpY2F0ZXMgaG93IHBvaW50IGFuZCBwbGFuZSBjb29yZGluYXRlcyBzaG91bGQgYmUgY29tcGFyZWRcbi8vIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBwb2ludCBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiB0aGUgcGxhbmUuXG52YXIgcGxhbmVBeGVzID0gW1xuICAxLCAvLyB0b3BcbiAgMCwgLy8gcmlnaHRcbiAgMSwgLy8gYm90dG9tXG4gIDAgIC8vIGxlZnRcbl07XG52YXIgcGxhbmVDbXAgPSBbXG4gIC0xLCAvLyB0b3BcbiAgLTEsIC8vIHJpZ2h0XG4gICAxLCAvLyBib3R0b21cbiAgIDEgIC8vIGxlZnRcbl07XG5cbi8vIEEgem9vbSBvZiBleGFjdGx5IDAgYnJlYWtzIHNvbWUgY29tcHV0YXRpb25zLCBzbyB3ZSBmb3JjZSBhIG1pbmltdW0gcG9zaXRpdmVcbi8vIHZhbHVlLiBXZSB1c2UgNiBkZWNpbWFsIHBsYWNlcyBmb3IgdGhlIGVwc2lsb24gdmFsdWUgdG8gYXZvaWQgYnJva2VuXG4vLyByZW5kZXJpbmcgZHVlIHRvIGxvc3Mgb2YgcHJlY2lzaW9uIGluIGZsb2F0aW5nIHBvaW50IGNvbXB1dGF0aW9ucy5cbnZhciB6b29tTGltaXRFcHNpbG9uID0gMC4wMDAwMDE7XG5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZsYXRWaWV3UGFyYW1zXG4gKlxuICogQSBjYW1lcmEgY29uZmlndXJhdGlvbiBmb3IgYSB7QGxpbmsgRmxhdFZpZXd9LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIGltYWdlIHBvaW50IGRpc3BsYXllZFxuICogICAgIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKiAgICAgV2hlbiBgeCA9PT0gMC41YCwgdGhlIGltYWdlIGlzIGNlbnRlcmVkIGhvcml6b250YWxseS5cbiAqICAgICBXaGVuIGB4ID09PSAwYCwgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW1hZ2UgaXMgYXQgdGhlIHZpZXdwb3J0IGNlbnRlci5cbiAqICAgICBXaGVuIGB4ID09PSAxYCwgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgaW1hZ2UgcG9pbnQgZGlzcGxheWVkIGF0XG4gKiAgICAgdGhlIHZpZXdwb3J0IGNlbnRlciwgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAqICAgICBXaGVuIGB5ID09PSAwLjVgLCB0aGUgaW1hZ2UgaXMgY2VudGVyZWQgdmVydGljYWxseS5cbiAqICAgICBXaGVuIGB5ID09PSAwYCwgdGhlIHRvcCBlZGdlIG9mIHRoZSBpbWFnZSBpcyBhdCB0aGUgdmlld3BvcnQgY2VudGVyLlxuICogICAgIFdoZW4gYHkgPT09IDFgLCB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9vbSBUaGUgaG9yaXpvbnRhbCB6b29tLCBpbiB0aGUgWzAsIOKInikgcmFuZ2UuXG4gKiAgICAgV2hlbiBgem9vbSA9PT0gMWAsIHRoZSB2aWV3cG9ydCBpcyBhcyB3aWRlIGFzIHRoZSBpbWFnZS5cbiAqICAgICBXaGVuIGB6b29tIDwgMWAsIHRoZSBpbWFnZSBpcyB6b29tZWQgaW4uXG4gKiAgICAgV2hlbiBgem9vbSA+IDFgLCB0aGUgaW1hZ2UgaXMgem9vbWVkIG91dC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtZWRpYUFzcGVjdFJhdGlvIFRoZSBpbWFnZSBhc3BlY3QgcmF0aW8uXG4gKiAgICAgV2hlbiBgbWVkaWFBc3BlY3RSYXRpbyA9PT0gMWAsIHRoZSBpbWFnZSB3aWR0aCBlcXVhbHMgaXRzIGhlaWdodC5cbiAqICAgICBXaGVuIGBtZWRpYUFzcGVjdFJhdGlvIDwgMWAsIHRoZSBpbWFnZSB3aWR0aCBpcyBsZXNzIHRoYW4gaXRzIGhlaWdodC5cbiAqICAgICBXaGVuIGBtZWRpYUFzcGVjdFJhdGlvID4gMWAsIHRoZSBpbWFnZSBoZWlnaHQgaXMgbGVzcyB0aGFuIGl0cyB3aWR0aC5cbiAqL1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBGbGF0Vmlld0Nvb3Jkc1xuICpcbiAqIFRoZSBwb3NpdGlvbiBvZiBhIHBvaW50IGluIGEgZmxhdCBpbWFnZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLCBpbiB0aGUgWzAsIDFdIHJhbmdlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gRmxhdFZpZXdMaW1pdGVyXG4gKlxuICogVmlldyBsaW1pdGVyIGZvciBhIHtAbGluayBGbGF0Vmlld30uXG4gKlxuICogQSB2aWV3IGxpbWl0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEge0BsaW5rIEZsYXRWaWV3UGFyYW1zfSBvYmplY3QsXG4gKiBvcHRpb25hbGx5IG1vZGlmaWVzIGl0IGluIHBsYWNlLCBhbmQgcmV0dXJucyBpdC4gSXQgY2FuIGJlIHVzZWQgdG8gZW5mb3JjZVxuICogY29uc3RyYWludHMgb24gdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBTZWUge0BsaW5rIEZsYXRWaWV3LmxpbWl0fSBmb3IgY29tbW9ubHkgdXNlZCBsaW1pdGVycy4gVGhleSBtYXkgYmUgY29tcG9zZWRcbiAqIHRvZ2V0aGVyIG9yIHdpdGggdXNlci1kZWZpbmVkIGxpbWl0ZXJzIHdpdGgge0BsaW5rIHV0aWwuY29tcG9zZX0uXG4gKlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtGbGF0Vmlld1BhcmFtc31cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzIEZsYXRWaWV3XG4gKiBAaW1wbGVtZW50cyBWaWV3XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgVmlld30gaW1wbGVtZW50aW5nIGFuIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBmb3IgZmxhdCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtc30gcGFyYW1zIFRoZSBpbml0aWFsIHZpZXcgcGFyYW1ldGVycy4gVGhlXG4gKiAgICAgYG1lZGlhQXNwZWN0UmF0aW9gIHBhcmFtZXRlciBtdXN0IGFsd2F5cyBiZSBzZXQuIFRoZSBvdGhlciBwYXJhbWV0ZXJzXG4gKiAgICAgZGVmYXVsdCB0byBge3g6IDAuNSwgeTogMC41LCB6OiAxIH1gIGlmIHVuc3BlY2lmaWVkLlxuICogQHBhcmFtIHtGbGF0Vmlld0xpbWl0ZXI9fSBsaW1pdGVyIFRoZSB2aWV3IGxpbWl0ZXIuIElmIHVuc3BlY2lmaWVkLCBubyB2aWV3XG4gKiAgICAgbGltaXRpbmcgaXMgYXBwbGllZC4gU2VlIHtAbGluayBGbGF0Vmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWRcbiAqICAgICBsaW1pdGVycy5cbiAqL1xuZnVuY3Rpb24gRmxhdFZpZXcocGFyYW1zLCBsaW1pdGVyKSB7XG4gIC8vIFJlcXVpcmUgYW4gYXNwZWN0IHJhdGlvIHRvIGJlIHNwZWNpZmllZC5cbiAgaWYgKCEocGFyYW1zICYmIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvICE9IG51bGwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZWRpYUFzcGVjdFJhdGlvIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG5cbiAgLy8gVGhlIGluaXRpYWwgdmFsdWVzIGZvciB0aGUgdmlldyBwYXJhbWV0ZXJzLlxuICB0aGlzLl94ID0gcGFyYW1zICYmIHBhcmFtcy54ICE9IG51bGwgPyBwYXJhbXMueCA6IGRlZmF1bHRYO1xuICB0aGlzLl95ID0gcGFyYW1zICYmIHBhcmFtcy55ICE9IG51bGwgPyBwYXJhbXMueSA6IGRlZmF1bHRZO1xuICB0aGlzLl96b29tID0gcGFyYW1zICYmIHBhcmFtcy56b29tICE9IG51bGwgPyBwYXJhbXMuem9vbSA6IGRlZmF1bHRab29tO1xuICB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3dpZHRoID0gcGFyYW1zICYmIHBhcmFtcy53aWR0aCAhPSBudWxsID9cbiAgICBwYXJhbXMud2lkdGggOiBkZWZhdWx0V2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHBhcmFtcyAmJiBwYXJhbXMuaGVpZ2h0ICE9IG51bGwgP1xuICAgIHBhcmFtcy5oZWlnaHQgOiBkZWZhdWx0SGVpZ2h0O1xuXG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgdmlldyBsaW1pdGVyLlxuICB0aGlzLl9saW1pdGVyID0gbGltaXRlciB8fCBudWxsO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgcHJvamVjdGlvbiBtYXRyaXggYW5kIGl0cyBpbnZlcnNlLlxuICB0aGlzLl9wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgdGhpcy5faW52UHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIGxhc3QgY2FsY3VsYXRlZCB2aWV3IGZydXN0dW0uXG4gIHRoaXMuX2ZydXN0dW0gPSBbXG4gICAgMCwgLy8gdG9wXG4gICAgMCwgLy8gcmlnaHRcbiAgICAwLCAvLyBib3R0b21cbiAgICAwICAvLyBsZWZ0XG4gIF07XG5cbiAgLy8gV2hldGhlciB0aGUgcHJvamVjdGlvbiBtYXRyaWNlcyBhbmQgdmlldyBmcnVzdHVtIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gIC8vIFRlbXBvcmFyeSB2YXJpYWJsZXMgdXNlZCBmb3IgY2FsY3VsYXRpb25zLlxuICB0aGlzLl9wYXJhbXMgPSB7fTtcbiAgdGhpcy5fdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAvLyBGb3JjZSB2aWV3IGxpbWl0aW5nIG9uIGluaXRpYWwgcGFyYW1ldGVycy5cbiAgdGhpcy5fdXBkYXRlKCk7XG59XG5cbmV2ZW50RW1pdHRlcihGbGF0Vmlldyk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB4IHBhcmFtZXRlci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3g7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB5IHBhcmFtZXRlci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3k7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB6b29tIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fem9vbTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1lZGlhIGFzcGVjdCByYXRpby5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLm1lZGlhQXNwZWN0UmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCB3aWR0aC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoXG4gKiB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtTaXplPX0gc2l6ZVxuICogQHJldHVybiB7U2l6ZX1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHNpemUgPSBzaXplIHx8IHt9O1xuICBzaXplLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICByZXR1cm4gc2l6ZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZVxuICogcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtcz19IHBhcmFtc1xuICogQHJldHVybiB7RmxhdFZpZXdQYXJhbXN9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLnggPSB0aGlzLl94O1xuICBwYXJhbXMueSA9IHRoaXMuX3k7XG4gIHBhcmFtcy56b29tID0gdGhpcy5fem9vbTtcbiAgcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPSB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvO1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBsaW1pdGVyLCBvciBudWxsIGlmIHVuc2V0LlxuICogQHJldHVybiB7P0ZsYXRWaWV3TGltaXRlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmxpbWl0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbWl0ZXI7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB4IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMueCA9IHg7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uKHkpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnkgPSB5O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHpvb20gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnpvb20gPSB6b29tO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBBZGQgeE9mZnNldCB0byB0aGUgeCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geE9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0WCA9IGZ1bmN0aW9uKHhPZmZzZXQpIHtcbiAgdGhpcy5zZXRYKHRoaXMuX3ggKyB4T2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBBZGQgeU9mZnNldCB0byB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geU9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0WSA9IGZ1bmN0aW9uKHlPZmZzZXQpXG57XG4gIHRoaXMuc2V0WSh0aGlzLl95ICsgeU9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHpvb21PZmZzZXQgdG8gdGhlIHpvb20gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbU9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb21PZmZzZXQpIHtcbiAgdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyB6b29tT2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIG1lZGlhIGFzcGVjdCByYXRpby5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWRpYUFzcGVjdFJhdGlvXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRNZWRpYUFzcGVjdFJhdGlvID0gZnVuY3Rpb24obWVkaWFBc3BlY3RSYXRpbykge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA9IG1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgdGhpcy5fcGFyYW1zLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zcGVjaWZpZWQgcGFyYW1ldGVycyBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge0ZsYXRWaWV3UGFyYW1ldGVyc30gcGFyYW1zXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy54ID0gcGFyYW1zLng7XG4gIHRoaXMuX3BhcmFtcy55ID0gcGFyYW1zLnk7XG4gIHRoaXMuX3BhcmFtcy56b29tID0gcGFyYW1zLnpvb207XG4gIHRoaXMuX3BhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlldyBsaW1pdGVyLlxuICogQHBhcmFtIHs/RmxhdFZpZXdMaW1pdGVyfSBsaW1pdGVyIFRoZSBuZXcgbGltaXRlciwgb3IgbnVsbCB0byB1bnNldC5cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNldExpbWl0ZXIgPSBmdW5jdGlvbihsaW1pdGVyKSB7XG4gIHRoaXMuX2xpbWl0ZXIgPSBsaW1pdGVyIHx8IG51bGw7XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3Jlc2V0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIHBhcmFtcy54ID0gbnVsbDtcbiAgcGFyYW1zLnkgPSBudWxsO1xuICBwYXJhbXMuem9vbSA9IG51bGw7XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gbnVsbDtcbiAgcGFyYW1zLndpZHRoID0gbnVsbDtcbiAgcGFyYW1zLmhlaWdodCA9IG51bGw7XG59O1xuXG5cbkZsYXRWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgLy8gQXZvaWQgb2JqZWN0IGFsbG9jYXRpb24gd2hlbiBubyBwYXJhbWV0ZXJzIGFyZSBzdXBwbGllZC5cbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgICBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvLyBTYXZlIG9sZCBwYXJhbWV0ZXJzIGZvciBsYXRlciBjb21wYXJpc29uLlxuICB2YXIgb2xkWCA9IHRoaXMuX3g7XG4gIHZhciBvbGRZID0gdGhpcy5feTtcbiAgdmFyIG9sZFpvb20gPSB0aGlzLl96b29tO1xuICB2YXIgb2xkTWVkaWFBc3BlY3RSYXRpbyA9IHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG4gIHZhciBvbGRXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIEZpbGwgaW4gb2JqZWN0IHdpdGggdGhlIG5ldyBzZXQgb2YgcGFyYW1ldGVycyB0byBwYXNzIGludG8gdGhlIGxpbWl0ZXIuXG4gIHBhcmFtcy54ID0gcGFyYW1zLnggIT0gbnVsbCA/IHBhcmFtcy54IDogb2xkWDtcbiAgcGFyYW1zLnkgPSBwYXJhbXMueSAhPSBudWxsID8gcGFyYW1zLnkgOiBvbGRZO1xuICBwYXJhbXMuem9vbSA9IHBhcmFtcy56b29tICE9IG51bGwgPyBwYXJhbXMuem9vbSA6IG9sZFpvb207XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gIT0gbnVsbCA/XG4gICAgcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gOiBvbGRNZWRpYUFzcGVjdFJhdGlvO1xuICBwYXJhbXMud2lkdGggPSBwYXJhbXMud2lkdGggIT0gbnVsbCA/IHBhcmFtcy53aWR0aCA6IG9sZFdpZHRoO1xuICBwYXJhbXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCAhPSBudWxsID8gcGFyYW1zLmhlaWdodCA6IG9sZEhlaWdodDtcblxuICAvLyBBcHBseSB2aWV3IGxpbWl0aW5nIHdoZW4gZGVmaW5lZC5cbiAgaWYgKHRoaXMuX2xpbWl0ZXIpIHtcbiAgICBwYXJhbXMgPSB0aGlzLl9saW1pdGVyKHBhcmFtcyk7XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgbGltaXRlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdyYWIgdGhlIGxpbWl0ZWQgcGFyYW1ldGVycy5cbiAgdmFyIG5ld1ggPSBwYXJhbXMueDtcbiAgdmFyIG5ld1kgPSBwYXJhbXMueTtcbiAgdmFyIG5ld1pvb20gPSBwYXJhbXMuem9vbTtcbiAgdmFyIG5ld01lZGlhQXNwZWN0UmF0aW8gPSBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbztcbiAgdmFyIG5ld1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICB2YXIgbmV3SGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcblxuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKCFyZWFsKG5ld1gpIHx8ICFyZWFsKG5ld1kpIHx8ICFyZWFsKG5ld1pvb20pIHx8XG4gICAgICAhcmVhbChuZXdNZWRpYUFzcGVjdFJhdGlvKSB8fCAhcmVhbChuZXdXaWR0aCkgfHwgIXJlYWwobmV3SGVpZ2h0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgLSBzdXNwZWN0IGEgYnJva2VuIGxpbWl0ZXInKTtcbiAgfVxuXG4gIC8vIENvbnN0cmFpbiB6b29tLlxuICBuZXdab29tID0gY2xhbXAobmV3Wm9vbSwgem9vbUxpbWl0RXBzaWxvbiwgSW5maW5pdHkpO1xuXG4gIC8vIFVwZGF0ZSBwYXJhbWV0ZXJzLlxuICB0aGlzLl94ID0gbmV3WDtcbiAgdGhpcy5feSA9IG5ld1k7XG4gIHRoaXMuX3pvb20gPSBuZXdab29tO1xuICB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvID0gbmV3TWVkaWFBc3BlY3RSYXRpbztcbiAgdGhpcy5fd2lkdGggPSBuZXdXaWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHBhcmFtZXRlcnMgY2hhbmdlZCBhbmQgZW1pdCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMuXG4gIGlmIChuZXdYICE9PSBvbGRYIHx8IG5ld1kgIT09IG9sZFkgfHwgbmV3Wm9vbSAhPT0gb2xkWm9vbSB8fFxuICAgICAgbmV3TWVkaWFBc3BlY3RSYXRpbyAhPT0gb2xkTWVkaWFBc3BlY3RSYXRpbyB8fFxuICAgICAgbmV3V2lkdGggIT09IG9sZFdpZHRoIHx8IG5ld0hlaWdodCAhPT0gb2xkSGVpZ2h0KSB7XG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbiAgaWYgKG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG4gIH1cblxufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3pvb21YID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl96b29tO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3pvb21ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtZWRpYUFzcGVjdFJhdGlvID0gdGhpcy5fbWVkaWFBc3BlY3RSYXRpbztcbiAgdmFyIGFzcGVjdCA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuICB2YXIgem9vbVggPSB0aGlzLl96b29tO1xuICB2YXIgem9vbVkgPSB6b29tWCAqIG1lZGlhQXNwZWN0UmF0aW8gLyBhc3BlY3Q7XG4gIGlmIChpc05hTih6b29tWSkpIHtcbiAgICB6b29tWSA9IHpvb21YO1xuICB9XG4gIHJldHVybiB6b29tWTtcbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLnVwZGF0ZVdpdGhDb250cm9sUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgdmFyIHNjYWxlID0gdGhpcy56b29tKCk7XG4gIHZhciB6b29tWCA9IHRoaXMuX3pvb21YKCk7XG4gIHZhciB6b29tWSA9IHRoaXMuX3pvb21ZKCk7XG5cbiAgLy8gVE9ETzogc2hvdWxkIHRoZSBzY2FsZSBiZSB0aGUgc2FtZSBmb3IgYm90aCBheGVzP1xuICB0aGlzLm9mZnNldFgocGFyYW1ldGVycy5heGlzU2NhbGVkWCAqIHpvb21YICsgcGFyYW1ldGVycy54ICogc2NhbGUpO1xuICB0aGlzLm9mZnNldFkocGFyYW1ldGVycy5heGlzU2NhbGVkWSAqIHpvb21ZICsgcGFyYW1ldGVycy55ICogc2NhbGUpO1xuICB0aGlzLm9mZnNldFpvb20ocGFyYW1ldGVycy56b29tICogc2NhbGUpO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3VwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByb2pNYXRyaXggPSB0aGlzLl9wcm9qTWF0cml4O1xuICB2YXIgaW52UHJvak1hdHJpeCA9IHRoaXMuX2ludlByb2pNYXRyaXg7XG4gIHZhciBmcnVzdHVtID0gdGhpcy5fZnJ1c3R1bTtcblxuICAvLyBSZWNhbGN1bGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aGVuIHJlcXVpcmVkLlxuICBpZiAodGhpcy5fcHJvamVjdGlvbkNoYW5nZWQpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3g7XG4gICAgdmFyIHkgPSB0aGlzLl95O1xuICAgIHZhciB6b29tWCA9IHRoaXMuX3pvb21YKCk7XG4gICAgdmFyIHpvb21ZID0gdGhpcy5fem9vbVkoKTtcblxuICAgIC8vIFJlY2FsY3VsYXRlIHZpZXcgZnJ1c3R1bS5cbiAgICB2YXIgdG9wICAgICA9IGZydXN0dW1bMF0gPSAoMC41IC0geSkgKyAwLjUgKiB6b29tWTtcbiAgICB2YXIgcmlnaHQgICA9IGZydXN0dW1bMV0gPSAoeCAtIDAuNSkgKyAwLjUgKiB6b29tWDtcbiAgICB2YXIgYm90dG9tICA9IGZydXN0dW1bMl0gPSAoMC41IC0geSkgLSAwLjUgKiB6b29tWTtcbiAgICB2YXIgbGVmdCAgICA9IGZydXN0dW1bM10gPSAoeCAtIDAuNSkgLSAwLjUgKiB6b29tWDtcblxuICAgIC8vIFJlY2FsY3VsYXRlIHByb2plY3Rpb24gbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgICBtYXQ0Lm9ydGhvKHByb2pNYXRyaXgsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgLTEsIDEpO1xuICAgIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIHByb2pNYXRyaXgpO1xuXG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZVByb2plY3Rpb24oKTtcbiAgcmV0dXJuIHRoaXMuX3Byb2pNYXRyaXg7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEByZXR1cm5zIHttYXQ0fVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuaW52ZXJzZVByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdXBkYXRlUHJvamVjdGlvbigpO1xuICByZXR1cm4gdGhpcy5faW52UHJvak1hdHJpeDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgdmlldyBmcnVzdHVtIGludGVyc2VjdHMgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1heSByZXR1cm4gZmFsc2UgcG9zaXRpdmVzLCBidXQgbmV2ZXIgZmFsc2UgbmVnYXRpdmVzLlxuICogSXQgaXMgdXNlZCBmb3IgZnJ1c3R1bSBjdWxsaW5nLCBpLmUuLCBleGNsdWRpbmcgaW52aXNpYmxlIHRpbGVzIGZyb20gdGhlXG4gKiByZW5kZXJpbmcgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzNbXX0gcmVjdGFuZ2xlIFRoZSB2ZXJ0aWNlcyBvZiB0aGUgcmVjdGFuZ2xlLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG5cbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiBhbnkgb2YgdGhlIGZydXN0dW1cbiAgLy8gcGxhbmVzLiBUaGlzIGlzIGEgc3VmZmljaWVudCBjb25kaXRpb24sIHRob3VnaCBub3QgbmVjZXNzYXJ5LCBmb3IgdGhlXG4gIC8vIHJlY3RhbmdsZSB0byBiZSBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIGZydW91dGVyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJ1c3R1bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW1pdCA9IGZydXN0dW1baV07XG4gICAgdmFyIGF4aXMgPSBwbGFuZUF4ZXNbaV07XG4gICAgdmFyIGNtcCA9IHBsYW5lQ21wW2ldO1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY3RhbmdsZS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHZlcnRleCA9IHJlY3RhbmdsZVtqXTtcbiAgICAgIGlmIChjbXAgPCAwICYmIHZlcnRleFtheGlzXSA8IGxpbWl0IHx8IGNtcCA+IDAgJiYgdmVydGV4W2F4aXNdID4gbGltaXQpIHtcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdCB0aGUgbGV2ZWwgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge0xldmVsW119IGxldmVsTGlzdCB0aGUgbGlzdCBvZiBsZXZlbHMgZnJvbSB3aGljaCB0byBzZWxlY3QuXG4gKiBAcmV0dXJuIHtMZXZlbH0gdGhlIHNlbGVjdGVkIGxldmVsLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2VsZWN0TGV2ZWwgPSBmdW5jdGlvbihsZXZlbHMpIHtcblxuICAvLyBNdWx0aXBseSB0aGUgdmlld3BvcnQgd2lkdGggYnkgdGhlIGRldmljZSBwaXhlbCByYXRpbyB0byBnZXQgdGhlIHJlcXVpcmVkXG4gIC8vIGhvcml6b250YWwgcmVzb2x1dGlvbiBpbiBwaXhlbHMuXG4gIC8vXG4gIC8vIENhbGN1bGF0ZSB0aGUgZnJhY3Rpb24gb2YgdGhlIGltYWdlIHRoYXQgd291bGQgYmUgdmlzaWJsZSBhdCB0aGUgY3VycmVudFxuICAvLyB6b29tIHZhbHVlLiBUaGVuLCBmb3IgZWFjaCBsZXZlbCwgbXVsdGlwbHkgYnkgdGhlIGxldmVsIHdpZHRoIHRvIGdldCB0aGVcbiAgLy8gd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBwb3J0aW9uIHRoYXQgd291bGQgYmUgdmlzaWJsZS5cbiAgLy9cbiAgLy8gU2VhcmNoIGZvciB0aGUgc21hbGxlc3QgbGV2ZWwgdGhhdCBzYXRpZmllcyB0aGUgdGhlIHJlcXVpcmVkIHdpZHRoLFxuICAvLyBmYWxsaW5nIGJhY2sgb24gdGhlIGxhcmdlc3QgbGV2ZWwgaWYgbm9uZSBkby5cblxuICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiB0aGlzLndpZHRoKCk7XG4gIHZhciB6b29tRmFjdG9yID0gdGhpcy5fem9vbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICBpZiAoem9vbUZhY3RvciAqIGxldmVsLndpZHRoKCkgPj0gcmVxdWlyZWRQaXhlbHMpIHtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV2ZWxzW2xldmVscy5sZW5ndGggLSAxXTtcblxufTtcblxuXG4vKipcbiAqIENvbnZlcnQgdmlldyBjb29yZGluYXRlcyBpbnRvIHNjcmVlbiBjb29yZGluYXRlcy4gSWYgYSByZXN1bHQgYXJndW1lbnQgaXNcbiAqIHByb3ZpZGVkLCBpdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZFxuICogaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7RmxhdFZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Q29vcmRzPX0gcmVzdWx0IFRoZSByZXN1bHQgYXJndW1lbnQgZm9yIHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtDb29yZHN9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlc1RvU2NyZWVuID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3ZlYztcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9XG5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgLy8gVW5kZWZpbmVkIG9uIGEgbnVsbCB2aWV3cG9ydC5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXN1bHQueCA9IG51bGw7XG4gICAgcmVzdWx0LnkgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyBmcm9tIGFyZ3VtZW50LCBmaWxsaW5nIGluIGRlZmF1bHQgdmFsdWVzLlxuICB2YXIgeCA9IGNvb3JkcyAmJiBjb29yZHMueCAhPSBudWxsID8gY29vcmRzLnggOiBkZWZhdWx0WDtcbiAgdmFyIHkgPSBjb29yZHMgJiYgY29vcmRzLnkgIT0gbnVsbCA/IGNvb3Jkcy55IDogZGVmYXVsdFk7XG5cbiAgLy8gUHJvamVjdCB2aWV3IHJheSBvbnRvIGNsaXAgc3BhY2UuXG4gIHZlYzQuc2V0KHJheSwgeCAtIDAuNSwgMC41IC0geSwgLTEsIDEpO1xuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMucHJvamVjdGlvbigpKTtcblxuICAvLyBDYWxjdWxhdGUgcGVyc3BlY3RpdmUgZGl2aWRlLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJheVtpXSAvPSByYXlbM107XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGFuZCByZXR1cm4uXG4gIHJlc3VsdC54ID0gd2lkdGggKiAocmF5WzBdICsgMSkgLyAyO1xuICByZXN1bHQueSA9IGhlaWdodCAqICgxIC0gcmF5WzFdKSAvIDI7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHNjcmVlbiBjb29yZGluYXRlcyBpbnRvIHZpZXcgY29vcmRpbmF0ZXMuIElmIGEgcmVzdWx0IGFyZ3VtZW50IGlzXG4gKiBwcm92aWRlZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaFxuICogb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtDb29yZHN9IGNvb3JkcyBUaGUgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtGbGF0Vmlld0Nvb3Jkcz19IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0ZsYXRWaWV3Q29vcmRzfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2NyZWVuVG9Db29yZGluYXRlcyA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gY2xpcCBzcGFjZS5cbiAgdmFyIHZlY3ggPSAyICogY29vcmRzLnggLyB3aWR0aCAtIDE7XG4gIHZhciB2ZWN5ID0gMSAtIDIgKiBjb29yZHMueSAvIGhlaWdodDtcbiAgdmVjNC5zZXQocmF5LCB2ZWN4LCB2ZWN5LCAxLCAxKTtcblxuICAvLyBQcm9qZWN0IGJhY2sgdG8gd29ybGQgc3BhY2UuXG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgdGhpcy5pbnZlcnNlUHJvamVjdGlvbigpKTtcblxuICAvLyBDb252ZXJ0IHRvIGZsYXQgY29vcmRpbmF0ZXMuXG4gIHJlc3VsdC54ID0gMC41ICsgcmF5WzBdO1xuICByZXN1bHQueSA9IDAuNSAtIHJheVsxXTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb25zIGZvciB2aWV3IGxpbWl0ZXJzLiBTZWUge0BsaW5rIEZsYXRWaWV3TGltaXRlcn0uXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkZsYXRWaWV3LmxpbWl0ID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgeCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0geCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB5IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB4OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFgocGFyYW1zKSB7XG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHkgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgeTogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRZKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnkgPSBjbGFtcChwYXJhbXMueSwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYW4gY29uc3RyYWlucyB0aGUgem9vbSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gem9vbSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB6b29tIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB6b29tOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFpvb20ocGFyYW1zKSB7XG4gICAgICBwYXJhbXMuem9vbSA9IGNsYW1wKHBhcmFtcy56b29tLCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBwcmV2ZW50cyB6b29taW5nIGluIGJleW9uZCB0aGUgZ2l2ZW5cbiAgICogcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIGltYWdlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcmVzb2x1dGlvbjogZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFJlc29sdXRpb24ocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLndpZHRoIDw9IDAgfHwgcGFyYW1zLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICB9XG4gICAgICB2YXIgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICB2YXIgbWluWm9vbSA9IHBpeGVsUmF0aW8oKSAqIHdpZHRoIC8gc2l6ZTtcbiAgICAgIHBhcmFtcy56b29tID0gY2xhbXAocGFyYW1zLnpvb20sIG1pblpvb20sIEluZmluaXR5KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHZhbHVlcyBvZiB0aGUgeCBwYXJhbWV0ZXIgdGhhdFxuICAgKiBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB4IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHggdmFsdWUuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIHZpc2libGVYOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFZpc2libGVYKHBhcmFtcykge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB6b29tIHZhbHVlIHRoYXQgbWFrZXMgdGhlIHNwZWNpZmllZCByYW5nZSBmdWxseSB2aXNpYmxlLlxuICAgICAgdmFyIG1heFpvb20gPSBtYXggLSBtaW47XG5cbiAgICAgIC8vIENsYW1wIHpvb20gdG8gdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICBpZiAocGFyYW1zLnpvb20gPiBtYXhab29tKSB7XG4gICAgICAgIHBhcmFtcy56b29tID0gbWF4Wm9vbTtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgWCBzdWNoIHRoYXQgdGhlIGltYWdlIGlzIHZpc2libGUgdXAgdG8gdGhlIHJhbmdlIGVkZ2VzLlxuICAgICAgdmFyIG1pblggPSBtaW4gKyAwLjUgKiBwYXJhbXMuem9vbTtcbiAgICAgIHZhciBtYXhYID0gbWF4IC0gMC41ICogcGFyYW1zLnpvb207XG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW5YLCBtYXhYKTtcblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgdmFsdWVzIG9mIHRoZSB5IHBhcmFtZXRlciB0aGF0XG4gICAqIGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgdmlzaWJsZVk6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0VmlzaWJsZVkocGFyYW1zKSB7XG5cbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGEgbnVsbCB2aWV3cG9ydC5cbiAgICAgIGlmIChwYXJhbXMud2lkdGggPD0gMCB8fCBwYXJhbXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBYIHRvIFkgY29udmVyc2lvbiBmYWN0b3IuXG4gICAgICB2YXIgdmlld3BvcnRBc3BlY3RSYXRpbyA9IHBhcmFtcy53aWR0aCAvIHBhcmFtcy5oZWlnaHQ7XG4gICAgICB2YXIgZmFjdG9yID0gdmlld3BvcnRBc3BlY3RSYXRpbyAvIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHpvb20gdmFsdWUgdGhhdCBtYWtlcyB0aGUgc3BlY2lmaWVkIHJhbmdlIGZ1bGx5IHZpc2libGUuXG4gICAgICB2YXIgbWF4Wm9vbSA9IChtYXggLSBtaW4pICogZmFjdG9yO1xuXG4gICAgICAvLyBDbGFtcCB6b29tIHRvIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAgaWYgKHBhcmFtcy56b29tID4gbWF4Wm9vbSkge1xuICAgICAgICBwYXJhbXMuem9vbSA9IG1heFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIFkgc3VjaCB0aGF0IHRoZSBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSByYW5nZSBlZGdlcy5cbiAgICAgIHZhciBtaW5ZID0gbWluICsgMC41ICogcGFyYW1zLnpvb20gLyBmYWN0b3I7XG4gICAgICB2YXIgbWF4WSA9IG1heCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZmFjdG9yO1xuICAgICAgcGFyYW1zLnkgPSBjbGFtcChwYXJhbXMueSwgbWluWSwgbWF4WSk7XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgem9vbSBwYXJhbWV0ZXIgc3VjaCB0aGF0XG4gICAqIHpvb21pbmcgb3V0IGlzIHByZXZlbnRlZCBiZXlvbmQgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBpbWFnZSBpcyBmdWxseVxuICAgKiB2aXNpYmxlLiBVbmxlc3MgdGhlIGltYWdlIGFuZCB0aGUgdmlld3BvcnQgaGF2ZSB0aGUgc2FtZSBhc3BlY3QgcmF0aW8sXG4gICAqIHRoaXMgd2lsbCBjYXVzZSBiYW5kcyB0byBhcHBlYXIgYXJvdW5kIHRoZSBpbWFnZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgbGV0dGVyYm94OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRMZXR0ZXJib3gocGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMud2lkdGggPD0gMCB8fCBwYXJhbXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3cG9ydEFzcGVjdFJhdGlvID0gcGFyYW1zLndpZHRoIC8gcGFyYW1zLmhlaWdodDtcblxuICAgICAgdmFyIGZ1bGxXaWR0aFpvb20gPSAxLjA7XG4gICAgICB2YXIgZnVsbEhlaWdodFpvb20gPSB2aWV3cG9ydEFzcGVjdFJhdGlvIC8gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG5cbiAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyB3aWRlciB0aGFuIHRoZSB2aWV3cG9ydCwgbGltaXQgdGhlIGhvcml6b250YWwgem9vbSB0b1xuICAgICAgLy8gdGhlIGltYWdlIHdpZHRoLlxuICAgICAgaWYgKHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID49IHZpZXdwb3J0QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgcGFyYW1zLnpvb20gPSBNYXRoLm1pbihwYXJhbXMuem9vbSwgZnVsbFdpZHRoWm9vbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyBuYXJyb3dlciB0aGFuIHRoZSB2aWV3cG9ydCwgbGltaXQgdGhlIHZlcnRpY2FsIHpvb20gdG9cbiAgICAgIC8vIHRoZSBpbWFnZSBoZWlnaHQuXG4gICAgICBpZiAocGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPD0gdmlld3BvcnRBc3BlY3RSYXRpbykge1xuICAgICAgICBwYXJhbXMuem9vbSA9IE1hdGgubWluKHBhcmFtcy56b29tLCBmdWxsSGVpZ2h0Wm9vbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmdWxsIGltYWdlIHdpZHRoIGlzIHZpc2libGUsIGxpbWl0IHggdG8gdGhlIGNlbnRyYWwgcG9pbnQuXG4gICAgICAvLyBFbHNlLCBib3VuZCB4IHN1Y2ggdGhhdCBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSBob3Jpem9udGFsIGVkZ2VzLlxuICAgICAgdmFyIG1pblgsIG1heFg7XG4gICAgICBpZiAocGFyYW1zLnpvb20gPiBmdWxsV2lkdGhab29tKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluWCA9IDAuMCArIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbFdpZHRoWm9vbTtcbiAgICAgICAgbWF4WCA9IDEuMCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbFdpZHRoWm9vbTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZ1bGwgaW1hZ2UgaGVpZ2h0IGlzIHZpc2libGUsIGxpbWl0IHkgdG8gdGhlIGNlbnRyYWwgcG9pbnQuXG4gICAgICAvLyBFbHNlLCBib3VuZCB5IHN1Y2ggdGhhdCBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSB2ZXJ0aWNhbCBlZGdlcy5cbiAgICAgIHZhciBtaW5ZLCBtYXhZO1xuICAgICAgaWYgKHBhcmFtcy56b29tID4gZnVsbEhlaWdodFpvb20pIHtcbiAgICAgICAgbWluWSA9IG1heFkgPSAwLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5ZID0gMC4wICsgMC41ICogcGFyYW1zLnpvb20gLyBmdWxsSGVpZ2h0Wm9vbTtcbiAgICAgICAgbWF4WSA9IDEuMCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbEhlaWdodFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIENsYW1wIHggYW5kIHkgaW50byB0aGUgY2FsY3VsYXRlZCBib3VuZHMuXG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW5YLCBtYXhYKTtcbiAgICAgIHBhcmFtcy55ID0gY2xhbXAocGFyYW1zLnksIG1pblksIG1heFkpO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH1cblxufTtcblxuXG5GbGF0Vmlldy50eXBlID0gRmxhdFZpZXcucHJvdG90eXBlLnR5cGUgPSAnZmxhdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGbGF0VmlldztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0O1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcbnZhciBjb252ZXJ0Rm92ID0gcmVxdWlyZSgnLi4vdXRpbC9jb252ZXJ0Rm92Jyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcbnZhciByZWFsID0gcmVxdWlyZSgnLi4vdXRpbC9yZWFsJyk7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgZGVjaW1hbCA9IHJlcXVpcmUoJy4uL3V0aWwvZGVjaW1hbCcpO1xudmFyIGNvbXBvc2UgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvc2UnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBEZWZhdWx0IHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4vLyBTdGFydCB3aXRoIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhvc2UgdmFsdWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbnZhciBkZWZhdWx0V2lkdGggPSAwO1xudmFyIGRlZmF1bHRIZWlnaHQgPSAwO1xuXG4vLyBEZWZhdWx0IHZpZXcgcGFyYW1ldGVycy5cbnZhciBkZWZhdWx0WWF3ID0gMDtcbnZhciBkZWZhdWx0UGl0Y2ggPSAwO1xudmFyIGRlZmF1bHRSb2xsID0gMDtcbnZhciBkZWZhdWx0Rm92ID0gTWF0aC5QSS80O1xudmFyIGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWCA9IDA7XG52YXIgZGVmYXVsdFByb2plY3Rpb25DZW50ZXJZID0gMDtcbnZhciBkZWZhdWx0VHggPSAwO1xudmFyIGRlZmF1bHRUeSA9IDA7XG52YXIgZGVmYXVsdFR6ID0gMDtcbnZhciBkZWZhdWx0T3ggPSAwO1xudmFyIGRlZmF1bHRPeSA9IDA7XG52YXIgZGVmYXVsdE96ID0gMDtcblxuLy8gQSBmb3Ygb2YgZXhhY3RseSAwIG9yIM+AIGJyZWFrcyBzb21lIGNvbXB1dGF0aW9ucywgc28gd2UgY29uc3RyYWluIGl0IHRvIHRoZVxuLy8gW2ZvdkxpbWl0RXBzaWxvbiwgz4AgLSBmb3ZMaW1pdEVwc2lsb25dIGludGVydmFsLiBXZSB1c2UgNiBkZWNpbWFsIHBsYWNlcyBmb3Jcbi8vIHRoZSBlcHNpbG9uIHZhbHVlIHRvIGF2b2lkIGJyb2tlbiByZW5kZXJpbmcgZHVlIHRvIGxvc3Mgb2YgcHJlY2lzaW9uIGluXG4vLyBmbG9hdGluZyBwb2ludCBjb21wdXRhdGlvbnMuXG52YXIgZm92TGltaXRFcHNpbG9uID0gMC4wMDAwMDE7XG5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIFJlY3RpbGluZWFyVmlld1BhcmFtc1xuICpcbiAqIEEgY2FtZXJhIGNvbmZpZ3VyYXRpb24gZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHlhdyBUaGUgeWF3IGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICogICAgIFdoZW4gYHlhdyA8IDBgLCB0aGUgdmlldyByb3RhdGVzIHRvIHRoZSBsZWZ0LlxuICogICAgIFdoZW4gYHlhdyA+IDBgLCB0aGUgdmlldyByb3RhdGVzIHRvIHRoZSByaWdodC5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl0Y2ggVGhlIHBpdGNoIGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICogICAgIFdoZW4gYHBpdGNoIDwgMGAsIHRoZSB2aWV3IHJvdGF0ZXMgZG93bndhcmRzLlxuICogICAgIFdoZW4gYHBpdGNoID4gMGAsIHRoZSB2aWV3IHJvdGF0ZXMgdXB3YXJkcy5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm9sbCBUaGUgcm9sbCBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqICAgICBXaGVuIGByb2xsIDwgMGAsIHRoZSB2aWV3IHJvdGF0ZXMgY2xvY2t3aXNlLlxuICogICAgIFdoZW4gYHJvbGwgPiAwYCwgdGhlIHZpZXcgcm90YXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqXG4gKiBAcHJvcGVydHkge2Zvdn0gZm92IFRoZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LCBpbiB0aGUgWzAsIM+AXSByYW5nZS5cbiAqL1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBSZWN0aWxpbmVhclZpZXdDb29yZHNcbiAqXG4gKiBUaGUgcG9zaXRpb24gb2YgYSBwb2ludCBpbiBhIDM2MMKwIGltYWdlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5YXcgVGhlIHlhdyBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXRjaCBUaGUgcGl0Y2ggYW5nbGUsIGluIHRoZSBbLc+ALCDPgF0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gUmVjdGlsaW5lYXJWaWV3TGltaXRlclxuICpcbiAqIFZpZXcgbGltaXRlciBmb3IgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fS5cbiAqXG4gKiBBIHZpZXcgbGltaXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3UGFyYW1zfVxuICogb2JqZWN0LCBvcHRpb25hbGx5IG1vZGlmaWVzIGl0IGluIHBsYWNlLCBhbmQgcmV0dXJucyBpdC4gSXQgY2FuIGJlIHVzZWQgdG9cbiAqIGVuZm9yY2UgY29uc3RyYWludHMgb24gdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBTZWUge0BsaW5rIFJlY3RpbGluZWFyVmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWQgbGltaXRlcnMuIFRoZXkgbWF5IGJlXG4gKiBjb21wb3NlZCB0b2dldGhlciBvciB3aXRoIHVzZXItZGVmaW5lZCBsaW1pdGVycyB3aXRoIHtAbGluayB1dGlsLmNvbXBvc2V9LlxuICpcbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zfSBwYXJhbXNcbiAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld1BhcmFtc31cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBSZWN0aWxpbmVhclZpZXdcbiAqIEBpbXBsZW1lbnRzIFZpZXdcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBWaWV3fSBpbXBsZW1lbnRpbmcgYSByZWN0aWxpbmVhciBwcm9qZWN0aW9uIGZvciAzNjDCsCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdQYXJhbXM9fSBwYXJhbXMgVGhlIGluaXRpYWwgdmlldyBwYXJhbWV0ZXJzLiBJZlxuICogICAgIHVuc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBge3lhdzogMCwgcGl0Y2g6IDAsIHJvbGw6IDAsIGZvdjogTWF0aC5QSS80IH1gLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyPX0gbGltaXRlciBUaGUgdmlldyBsaW1pdGVyLiBJZiB1bnNwZWNpZmllZCxcbiAqICAgICBubyB2aWV3IGxpbWl0aW5nIGlzIGFwcGxpZWQuIFNlZSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3LmxpbWl0fSBmb3JcbiAqICAgICBjb21tb25seSB1c2VkIGxpbWl0ZXJzLlxuICovXG5mdW5jdGlvbiBSZWN0aWxpbmVhclZpZXcocGFyYW1zLCBsaW1pdGVyKSB7XG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAgdGhpcy5feWF3ID0gcGFyYW1zICYmIHBhcmFtcy55YXcgIT0gbnVsbCA/IHBhcmFtcy55YXcgOiBkZWZhdWx0WWF3O1xuICB0aGlzLl9waXRjaCA9IHBhcmFtcyAmJiBwYXJhbXMucGl0Y2ggIT0gbnVsbCA/IHBhcmFtcy5waXRjaCA6IGRlZmF1bHRQaXRjaDtcbiAgdGhpcy5fcm9sbCA9IHBhcmFtcyAmJiBwYXJhbXMucm9sbCAhPSBudWxsID8gcGFyYW1zLnJvbGwgOiBkZWZhdWx0Um9sbDtcbiAgdGhpcy5fZm92ID0gcGFyYW1zICYmIHBhcmFtcy5mb3YgIT0gbnVsbCA/IHBhcmFtcy5mb3YgOiBkZWZhdWx0Rm92O1xuICB0aGlzLl93aWR0aCA9IHBhcmFtcyAmJiBwYXJhbXMud2lkdGggIT0gbnVsbCA/XG4gICAgcGFyYW1zLndpZHRoIDogZGVmYXVsdFdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBwYXJhbXMgJiYgcGFyYW1zLmhlaWdodCAhPSBudWxsID9cbiAgICBwYXJhbXMuaGVpZ2h0IDogZGVmYXVsdEhlaWdodDtcbiAgdGhpcy5fcHJvamVjdGlvbkNlbnRlclggPSBwYXJhbXMgJiYgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA6IGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fcHJvamVjdGlvbkNlbnRlclkgPSBwYXJhbXMgJiYgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA6IGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWTtcblxuICAvLyBBIDNEIHRyYW5zbGF0aW9uIG9mIHRoZSB2aWV3cG9pbnQuXG4gIHRoaXMuX3R4ID0gcGFyYW1zICYmIHBhcmFtcy50eCAhPSBudWxsID8gcGFyYW1zLnR4IDogZGVmYXVsdFR4O1xuICB0aGlzLl90eSA9IHBhcmFtcyAmJiBwYXJhbXMudHkgIT0gbnVsbCA/IHBhcmFtcy50eSA6IGRlZmF1bHRUeTtcbiAgdGhpcy5fdHogPSBwYXJhbXMgJiYgcGFyYW1zLnR6ICE9IG51bGwgPyBwYXJhbXMudHogOiBkZWZhdWx0VHo7XG5cbiAgLy8gQW4gYWRkaXRpb25hbCAzRCB0cmFuc2xhdGlvbiBvZmZzZXQgb2YgdGhlIHZpZXdwb2ludC4gXG4gIC8vIEJ1dCB0aGUgdmlld2luZyByb3RhdGlvbiB3aWxsIGJlIHN0aWxsIGZyb20gdGhlIG5vbi1vZmZzZXQgcG9pbnQuXG4gIHRoaXMuX294ID0gcGFyYW1zICYmIHBhcmFtcy5veCAhPSBudWxsID8gcGFyYW1zLm94IDogZGVmYXVsdE94O1xuICB0aGlzLl9veSA9IHBhcmFtcyAmJiBwYXJhbXMub3kgIT0gbnVsbCA/IHBhcmFtcy5veSA6IGRlZmF1bHRPeTtcbiAgdGhpcy5fb3ogPSBwYXJhbXMgJiYgcGFyYW1zLm96ICE9IG51bGwgPyBwYXJhbXMub3ogOiBkZWZhdWx0T3o7XG5cbiAgLy8gSW52ZXJ0IGNvbnRyb2wuXG4gIHRoaXMuX2ludmVydENvbnRyb2wgPSBwYXJhbXMgJiYgcGFyYW1zLmludmVydENvbnRyb2wgIT0gbnVsbCA/IHBhcmFtcy5pbnZlcnRDb250cm9sIDogZmFsc2U7XG5cbiAgLy8gVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSB2aWV3IGxpbWl0ZXIuXG4gIHRoaXMuX2xpbWl0ZXIgPSBsaW1pdGVyIHx8IG51bGw7XG5cbiAgLy8gVGhlIGxhc3QgY2FsY3VsYXRlZCBwcm9qZWN0aW9uIG1hdHJpeCBhbmQgaXRzIGludmVyc2UuXG4gIHRoaXMuX3Byb2pNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICB0aGlzLl9pbnZQcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUaGUgbGFzdCBjYWxjdWxhdGVkIHZpZXcgbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgdGhpcy5fdmlld01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIHRoaXMuX2ludlZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgdmlldyBmcnVzdHVtLlxuICB0aGlzLl9mcnVzdHVtID0gW1xuICAgIHZlYzQuY3JlYXRlKCksIC8vIGxlZnRcbiAgICB2ZWM0LmNyZWF0ZSgpLCAvLyByaWdodFxuICAgIHZlYzQuY3JlYXRlKCksIC8vIGJvdHRvbVxuICAgIHZlYzQuY3JlYXRlKCksIC8vIHRvcFxuICAgIHZlYzQuY3JlYXRlKCkgIC8vIGNhbWVyYVxuICBdO1xuXG4gIC8vIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gbWF0cmljZXMgYW5kIHRoZSB2aWV3IGZydXN0dW0gbmVlZCB0byBiZSB1cGRhdGVkLlxuICB0aGlzLl9tYXRyaXhDaGFuZ2VkID0gdHJ1ZTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGVzIHVzZWQgZm9yIGNhbGN1bGF0aW9ucy5cbiAgdGhpcy5fcGFyYW1zID0ge307XG4gIHRoaXMuX2ZvdnMgPSB7fTtcbiAgdGhpcy5fdG1wVmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAvLyBGb3JjZSB2aWV3IGxpbWl0aW5nIG9uIGluaXRpYWwgcGFyYW1ldGVycy5cbiAgdGhpcy5fdXBkYXRlKCk7XG59XG5cbmV2ZW50RW1pdHRlcihSZWN0aWxpbmVhclZpZXcpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHlhdyBhbmdsZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS55YXcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3lhdztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHBpdGNoIGFuZ2xlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnBpdGNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9waXRjaDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJvbGwgYW5nbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucm9sbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcm9sbDtcbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5wcm9qZWN0aW9uQ2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcHJvamVjdGlvbkNlbnRlclg7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbkNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZvdiB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5mb3YgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Zvdjtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IHdpZHRoLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9pbnQncyB0eC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS50eCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdHg7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvaW50J3MgdHkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUudHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3R5O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb2ludCdzIHR6LlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnR6ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90ejtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9pbnQncyBveC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5veCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fb3g7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvaW50J3Mgb3kuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub3kgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX295O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb2ludCdzIHR6LlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm96ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9vejtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnQgY29udHJvbCBmbGFnLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5pbnZlcnRDb250cm9sID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbnZlcnRDb250cm9sO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U2l6ZT19IHNpemVcbiAqIEByZXR1cm4ge1NpemV9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgc2l6ZSA9IHNpemUgfHwge307XG4gIHNpemUud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgc2l6ZS5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gIHJldHVybiBzaXplO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBwYXJhbWV0ZXJzLiBJZiBhbiBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlXG4gKiByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld1BhcmFtcz19IG9ialxuICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMueWF3ID0gdGhpcy5feWF3O1xuICBwYXJhbXMucGl0Y2ggPSB0aGlzLl9waXRjaDtcbiAgcGFyYW1zLnJvbGwgPSB0aGlzLl9yb2xsO1xuICBwYXJhbXMuZm92ID0gdGhpcy5fZm92O1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBsaW1pdGVyLCBvciBudWxsIGlmIHVuc2V0LlxuICogQHJldHVybiB7P1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUubGltaXRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGltaXRlcjtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHlhdyBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5YXdcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRZYXcgPSBmdW5jdGlvbih5YXcpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnlhdyA9IHlhdztcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBwaXRjaCBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFBpdGNoID0gZnVuY3Rpb24ocGl0Y2gpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnBpdGNoID0gcGl0Y2g7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcm9sbCBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb2xsXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0Um9sbCA9IGZ1bmN0aW9uKHJvbGwpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnJvbGwgPSByb2xsO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGZvdiB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRGb3YgPSBmdW5jdGlvbihmb3YpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLmZvdiA9IGZvdjtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UHJvamVjdGlvbkNlbnRlclggPSBmdW5jdGlvbihwcm9qZWN0aW9uQ2VudGVyWCkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclggPSBwcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UHJvamVjdGlvbkNlbnRlclkgPSBmdW5jdGlvbihwcm9qZWN0aW9uQ2VudGVyWSkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclkgPSBwcm9qZWN0aW9uQ2VudGVyWTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogQWRkIHlhd09mZnNldCB0byB0aGUgY3VycmVudCB5YXcgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0geWF3T2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0WWF3ID0gZnVuY3Rpb24oeWF3T2Zmc2V0KSB7XG4gIHRoaXMuc2V0WWF3KHRoaXMuX3lhdyArIHlhd09mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHBpdGNoT2Zmc2V0IHRvIHRoZSBjdXJyZW50IHBpdGNoIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoT2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0UGl0Y2ggPSBmdW5jdGlvbihwaXRjaE9mZnNldCkge1xuICB0aGlzLnNldFBpdGNoKHRoaXMuX3BpdGNoICsgcGl0Y2hPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZCByb2xsT2Zmc2V0IHRvIHRoZSBjdXJyZW50IHJvbGwgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gcm9sbE9mZnNldFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm9mZnNldFJvbGwgPSBmdW5jdGlvbihyb2xsT2Zmc2V0KSB7XG4gIHRoaXMuc2V0Um9sbCh0aGlzLl9yb2xsICsgcm9sbE9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIGZvdk9mZnNldCB0byB0aGUgY3VycmVudCBmb3YgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZm92T2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0Rm92ID0gZnVuY3Rpb24oZm92T2Zmc2V0KSB7XG4gIHRoaXMuc2V0Rm92KHRoaXMuX2ZvdiArIGZvdk9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtTaXplfSBzaXplXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgdGhpcy5fcGFyYW1zLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9pbnQncyB0eC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFR4ID0gZnVuY3Rpb24odHgpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnR4ID0gdHg7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvaW50J3MgdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gdHlcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRUeSA9IGZ1bmN0aW9uKHR5KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy50eSA9IHR5O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXdwb2ludCdzIHR6LlxuICogQHBhcmFtIHtudW1iZXJ9IHR6XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0VHogPSBmdW5jdGlvbih0eikge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMudHogPSB0ejtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9pbnQncyBveC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0eFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldE94ID0gZnVuY3Rpb24ob3gpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLm94ID0gb3g7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvaW50J3Mgb3kuXG4gKiBAcGFyYW0ge251bWJlcn0gb3lcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRPeSA9IGZ1bmN0aW9uKG95KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy5veSA9IG95O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXdwb2ludCdzIG96LlxuICogQHBhcmFtIHtudW1iZXJ9IG96XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0T3ogPSBmdW5jdGlvbihveikge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMub3ogPSBvejtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnQgY29udHJvbCBmbGFnLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRJbnZlcnRDb250cm9sID0gZnVuY3Rpb24oaW52ZXJ0Q29udHJvbCkge1xuICB0aGlzLl9pbnZlcnRDb250cm9sID0gaW52ZXJ0Q29udHJvbDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB2aWV3IHBhcmFtZXRlcnMuIFVuc3BlY2lmaWVkIHBhcmFtZXRlcnMgYXJlIGxlZnQgdW5jaGFuZ2VkLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdQYXJhbWV0ZXJzfSBwYXJhbXNcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy55YXcgPSBwYXJhbXMueWF3O1xuICB0aGlzLl9wYXJhbXMucGl0Y2ggPSBwYXJhbXMucGl0Y2g7XG4gIHRoaXMuX3BhcmFtcy5yb2xsID0gcGFyYW1zLnJvbGw7XG4gIHRoaXMuX3BhcmFtcy5mb3YgPSBwYXJhbXMuZm92O1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclggPSBwYXJhbXMucHJvamVjdGlvbkNlbnRlclg7XG4gIHRoaXMuX3BhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB2aWV3IGxpbWl0ZXIuXG4gKiBAcGFyYW0gez9SZWN0aWxpbmVhclZpZXdMaW1pdGVyfSBsaW1pdGVyIFRoZSBuZXcgbGltaXRlciwgb3IgbnVsbCB0byB1bnNldC5cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRMaW1pdGVyID0gZnVuY3Rpb24obGltaXRlcikge1xuICB0aGlzLl9saW1pdGVyID0gbGltaXRlciB8fCBudWxsO1xuICB0aGlzLl91cGRhdGUoKTtcbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5fcmVzZXRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMuX3BhcmFtcztcbiAgcGFyYW1zLnlhdyA9IG51bGw7XG4gIHBhcmFtcy5waXRjaCA9IG51bGw7XG4gIHBhcmFtcy5yb2xsID0gbnVsbDtcbiAgcGFyYW1zLmZvdiA9IG51bGw7XG4gIHBhcmFtcy53aWR0aCA9IG51bGw7XG4gIHBhcmFtcy5oZWlnaHQgPSBudWxsO1xuICBwYXJhbXMucG9zaXRpb24gPSBudWxsO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICAvLyBBdm9pZCBvYmplY3QgYWxsb2NhdGlvbiB3aGVuIG5vIHBhcmFtZXRlcnMgYXJlIHN1cHBsaWVkLlxuICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICAgIHBhcmFtcyA9IHRoaXMuX3BhcmFtcztcbiAgfVxuXG4gIC8vIFNhdmUgb2xkIHBhcmFtZXRlcnMgZm9yIGxhdGVyIGNvbXBhcmlzb24uXG4gIHZhciBvbGRZYXcgPSB0aGlzLl95YXc7XG4gIHZhciBvbGRQaXRjaCA9IHRoaXMuX3BpdGNoO1xuICB2YXIgb2xkUm9sbCA9IHRoaXMuX3JvbGw7XG4gIHZhciBvbGRGb3YgPSB0aGlzLl9mb3Y7XG4gIHZhciBvbGRQcm9qZWN0aW9uQ2VudGVyWCA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xuICB2YXIgb2xkUHJvamVjdGlvbkNlbnRlclkgPSB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWTtcbiAgdmFyIG9sZFdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBvbGRIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gIFxuICB2YXIgb2xkVHggPSB0aGlzLl90eDtcbiAgdmFyIG9sZFR5ID0gdGhpcy5fdHk7XG4gIHZhciBvbGRUeiA9IHRoaXMuX3R6O1xuICB2YXIgb2xkT3ggPSB0aGlzLl9veDtcbiAgdmFyIG9sZE95ID0gdGhpcy5fb3k7XG4gIHZhciBvbGRPeiA9IHRoaXMuX296O1xuXG4gIC8vIEZpbGwgaW4gb2JqZWN0IHdpdGggdGhlIG5ldyBzZXQgb2YgcGFyYW1ldGVycyB0byBwYXNzIGludG8gdGhlIGxpbWl0ZXIuXG4gIHBhcmFtcy55YXcgPSBwYXJhbXMueWF3ICE9IG51bGwgPyBwYXJhbXMueWF3IDogb2xkWWF3O1xuICBwYXJhbXMucGl0Y2ggPSBwYXJhbXMucGl0Y2ggIT0gbnVsbCA/IHBhcmFtcy5waXRjaCA6IG9sZFBpdGNoO1xuICBwYXJhbXMucm9sbCA9IHBhcmFtcy5yb2xsICE9IG51bGwgPyBwYXJhbXMucm9sbCA6IG9sZFJvbGw7XG4gIHBhcmFtcy5mb3YgPSBwYXJhbXMuZm92ICE9IG51bGwgPyBwYXJhbXMuZm92IDogb2xkRm92O1xuICBwYXJhbXMud2lkdGggPSBwYXJhbXMud2lkdGggIT0gbnVsbCA/IHBhcmFtcy53aWR0aCA6IG9sZFdpZHRoO1xuICBwYXJhbXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCAhPSBudWxsID8gcGFyYW1zLmhlaWdodCA6IG9sZEhlaWdodDtcbiAgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA6IG9sZFByb2plY3Rpb25DZW50ZXJYO1xuICBwYXJhbXMucHJvamVjdGlvbkNlbnRlclkgPSBwYXJhbXMucHJvamVjdGlvbkNlbnRlclkgIT0gbnVsbCA/XG4gICAgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZIDogb2xkUHJvamVjdGlvbkNlbnRlclk7XG5cbiAgcGFyYW1zLnR4ID0gcGFyYW1zLnR4ICE9IG51bGwgPyBwYXJhbXMudHggOiBvbGRUeDtcbiAgcGFyYW1zLnR5ID0gcGFyYW1zLnR5ICE9IG51bGwgPyBwYXJhbXMudHkgOiBvbGRUeTtcbiAgcGFyYW1zLnR6ID0gcGFyYW1zLnR6ICE9IG51bGwgPyBwYXJhbXMudHogOiBvbGRUejtcbiAgcGFyYW1zLm94ID0gcGFyYW1zLm94ICE9IG51bGwgPyBwYXJhbXMub3ggOiBvbGRPeDtcbiAgcGFyYW1zLm95ID0gcGFyYW1zLm95ICE9IG51bGwgPyBwYXJhbXMub3kgOiBvbGRPeTtcbiAgcGFyYW1zLm96ID0gcGFyYW1zLm96ICE9IG51bGwgPyBwYXJhbXMub3ogOiBvbGRPejtcblxuICAvLyBBcHBseSB2aWV3IGxpbWl0aW5nIHdoZW4gZGVmaW5lZC5cbiAgaWYgKHRoaXMuX2xpbWl0ZXIpIHtcbiAgICBwYXJhbXMgPSB0aGlzLl9saW1pdGVyKHBhcmFtcyk7XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgbGltaXRlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICBwYXJhbXMgPSB0aGlzLl9ub3JtYWxpemUocGFyYW1zKTtcblxuICAvLyBHcmFiIHRoZSBsaW1pdGVkIHBhcmFtZXRlcnMuXG4gIHZhciBuZXdZYXcgPSBwYXJhbXMueWF3O1xuICB2YXIgbmV3UGl0Y2ggPSBwYXJhbXMucGl0Y2g7XG4gIHZhciBuZXdSb2xsID0gcGFyYW1zLnJvbGw7XG4gIHZhciBuZXdGb3YgPSBwYXJhbXMuZm92O1xuICB2YXIgbmV3V2lkdGggPSBwYXJhbXMud2lkdGg7XG4gIHZhciBuZXdIZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICB2YXIgbmV3UHJvamVjdGlvbkNlbnRlclggPSBwYXJhbXMucHJvamVjdGlvbkNlbnRlclg7XG4gIHZhciBuZXdQcm9qZWN0aW9uQ2VudGVyWSA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWTtcblxuICB2YXIgbmV3VHggPSBwYXJhbXMudHg7XG4gIHZhciBuZXdUeSA9IHBhcmFtcy50eTtcbiAgdmFyIG5ld1R6ID0gcGFyYW1zLnR6O1xuICB2YXIgbmV3T3ggPSBwYXJhbXMub3g7XG4gIHZhciBuZXdPeSA9IHBhcmFtcy5veTtcbiAgdmFyIG5ld096ID0gcGFyYW1zLm96O1xuXG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAoIXJlYWwobmV3WWF3KSB8fCAhcmVhbChuZXdQaXRjaCkgfHwgIXJlYWwobmV3Um9sbCkgfHxcbiAgICAgICFyZWFsKG5ld0ZvdikgfHwgIXJlYWwobmV3V2lkdGgpIHx8ICFyZWFsKG5ld0hlaWdodCkgfHxcbiAgICAgICFyZWFsKG5ld1Byb2plY3Rpb25DZW50ZXJYKSB8fCAhcmVhbChuZXdQcm9qZWN0aW9uQ2VudGVyWSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB2aWV3IC0gc3VzcGVjdCBhIGJyb2tlbiBsaW1pdGVyJyk7XG4gIH1cblxuICAvLyBVcGRhdGUgcGFyYW1ldGVycy5cbiAgdGhpcy5feWF3ID0gbmV3WWF3O1xuICB0aGlzLl9waXRjaCA9IG5ld1BpdGNoO1xuICB0aGlzLl9yb2xsID0gbmV3Um9sbDtcbiAgdGhpcy5fZm92ID0gbmV3Rm92O1xuICB0aGlzLl93aWR0aCA9IG5ld1dpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYID0gbmV3UHJvamVjdGlvbkNlbnRlclg7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZID0gbmV3UHJvamVjdGlvbkNlbnRlclk7XG4gIFxuICB0aGlzLl90eCA9IG5ld1R4O1xuICB0aGlzLl90eSA9IG5ld1R5O1xuICB0aGlzLl90eiA9IG5ld1R6O1xuICB0aGlzLl9veCA9IG5ld094O1xuICB0aGlzLl9veSA9IG5ld095O1xuICB0aGlzLl9veiA9IG5ld096O1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHBhcmFtZXRlcnMgY2hhbmdlZCBhbmQgZW1pdCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMuXG4gIGlmIChuZXdZYXcgIT09IG9sZFlhdyB8fCBuZXdQaXRjaCAhPT0gb2xkUGl0Y2ggfHwgbmV3Um9sbCAhPT0gb2xkUm9sbCB8fFxuICAgICAgbmV3Rm92ICE9PSBvbGRGb3YgfHwgbmV3V2lkdGggIT09IG9sZFdpZHRoIHx8IG5ld0hlaWdodCAhPT0gb2xkSGVpZ2h0IHx8XG4gICAgICBuZXdQcm9qZWN0aW9uQ2VudGVyWCAhPT0gb2xkUHJvamVjdGlvbkNlbnRlclggfHxcbiAgICAgIG5ld1Byb2plY3Rpb25DZW50ZXJZICE9PSBvbGRQcm9qZWN0aW9uQ2VudGVyWSB8fFxuICAgICAgbmV3VHggIT09IG9sZFR4IHx8IG5ld1R5ICE9PSBvbGRUeSB8fCBuZXdUeiAhPT0gb2xkVHogfHxcbiAgICAgIG5ld094ICE9PSBvbGRPeCB8fCBuZXdPeSAhPT0gb2xkT3kgfHwgbmV3T3ogIT09IG9sZE96KSB7XG4gICAgdGhpcy5fbWF0cml4Q2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbiAgfVxuICBpZiAobmV3V2lkdGggIT09IG9sZFdpZHRoIHx8IG5ld0hlaWdodCAhPT0gb2xkSGVpZ2h0KSB7XG4gICAgdGhpcy5lbWl0KCdyZXNpemUnKTtcbiAgfVxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9ub3JtYWxpemUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICB0aGlzLl9ub3JtYWxpemVDb29yZGluYXRlcyhwYXJhbXMpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IG5laXRoZXIgdGhlIGhvcml6b250YWwgbm9yIHRoZSB2ZXJ0aWNhbCBmaWVsZHMgb2Ygdmlld1xuICAvLyBleGNlZWQgz4AgLSBmb3ZMaW1pdEVwc2lsb24uXG4gIHZhciBoZm92UGkgPSBjb252ZXJ0Rm92Lmh0b3YoTWF0aC5QSSwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgdmFyIG1heEZvdiA9IGlzTmFOKGhmb3ZQaSkgPyBNYXRoLlBJIDogTWF0aC5taW4oTWF0aC5QSSwgaGZvdlBpKTtcbiAgcGFyYW1zLmZvdiA9IGNsYW1wKHBhcmFtcy5mb3YsIGZvdkxpbWl0RXBzaWxvbiwgbWF4Rm92IC0gZm92TGltaXRFcHNpbG9uKTtcblxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9ub3JtYWxpemVDb29yZGluYXRlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAvLyBDb25zdHJhaW4geWF3LCBwaXRjaCBhbmQgcm9sbCB0byB0aGUgWy3PgCwgz4BdIGludGVydmFsLlxuICBpZiAoJ3lhdycgaW4gcGFyYW1zKSB7XG4gICAgcGFyYW1zLnlhdyA9IG1vZChwYXJhbXMueWF3IC0gTWF0aC5QSSwgLTIqTWF0aC5QSSkgKyBNYXRoLlBJO1xuICB9XG4gIGlmICgncGl0Y2gnIGluIHBhcmFtcykge1xuICAgIHBhcmFtcy5waXRjaCA9IG1vZChwYXJhbXMucGl0Y2ggLSBNYXRoLlBJLCAtMipNYXRoLlBJKSArIE1hdGguUEk7XG4gIH1cbiAgaWYgKCdyb2xsJyBpbiBwYXJhbXMpIHtcbiAgICBwYXJhbXMucm9sbCA9IG1vZChwYXJhbXMucm9sbCAtIE1hdGguUEksIC0yKk1hdGguUEkpICsgTWF0aC5QSTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIE5vcm1hbGl6ZSB2aWV3IGNvb3JkaW5hdGVzIHNvIHRoYXQgdGhleSBhcmUgdGhlIGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnQgdmlldy5cbiAqIFVzZWZ1bCBmb3IgdHdlZW5pbmcgdGhlIHZpZXcgdGhyb3VnaCB0aGUgc2hvcnRlc3QgcGF0aC4gSWYgYSByZXN1bHQgYXJndW1lbnRcbiAqIGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aCB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoXG4gKiBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc30gY29vcmRzIFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgbm9ybWFsaXplZFxuICogICAgIHZpZXcgY29vcmRpbmF0ZXMuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUubm9ybWFsaXplVG9DbG9zZXN0ID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcblxuICB2YXIgdmlld1lhdyA9IHRoaXMuX3lhdztcbiAgdmFyIHZpZXdQaXRjaCA9IHRoaXMuX3BpdGNoO1xuXG4gIHZhciBjb29yZFlhdyA9IGNvb3Jkcy55YXc7XG4gIHZhciBjb29yZFBpdGNoID0gY29vcmRzLnBpdGNoO1xuXG4gIC8vIENoZWNrIGlmIHRoZSB5YXcgaXMgY2xvc2VyIGFmdGVyIHN1YnRyYWN0aW5nIG9yIGFkZGluZyBhIGZ1bGwgY2lyY2xlLlxuICB2YXIgcHJldllhdyA9IGNvb3JkWWF3IC0gMipNYXRoLlBJO1xuICB2YXIgbmV4dFlhdyA9IGNvb3JkWWF3ICsgMipNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMocHJldllhdyAtIHZpZXdZYXcpIDwgTWF0aC5hYnMoY29vcmRZYXcgLSB2aWV3WWF3KSkge1xuICAgIGNvb3JkWWF3ID0gcHJldllhdztcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyhuZXh0WWF3IC0gdmlld1lhdykgPCBNYXRoLmFicyhjb29yZFlhdyAtIHZpZXdZYXcpKSB7XG4gICAgY29vcmRZYXcgPSBuZXh0WWF3O1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHBpdGNoIGlzIGNsb3NlciBhZnRlciBzdWJ0cmFjdGluZyBvciBhZGRpbmcgYSBmdWxsIGNpcmNsZS5cbiAgdmFyIHByZXZQaXRjaCA9IGNvb3JkUGl0Y2ggLSAyKk1hdGguUEk7XG4gIHZhciBuZXh0UGl0Y2ggPSBjb29yZFBpdGNoICsgMipNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMocHJldlBpdGNoIC0gdmlld1BpdGNoKSA8IE1hdGguYWJzKGNvb3JkUGl0Y2ggLSB2aWV3UGl0Y2gpKSB7XG4gICAgY29vcmRQaXRjaCA9IHByZXZQaXRjaDtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyhwcmV2UGl0Y2ggLSB2aWV3UGl0Y2gpIDwgTWF0aC5hYnMoY29vcmRQaXRjaCAtIHZpZXdQaXRjaCkpIHtcbiAgICBjb29yZFBpdGNoID0gbmV4dFBpdGNoO1xuICB9XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IHt9O1xuICByZXN1bHQueWF3ID0gY29vcmRZYXc7XG4gIHJlc3VsdC5waXRjaCA9IGNvb3JkUGl0Y2g7XG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS51cGRhdGVXaXRoQ29udHJvbFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gIC8vIGF4aXNTY2FsZWRYIGFuZCBheGlzU2NhbGVkWSBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBvd24gYXhpc1xuICAvLyB4IGFuZCB5IGFyZSBzY2FsZWQgYnkgdGhlIHNhbWUgdmFsdWVcblxuICAvLyBJZiB0aGUgdmlld3BvcnQgZGltZW5zaW9ucyBhcmUgemVybywgYXNzdW1lIGEgc3F1YXJlIHZpZXdwb3J0XG4gIC8vIHdoZW4gY29udmVydGluZyBmcm9tIGhmb3YgdG8gdmZvdi5cbiAgdmFyIHZmb3YgPSB0aGlzLl9mb3Y7XG4gIHZhciBoZm92ID0gY29udmVydEZvdi52dG9oKHZmb3YsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICBpZiAoaXNOYU4oaGZvdikpIHtcbiAgICBoZm92ID0gdmZvdjtcbiAgfVxuXG4gIC8vIFRPRE86IHJldmlzaXQgdGhpcyBhZnRlciB3ZSByZXRoaW5rIHRoZSBjb250cm9sIHBhcmFtZXRlcnMuXG4gIHRoaXMub2Zmc2V0WWF3KHBhcmFtZXRlcnMuYXhpc1NjYWxlZFggKiBoZm92ICsgcGFyYW1ldGVycy54ICogMiAqIGhmb3YgKyBwYXJhbWV0ZXJzLnlhdyk7XG4gIHRoaXMub2Zmc2V0UGl0Y2gocGFyYW1ldGVycy5heGlzU2NhbGVkWSAqIHZmb3YgKyBwYXJhbWV0ZXJzLnkgKiAyICogaGZvdiArIHBhcmFtZXRlcnMucGl0Y2gpO1xuICB0aGlzLm9mZnNldFJvbGwoLXBhcmFtZXRlcnMucm9sbCk7XG4gIHRoaXMub2Zmc2V0Rm92KHBhcmFtZXRlcnMuem9vbSAqIHZmb3YpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl91cGRhdGVNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByb2pNYXRyaXggPSB0aGlzLl9wcm9qTWF0cml4O1xuICB2YXIgaW52UHJvak1hdHJpeCA9IHRoaXMuX2ludlByb2pNYXRyaXg7XG4gIHZhciB2aWV3TWF0cml4ID0gdGhpcy5fdmlld01hdHJpeDtcbiAgdmFyIGludlZpZXdNYXRyaXggPSB0aGlzLl9pbnZWaWV3TWF0cml4O1xuICB2YXIgZnJ1c3R1bSA9IHRoaXMuX2ZydXN0dW07XG5cbiAgaWYgKHRoaXMuX21hdHJpeENoYW5nZWQpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgdmFyIHZmb3YgPSB0aGlzLl9mb3Y7XG4gICAgdmFyIGhmb3YgPSBjb252ZXJ0Rm92LnZ0b2godmZvdiwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuXG4gICAgdmFyIHByb2plY3Rpb25DZW50ZXJYID0gdGhpcy5fcHJvamVjdGlvbkNlbnRlclg7XG4gICAgdmFyIHByb2plY3Rpb25DZW50ZXJZID0gdGhpcy5fcHJvamVjdGlvbkNlbnRlclk7XG5cbiAgICAvLyBQcm9qZWN0aW9uIE1hdHJpeC5cbiAgICBpZiAocHJvamVjdGlvbkNlbnRlclggIT09IDAgfHwgcHJvamVjdGlvbkNlbnRlclkgIT09IDApIHtcbiAgICAgIHZhciBvZmZzZXRBbmdsZVggPSBNYXRoLmF0YW4ocHJvamVjdGlvbkNlbnRlclggKiAyICogTWF0aC50YW4oaGZvdi8yKSk7XG4gICAgICB2YXIgb2Zmc2V0QW5nbGVZID0gTWF0aC5hdGFuKHByb2plY3Rpb25DZW50ZXJZICogMiAqIE1hdGgudGFuKHZmb3YvMikpO1xuICAgICAgdmFyIGZvdnMgPSB0aGlzLl9mb3ZzO1xuICAgICAgZm92cy5sZWZ0RGVncmVlcyA9IChoZm92LzIgKyBvZmZzZXRBbmdsZVgpICogMTgwL01hdGguUEk7XG4gICAgICBmb3ZzLnJpZ2h0RGVncmVlcyA9IChoZm92LzIgLSBvZmZzZXRBbmdsZVgpICogMTgwL01hdGguUEk7XG4gICAgICBmb3ZzLnVwRGVncmVlcyA9ICh2Zm92LzIgKyBvZmZzZXRBbmdsZVkpICogMTgwL01hdGguUEk7XG4gICAgICBmb3ZzLmRvd25EZWdyZWVzID0gKHZmb3YvMiAtIG9mZnNldEFuZ2xlWSkgKiAxODAvTWF0aC5QSTtcbiAgICAgIG1hdDQucGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcocHJvak1hdHJpeCwgZm92cywgLTEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXQ0LnBlcnNwZWN0aXZlKHByb2pNYXRyaXgsIHZmb3YsIGFzcGVjdCwgLTEsIDEpO1xuICAgIH1cblxuICAgIC8vIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIHByb2pNYXRyaXgpO1xuXG4gICAgLy8gLy8gVmlldyBNYXRyaXguXG4gICAgLy8gbWF0NC5pZGVudGl0eSh2aWV3TWF0cml4KTtcbiAgICAvLyBtYXQ0LnRyYW5zbGF0ZSh2aWV3TWF0cml4LCB2aWV3TWF0cml4LCB2ZWMzLm5lZ2F0ZSh2ZWMzLmNyZWF0ZSgpLCBbdGhpcy5fb3gsIHRoaXMuX295LCB0aGlzLl9vel0pKTtcblxuICAgIC8vIC8vIEludmVydCBjb250cm9sLlxuICAgIC8vIHZhciByb2xsID0gdGhpcy5faW52ZXJ0Q29udHJvbCA/IC10aGlzLl9yb2xsIDogdGhpcy5fcm9sbDtcbiAgICAvLyB2YXIgcGl0Y2ggPSB0aGlzLl9pbnZlcnRDb250cm9sID8gLXRoaXMuX3BpdGNoIDp0aGlzLl9waXRjaDtcbiAgICAvLyB2YXIgeWF3ID0gdGhpcy5faW52ZXJ0Q29udHJvbCA/IC10aGlzLl95YXcgOiB0aGlzLl95YXc7XG4gICAgLy8gbWF0NC5yb3RhdGVaKHZpZXdNYXRyaXgsIHZpZXdNYXRyaXgsIHJvbGwpO1xuICAgIC8vIG1hdDQucm90YXRlWCh2aWV3TWF0cml4LCB2aWV3TWF0cml4LCBwaXRjaCk7XG4gICAgLy8gbWF0NC5yb3RhdGVZKHZpZXdNYXRyaXgsIHZpZXdNYXRyaXgsIHlhdyk7XG5cbiAgICAvLyBtYXQ0LnRyYW5zbGF0ZSh2aWV3TWF0cml4LCB2aWV3TWF0cml4LCB2ZWMzLm5lZ2F0ZSh2ZWMzLmNyZWF0ZSgpLCBbdGhpcy5fdHgsIHRoaXMuX3R5LCB0aGlzLl90el0pKTtcblxuICAgIC8vIG1hdDQuaW52ZXJ0KGludlZpZXdNYXRyaXgsIHZpZXdNYXRyaXgpO1xuXG4gICAgLy8gLy8gR2V0IHRoZSBmcnVzdHVtIHBsYW5lcy5cbiAgICAvLyB2YXIgbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAvLyBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgcHJvak1hdHJpeCwgdmlld01hdHJpeCk7XG4gICAgLy8gdGhpcy5fbWF0cml4VG9GcnVzdHVtKG1hdHJpeCwgZnJ1c3R1bSk7XG5cbiAgICBtYXQ0LnJvdGF0ZVoocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGhpcy5fcm9sbCk7XG4gICAgbWF0NC5yb3RhdGVYKHByb2pNYXRyaXgsIHByb2pNYXRyaXgsIHRoaXMuX3BpdGNoKTtcbiAgICBtYXQ0LnJvdGF0ZVkocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGhpcy5feWF3KTtcbiAgICBtYXQ0LnRyYW5zbGF0ZShwcm9qTWF0cml4LCBwcm9qTWF0cml4LCB2ZWMzLm5lZ2F0ZSh2ZWMzLmNyZWF0ZSgpLCBbdGhpcy5fdHgsIHRoaXMuX3R5LCB0aGlzLl90el0pKTtcbiAgICBtYXQ0LmludmVydChpbnZQcm9qTWF0cml4LCBwcm9qTWF0cml4KTtcbiAgICB0aGlzLl9tYXRyaXhUb0ZydXN0dW0ocHJvak1hdHJpeCwgZnJ1c3R1bSk7XG5cbiAgICB0aGlzLl9tYXRyaXhDaGFuZ2VkID0gZmFsc2U7XG4gIH1cbn07XG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuX21hdHJpeFRvRnJ1c3R1bSA9IGZ1bmN0aW9uKHAsIGYpIHtcbiAgLy8gRXh0cmFjdCBmcnVzdHVtIHBsYW5lcyBmcm9tIHByb2plY3Rpb24gbWF0cml4LlxuICAvLyBodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1MS9IVDEyL2xhYi9wbGFuZV9leHRyYWN0aW9uLnBkZlxuICB2ZWM0LnNldChmWzBdLCBwWzNdICsgcFswXSwgcFs3XSArIHBbNF0sIHBbMTFdICsgcFs4XSwgcFsxNV0gKyBwWzEyXSk7IC8vIGxlZnRcbiAgdmVjNC5zZXQoZlsxXSwgcFszXSAtIHBbMF0sIHBbN10gLSBwWzRdLCBwWzExXSAtIHBbOF0sIHBbMTVdIC0gcFsxMl0pOyAvLyByaWdodFxuICB2ZWM0LnNldChmWzJdLCBwWzNdICsgcFsxXSwgcFs3XSArIHBbNV0sIHBbMTFdICsgcFs5XSwgcFsxNV0gKyBwWzEzXSk7IC8vIHRvcFxuICB2ZWM0LnNldChmWzNdLCBwWzNdIC0gcFsxXSwgcFs3XSAtIHBbNV0sIHBbMTFdIC0gcFs5XSwgcFsxNV0gLSBwWzEzXSk7IC8vIGJvdHRvbVxuICB2ZWM0LnNldChmWzRdLCBwWzNdICsgcFsyXSwgcFs3XSArIHBbNl0sIHBbMTFdICsgcFsxMF0sIHBbMTVdICsgcFsxNF0pOyAvLyBjYW1lcmFcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcmV0dXJucyB7bWF0NH1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZU1hdHJpeCgpO1xuICByZXR1cm4gdGhpcy5fcHJvak1hdHJpeDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEByZXR1cm5zIHttYXQ0fVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLmludmVyc2VQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZU1hdHJpeCgpO1xuICByZXR1cm4gdGhpcy5faW52UHJvak1hdHJpeDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmlldyBtYXRyaXggZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcmV0dXJucyB7bWF0NH1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS52aWV3TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZU1hdHJpeCgpO1xuICByZXR1cm4gdGhpcy5fdmlld01hdHJpeDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIHZpZXcgbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuaW52ZXJzZVZpZXdNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdXBkYXRlTWF0cml4KCk7XG4gIHJldHVybiB0aGlzLl9pbnZWaWV3TWF0cml4O1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSB2aWV3IGZydXN0dW0gaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF5IHJldHVybiBmYWxzZSBwb3NpdGl2ZXMsIGJ1dCBuZXZlciBmYWxzZSBuZWdhdGl2ZXMuXG4gKiBJdCBpcyB1c2VkIGZvciBmcnVzdHVtIGN1bGxpbmcsIGkuZS4sIGV4Y2x1ZGluZyBpbnZpc2libGUgdGlsZXMgZnJvbSB0aGVcbiAqIHJlbmRlcmluZyBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7dmVjMltdfSByZWN0YW5nbGUgVGhlIHZlcnRpY2VzIG9mIHRoZSByZWN0YW5nbGUuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICB0aGlzLl91cGRhdGVNYXRyaXgoKTtcblxuICB2YXIgZnJ1c3R1bSA9IHRoaXMuX2ZydXN0dW07XG4gIHZhciB2ZXJ0ZXggPSB0aGlzLl90bXBWZWM7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcmVjdGFuZ2xlIGlzIG9uIHRoZSBvdXRlciBzaWRlIG9mIGFueSBvZiB0aGUgZnJ1c3R1bVxuICAvLyBwbGFuZXMuIFRoaXMgaXMgYSBzdWZmaWNpZW50IGNvbmRpdGlvbiwgdGhvdWdoIG5vdCBuZWNlc3NhcnksIGZvciB0aGVcbiAgLy8gcmVjdGFuZ2xlIHRvIGJlIGNvbXBsZXRlbHkgb3V0c2lkZSB0aGUgZnJ1c3R1bS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcnVzdHVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYW5lID0gZnJ1c3R1bVtpXTtcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWN0YW5nbGUubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBjb3JuZXIgPSByZWN0YW5nbGVbal07XG4gICAgICB2ZWM0LnNldCh2ZXJ0ZXgsIGNvcm5lclswXSwgY29ybmVyWzFdLCBjb3JuZXJbMl0sIDEuMCk7XG4gICAgICBpZiAodmVjNC5kb3QocGxhbmUsIHZlcnRleCkgPj0gMCkge1xuICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluc2lkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBTZWxlY3QgdGhlIGxldmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSB2aWV3LlxuICogQHBhcmFtIHtMZXZlbFtdfSBsZXZlbExpc3QgdGhlIGxpc3Qgb2YgbGV2ZWxzIGZyb20gd2hpY2ggdG8gc2VsZWN0LlxuICogQHJldHVybiB7TGV2ZWx9IHRoZSBzZWxlY3RlZCBsZXZlbC5cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZWxlY3RMZXZlbCA9IGZ1bmN0aW9uKGxldmVsTGlzdCkge1xuXG4gIC8vIE11bHRpcGx5IHRoZSB2aWV3cG9ydCB3aWR0aCBieSB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIHRvIGdldCB0aGUgcmVxdWlyZWRcbiAgLy8gaG9yaXpvbnRhbCByZXNvbHV0aW9uIGluIHBpeGVscy5cbiAgLy9cbiAgLy8gQ2FsY3VsYXRlIHRoZSBmcmFjdGlvbiBvZiBhIGN1YmUgZmFjZSB0aGF0IHdvdWxkIGJlIHZpc2libGUgZ2l2ZW4gdGhlXG4gIC8vIGN1cnJlbnQgdmVydGljYWwgZmllbGQgb2Ygdmlldy4gVGhlbiwgZm9yIGVhY2ggbGV2ZWwsIG11bHRpcGx5IGJ5IHRoZVxuICAvLyBsZXZlbCBoZWlnaHQgdG8gZ2V0IHRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBwb3J0aW9uIHRoYXQgd291bGQgYmVcbiAgLy8gdmlzaWJsZS5cbiAgLy9cbiAgLy8gU2VhcmNoIGZvciB0aGUgc21hbGxlc3QgbGV2ZWwgdGhhdCBzYXRpZmllcyB0aGUgdGhlIHJlcXVpcmVkIGhlaWdodCxcbiAgLy8gZmFsbGluZyBiYWNrIG9uIHRoZSBsYXJnZXN0IGxldmVsIGlmIG5vbmUgZG8uXG5cbiAgdmFyIHJlcXVpcmVkUGl4ZWxzID0gcGl4ZWxSYXRpbygpICogdGhpcy5faGVpZ2h0O1xuICB2YXIgY292ZXJGYWN0b3IgPSBNYXRoLnRhbigwLjUgKiB0aGlzLl9mb3YpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxMaXN0W2ldO1xuICAgIGlmIChjb3ZlckZhY3RvciAqIGxldmVsLmhlaWdodCgpID49IHJlcXVpcmVkUGl4ZWxzKSB7XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxldmVsTGlzdFtsZXZlbExpc3QubGVuZ3RoIC0gMV07XG5cbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHZpZXcgcGFyYW1ldGVycyBpbnRvIHNjcmVlbiBwb3NpdGlvbi4gSWYgYSByZXN1bHQgYXJndW1lbnQgaXNcbiAqIHByb3ZpZGVkLCBpdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZFxuICogaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzfSBjb29yZHMgVGhlIHZpZXcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0Nvb3Jkcz19IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICogQHJldHVybiB7Q29vcmRzfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLmNvb3JkaW5hdGVzVG9TY3JlZW4gPSBmdW5jdGlvbihjb29yZHMsIHJlc3VsdCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdG1wVmVjO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH1cblxuICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBVbmRlZmluZWQgb24gYSBudWxsIHZpZXdwb3J0LlxuICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgIHJlc3VsdC54ID0gbnVsbDtcbiAgICByZXN1bHQueSA9IG51bGw7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDb21wdXRlIHZpZXcgcmF5IHBvaW50aW5nIGludG8gdGhlICh5YXcsIHBpdGNoKSBkaXJlY3Rpb24uXG4gIHZhciB5YXcgPSBjb29yZHMueWF3O1xuICB2YXIgcGl0Y2ggPSBjb29yZHMucGl0Y2g7XG4gIHZhciB4ID0gTWF0aC5zaW4oeWF3KSAqIE1hdGguY29zKHBpdGNoKTtcbiAgdmFyIHkgPSAtTWF0aC5zaW4ocGl0Y2gpO1xuICB2YXIgeiA9IC1NYXRoLmNvcyh5YXcpICogTWF0aC5jb3MocGl0Y2gpO1xuICB2ZWM0LnNldChyYXksIHgsIHksIHosIDEpO1xuXG4gIC8vIFByb2plY3QgdmlldyByYXkgb250byBjbGlwIHNwYWNlLlxuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMucHJvamVjdGlvbigpKTtcblxuICAvLyB3IGluIGNsaXAgc3BhY2UgZXF1YWxzIC16IGluIGNhbWVyYSBzcGFjZS5cbiAgaWYgKHJheVszXSA+PSAwKSB7XG4gICAgLy8gUG9pbnQgaXMgaW4gZnJvbnQgb2YgY2FtZXJhLlxuICAgIC8vIENvbnZlcnQgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgcmVzdWx0LnggPSB3aWR0aCAqIChyYXlbMF0gLyByYXlbM10gKyAxKSAvIDI7XG4gICAgcmVzdWx0LnkgPSBoZWlnaHQgKiAoMSAtIHJheVsxXSAvIHJheVszXSkgLyAyO1xuICB9IGVsc2Uge1xuICAgIC8vIFBvaW50IGlzIGJlaGluZCBjYW1lcmEuXG4gICAgcmVzdWx0LnggPSBudWxsO1xuICAgIHJlc3VsdC55ID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQ29udmVydCBzY3JlZW4gY29vcmRpbmF0ZXMgaW50byB2aWV3IGNvb3JkaW5hdGVzLiBJZiBhIHJlc3VsdCBhcmd1bWVudCBpc1xuICogcHJvdmlkZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZSByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2hcbiAqIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7Q29vcmRzfSBjb29yZHMgVGhlIHNjcmVlbiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzPX0gcmVzdWx0IFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNjcmVlblRvQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihjb29yZHMsIHJlc3VsdCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdG1wVmVjO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH1cblxuICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBDb252ZXJ0IHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIGNsaXAgc3BhY2UuXG4gIHZhciB2ZWN4ID0gMiAqIGNvb3Jkcy54IC8gd2lkdGggLSAxO1xuICB2YXIgdmVjeSA9IDEgLSAyICogY29vcmRzLnkgLyBoZWlnaHQ7XG4gIHZlYzQuc2V0KHJheSwgdmVjeCwgdmVjeSwgMSwgMSk7XG5cbiAgLy8gUHJvamVjdCBiYWNrIHRvIHdvcmxkIHNwYWNlLlxuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMuaW52ZXJzZVByb2plY3Rpb24oKSk7XG5cbiAgLy8gQ29udmVydCB0byBzcGhlcmljYWwgY29vcmRpbmF0ZXMuXG4gIHZhciByID0gTWF0aC5zcXJ0KHJheVswXSAqIHJheVswXSArIHJheVsxXSAqIHJheVsxXSArIHJheVsyXSAqIHJheVsyXSk7XG4gIHJlc3VsdC55YXcgPSBNYXRoLmF0YW4yKHJheVswXSwgLXJheVsyXSk7XG4gIHJlc3VsdC5waXRjaCA9IE1hdGguYWNvcyhyYXlbMV0gLyByKSAtIE1hdGguUEkvMjtcblxuICB0aGlzLl9ub3JtYWxpemVDb29yZGluYXRlcyhyZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gcmVxdWlyZWQgdG8gcG9zaXRpb24gYW4gZWxlbWVudCB3aXRoXG4gKiBwZXJzcGVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc30gY29vcmRzIFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHNwaGVyZSBlbWJlZGRpbmcgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXh0cmFUcmFuc2Zvcm1zIEV4dHJhIHRyYW5zZm9ybWF0aW9ucyB0byBiZSBhcHBsaWVkIGFmdGVyXG4gKiAgICAgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZC4gVGhpcyBtYXkgYmUgdXNlZCB0byByb3RhdGUgdGhlIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBDU1MgM0QgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZXNUb1BlcnNwZWN0aXZlVHJhbnNmb3JtID0gZnVuY3Rpb24oXG4gICAgY29vcmRzLCByYWRpdXMsIGV4dHJhVHJhbnNmb3Jtcykge1xuICBleHRyYVRyYW5zZm9ybXMgPSBleHRyYVRyYW5zZm9ybXMgfHwgXCJcIjtcblxuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIGZvdiA9IHRoaXMuX2ZvdjtcbiAgdmFyIHBlcnNwZWN0aXZlID0gMC41ICogaGVpZ2h0IC8gTWF0aC50YW4oZm92IC8gMik7XG5cbiAgdmFyIHRyYW5zZm9ybSA9ICcnO1xuXG4gIC8vIENlbnRlciBob3RzcG90IGluIHNjcmVlbi5cbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVYKCcgKyBkZWNpbWFsKHdpZHRoLzIpICsgJ3B4KSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVkoJyArIGRlY2ltYWwoaGVpZ2h0LzIpICsgJ3B4KSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSAnO1xuXG4gIC8vIFNldCB0aGUgcGVyc3BlY3RpdmUgZGVwdGguXG4gIHRyYW5zZm9ybSArPSAncGVyc3BlY3RpdmUoJyArIGRlY2ltYWwocGVyc3BlY3RpdmUpICsgJ3B4KSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVooJyArIGRlY2ltYWwocGVyc3BlY3RpdmUpICsgJ3B4KSAnO1xuXG4gIC8vIFNldCB0aGUgY2FtZXJhIHJvdGF0aW9uLlxuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVooJyArIGRlY2ltYWwoLXRoaXMuX3JvbGwpICsgJ3JhZCkgJztcbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVYKCcgKyBkZWNpbWFsKC10aGlzLl9waXRjaCkgKyAncmFkKSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVkoJyArIGRlY2ltYWwodGhpcy5feWF3KSArICdyYWQpICc7XG5cbiAgLy8gU2V0IHRoZSBob3RzcG90IHJvdGF0aW9uLlxuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVkoJyArIGRlY2ltYWwoLWNvb3Jkcy55YXcpICsgJ3JhZCkgJztcbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVYKCcgKyBkZWNpbWFsKGNvb3Jkcy5waXRjaCkgKyAncmFkKSAnO1xuXG4gIC8vIE1vdmUgYmFjayB0byBzcGhlcmUuXG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWignICsgZGVjaW1hbCgtcmFkaXVzKSArICdweCkgJztcblxuICAvLyBBcHBseSB0aGUgZXh0cmEgdHJhbnNmb3JtYXRpb25zXG4gIHRyYW5zZm9ybSArPSBleHRyYVRyYW5zZm9ybXMgKyAnICc7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn07XG5cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9ucyBmb3IgdmlldyBsaW1pdGVycy4gU2VlIHtAbGluayBSZWN0aWxpbmVhclZpZXdMaW1pdGVyfS5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LmxpbWl0ID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgeWF3IGFuZ2xlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHlhdyB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB5YXcgdmFsdWUuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICB5YXc6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0WWF3KHBhcmFtcykge1xuICAgICAgcGFyYW1zLnlhdyA9IGNsYW1wKHBhcmFtcy55YXcsIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHBpdGNoIGFuZ2xlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBpdGNoIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBpdGNoIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcGl0Y2g6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0UGl0Y2gocGFyYW1zKSB7XG4gICAgICBwYXJhbXMucGl0Y2ggPSBjbGFtcChwYXJhbXMucGl0Y2gsIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHJvbGwgYW5nbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcm9sbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSByb2xsIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcm9sbDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRSb2xsKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnJvbGwgPSBjbGFtcChwYXJhbXMucm9sbCwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIGhvcml6b250YWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICBoZm92OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdEhmb3YocGFyYW1zKSB7XG4gICAgICB2YXIgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgICB2YXIgdm1pbiA9IGNvbnZlcnRGb3YuaHRvdihtaW4sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgdm1heCA9IGNvbnZlcnRGb3YuaHRvdihtYXgsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwYXJhbXMuZm92ID0gY2xhbXAocGFyYW1zLmZvdiwgdm1pbiwgdm1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmVydGljYWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHZmb3Y6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0VmZvdihwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5mb3YgPSBjbGFtcChwYXJhbXMuZm92LCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBwcmV2ZW50cyB6b29taW5nIGluIGJleW9uZCB0aGUgZ2l2ZW5cbiAgICogcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIGN1YmUgZmFjZSB3aWR0aCBpbiBwaXhlbHMgb3IsIGVxdWl2YWxlbnRseSwgb25lXG4gICAqICAgICBmb3VydGggb2YgdGhlIGVxdWlyZWN0YW5ndWxhciB3aWR0aCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICByZXNvbHV0aW9uOiBmdW5jdGlvbihzaXplKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0UmVzb2x1dGlvbihwYXJhbXMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiBoZWlnaHQ7XG4gICAgICAgIHZhciBtaW5Gb3YgPSAyICogTWF0aC5hdGFuKHJlcXVpcmVkUGl4ZWxzIC8gc2l6ZSk7XG4gICAgICAgIHBhcmFtcy5mb3YgPSBjbGFtcChwYXJhbXMuZm92LCBtaW5Gb3YsIEluZmluaXR5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGxpbWl0cyB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZmllbGQgb2ZcbiAgICogdmlldywgcHJldmVudHMgem9vbWluZyBpbiBwYXN0IHRoZSBpbWFnZSByZXNvbHV0aW9uLCBhbmQgbGltaXRzIHRoZSBwaXRjaFxuICAgKiByYW5nZSB0byBwcmV2ZW50IHRoZSBjYW1lcmEgd3JhcHBpbmcgYXJvdW5kIGF0IHRoZSBwb2xlcy4gVGhlc2UgYXJlIHRoZVxuICAgKiBtb3N0IGNvbW1vbiB2aWV3IGNvbnN0cmFpbnRzIGZvciBhIDM2MMKwIHBhbm9yYW1hLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBUaGUgY3ViZSBmYWNlIHdpZHRoIGluIHBpeGVscyBvcixcbiAgICogICAgIGVxdWl2YWxlbnRseSwgb25lIGZvdXJ0aCBvZiB0aGUgZXF1aXJlY3Rhbmd1bGFyIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFZGb3YgVGhlIG1heGltdW0gdmVydGljYWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhIRm92PW1heFZGb3ZdIFRoZSBtYXhpbXVtIGhvcml6b250YWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHRyYWRpdGlvbmFsOiBmdW5jdGlvbihtYXhSZXNvbHV0aW9uLCBtYXhWRm92LCBtYXhIRm92KSB7XG4gICAgbWF4SEZvdiA9IG1heEhGb3YgIT0gbnVsbCA/IG1heEhGb3YgOiBtYXhWRm92O1xuXG4gICAgcmV0dXJuIGNvbXBvc2UoXG4gICAgICBSZWN0aWxpbmVhclZpZXcubGltaXQucmVzb2x1dGlvbihtYXhSZXNvbHV0aW9uKSxcbiAgICAgIFJlY3RpbGluZWFyVmlldy5saW1pdC52Zm92KDAsIG1heFZGb3YpLFxuICAgICAgUmVjdGlsaW5lYXJWaWV3LmxpbWl0Lmhmb3YoMCwgbWF4SEZvdiksXG4gICAgICBSZWN0aWxpbmVhclZpZXcubGltaXQucGl0Y2goLU1hdGguUEkvMiwgTWF0aC5QSS8yKSk7XG4gIH1cblxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcudHlwZSA9IFJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUudHlwZSA9ICdyZWN0aWxpbmVhcic7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0aWxpbmVhclZpZXc7XG4iXX0=
