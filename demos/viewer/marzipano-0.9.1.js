(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Marzipano = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.bowser=t():e.bowser=t()}(this,(function(){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var n=t[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(i,n,function(t){return e[t]}.bind(null,n));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i=r(18),n=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,i){void 0===i&&(i=!1);var n=e.getVersionPrecision(t),s=e.getVersionPrecision(r),o=Math.max(n,s),a=0,u=e.map([t,r],(function(t){var r=o-e.getVersionPrecision(t),i=t+new Array(r+1).join(".0");return e.map(i.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(i&&(a=o-Math.min(n,s)),o-=1;o>=a;){if(u[0][o]>u[1][o])return 1;if(u[0][o]===u[1][o]){if(o===a)return 0;o-=1}else if(u[0][o]<u[1][o])return-1}},e.map=function(e,t){var r,i=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)i.push(t(e[r]));return i},e.getBrowserAlias=function(e){return i.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return i.BROWSER_MAP[e]||""},e}();t.default=n,e.exports=t.default},18:function(e,t,r){"use strict";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"}},90:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(91))&&i.__esModule?i:{default:i},s=r(18);function o(e,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var a=function(){function e(){}var t,r,i;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new n.default(e,t)},e.parse=function(e){return new n.default(e).getResult()},t=e,i=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&o(t.prototype,r),i&&o(t,i),e}();t.default=a,e.exports=t.default},91:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i=u(r(92)),n=u(r(93)),s=u(r(94)),o=u(r(95)),a=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=i.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=n.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=s.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return Object.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},i=0,n={},s=0;if(Object.keys(e).forEach((function(t){var o=e[t];"string"==typeof o?(n[t]=o,s+=1):"object"==typeof o&&(r[t]=o,i+=1)})),i>0){var o=Object.keys(r),a=o.find((function(e){return t.isOS(e)}));if(a){var u=this.satisfies(r[a]);if(void 0!==u)return u}var d=o.find((function(e){return t.isPlatform(e)}));if(d){var c=this.satisfies(r[d]);if(void 0!==c)return c}}if(s>0){var f=Object.keys(n).find((function(e){return t.isBrowser(e,!0)}));if(void 0!==f)return this.compareVersion(n[f])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),i=e.toLowerCase(),n=a.default.getBrowserTypeByAlias(i);return t&&n&&(i=n.toLowerCase()),i===r},t.compareVersion=function(e){var t=[0],r=e,i=!1,n=this.getBrowserVersion();if("string"==typeof n)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(i=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(i=!0,r=e.substr(1)),t.indexOf(a.default.compareVersions(n,r,i))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e){return this.isBrowser(e)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i};var s=/version\/(\d+(\.?_?\d+)+)/i,o=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=n.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=n.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=n.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=n.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=n.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=n.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=n.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=n.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=n.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=n.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=n.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=n.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=n.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=n.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=n.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=n.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=n.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=n.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=n.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=n.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=n.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=n.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=n.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:n.default.getFirstMatch(t,e),version:n.default.getSecondMatch(t,e)}}}];t.default=o,e.exports=t.default},93:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var o=[{test:[/Roku\/DVP/],describe:function(e){var t=n.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=n.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows/i],describe:function(e){var t=n.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=n.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/macintosh/i],describe:function(e){var t=n.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=n.default.getMacOSVersionName(t),i={name:s.OS_MAP.MacOS,version:t};return r&&(i.versionName=r),i}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=n.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=n.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=n.default.getAndroidVersionName(t),i={name:s.OS_MAP.Android,version:t};return r&&(i.versionName=r),i}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=n.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=n.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||n.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||n.default.getFirstMatch(/\bbb(\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=n.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=n.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=n.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=o,e.exports=t.default},94:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var o=[{test:[/googlebot/i],describe:function(){return{type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=n.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=n.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"blackberry"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return"bada"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"windows phone"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return"android"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"macos"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return"windows"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"linux"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"playstation 4"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return"roku"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=o,e.exports=t.default},95:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var o=[{test:function(e){return"microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=n.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=n.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=n.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=n.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=n.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=o,e.exports=t.default}})}));
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

exports.glMatrix = glMatrix;

var mat2 = _interopRequireWildcard(require("./mat2.js"));

exports.mat2 = mat2;

var mat2d = _interopRequireWildcard(require("./mat2d.js"));

exports.mat2d = mat2d;

var mat3 = _interopRequireWildcard(require("./mat3.js"));

exports.mat3 = mat3;

var mat4 = _interopRequireWildcard(require("./mat4.js"));

exports.mat4 = mat4;

var quat = _interopRequireWildcard(require("./quat.js"));

exports.quat = quat;

var quat2 = _interopRequireWildcard(require("./quat2.js"));

exports.quat2 = quat2;

var vec2 = _interopRequireWildcard(require("./vec2.js"));

exports.vec2 = vec2;

var vec3 = _interopRequireWildcard(require("./vec3.js"));

exports.vec3 = vec3;

var vec4 = _interopRequireWildcard(require("./vec4.js"));

exports.vec4 = vec4;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }
},{"./common.js":2,"./mat2.js":4,"./mat2d.js":5,"./mat3.js":6,"./mat4.js":7,"./quat.js":8,"./quat2.js":9,"./vec2.js":10,"./vec3.js":11,"./vec4.js":12}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */


function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */


function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */


function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */


function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b, c,
 *  d, tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */


function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */


function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */


function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/


function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}

;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}

;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.getAngle = getAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.exp = exp;
exports.ln = ln;
exports.pow = pow;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {quat} a     Origin unit quaternion 
 * @param  {quat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 * 
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":2,"./mat3.js":6,"./vec3.js":11,"./vec4.js":12}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromMat4 = fromMat4;
exports.copy = copy;
exports.identity = identity;
exports.set = set;
exports.getDual = getDual;
exports.setDual = setDual;
exports.getTranslation = getTranslation;
exports.translate = translate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateAroundAxis = rotateAroundAxis;
exports.add = add;
exports.multiply = multiply;
exports.scale = scale;
exports.lerp = lerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.normalize = normalize;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var quat = _interopRequireWildcard(require("./quat.js"));

var mat4 = _interopRequireWildcard(require("./mat4.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */


function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q a normalized quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */


function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */


function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */


var getReal = quat.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */

exports.getReal = getReal;

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */


var setReal = quat.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

exports.setReal = setReal;

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */


function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */


function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */


function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */


function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */


function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */


function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

exports.mul = mul;

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */


var dot = quat.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

exports.dot = dot;

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */


function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */


var length = quat.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = quat.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

exports.sqrLen = sqrLen;

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */


function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}
},{"./common.js":2,"./mat4.js":7,"./quat.js":8}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */


function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}

;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],13:[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @class
 * @classdesc Minimalistic event emitter mixin.
 */
function EventEmitter() {}

/**
 * Registers an event listener for the specified event. If the listener has
 * already been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.addEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name] = eventMap[name] || [];
  if (handlerList.indexOf(fn) < 0) {
    handlerList.push(fn);
  }
};

/**
 * Unregisters an event listener from the specified event. If the listener
 * hasn't been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.removeEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  if (handlerList) {
    var index = handlerList.indexOf(fn);
    if (index >= 0) {
      handlerList.splice(index, 1);
    }
  }
};

/**
 * Emits an event, causing all registered event listeners for that event to be
 * called in registration order.
 *
 * @param {string} name The event name.
 * @param {...*} var_args Arguments to call listeners with.
 */
EventEmitter.prototype.emit = function(name, var_args) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  var args = Array.prototype.slice.call(arguments, 1);
  if (handlerList) {
    for (var i = 0; i < handlerList.length; i++) {
      var fn = handlerList[i];
      fn.apply(this, args);
    }
  }
};

/**
 * Mixes in {@link EventEmitter} into a constructor function.
 *
 * @param {function} ctor The constructor function.
 */
function eventEmitter(ctor) {
  for (var prop in EventEmitter.prototype) {
    if (EventEmitter.prototype.hasOwnProperty(prop)) {
      ctor.prototype[prop] = EventEmitter.prototype[prop];
    }
  }
}

module.exports = eventEmitter;

},{}],15:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var cssSupported = require('./support/Css');
var positionAbsolutely = require('./util/positionAbsolutely');
var setTransform = require('./util/dom').setTransform;
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * @class Hotspot
 * @classdesc
 *
 * A Hotspot allows a DOM element to be placed at a fixed position in the
 * image. The position is updated automatically when the {@link View view}
 * changes.
 *
 * Positioning is performed with the `transform` CSS property when available,
 * falling back to the `position`, `left` and `top` properties when not.
 * In both cases, the top left corner of the element is placed in the requested
 * position; clients are expected to use additional children elements or other
 * CSS properties to achieve more sophisticated layouts.
 *
 * There are two kinds of hotspots: regular and embedded. A regular hotspot
 * does not change size depending on the zoom level. An embedded hotspot is
 * displayed at a fixed size relative to the panorama, always covering the
 * same portion of the image. Embedded hotspots require CSS 3D transform
 * support.
 *
 * Clients should call {@link HotspotContainer#createHotspot} instead of
 * invoking the constructor directly.
 *
 * @param {Element} domElement The DOM element.
 * @param {View} view The view.
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords} for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Additional options.
 * @param {Object} opts.perspective Perspective options for embedded hotspots.
 * @param {number} [opts.perspective.radius=null] If set, embed the hotspot
 *     into the image by transforming it into the surface of a sphere with this
 *     radius.
 * @param {string} [opts.perspective.extraTransforms=null] If set, append this
 *     value to the CSS `transform` property used to position the hotspot. This
 *     may be used to rotate an embedded hotspot.
 */
function Hotspot(domElement, parentDomElement, view, coords, opts) {

  opts = opts || {};
  opts.perspective = opts.perspective || {};
  opts.perspective.extraTransforms =
      opts.perspective.extraTransforms != null ? opts.perspective.extraTransforms : "";

  if ((opts.perspective.radius || opts.perspective.extraTransforms) && !cssSupported()) {
    throw new Error('CSS transforms on hotspots are not supported on this browser');
  }

  this._domElement = domElement;
  this._parentDomElement = parentDomElement;
  this._view = view;
  this._coords = {};
  this._perspective = {};

  this.setPosition(coords);

  // Add hotspot into the DOM.
  this._parentDomElement.appendChild(this._domElement);

  this.setPerspective(opts.perspective);

  // Whether the hotspot is visible.
  // The hotspot may still be hidden if it's inside a hidden HotspotContainer.
  this._visible = true;

  // The current calculated screen position.
  this._position = { x: 0, y: 0 };
}

eventEmitter(Hotspot);


/**
 * Destructor.
 * Clients should call {@link HotspotContainer#destroyHotspot} instead.
 */
Hotspot.prototype.destroy = function() {
  this._parentDomElement.removeChild(this._domElement);
  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
Hotspot.prototype.domElement = function() {
  return this._domElement;
};


/**
 * @return {Object}
 */
Hotspot.prototype.position = function() {
  return this._coords;
};


/**
 * @param {Object} coords
 */
Hotspot.prototype.setPosition = function(coords) {
  for (var key in coords) {
    this._coords[key] = coords[key];
  }
  this._update();
  // TODO: We should probably emit a hotspotsChange event on the parent
  // HotspotContainer. What's the best way to do so?
};


/**
 * @return {Object}
 */
Hotspot.prototype.perspective = function() {
  return this._perspective;
};


/**
 * @param {Object}
 */
Hotspot.prototype.setPerspective = function(perspective) {
  for (var key in perspective) {
    this._perspective[key] = perspective[key];
  }
  this._update();
};


/**
 * Show the hotspot
 */
Hotspot.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._update();
  }
};


/**
 * Hide the hotspot
 */
Hotspot.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._update();
  }
};


Hotspot.prototype._update = function() {
  var element = this._domElement;

  var params = this._coords;
  var position = this._position;
  var x, y;

  var isVisible = false;

  if (this._visible) {
    var view = this._view;

    if (this._perspective.radius) {
      // Hotspots that are embedded in the panorama may be visible even when
      // positioned behind the camera.
      isVisible = true;
      this._setEmbeddedPosition(view, params);
    } else {
      // Regular hotspots are only visible when positioned in front of the
      // camera. Note that they may be partially visible when positioned outside
      // the viewport.
      view.coordinatesToScreen(params, position);
      x = position.x;
      y = position.y;

      if (x != null && y != null) {
        isVisible = true;
        this._setPosition(x, y);
      }
    }
  }

  // Show if visible, hide if not.
  if (isVisible) {
    element.style.display = 'block';
    element.style.position = 'absolute';
  }
  else {
    element.style.display = 'none';
    element.style.position = '';
  }

};


Hotspot.prototype._setEmbeddedPosition = function(view, params) {
  var transform = view.coordinatesToPerspectiveTransform(
      params, this._perspective.radius, this._perspective.extraTransforms);
  setTransform(this._domElement, transform);
};


Hotspot.prototype._setPosition = function(x, y) {
  positionAbsolutely(this._domElement, x, y, this._perspective.extraTransforms);
};


module.exports = Hotspot;

},{"./support/Css":82,"./util/clearOwnProperties":91,"./util/dom":100,"./util/positionAbsolutely":111,"minimal-event-emitter":14}],16:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Hotspot = require('./Hotspot');
var calcRect = require('./util/calcRect');
var cssPointerEventsSupported = require('./support/cssPointerEvents');
var positionAbsolutely = require('./util/positionAbsolutely');
var setAbsolute = require('./util/dom').setAbsolute;
var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setOverflowVisible = require('./util/dom').setOverflowVisible;
var setNullSize = require('./util/dom').setNullSize;
var setPixelSize = require('./util/dom').setPixelSize;
var setPointerEvents = require('./util/dom').setWithVendorPrefix('pointer-events');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that a hotspot has been created or destroyed on the container.
 * @event HotspotContainer#hotspotsChange
 */

/**
 * @class HotspotContainer
 * @classdesc
 *
 * Creates a DOM element to hold {@link Hotspot hotspots} and updates their
 * position when necessary.
 *
 * @param {Element} parentDomElement The DOM element inside which the container
 *     should be created.
 * @param {Stage} stage The underlying stage.
 * @param {View} view The view according to which the hotspots are positioned.
 * @param {RenderLoop} renderLoop The render loop indicating when the hotspots
 *     must be rendered.
 * @param {Object} opts
 * @param {RectSpec} opts.rect Rectangular region covered by the container. See
 *    {@link Effects#rect}.
 */
function HotspotContainer(parentDomElement, stage, view, renderLoop, opts) {
  opts = opts || {};

  this._parentDomElement = parentDomElement;
  this._stage = stage;
  this._view = view;
  this._renderLoop = renderLoop;

  // Hotspot list.
  this._hotspots = [];

  // Whether the hotspot container should be visible.
  // It may still be hidden if a rect effect is set on a browser without
  // pointer-events support.
  this._visible = true;

  // The current rect.
  this._rect = opts.rect;

  // Whether the visibility or the rect have changed since the last DOM update.
  this._visibilityOrRectChanged = true;

  // The last seen stage dimensions.
  this._stageWidth = null;
  this._stageHeight = null;

  // Temporary variable to hold the calculated position and size.
  this._tmpRect = {};

  // Wrapper element. When the rect effect is set, the wrapper will have nonzero
  // dimensions and `pointer-events: none` so that hotspots outside the rect are
  // hidden, but no mouse events are hijacked. The exception is browsers without
  // pointer-events support, where we refuse to show the hotspots when a rect is
  // set as it would prevent the controls from receiving mouse events.
  this._hotspotContainerWrapper = document.createElement('div');
  setAbsolute(this._hotspotContainerWrapper);
  setPointerEvents(this._hotspotContainerWrapper, 'none');
  this._parentDomElement.appendChild(this._hotspotContainerWrapper);

  // Hotspot container element. It has zero dimensions and `pointer-events: all`
  // to override the `pointer-events: none` on the wrapper and allow hotspots to
  // be interacted with.
  this._hotspotContainer = document.createElement('div');
  setAbsolute(this._hotspotContainer);
  setPointerEvents(this._hotspotContainer, 'all');
  this._hotspotContainerWrapper.appendChild(this._hotspotContainer);

  // Update when the hotspots change or scene is re-rendered.
  this._updateHandler = this._update.bind(this);
  this._renderLoop.addEventListener('afterRender', this._updateHandler);
}

eventEmitter(HotspotContainer);


/**
 * Destructor.
 */
HotspotContainer.prototype.destroy = function() {
  while (this._hotspots.length) {
    this.destroyHotspot(this._hotspots[0]);
  }

  this._parentDomElement.removeChild(this._hotspotContainerWrapper);

  this._renderLoop.removeEventListener('afterRender', this._updateHandler);

  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
HotspotContainer.prototype.domElement = function() {
  return this._hotspotContainer;
};


/**
 * @param {Rect} rect
 */
HotspotContainer.prototype.setRect = function(rect) {
  if (rect && !cssPointerEventsSupported() && typeof console !== 'undefined') {
    console.warn(
        "Using a rect effect is not fully supported on this browser. " +
        "Hotspots may not be shown.")
  }
  this._rect = rect;
  this._visibilityOrRectChanged = true;
};


/**
 * @return {Rect}
 */
HotspotContainer.prototype.rect = function() {
  return this._rect;
};


/**
 * Creates a new hotspot in this container.
 *
 * @param {Element} domElement DOM element to use for the hotspot
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords}` for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Options in the same format as the `opts` argument to
 *     the {@link Hotspot} constructor.
 * @return {Hotspot}
 */
HotspotContainer.prototype.createHotspot = function(domElement, coords, opts) {
  coords = coords || {};

  var hotspot = new Hotspot(
      domElement, this._hotspotContainer, this._view, coords, opts);
  this._hotspots.push(hotspot);
  hotspot._update();

  this.emit('hotspotsChange');

  return hotspot;
};


/**
 * @param {Hotspot} hotspot
 * @return {boolean}
 */
HotspotContainer.prototype.hasHotspot = function(hotspot) {
  return this._hotspots.indexOf(hotspot) >= 0;
};


/**
 * @return {Hotspot[]}
 */
HotspotContainer.prototype.listHotspots = function() {
  return [].concat(this._hotspots);
};


/**
 * Removes a hotspot from the container.
 *
 * @param {Hotspot} hotspot
 */
HotspotContainer.prototype.destroyHotspot = function(hotspot) {
  var i = this._hotspots.indexOf(hotspot);
  if (i < 0) {
    throw new Error('No such hotspot');
  }
  this._hotspots.splice(i, 1);

  hotspot.destroy();
  this.emit('hotspotsChange');
};


/**
 * Hide the container's DOM element, causing every contained {@link Hotspot} to
 * be hidden.
 */
HotspotContainer.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


/**
 * Show the container's DOM element, causing every contained {@link Hotspot} to
 * be shown.
 */
HotspotContainer.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


HotspotContainer.prototype._update = function() {
  var wrapper = this._hotspotContainerWrapper;
  var width = this._stage.width();
  var height = this._stage.height();
  var tmpRect = this._tmpRect;

  // Avoid updating the wrapper DOM unless necessary.
  if (this._visibilityOrRectChanged ||
      (this._rect && (width !== this._stageWidth || height !== this._stageHeight))) {
    var visible = this._visible && !(this._rect && !cssPointerEventsSupported());
    wrapper.style.display = visible ? 'block' : 'none';

    if (visible) {
      if (this._rect) {
        calcRect(width, height, this._rect, tmpRect);
        positionAbsolutely(wrapper, width * tmpRect.x, height * tmpRect.y);
        setPixelSize(wrapper, width * tmpRect.width, height * tmpRect.height);
        setOverflowHidden(wrapper);
      } else {
        positionAbsolutely(wrapper, 0, 0);
        setNullSize(wrapper);
        setOverflowVisible(wrapper);
      }
    }

    this._stageWidth = width;
    this._stageHeight = height;
    this._visibilityOrRectChanged = false;
  }

  // Update hotspots unconditionally, as the view parameters may have changed.
  for (var i = 0; i < this._hotspots.length; i++) {
    this._hotspots[i]._update();
  }
};


module.exports = HotspotContainer;

},{"./Hotspot":15,"./support/cssPointerEvents":85,"./util/calcRect":87,"./util/clearOwnProperties":91,"./util/dom":100,"./util/positionAbsolutely":111,"minimal-event-emitter":14}],17:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


var eventEmitter = require('minimal-event-emitter');
var extend = require('./util/extend');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the layer has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Layer#renderComplete
 */

/**
 * @class Layer
 * @classdesc
 *
 * A Layer is a combination of {@link Source}, {@link Geometry}, {@link View}
 * and {@link TextureStore} that may be added into a {@link Stage} and rendered
 * with {@link Effects}.
 *
 * @param {Source} source
 * @param {Geometry} geometry
 * @param {View} view
 * @param {TextureStore} textureStore
 * @param {Object} opts
 * @param {Effects} opts.effects
*/
function Layer(source, geometry, view, textureStore, opts) {
  opts = opts || {};

  var self = this;

  this._source = source;
  this._geometry = geometry;
  this._view = view;
  this._textureStore = textureStore;

  this._effects = opts.effects || {};

  this._fixedLevelIndex = null;

  this._viewChangeHandler = function() {
    self.emit('viewChange', self.view());
  };

  this._view.addEventListener('change', this._viewChangeHandler);

  this._textureStoreChangeHandler = function() {
    self.emit('textureStoreChange', self.textureStore());
  };

  this._textureStore.addEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureInvalid',
    this._textureStoreChangeHandler);
}

eventEmitter(Layer);


/**
 * Destructor.
 */
Layer.prototype.destroy = function() {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._textureStore.removeEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureInvalid',
    this._textureStoreChangeHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying {@link Source source}.
 * @return {Source}
 */
Layer.prototype.source = function() {
  return this._source;
};


/**
 * Returns the underlying {@link Geometry geometry}.
 * @return {Geometry}
 */
Layer.prototype.geometry = function() {
  return this._geometry;
};


/**
 * Returns the underlying {@link View view}.
 * @return {View}
 */
Layer.prototype.view = function() {
  return this._view;
};


/**
 * Returns the underlying {@link TextureStore texture store}.
 * @return {TextureStore}
 */
Layer.prototype.textureStore = function() {
  return this._textureStore;
};


/**
 * Returns the currently set {@link Effects effects}.
 * @return {Effects}
 */
Layer.prototype.effects = function() {
  return this._effects;
};


/**
 * Sets the {@link Effects effects}.
 * @param {Effects} effects
 */
Layer.prototype.setEffects = function(effects) {
  this._effects = effects;
  this.emit('effectsChange', this._effects);
};


/**
 * Merges effects into the currently set ones. The merge is non-recursive; for
 * instance, if current effects are `{ rect: { relativeWidth: 0.5 } }`,
 * calling this method with `{ rect: { relativeX: 0.5 }}` will reset
 * `rect.relativeWidth`.
 *
 * @param {Effects} effects
 */
Layer.prototype.mergeEffects = function(effects) {
  extend(this._effects, effects);
  this.emit('effectsChange', this._effects);
};


/**
 * Returns the fixed level index.
 * @return {(number|null)}
 */
Layer.prototype.fixedLevel = function() {
  return this._fixedLevelIndex;
};


/**
 * Sets the fixed level index. When set, the corresponding level will be
 * used regardless of the view parameters. Unset with a null argument.
 *
 * @param {(number|null)} levelIndex
 * @throws An error if the level index is out of range.
 */
Layer.prototype.setFixedLevel = function(levelIndex) {
  if (levelIndex !== this._fixedLevelIndex) {
    if (levelIndex != null && (levelIndex >= this._geometry.levelList.length ||
        levelIndex < 0)) {
      throw new Error("Level index out of range: " + levelIndex);
    }
    this._fixedLevelIndex = levelIndex;
    this.emit('fixedLevelChange', this._fixedLevelIndex);
  }
};


Layer.prototype._selectLevel = function() {
  var level;
  if (this._fixedLevelIndex != null) {
    level = this._geometry.levelList[this._fixedLevelIndex];
  } else {
    level = this._view.selectLevel(this._geometry.selectableLevelList);
  }
  return level;
};


Layer.prototype.visibleTiles = function(result) {
  var level = this._selectLevel();
  return this._geometry.visibleTiles(this._view, level, result);
};


/**
 * Pin a whole level into the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.pinLevel = function(levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.pin(tiles[i]);
  }
};


/**
 * Unpin a whole level from the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.unpinLevel = function(levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.unpin(tiles[i]);
  }
};


/**
 * Pin the first level. Equivalent to `pinLevel(0)`.
 */
Layer.prototype.pinFirstLevel = function() {
  return this.pinLevel(0);
};


/**
 * Unpin the first level. Equivalent to `unpinLevel(0)`.
 */
Layer.prototype.unpinFirstLevel = function() {
  return this.unpinLevel(0);
};


module.exports = Layer;

},{"./util/clearOwnProperties":91,"./util/extend":101,"minimal-event-emitter":14}],18:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('./util/inherits');

/**
 * @class NetworkError
 * @extends {Error}
 * @classdesc
 *
 * Signals an error that occurred while fetching a URL. This is used by
 * {@link Loader loaders} to distinguish network failures from other errors.
 */
function NetworkError(message) {
  // See: https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript
  this.constructor.super_.apply(this, arguments);
  this.message = message;
}

inherits(NetworkError, Error);

module.exports = NetworkError;

},{"./util/inherits":104}],19:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that {@link Stage#render} is about to be called.
 * @event RenderLoop#beforeRender
 */

/**
 * Signals that {@link Stage#render} has just been called.
 * @event RenderLoop#afterRender
 */

/**
 * @class RenderLoop
 * @classdesc
 *
 * A RenderLoop wraps a {@link Stage} and calls {@link Stage#render} on the next
 * frame whenever it fires {@link Stage#renderInvalid}. It may be started and
 * stopped, and is initially in the stopped state, in which no call to
 * {@link Stage#render} occurs.
 *
 * @listens Stage#renderInvalid
 *
 * @param {Stage} stage
 */
function RenderLoop(stage) {

  var self = this;

  // The stage wrapped by the loop.
  this._stage = stage;

  // Whether the loop is running.
  this._running = false;

  // Whether the loop is currently rendering.
  this._rendering = false;

  // The current requestAnimationFrame handle.
  this._requestHandle = null;

  // The callback passed into requestAnimationFrame.
  this._boundLoop = this._loop.bind(this);

  // Handler for renderInvalid events emitted by the stage.
  this._renderInvalidHandler = function() {
    // If we are already rendering, there's no need to schedule a new render
    // on the next frame.
    if (!self._rendering) {
      self.renderOnNextFrame();
    }
  };

  // Handle renderInvalid events emitted by the stage.
  this._stage.addEventListener('renderInvalid', this._renderInvalidHandler);

}

eventEmitter(RenderLoop);


/**
 * Destructor.
 */
RenderLoop.prototype.destroy = function() {
  this.stop();
  this._stage.removeEventListener('renderInvalid', this._renderInvalidHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying stage.
 * @return {Stage}
 */
RenderLoop.prototype.stage = function() {
  return this._stage;
};


/**
 * Starts the render loop.
 */
RenderLoop.prototype.start = function() {
  this._running = true;
  this.renderOnNextFrame();
};


/**
 * Stops the render loop.
 */
RenderLoop.prototype.stop = function() {
  if (this._requestHandle) {
    window.cancelAnimationFrame(this._requestHandle);
    this._requestHandle = null;
  }
  this._running = false;
};


/**
 * Forces the stage to render on the next frame, even if its contents remain
 * valid. Does nothing if the loop is stopped.
 */
RenderLoop.prototype.renderOnNextFrame = function() {
  if (this._running && !this._requestHandle) {
    this._requestHandle = window.requestAnimationFrame(this._boundLoop);
  }
};


RenderLoop.prototype._loop = function() {
  if (!this._running) {
    throw new Error('Render loop running while in stopped state');
  }
  this._requestHandle = null;
  this._rendering = true;
  this.emit('beforeRender');
  this._rendering = false;
  this._stage.render();
  this.emit('afterRender');
};


module.exports = RenderLoop;

},{"./util/clearOwnProperties":91,"minimal-event-emitter":14}],20:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Layer = require('./Layer');
var TextureStore = require('./TextureStore');
var HotspotContainer = require('./HotspotContainer');
var eventEmitter = require('minimal-event-emitter');
var now = require('./util/now');
var noop = require('./util/noop');
var type = require('./util/type');
var defaults = require('./util/defaults');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the scene's view has changed. See {@link View#event:change}.
 * @event Scene#viewChange
 */

/**
 * Signals that the scene's layers have changed.
 * @event Scene#layerChange
 */

/**
 * @class Scene
 * @classdesc
 *
 * A Scene is a stack of {@link Layer layers} sharing the same {@link View view}
 * and {@link HotspotContainer hotspot container}. It belongs to the
 * {@link Viewer viewer} inside which it is displayed.
 *
 * Clients should call {@link Viewer#createScene} instead of invoking the
 * constructor directly.
 *
 * @param {Viewer} viewer The viewer this scene belongs to.
 * @param {View} view The scene's underlying view.
 */
function Scene(viewer, view) {
  this._viewer = viewer;
  this._view = view;
  this._layers = [];

  // Hotspot container. Assume it occupies a full rect.
  this._hotspotContainer = new HotspotContainer(
    viewer._controlContainer,
    viewer.stage(),
    this._view,
    viewer.renderLoop());

  // The current movement.
  this._movement = null;
  this._movementStartTime = null;
  this._movementStep = null;
  this._movementParams = null;
  this._movementCallback = null;

  // Event listener for updating the view according to the current movement.
  // The listener is set/unset on the render loop when a movement starts/stops.
  this._updateMovementHandler = this._updateMovement.bind(this);

  // Show or hide hotspots when scene changes.
  this._updateHotspotContainerHandler = this._updateHotspotContainer.bind(this);
  this._viewer.addEventListener('sceneChange', this._updateHotspotContainerHandler);

  // Emit event when view changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');
  this._view.addEventListener('change', this._viewChangeHandler);

  // Update the hotspot container.
  this._updateHotspotContainer();
}

eventEmitter(Scene);


/**
 * Destructor. Clients should call {@link Viewer#destroyScene} instead.
 */
Scene.prototype.destroy = function() {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._viewer.removeEventListener('sceneChange', this._updateHotspotContainerHandler);

  if (this._movement) {
    this.stopMovement();
  }

  this._hotspotContainer.destroy();

  this.destroyAllLayers();

  clearOwnProperties(this);
};



/**
 * Returns the {@link HotspotContainer hotspot container} for the scene.
 * @return {Layer}
 */
Scene.prototype.hotspotContainer = function() {
  return this._hotspotContainer;
};

/**
 * Returns the first of the {@link Layer layers} belonging to the scene, or
 * null if the scene has no layers.
 *
 * This method is equivalent to `Scene#listLayers[0]`. It may be removed in the
 * future.
 *
 * @return {Layer}
 */
Scene.prototype.layer = function() {
  return this._layers[0];
};

/**
* Returns a list of all {@link Layer layers} belonging to the scene. The
* returned list is in display order, background to foreground.
* @return {Layer[]}
 */
Scene.prototype.listLayers = function() {
  return [].concat(this._layers);
};


/**
 * Returns the scene's underlying {@link View view}.
 * @return {View}
 */
Scene.prototype.view = function() {
  return this._view;
};


/**
 * Returns the {@link Viewer viewer} the scene belongs to.
 * @return {Viewer}
 */
Scene.prototype.viewer = function() {
  return this._viewer;
};


/**
 * Returns whether the scene is currently visible.
 * @return {boolean}
 */
Scene.prototype.visible = function() {
  return this._viewer.scene() === this;
};


/**
 * Creates a new {@link Layer layer} and adds it into the scene in the
 * foreground position.
 *
 * @param {Object} opts Layer creation options.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Source} opts.geometry The layer's underlying {@link Geometry}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Layer}
 */
Scene.prototype.createLayer = function(opts) {
  opts = opts || {};

  var textureStoreOpts = opts.textureStoreOpts || {};
  var layerOpts = opts.layerOpts || {};

  var source = opts.source;
  var geometry = opts.geometry;
  var view = this._view;
  var stage = this._viewer.stage();
  var textureStore = new TextureStore(source, stage, textureStoreOpts);
  var layer = new Layer(source, geometry, view, textureStore, layerOpts);

  this._layers.push(layer);

  if (opts.pinFirstLevel) {
    layer.pinFirstLevel();
  }

  // Signal that the layers have changed.
  this.emit('layerChange');

  return layer;
};


/**
 * Destroys a {@link Layer layer} and removes it from the scene.
 * @param {Layer} layer
 * @throws An error if the layer does not belong to the scene.
 */
Scene.prototype.destroyLayer = function(layer) {
  var i = this._layers.indexOf(layer);
  if (i < 0) {
    throw new Error('No such layer in scene');
  }

  this._layers.splice(i, 1);

  // Signal that the layers have changed.
  this.emit('layerChange');

  layer.textureStore().destroy();
  layer.destroy();
};


/**
 * Destroys all {@link Layer layers} and removes them from the scene.
 */
Scene.prototype.destroyAllLayers = function() {
  while (this._layers.length > 0) {
    this.destroyLayer(this._layers[0]);
  }
};


/**
 * Switches to the scene.
 *
 * This is equivalent to calling {@link Viewer#switchScene} on this scene.
 *
 * @param {Object} opts Options to pass into {@link Viewer#switchScene}.
 * @param {function} done Function to call when the switch is complete.
 */
Scene.prototype.switchTo = function(opts, done) {
  return this._viewer.switchScene(this, opts, done);
};


/**
 * Tweens the scene's underlying {@link View view}.
 *
 * @param {Object} params Target view parameters.
 * @param {Object} opts Transition options.
 * @param {function} [opts.ease=easeInOutQuad] Tween easing function
 * @param {number} [opts.controlsInterrupt=false] allow controls to interrupt
 *     an ongoing tween.
 * @param {number} [opts.transitionDuration=1000] Tween duration, in
 *     milliseconds.
 * @param {number} [opts.closest=true] Whether to tween through the shortest
 *    path between the initial and final view parameters. This requires
 *    {@link View#normalizeToClosest} to be implemented, and does nothing
 *    otherwise.
 * @param {function} done Function to call when the tween finishes or is
 *    interrupted.
 */
Scene.prototype.lookTo = function(params, opts, done) {
  opts = opts || {};
  done = done || noop;

  if (type(params) !== 'object') {
    throw new Error("Target view parameters must be an object");
  }

  // Quadratic in/out easing.
  var easeInOutQuad = function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  };

  var ease = opts.ease != null ? opts.ease : easeInOutQuad;
  var controlsInterrupt = opts.controlsInterrupt != null ? opts.controlsInterrupt : false;
  var duration = opts.transitionDuration != null ? opts.transitionDuration : 1000;
  var shortest = opts.shortest != null ? opts.shortest : true;

  var view = this._view;

  var initialParams = view.parameters();

  var finalParams = {};
  defaults(finalParams, params);
  defaults(finalParams, initialParams);

  // Tween through the shortest path if requested.
  // The view must implement the normalizeToClosest() method.
  if (shortest && view.normalizeToClosest) {
    view.normalizeToClosest(finalParams, finalParams);
  }

  var movement = function() {

    var finalUpdate = false;

    return function(params, elapsed) {

      if (elapsed >= duration && finalUpdate) {
        return null;
      }

      var delta = Math.min(elapsed / duration, 1);

      for (var param in params) {
        var start = initialParams[param];
        var end = finalParams[param];
        params[param] = start + ease(delta) * (end - start);
      }

      finalUpdate = elapsed >= duration;

      return params;

    };
  };

  var reenableControls = this._viewer.controls().enabled();

  if (!controlsInterrupt) {
    this._viewer.controls().disable();
  }

  this.startMovement(movement, function() {
    if (reenableControls) {
      this._viewer.controls().enable();
    }
    done();
  });

};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Scene.prototype.startMovement = function(fn, done) {

  var renderLoop = this._viewer.renderLoop();

  if (this._movement) {
    this.stopMovement();
  }

  var step = fn();
  if (typeof step !== 'function') {
    throw new Error('Bad movement');
  }

  this._movement = fn;
  this._movementStep = step;
  this._movementStartTime = now();
  this._movementParams = {};
  this._movementCallback = done;

  renderLoop.addEventListener('beforeRender', this._updateMovementHandler);
  renderLoop.renderOnNextFrame();
};


/**
 * Stops the current movement.
 */
Scene.prototype.stopMovement = function() {

  var renderLoop = this._viewer.renderLoop();

  if (!this._movement) {
    return;
  }

  if (this._movementCallback) {
    this._movementCallback();
  }

  renderLoop.removeEventListener('beforeRender', this._updateMovementHandler);

  this._movement = null;
  this._movementStep = null;
  this._movementStartTime = null;
  this._movementParams = null;
  this._movementCallback = null;
};


/**
 * Returns the current movement.
 * @return {function}
 */
Scene.prototype.movement = function() {
  return this._movement;
};


Scene.prototype._updateMovement = function() {

  if (!this._movement) {
    throw new Error('Should not call update');
  }

  var renderLoop = this._viewer.renderLoop();
  var view = this._view;

  var elapsed = now() - this._movementStartTime;
  var step = this._movementStep;
  var params = this._movementParams;

  params = view.parameters(params);
  params = step(params, elapsed);
  if (params == null) {
    this.stopMovement();
  } else {
    view.setParameters(params);
    renderLoop.renderOnNextFrame();
  }

};


Scene.prototype._updateHotspotContainer = function() {
  if (this.visible()) {
    this._hotspotContainer.show();
  } else {
    this._hotspotContainer.hide();
  }
};


module.exports = Scene;

},{"./HotspotContainer":16,"./Layer":17,"./TextureStore":21,"./util/clearOwnProperties":91,"./util/defaults":96,"./util/noop":107,"./util/now":108,"./util/type":116,"minimal-event-emitter":14}],21:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Map = require('./collections/Map');
var Set = require('./collections/Set');
var LruSet = require('./collections/LruSet');
var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var retry = require('./util/retry');
var chain = require('./util/chain');
var inherits = require('./util/inherits');
var clearOwnProperties = require('./util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.textureStore;


// A Stage informs the TextureStore about the set of visible tiles during a
// frame by calling startFrame, markTile and endFrame. In a particular frame,
// TextureStore expects one or more calls to startFrame, followed by zero or
// more calls to markTile, followed by one or more calls to endFrame. The
// number of calls to startFrame and endFrame must match. Calls to other
// TextureStore methods may be freely interleaved with this sequence.
//
// At any given time, TextureStore is in one of four states. The START state
// corresponds to the interval between the first startFrame and the first
// markTile of a frame. The MARK state corresponds to the interval between the
// first markTile and the first endFrame. The END state corresponds to the
// interval between the first and the last endFrame. At any other time, the
// TextureStore is in the IDLE state.
var State = {
  IDLE: 0,
  START: 1,
  MARK: 2,
  END: 3
};


var defaultOptions = {
  // Maximum number of cached textures for previously visible tiles.
  previouslyVisibleCacheSize: 512
};


// Assign an id to each operation so we can track its state.
// We actually only need this in debug mode, but the code is less convoluted
// if we track unconditionally, and the performance hit is minimal anyway.
var nextId = 0;


// Distinguishes a cancellation from other kinds of errors.
function CancelError() {}
inherits(CancelError, Error);


/**
 * @class TextureStoreItem
 * @classdesc
 *
 * An item saved in a {@link TextureStore}.
 *
 * Clients do not need to instantiate this. It is automatically instantiated by
 * a {@link TextureStore} to manage the lifetime of a stored item: loading,
 * refreshing, unloading and emitting associated events.
 *
 * @param {TextureStore} store The underlying {@link TextureStore}.
 * @param {Tile} tile The underlying tile.
 */
function TextureStoreItem(store, tile) {

  var self = this;

  var id = nextId++;

  self._id = id;
  self._store = store;
  self._tile = tile;

  self._asset = null;
  self._texture = null;

  self._changeHandler = function() {
    store.emit('textureInvalid', tile);
  };

  var source = store.source();
  var stage = store.stage();

  var loadAsset = source.loadAsset.bind(source);
  var createTexture = stage.createTexture.bind(stage);

  // Retry loading the asset until it succeeds, then create the texture from it.
  // This process may be canceled at any point by calling the destroy() method.
  var fn = chain(retry(loadAsset), createTexture);

  store.emit('textureStartLoad', tile);
  if (debug) {
    console.log('loading', id, tile);
  }

  self._cancel = fn(stage, tile, function(err, _tile, asset, texture) {

    // Make sure we do not call cancel after the operation is complete.
    self._cancel = null;

    if (err) {
      // The loading process was interrupted by an error.
      // This could either be because the texture creation failed, or because
      // the operation was canceled before the loading was complete.

      // Destroy the asset and texture, if they exist.
      if (asset) {
        asset.destroy();
      }
      if (texture) {
        texture.destroy();
      }

      // Emit events.
      if (err instanceof CancelError) {
        store.emit('textureCancel', tile);
        if (debug) {
          console.log('cancel', id, tile);
        }
      } else {
        store.emit('textureError', tile, err);
        if (debug) {
          console.log('error', id, tile);
        }
      }

      return;
    }

    // Save a local reference to the texture.
    self._texture = texture;

    // If the asset is dynamic, save a local reference to it and set up a
    // handler to be called whenever it changes. Otherwise, destroy the asset
    // as we won't be needing it any longer.
    if (asset.isDynamic()) {
      self._asset = asset;
      asset.addEventListener('change', self._changeHandler);
    } else {
      asset.destroy();
    }

    // Emit event.
    store.emit('textureLoad', tile);
    if (debug) {
      console.log('load', id, tile);
    }
  });

}


TextureStoreItem.prototype.asset = function() {
  return this._asset;
};


TextureStoreItem.prototype.texture = function() {
  return this._texture;
};


TextureStoreItem.prototype.destroy = function() {
  var id = this._id;
  var store = this._store;
  var tile = this._tile;
  var asset = this._asset;
  var texture = this._texture;
  var cancel = this._cancel;

  if (cancel) {
    // The texture is still loading, so cancel it.
    cancel(new CancelError('Texture load cancelled'));
    return;
  }

  // Destroy asset.
  if (asset) {
    asset.removeEventListener('change', this._changeHandler);
    asset.destroy();
  }

  // Destroy texture.
  if (texture) {
    texture.destroy();
  }

  // Emit event.
  store.emit('textureUnload', tile);
  if (debug) {
    console.log('unload', id, tile);
  }

  clearOwnProperties(this);
};

eventEmitter(TextureStoreItem);

/**
 * Signals that a texture has started to load.
 *
 * This event is followed by either {@link TextureStore#textureLoad},
 * {@link TextureStore#textureError} or {@link TextureStore#textureCancel}.
 *
 * @event TextureStore#textureStartLoad
 * @param {Tile} tile The tile for which the texture has started to load.
 */

/**
 * Signals that a texture has been loaded.
 *
 * @event TextureStore#textureLoad
 * @param {Tile} tile The tile for which the texture was loaded.
 */

/**
 * Signals that a texture has been unloaded.
 *
 * @event TextureStore#textureUnload
 * @param {Tile} tile The tile for which the texture was unloaded.
 */

/**
 * Signals that a texture has been invalidated.
 *
 * This event may be raised for a texture with an underlying dynamic asset. It
 * may only occur while the texture is loaded, i.e., in between
 * {@link TextureStore#textureLoad} and {@link TextureStore#textureUnload}.
 *
 * @event TextureStore#textureInvalid
 * @param {Tile} tile The tile for which the texture was invalidated.
 */

/**
 * Signals that loading a texture has been cancelled.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * becomes unnecessary before it finishes loading.
 *
 * @event TextureStore#textureCancel
 * @param {Tile} tile The tile for which the texture loading was cancelled.
 */

/**
 * Signals that loading a texture has failed.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * fails to load.
 *
 * @event TextureStore#textureError
 * @param {Tile} tile The tile for which the texture loading has failed.
 */

/**
 * @class TextureStore
 * @classdesc
 *
 * A TextureStore maintains a cache of textures used to render a {@link Layer}.
 *
 * A {@link Stage} communicates with the TextureStore through the startFrame(),
 * markTile() and endFrame() methods, which indicate the tiles that are visible
 * in the current frame. Textures for visible tiles are loaded and retained
 * as long as the tiles remain visible. A limited amount of textures whose
 * tiles were previously visible are cached according to an LRU policy. Tiles
 * may be pinned to keep their respective textures cached even when they are
 * invisible; these textures do not count towards the previously visible limit.
 *
 * Multiple layers belonging to the same underlying {@link WebGlStage} may
 * share the same TextureStore. Layers belonging to distinct {@link WebGlStage}
 * instances, or belonging to a {@link CssStage} or a {@link FlashStage},
 * may not do so due to restrictions on the use of textures across stages.
 *
 * @param {Source} source The underlying source.
 * @param {Stage} stage The underlying stage.
 * @param {Object} opts Options.
 * @param {Number} [opts.previouslyVisibleCacheSize=32] The maximum number of
 *     previously visible textures to cache according to an LRU policy.
 */
function TextureStore(source, stage, opts) {
  opts = defaults(opts || {}, defaultOptions);

  this._source = source;
  this._stage = stage;

  // The current state.
  this._state = State.IDLE;

  // The number of startFrame calls yet to be matched by endFrame calls during
  // the current frame.
  this._delimCount = 0;

  // The cache proper: map cached tiles to their respective textures/assets.
  this._itemMap = new Map();

  // The subset of cached tiles that are currently visible.
  this._visible = new Set();

  // The subset of cached tiles that were visible recently, but are not
  // visible right now. Newly inserted tiles replace older ones.
  this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);

  // The subset of cached tiles that should never be evicted from the cache.
  // A tile may be pinned more than once; map each tile into a reference count.
  this._pinMap = new Map();

  // Temporary variables.
  this._newVisible = new Set();
  this._noLongerVisible = [];
  this._visibleAgain = [];
  this._evicted = [];
}

eventEmitter(TextureStore);


/**
 * Destructor.
 */
TextureStore.prototype.destroy = function() {
  this.clear();
  clearOwnProperties(this);
};


/**
 * Return the underlying {@link Stage}.
 * @return {Stage}
 */
TextureStore.prototype.stage = function() {
  return this._stage;
};


/**
 * Return the underlying {@link Source}.
 * @return {Source}
 */
TextureStore.prototype.source = function() {
  return this._source;
};


/**
 * Remove all textures from the TextureStore, including pinned textures.
 */
TextureStore.prototype.clear = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    self._evicted.push(tile);
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all internal state.
  self._itemMap.clear();
  self._visible.clear();
  self._previouslyVisible.clear();
  self._pinMap.clear();
  self._newVisible.clear();
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


/**
 * Remove all textures in the TextureStore, excluding unpinned textures.
 */
TextureStore.prototype.clearNotPinned = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._evicted.push(tile);
    }
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all caches except the pinned set.
  self._visible.clear();
  self._previouslyVisible.clear();

  // Clear temporary variables.
  self._evicted.length = 0;
};


/**
 * Signal the beginning of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.startFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.IDLE && this._state !== State.START) {
    throw new Error('TextureStore: startFrame called out of sequence');
  }

  // Enter the START state, if not already there.
  this._state = State.START;

  // Expect one more endFrame call.
  this._delimCount++;
};


/**
 * Mark a tile as visible within the current frame. Called from {@link Stage}.
 * @param {Tile} tile The tile to mark.
 */
TextureStore.prototype.markTile = function(tile) {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK) {
    throw new Error('TextureStore: markTile called out of sequence');
  }

  // Enter the MARK state, if not already there.
  this._state = State.MARK;

  // Refresh texture for dynamic assets.
  var item = this._itemMap.get(tile);
  var texture = item && item.texture();
  var asset = item && item.asset();
  if (texture && asset) {
    texture.refresh(tile, asset);
  }

  // Add tile to the visible set.
  this._newVisible.add(tile);
};


/**
 * Signal the end of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.endFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {
    throw new Error('TextureStore: endFrame called out of sequence');
  }

  // Enter the END state, if not already there.
  this._state = State.END;

  // Expect one less call to endFrame.
  this._delimCount--;

  // If no further calls are expected, process frame and enter the IDLE state.
  if (!this._delimCount) {
    this._update();
    this._state = State.IDLE;
  }
};


TextureStore.prototype._update = function() {
  var self = this;

  // Calculate the set of tiles that used to be visible but no longer are.
  self._noLongerVisible.length = 0;
  self._visible.forEach(function(tile) {
    if (!self._newVisible.has(tile)) {
      self._noLongerVisible.push(tile);
    }
  });

  // Calculate the set of tiles that were visible recently and have become
  // visible again.
  self._visibleAgain.length = 0;
  self._newVisible.forEach(function(tile) {
    if (self._previouslyVisible.has(tile)) {
      self._visibleAgain.push(tile);
    }
  });

  // Remove tiles that have become visible again from the list of previously
  // visible tiles.
  self._visibleAgain.forEach(function(tile) {
    self._previouslyVisible.remove(tile);
  });

  // Cancel loading of tiles that are no longer visible.
  // Move no longer visible tiles with a loaded texture into the previously
  // visible set, and collect the tiles evicted from the latter.
  self._evicted.length = 0;
  self._noLongerVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    var texture = item && item.texture();
    if (texture) {
      var otherTile = self._previouslyVisible.add(tile);
      if (otherTile != null) {
        self._evicted.push(otherTile);
      }
    } else if (item) {
      self._unloadTile(tile);
    }
  });

  // Unload evicted tiles, unless they are pinned.
  self._evicted.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._unloadTile(tile);
    }
  });

  // Load visible tiles that are not already in the store.
  // Refresh texture on visible tiles for dynamic assets.
  self._newVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    if (!item) {
      self._loadTile(tile);
    }
  });

  // Swap the old visible set with the new one.
  var tmp = self._visible;
  self._visible = self._newVisible;
  self._newVisible = tmp;

  // Clear the new visible set.
  self._newVisible.clear();

  // Clear temporary variables.
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


TextureStore.prototype._loadTile = function(tile) {
  if (this._itemMap.has(tile)) {
    throw new Error('TextureStore: loading texture already in cache');
  }
  var item = new TextureStoreItem(this, tile);
  this._itemMap.set(tile, item);
};


TextureStore.prototype._unloadTile = function(tile) {
  var item = this._itemMap.del(tile);
  if (!item) {
    throw new Error('TextureStore: unloading texture not in cache');
  }
  item.destroy();
};


TextureStore.prototype.asset = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.asset();
  }
  return null;
};


TextureStore.prototype.texture = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.texture();
  }
  return null;
};


/**
 * Pin a tile. Textures for pinned tiles are never evicted from the store.
 * Upon pinning, the texture is created if not already present. Pins are
 * reference-counted; a tile may be pinned multiple times and must be unpinned
 * the corresponding number of times. Pinning is useful e.g. to ensure that
 * the lowest-resolution level of an image is always available to fall back
 * onto.
 * @param {Tile} tile the tile to pin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.pin = function(tile) {
  // Increment reference count.
  var count = (this._pinMap.get(tile) || 0) + 1;
  this._pinMap.set(tile, count);
  // If the texture for the tile is not present, load it now.
  if (!this._itemMap.has(tile)) {
    this._loadTile(tile);
  }
  return count;
};


/**
 * Unpin a tile. Pins are reference-counted; a tile may be pinned multiple
 * times and must be unpinned the corresponding number of times.
 * @param {Tile} tile the tile to unpin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.unpin = function(tile) {
  var count = this._pinMap.get(tile);
  // Consistency check.
  if (!count) {
    throw new Error('TextureStore: unpin when not pinned');
  } else {
    // Decrement reference count.
    count--;
    if (count > 0) {
      this._pinMap.set(tile, count);
    } else {
      this._pinMap.del(tile);
      // If the tile does not belong to either the visible or previously
      // visible sets, evict it from the cache.
      if (!this._visible.has(tile) && !this._previouslyVisible.has(tile)) {
        this._unloadTile(tile);
      }
    }
  }
  return count;
};


/**
 * Return type for {@link TextureStore#query}.
 * @typedef {Object} TileState
 * @property {boolean} visible Whether the tile is in the visible set.
 * @property {boolean} previouslyVisible Whether the tile is in the previously
 *     visible set.
 * @property {boolean} hasAsset Whether the asset for the tile is present.
 * @property {boolean} hasTexture Whether the texture for the tile is present.
 * @property {boolean} pinned Whether the tile is in the pinned set.
 * @property {number} pinCount The pin reference count for the tile.
 */


/**
 * Return the state of a tile.
 * @param {Tile} tile The tile to query.
 * @return {TileState}
 */
TextureStore.prototype.query = function(tile) {
  var item = this._itemMap.get(tile);
  var pinCount = this._pinMap.get(tile) || 0;
  return {
    visible: this._visible.has(tile),
    previouslyVisible: this._previouslyVisible.has(tile),
    hasAsset: item != null && item.asset() != null,
    hasTexture: item != null && item.texture() != null,
    pinned: pinCount !== 0,
    pinCount: pinCount
  };
};


module.exports = TextureStore;

},{"./collections/LruSet":30,"./collections/Map":31,"./collections/Set":32,"./util/chain":89,"./util/clearOwnProperties":91,"./util/defaults":96,"./util/inherits":104,"./util/retry":114,"minimal-event-emitter":14}],22:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Set = require('./collections/Set');

/**
 * @class TileSearcher
 * @classdesc
 *
 * A TileSearcher performs searches for visible tiles.
 */
function TileSearcher() {
  // Stack of tiles to be explored.
  this._stack = [];

  // Set of already explored tiles.
  this._visited = new Set();

  // Tile vertices. Allocated by Tile#vertices on first use.
  this._vertices = null;
}

/**
 * Performs a search for visible tiles by starting at a given tile and
 * recursively exploring neighbors until no more visible tiles are found.
 *
 * @param {View} view The view used to deem whether a tile is visible.
 * @param {Tile} tile The starting tile.
 * @param {Tile[]} result An array to append the visible tiles to, including the
 *     starting tile when visible. Existing array members are preserved.
 * @return {number} The number of visible tiles found.
 */
TileSearcher.prototype.search = function(view, startingTile, result) {
  var stack = this._stack;
  var visited = this._visited;
  var vertices = this._vertices;

  var count = 0;

  // Clear internal state.
  this._clear();

  stack.push(startingTile);

  while (stack.length > 0) {
    var tile = stack.pop();

    if (visited.has(tile)) {
      // Skip already visited tile.
      continue;
    }

    if (!view.intersects(tile.vertices(vertices))) {
      // Skip non-visible tile.
      continue;
    }

    // Mark tile as visited.
    visited.add(tile);

    // Add neighbors to the stack of tiles to explore.
    var neighbors = tile.neighbors();
    for (var i = 0; i < neighbors.length; i++) {
      stack.push(neighbors[i]);
    }

    // Add to result.
    result.push(tile);

    count++;
  }

  // Reuse the vertices array in future searches.
  this._vertices = vertices;

  // Clear internal state.
  this._clear();

  return count;
};

TileSearcher.prototype._clear = function() {
  this._stack.length = 0;
  this._visited.clear();
};

module.exports = TileSearcher;

},{"./collections/Set":32}],23:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var now = require('./util/now');

var defaultOptions = {
  duration: Infinity
};


/**
 * Signals a timeout.
 * @event Timer#timeout
 */


/**
 * @class Timer
 * @classdesc
 *
 * A Timer provides a mechanism to receive an event after a timeout.
 *
 * A timer has a set duration, and is either started or stopped at a given time.
 * The timer is initially stopped. When the timer is started, a timeout event is
 * scheduled to fire once the set duration elapses. When the timer is stopped,
 * the scheduled timeout event is cancelled. When a timeout event fires, the
 * timer returns to the stopped state.
 *
 * @param {number} [opts.duration=Infinity] Timeout in milliseconds.
 */
function Timer(opts) {

  opts = defaults(opts || {}, defaultOptions);

  this._duration = opts.duration;

  this._startTime = null;

  this._handle = null;

  this._check = this._check.bind(this);

}

eventEmitter(Timer);


/**
 * Starts the timer. If the timer is already started, this has the effect of
 * stopping and starting again (i.e. resetting the timer).
 */
Timer.prototype.start = function() {
  this._startTime = now();
  if (this._handle == null && this._duration < Infinity) {
    this._setup(this._duration);
  }
};


/**
 * Returns whether the timer is in the started state.
 * @return {boolean}
 */
Timer.prototype.started = function() {
  return this._startTime != null;
};


/**
 * Stops the timer.
 */
Timer.prototype.stop = function() {
  this._startTime = null;
  if (this._handle != null) {
    clearTimeout(this._handle);
    this._handle = null;
  }
};


Timer.prototype._setup = function(interval) {
  this._handle = setTimeout(this._check, interval);
};


Timer.prototype._teardown = function() {
  clearTimeout(this._handle);
  this._handle = null;
};


Timer.prototype._check = function() {
  var currentTime = now();
  var elapsed = currentTime - this._startTime;
  var remaining = this._duration - elapsed;

  this._teardown();

  if (remaining <= 0) {
    this.emit('timeout');
    this._startTime = null;
  } else if (remaining < Infinity) {
    this._setup(remaining);
  }
};


/**
 * Returns the currently set duration.
 */
Timer.prototype.duration = function() {
  return this._duration;
};


/**
 * Sets the duration. If the timer is already started, the timeout event is
 * rescheduled to occur once the new duration has elapsed since the last call
 * to start. In particular, if an amount of time larger than the new duration
 * has already elapsed, the timeout event fires immediately.
 * @param {number}
 */
Timer.prototype.setDuration = function(duration) {
  this._duration = duration;
  if (this._startTime != null) {
    this._check();
  }
};


module.exports = Timer;

},{"./util/defaults":96,"./util/now":108,"minimal-event-emitter":14}],24:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var browser = require('bowser');
var eventEmitter = require('minimal-event-emitter');

var RenderLoop = require('./RenderLoop');
var Controls = require('./controls/Controls');
var Scene = require('./Scene');
var Timer = require('./Timer');

var WebGlStage = require('./stages/WebGl');
var CssStage = require('./stages/Css');
var FlashStage = require('./stages/Flash');

var ControlCursor = require('./controls/ControlCursor');
var HammerGestures = require('./controls/HammerGestures');

var registerDefaultControls = require('./controls/registerDefaultControls');
var registerDefaultRenderers = require('./renderers/registerDefaultRenderers');

var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setAbsolute = require('./util/dom').setAbsolute;
var setFullSize = require('./util/dom').setFullSize;
var setBlocking = require('./util/dom').setBlocking;

var tween = require('./util/tween');
var noop = require('./util/noop');
var clearOwnProperties = require('./util/clearOwnProperties');

var stageMap = {
  webgl: WebGlStage,
  css: CssStage,
  flash: FlashStage
};

var stagePrefList = [
  WebGlStage,
  CssStage,
  FlashStage
];

/**
 * Signals that the current scene has changed.
 * @event Viewer#sceneChange
 */

/**
 * Signals that the view of the current scene has changed. See
 * {@link View#event:change}.
 * @event Viewer#viewChange
 */

/**
 * @class Viewer
 * @classdesc
 *
 * A Viewer is a container for multiple {@link Scene scenes} to be displayed
 * inside a {@link Stage stage} contained in the DOM.
 *
 * Scenes may be created by calling {@link Viewer#createScene}. Except during a
 * scene switch, a single one of them, called the current scene, is visible.
 * Calling {@link Viewer#switchScene} sets the current scene and switches to it.
 *
 * @param {Element} domElement The DOM element to contain the stage.
 * @param {Object} opts Viewer creation options.
 * @param {(null|'webgl'|'css'|'flash')} [opts.stageType=null] The type of stage
 *     to create. The default is to choose the most appropriate type depending
 *     on the browser capabilities.
 * @param {Object} opts.controls Options to be passed to
 *     {@link registerDefaultControls}.
 * @param {Object} opts.stage Options to be passed to the {@link Stage}
 *     constructor.
 * @param {Object} opts.cursors Cursor options.
 * @param {Object} opts.cursors.drag Drag cursor options to be passed to the
 *     {@link ControlCursor} constructor.
 */
function Viewer(domElement, opts) {
  opts = opts || {};

  this._domElement = domElement;

  // Add `overflow: hidden` to the domElement.
  setOverflowHidden(domElement);

  // Select the stage type to use.
  var Stage;
  if (opts.stageType) {
    // If a specific stage type was specified, use that one.
    Stage = stageMap[opts.stageType];
    if (!Stage) {
      throw new Error('Unknown stage type: ' + opts.stageType);
    }
  } else {
    // Choose the best supported stage according to the default preference
    // order. Note that this may yield an unsupported stage for some
    // geometry/view combinations. Client code is expected to pass in a
    // specific stage type in those cases.
    for (var i = 0; i < stagePrefList.length; i++) {
      if (stagePrefList[i].supported()) {
        Stage = stagePrefList[i];
        break;
      }
    }
    if (!Stage) {
      throw new Error('None of the stage types are supported');
    }
  }

  // Create stage.
  this._stage = new Stage(opts.stage);

  // Register the default renderers for the selected stage.
  registerDefaultRenderers(this._stage);

  // Add the stage element into the DOM.
  this._domElement.appendChild(this._stage.domElement());

  // Create control container.
  // Controls cannot be placed directly on the root DOM element because
  // Hammer.js will prevent click events from reaching the elements beneath.

  // The hotspot containers will be added inside the controls container.
  this._controlContainer = document.createElement('div');
  setAbsolute(this._controlContainer);
  setFullSize(this._controlContainer);

  // Prevent bounce scroll effect on iOS.
  // Applied only for iOS, as Android's events must have the default action to allow interaction with hotspots.
  if (browser.ios) {
    this._controlContainer.addEventListener('touchmove', function(event) {
      event.preventDefault();
    });
  }


  // Old IE does not detect mouse events on elements without background
  // Add a child element to the controls with full width, a background color
  // and opacity 0
  var controlCapture = document.createElement('div');
  setAbsolute(controlCapture);
  setFullSize(controlCapture);
  setBlocking(controlCapture);

  this._controlContainer.appendChild(controlCapture);
  domElement.appendChild(this._controlContainer);

  // Respond to window size changes.
  this._size = {};
  this.updateSize();
  this._updateSizeListener = this.updateSize.bind(this);
  window.addEventListener('resize', this._updateSizeListener);

  // Create render loop.
  this._renderLoop = new RenderLoop(this._stage);

  // Create the controls and register them with the render loop.
  this._controls = new Controls();
  this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);
  this._controls.attach(this._renderLoop);

  // Expose HammerJS.
  this._hammerManagerTouch = HammerGestures.get(this._controlContainer, 'touch');
  this._hammerManagerMouse = HammerGestures.get(this._controlContainer, 'mouse');

  // Initialize drag cursor.
  this._dragCursor = new ControlCursor(this._controls, 'mouseViewDrag', domElement, opts.cursors && opts.cursors.drag || {});

  // Start the render loop.
  this._renderLoop.start();

  // Scene list.
  this._scenes = [];

  // The currently visible scene.
  // During a scene transition, this is the scene being switched to.
  this._currentScene = null;

  // The scene being switched from during a scene transition.
  // This is necessary to update the layers correctly when they are added or
  // removed during a transition.
  this._replacedScene = null;

  // The current transition.
  this._cancelCurrentTween = null;

  // The event listener fired when the current scene layers change.
  // This is attached to the correct scene whenever the current scene changes.
  this._layerChangeHandler = this._updateSceneLayers.bind(this);

  // The event listener fired when the current scene view changes.
  // This is attached to the correct scene whenever the current scene changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');

  // Setup the idle timer.
  // By default, the timer has an infinite duration so it does nothing.
  this._idleTimer = new Timer();
  this._idleTimer.start();

  // Reset the timer whenever the view changes.
  this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);
  this.addEventListener('viewChange', this._resetIdleTimerHandler);

  // Start the idle movement when the idle timer fires.
  this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);
  this._idleTimer.addEventListener('timeout', this._triggerIdleTimerHandler);

  // Stop an ongoing movement when the controls are activated or when the
  // scene changes.
  this._stopMovementHandler = this.stopMovement.bind(this);
  this._controls.addEventListener('active', this._stopMovementHandler);
  this.addEventListener('sceneChange', this._stopMovementHandler);

  // The currently programmed idle movement.
  this._idleMovement = null;
}

eventEmitter(Viewer);


/**
 * Destructor.
 */
Viewer.prototype.destroy = function() {

  window.removeEventListener('resize', this._updateSizeListener);

  if (this._currentScene) {
    this._removeSceneEventListeners(this._currentScene);
  }

  if (this._replacedScene) {
    this._removeSceneEventListeners(this._replacedScene);
  }

  this._dragCursor.destroy();

  for (var methodName in this._controlMethods) {
    this._controlMethods[methodName].destroy();
  }

  while (this._scenes.length) {
    this.destroyScene(this._scenes[0]);
  }

  // The Flash renderer must be torn down before the element is removed from
  // the DOM, so all scenes must have been destroyed before this point.
  this._domElement.removeChild(this._stage.domElement());

  this._stage.destroy();
  this._renderLoop.destroy();
  this._controls.destroy();
  this._controls = null;

  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
  }

  clearOwnProperties(this);
};


/**
 * Updates the stage size to fill the containing element.
 *
 * This method is automatically called when the browser window is resized.
 * Most clients won't need to explicitly call it to keep the size up to date.
 */
Viewer.prototype.updateSize = function() {
  var size = this._size;
  size.width = this._domElement.clientWidth;
  size.height = this._domElement.clientHeight;
  this._stage.setSize(size);
};


/**
 * Returns the underlying {@link Stage stage}.
 * @return {Stage}
 */
Viewer.prototype.stage = function() {
  return this._stage;
};


/**
 * Returns the underlying {@link RenderLoop render loop}.
 * @return {RenderLoop}
 */
Viewer.prototype.renderLoop = function() {
  return this._renderLoop;
};


/**
 * Returns the underlying {@link Controls controls}.
 * @return {Controls}
 */
Viewer.prototype.controls = function() {
  return this._controls;
};


/**
 * Returns the underlying DOM element.
 * @return {Element}
 */
Viewer.prototype.domElement = function() {
  return this._domElement;
};


/**
 * Creates a new {@link Scene scene} with a single layer and adds it to the
 * viewer.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Scene}
 */
Viewer.prototype.createScene = function(opts) {
  opts = opts || {};

  var scene = this.createEmptyScene({ view: opts.view });

  scene.createLayer({
    source: opts.source,
    geometry: opts.geometry,
    pinFirstLevel: opts.pinFirstLevel,
    textureStoreOpts: opts.textureStoreOpts,
    layerOpts: opts.layerOpts
  });

  return scene;
};


/**
 * Creates a new {@link Scene scene} with no layers and adds it to the viewer.
 *
 * Layers may be added to the scene by calling {@link Scene#createLayer}.
 * However, if the scene has a single layer, it is simpler to call
 * {@link Viewer#createScene} instead of this method.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @return {Scene}
 */
Viewer.prototype.createEmptyScene = function(opts) {
  opts = opts || {};

  var scene = new Scene(this, opts.view);
  this._scenes.push(scene);

  return scene;
};


Viewer.prototype._updateSceneLayers = function() {
  var i;
  var layer;

  var stage = this._stage;
  var currentScene = this._currentScene;
  var replacedScene = this._replacedScene;

  var oldLayers = stage.listLayers();

  // The stage contains layers from at most two scenes: the current one, on top,
  // and the one currently being switched away from, on the bottom.
  var newLayers = [];
  if (replacedScene) {
    newLayers = newLayers.concat(replacedScene.listLayers());
  }
  if (currentScene) {
    newLayers = newLayers.concat(currentScene.listLayers());
  }

  // A single layer can be added or removed from the scene at a time.
  if (Math.abs(oldLayers.length - newLayers.length) !== 1) {
    throw new Error('Stage and scene out of sync');
  }

  if (newLayers.length < oldLayers.length) {
    // A layer was removed.
    for (i = 0; i < oldLayers.length; i++) {
      layer = oldLayers[i];
      if (newLayers.indexOf(layer) < 0) {
        this._removeLayerFromStage(layer);
        break;
      }
    }
  }
  if (newLayers.length > oldLayers.length) {
    // A layer was added.
    for (i = 0; i < newLayers.length; i++) {
      layer = newLayers[i];
      if (oldLayers.indexOf(layer) < 0) {
        this._addLayerToStage(layer, i);
      }
    }
  }

  // TODO: When in the middle of a scene transition, call the transition update
  // function immediately to prevent an added layer from flashing with the wrong
  // opacity.
};


Viewer.prototype._addLayerToStage = function(layer, i) {
  // Pin the first level to ensure a fallback while the layer is visible.
  // Note that this is distinct from the `pinFirstLevel` option passed to
  // createScene(), which pins the layer even when it's not visible.
  layer.pinFirstLevel();
  this._stage.addLayer(layer, i);
};


Viewer.prototype._removeLayerFromStage = function(layer) {
  this._stage.removeLayer(layer);
  layer.unpinFirstLevel();
  layer.textureStore().clearNotPinned();
};


Viewer.prototype._addSceneEventListeners = function(scene) {
  scene.addEventListener('layerChange', this._layerChangeHandler);
  scene.addEventListener('viewChange', this._viewChangeHandler);
};


Viewer.prototype._removeSceneEventListeners = function(scene) {
  scene.removeEventListener('layerChange', this._layerChangeHandler);
  scene.removeEventListener('viewChange', this._viewChangeHandler);
};


/**
 * Destroys a {@link Scene scene} and removes it from the viewer.
 * @param {Scene} scene
 */
Viewer.prototype.destroyScene = function(scene) {
  var i = this._scenes.indexOf(scene);
  if (i < 0) {
    throw new Error('No such scene in viewer');
  }

  var j;
  var layers;

  if (this._currentScene === scene) {
    // The destroyed scene is the current scene.
    // Remove event listeners, remove layers from stage and cancel transition.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    if (this._cancelCurrentTween) {
      this._cancelCurrentTween();
      this._cancelCurrentTween = null;
    }
    this._currentScene = null;
    this.emit('sceneChange');
  }

  if (this._replacedScene === scene) {
    // The destroyed scene is being switched away from.
    // Remove event listeners and remove layers from stage.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    this._replacedScene = null;
  }

  this._scenes.splice(i, 1);

  scene.destroy();
};


/**
 * Destroys all {@link Scene scenes} and removes them from the viewer.
 */
Viewer.prototype.destroyAllScenes = function() {
  while (this._scenes.length > 0) {
    this.destroyScene(this._scenes[0]);
  }
};


/**
 * Returns whether the viewer contains a {@link Scene scene}.
 * @param {Scene} scene
 * @return {boolean}
 */
Viewer.prototype.hasScene = function(scene) {
  return this._scenes.indexOf(scene) >= 0;
};


/**
 * Returns a list of all {@link Scene scenes}.
 * @return {Scene[]}
 */
Viewer.prototype.listScenes = function() {
  return [].concat(this._scenes);
};


/**
 * Returns the current {@link Scene scene}, or null if there isn't one.
 *
 * To change the current scene, call {@link Viewer#switchScene}.
 *
 * @return {Scene}
 */
Viewer.prototype.scene = function() {
  return this._currentScene;
};


/**
 * Returns the {@link View view} for the current {@link Scene scene}, or null
 * if there isn't one.
 * @return {View}
 */
Viewer.prototype.view = function() {
  var scene = this._currentScene;
  if (scene) {
    return scene.view();
  }
  return null;
};


/**
 * Tweens the {@link View view} for the current {@link Scene scene}.
 *
 * This method is equivalent to calling {@link Scene#lookTo} on the current
 * scene.
 *
 * @param {Object} opts Options to pass into {@link Scene#lookTo}.
 * @param {function} done Function to call when the tween is complete.
 */
Viewer.prototype.lookTo = function(params, opts, done) {
  // TODO: is it an error to call lookTo when no scene is displayed?
  var scene = this._currentScene;
  if (scene) {
    scene.lookTo(params, opts, done);
  }
};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * This method is equivalent to calling {@link Scene#startMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Viewer.prototype.startMovement = function(fn, done) {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.startMovement(fn, done);
};


/**
 * Stops the current movement.
 *
 * This method is equivalent to calling {@link Scene#stopMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 */
Viewer.prototype.stopMovement = function() {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.stopMovement();
};


/**
 * Returns the current movement.
 *
 * This method is equivalent to calling {@link Scene#movement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @return {function}
 */
Viewer.prototype.movement = function() {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  return scene.movement();
};


/**
 * Schedules an idle movement to be automatically started when the view remains
 * unchanged for the given timeout period.
 *
 * Changing the view while the idle movement is active stops the movement and
 * schedules it to start again after the same timeout period. To disable it
 * permanently, call with a null movement or an infinite timeout.
 *
 * @param {number} timeout Timeout period in milliseconds.
 * @param {function} movement Automatic movement function, or null to disable.
 */
Viewer.prototype.setIdleMovement = function(timeout, movement) {
  this._idleTimer.setDuration(timeout);
  this._idleMovement = movement;
};


/**
 * Stops the idle movement. It will be started again after the timeout set by
 * {@link Viewer#setIdleMovement}.
 */
Viewer.prototype.breakIdleMovement = function() {
  this.stopMovement();
  this._resetIdleTimer();
};


Viewer.prototype._resetIdleTimer = function() {
  this._idleTimer.start();
};


Viewer.prototype._triggerIdleTimer = function() {
  var idleMovement = this._idleMovement;
  if (!idleMovement) {
    return;
  }
  this.startMovement(idleMovement);
};


var defaultSwitchDuration = 1000;

function defaultTransitionUpdate(val, newScene, oldScene) {
  var layers = newScene.listLayers();
  layers.forEach(function(layer) {
    layer.mergeEffects({ opacity: val });
  });

  newScene._hotspotContainer.domElement().style.opacity = val;
}


/**
 * Switches to another {@link Scene scene} with a fade transition. This scene
 * becomes the current one.
 *
 * If a transition is already taking place, it is interrupted before the new one
 * starts.
 *
 * @param {Scene} newScene The scene to switch to.
 * @param {Object} opts Transition options.
 * @param {number} [opts.transitionDuration=1000] Transition duration, in
 *     milliseconds.
 * @param {number} [opts.transitionUpdate=defaultTransitionUpdate]
 *     Transition update function, with signature `f(t, newScene, oldScene)`.
 *     This function is called on each frame with `t` increasing from 0 to 1.
 *     An initial call with `t=0` and a final call with `t=1` are guaranteed.
 *     The default function sets the opacity of the new scene to `t`.
 * @param {function} done Function to call when the transition finishes or is
 *     interrupted. If the new scene is equal to the old one, no transition
 *     takes place, but this function is still called.
 */
Viewer.prototype.switchScene = function(newScene, opts, done) {
  var self = this;

  opts = opts || {};
  done = done || noop;

  var stage = this._stage;

  var oldScene = this._currentScene;

  // Do nothing if the target scene is the current one.
  if (oldScene === newScene) {
    done();
    return;
  }

  if (this._scenes.indexOf(newScene) < 0) {
    throw new Error('No such scene in viewer');
  }

  // Cancel an already ongoing transition. This ensures that the stage contains
  // layers from exactly one scene before the transition begins.
  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
    this._cancelCurrentTween = null;
  }

  var oldSceneLayers = oldScene ? oldScene.listLayers() : [];
  var newSceneLayers = newScene.listLayers();
  var stageLayers = stage.listLayers();

  // Check that the stage contains exactly as many layers as the current scene,
  // and that the top layer is the right one. If this test fails, either there
  // is a bug or the user tried to modify the stage concurrently.
  if (oldScene && ((stageLayers.length !== oldSceneLayers.length) ||
      (stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0]))) {
    throw new Error('Stage not in sync with viewer');
  }

  // Get the transition parameters.
  var duration = opts.transitionDuration != null ?
      opts.transitionDuration : defaultSwitchDuration;
  var update = opts.transitionUpdate != null ?
      opts.transitionUpdate : defaultTransitionUpdate;

  // Add new scene layers into the stage before starting the transition.
  for (var i = 0; i < newSceneLayers.length; i++) {
    this._addLayerToStage(newSceneLayers[i]);
  }

  // Update function to be called on every frame.
  function tweenUpdate(val) {
    update(val, newScene, oldScene);
  }

  // Once the transition is complete, remove old scene layers from the stage and
  // remove the event listeners. If the old scene was destroyed during the
  // transition, this has already been taken care of. Otherwise, we still need
  // to get a fresh copy of the scene's layers, since they might have changed
  // during the transition.
  function tweenDone() {
    if (self._replacedScene) {
      self._removeSceneEventListeners(self._replacedScene);
      oldSceneLayers = self._replacedScene.listLayers();
      for (var i = 0; i < oldSceneLayers.length; i++) {
        self._removeLayerFromStage(oldSceneLayers[i]);
      }
      self._replacedScene = null;
    }
    self._cancelCurrentTween = null;
    done();
  }

  // Store the cancelable for the transition.
  this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);

  // Update the current and replaced scene.
  this._currentScene = newScene;
  this._replacedScene = oldScene;

  // Emit scene and view change events.
  this.emit('sceneChange');
  this.emit('viewChange');

  // Add event listeners to the new scene.
  // Note that event listeners can only be removed from the old scene once the
  // transition is complete, since layers might get added or removed in the
  // interim.
  this._addSceneEventListeners(newScene);
};


module.exports = Viewer;

},{"./RenderLoop":19,"./Scene":20,"./Timer":23,"./controls/ControlCursor":37,"./controls/Controls":38,"./controls/HammerGestures":42,"./controls/registerDefaultControls":49,"./renderers/registerDefaultRenderers":70,"./stages/Css":77,"./stages/Flash":78,"./stages/WebGl":81,"./util/clearOwnProperties":91,"./util/dom":100,"./util/noop":107,"./util/tween":115,"bowser":1,"minimal-event-emitter":14}],25:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('./Static');
var inherits = require('../util/inherits');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class DynamicAsset
 * @implements Asset
 * @extends StaticAsset
 * @classdesc
 *
 * A mutable {@link Asset} compatible with {@link WebGlStage} and
 * {@link CssStage}.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function DynamicAsset(element) {
  this.constructor.super_.call(this, element);
  this._timestamp = 0;
}

inherits(DynamicAsset, StaticAsset);
eventEmitter(DynamicAsset);

/**
 * Destructor.
 */
DynamicAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

DynamicAsset.prototype.timestamp = function() {
  return this._timestamp;
};

DynamicAsset.prototype.isDynamic = function() {
  return true;
};

/**
 * Marks the asset dirty, signaling that the contents of the underlying pixel
 * source have changed.
 *
 * @throws If the asset is not dynamic.
 */
DynamicAsset.prototype.markDirty = function() {
  this._timestamp++;
  this.emit('change');
};

module.exports = DynamicAsset;

},{"../util/clearOwnProperties":91,"../util/inherits":104,"./Static":27,"minimal-event-emitter":14}],26:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class FlashAsset
 * @implements Asset
 * @classdesc
 *
 * An immutable {@link Asset} compatible with {@link FlashStage}.
 * 
 * The asset's underlying pixel source is a unique image ID associated with
 * a Flash application.
 *
 * @param {Element} flashElement The HTML element for the Flash application.
 * @param {number} imageId The unique image ID inside the Flash application.
 */
function FlashAsset(flashElement, imageId) {
  this._flashElement = flashElement;
  this._imageId = imageId;
}

eventEmitter(FlashAsset);

/**
 * Destructor.
 */
FlashAsset.prototype.destroy = function() {
  this._flashElement.unloadImage(this._imageId);
  clearOwnProperties(this);
};

FlashAsset.prototype.element = function() {
  return this._imageId;
};

FlashAsset.prototype.width = function() {
  // Not actually used anywhere.
  return 0;
};

FlashAsset.prototype.height = function() {
  // Not actually used anywhere.
  return 0;
};

FlashAsset.prototype.timestamp = function() {
  return 0;
};

FlashAsset.prototype.isDynamic = function() {
  return false;
};

module.exports = FlashAsset;

},{"../util/clearOwnProperties":91,"minimal-event-emitter":14}],27:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var global = require('../util/global');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

var propertyMap = {
  HTMLImageElement: ['naturalWidth', 'naturalHeight'],
  HTMLCanvasElement: ['width', 'height'],
  ImageBitmap: ['width', 'height']
};

/**
 * @class StaticAsset
 * @implements Asset
 * @classdesc
 *
 * An immutable {@link Asset} compatible with {@link WebGlStage} and
 * {@link CssStage}.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function StaticAsset(element) {
  var supported = false;
  for (var type in propertyMap) {
    if (global[type] && element instanceof global[type]) {
      supported = true;
      this._widthProp = propertyMap[type][0];
      this._heightProp = propertyMap[type][1];
      break;
    }
  }
  if (!supported) {
    throw new Error('Unsupported pixel source');
  }

  this._element = element;
}

eventEmitter(StaticAsset);

/**
 * Destructor.
 */
StaticAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

StaticAsset.prototype.element = function() {
  return this._element;
};

StaticAsset.prototype.width = function() {
  return this._element[this._widthProp];
};

StaticAsset.prototype.height = function() {
  return this._element[this._heightProp];
};

StaticAsset.prototype.timestamp = function() {
  return 0;
};

StaticAsset.prototype.isDynamic = function() {
  return false;
};

module.exports = StaticAsset;

},{"../util/clearOwnProperties":91,"../util/global":102,"minimal-event-emitter":14}],28:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('./util/defaults');

var defaultSpeed = 0.1;
var defaultAccel = 0.01;

var defaultOptions = {
  yawSpeed: defaultSpeed,
  pitchSpeed: defaultSpeed,
  fovSpeed: defaultSpeed,
  yawAccel: defaultAccel,
  pitchAccel: defaultAccel,
  fovAccel: defaultAccel,
  targetPitch: 0,
  targetFov: null
};

/**
 * @param {Object} opts
 * @param {Number} [opts.yawSpeed=0.1] Yaw maximum speed
 * @param {Number} [opts.pitchSpeed=0.1] Pitch maximum speed
 * @param {Number} [opts.fovSpeed=0.1] Fov maximum speed
 * @param {Number} [opts.yawAccel=0.01] Yaw acceleration
 * @param {Number} [opts.pitchAccel=0.01] Pitch acceleration
 * @param {Number} [opts.fovAccel=0.01] Fov acceleration
 * @param {Number} [opts.targetPitch=0] Value that pitch converges to. `null` means that the pitch will not change.
 * @param {Number} [opts.targetFov=null] Value that fov converges to. `null` means that the fov will not change.
 * @returns Movement function that can be passed to {@link Viewer#setIdleMovement} or {@link Scene#startMovement}
*/
function autorotate(opts) {

  opts = defaults(opts || {}, defaultOptions);

  var yawSpeed = opts.yawSpeed;
  var pitchSpeed = opts.pitchSpeed;
  var fovSpeed = opts.fovSpeed;
  var yawAccel = opts.yawAccel;
  var pitchAccel = opts.pitchAccel;
  var fovAccel = opts.fovAccel;
  var targetPitch = opts.targetPitch;
  var targetFov = opts.targetFov;

  return function start() {

    var lastTime = 0;
    var lastYawSpeed = 0;
    var lastPitchSpeed = 0;
    var lastFovSpeed = 0;

    var currentYawSpeed = 0;
    var currentPitchSpeed = 0;
    var currentFovSpeed = 0;

    var timeDelta;
    var yawDelta;
    var pitchDelta;
    var fovDelta;

    return function step(params, currentTime) {

      timeDelta = (currentTime - lastTime) / 1000;
      currentYawSpeed = Math.min(lastYawSpeed + timeDelta * yawAccel, yawSpeed);
      yawDelta = currentYawSpeed * timeDelta;
      params.yaw = params.yaw + yawDelta;

      if (targetPitch != null && params.pitch !== targetPitch) {
        var pitchThresh = 0.5 * lastPitchSpeed * lastPitchSpeed / pitchAccel;
        if (Math.abs(targetPitch - params.pitch) > pitchThresh) {
          // Acceleration phase
          currentPitchSpeed = Math.min(lastPitchSpeed + timeDelta * pitchAccel, pitchSpeed);
        } else {
          // Deceleration phase
          currentPitchSpeed = Math.max(lastPitchSpeed - timeDelta * pitchAccel, 0);
        }
        // currentPitchSpeed is the absolute value (>= 0)
        pitchDelta = currentPitchSpeed * timeDelta;
        if (targetPitch < params.pitch) {
          params.pitch = Math.max(targetPitch, params.pitch - pitchDelta);
        }
        if (targetPitch > params.pitch) {
          params.pitch = Math.min(targetPitch, params.pitch + pitchDelta);
        }
      }

      if (targetFov != null && params.fov !== targetPitch) {
        var fovThresh = 0.5 * lastFovSpeed * lastFovSpeed / fovAccel;
        if (Math.abs(targetFov - params.fov) > fovThresh) {
          // Acceleration phase
          currentFovSpeed = Math.min(lastFovSpeed + timeDelta * fovAccel, fovSpeed);
        } else {
          // Deceleration phase
          currentFovSpeed = Math.max(lastFovSpeed - timeDelta * fovAccel, 0);
        }
        // currentFovSpeed is the absolute value (>= 0)
        fovDelta = currentFovSpeed * timeDelta;
        if (targetFov < params.fov) {
          params.fov = Math.max(targetFov, params.fov - fovDelta);
        }
        if (targetFov > params.fov) {
          params.fov = Math.min(targetFov, params.fov + fovDelta);
        }
      }

      lastTime = currentTime;
      lastYawSpeed = currentYawSpeed;
      lastPitchSpeed = currentPitchSpeed;
      lastFovSpeed = currentFovSpeed;

      return params;

    };

  };

}

module.exports = autorotate;
},{"./util/defaults":96}],29:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruMap holds up to a maximum number of key-value pairs, ordered by their
// time of insertion. When the addition of a key-value pair would cause the
// capacity to be exceeded, the oldest key-value pair in the set is evicted.
// As a special case, an LruMap with zero capacity always rejects the insertion
// of a key-value pair.
//
// Keys must implement hash() and equals(). Note that the implementation doesn't
// currently use hash(), but a future version might.
function LruMap(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruMap: invalid capacity');
  }
  this._capacity = capacity;

  // Keys and values are stored in circular arrays ordered by decreasing age.
  // Start is the index of the oldest key/value and size is the number of valid
  // key/values; the region containing valid keys/values may wrap around.
  this._keys = new Array(this._capacity);
  this._values = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruMap.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Returns the value associated to the specified key, or null if not found.
LruMap.prototype.get = function(key) {
  for (var i = 0; i < this._size; i++) {
    var existingKey = this._keys[this._index(i)];
    if (key.equals(existingKey)) {
      return this._values[this._index(i)];
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value. The key-value pair becomes the newest. If the map
// is at capacity, the oldest key-value pair is removed. Returns the removed
// key, or null otherwise. If the capacity is zero, does nothing and returns
// the key.
LruMap.prototype.set = function(key, value) {
  if (this._capacity === 0) {
    return key;
  }
  this.del(key);
  var evictedKey =
      this._size === this._capacity ? this._keys[this._index(0)] : null;
  this._keys[this._index(this._size)] = key;
  this._values[this._index(this._size)] = value;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedKey;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
LruMap.prototype.del = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      var existingValue = this._values[this._index(i)];
      for (var j = i; j < this._size - 1; j++) {
        this._keys[this._index(j)] = this._keys[this._index(j + 1)];
        this._values[this._index(j)] = this._values[this._index(j + 1)];
      }
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
LruMap.prototype.has = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
LruMap.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
LruMap.prototype.clear = function() {
  this._keys.length = 0;
  this._values.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(key, value) for each item in the map, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
LruMap.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._keys[this._index(i)], this._values[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruMap;

},{"../util/mod":106}],30:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruSet holds up to a maximum number of elements, ordered by their time of
// insertion. When the addition of an element would cause the capacity to be
// exceeded, the oldest element in the set is evicted. As a special case, an
// LruSet with zero capacity always rejects the insertion of an element.
//
// Elements must implement hash() and equals(). Note that the implementation
// doesn't currently use hash(), but a future version might.
function LruSet(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruSet: invalid capacity');
  }
  this._capacity = capacity;

  // Elements are stored in a circular array ordered by decreasing age.
  // Start is the index of the oldest element and size is the number of valid
  // elements; the region containing valid elements may wrap around.
  this._elements = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruSet.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Adds an element into the set, possibly replacing an equal element already in
// the set. The element becomes the newest. If the set is at capacity, the
// oldest element is removed. Returns the removed element if it does not equal
// the inserted element, or null otherwise. If the capacity is zero, does
// nothing and returns the element.
LruSet.prototype.add = function(element) {
  if (this._capacity === 0) {
    return element;
  }
  this.remove(element);
  var evictedElement =
      this._size === this._capacity ? this._elements[this._index(0)] : null;
  this._elements[this._index(this._size)] = element;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedElement;
};

// Removes an element from the set.
// Returns the removed element, or null if the element was not found.
LruSet.prototype.remove = function(element) {
  for (var i = 0; i < this._size; i++) {
    var existingElement = this._elements[this._index(i)];
    if (element.equals(existingElement)) {
      for (var j = i; j < this._size - 1; j++) {
        this._elements[this._index(j)] = this._elements[this._index(j + 1)];
      }
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
LruSet.prototype.has = function(element) {
  for (var i = 0; i < this._size; i++) {
    if (element.equals(this._elements[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
LruSet.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
LruSet.prototype.clear = function() {
  this._elements.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
LruSet.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._elements[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruSet;

},{"../util/mod":106}],31:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A map data structure for keys implementing hash() and equals() and arbitrary
// values. The capacity, if given, is just a hint; the map is allowed to exceed
// it, but performance may suffer.
function Map(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Map: invalid capacity');
  }
  this._capacity = capacity || defaultCapacity;

  this._keyBuckets = [];
  this._valBuckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets.push([]);
    this._valBuckets.push([]);
  }
  this._size = 0;
}

// Returns the value associated with the specified key, or null if not found.
Map.prototype.get = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var valBucket = this._valBuckets[h];
      var existingValue = valBucket[i];
      return existingValue;
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value.
// Returns the replaced value, or null if no value was replaced.
Map.prototype.set = function(key, val) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      keyBucket[i] = key;
      valBucket[i] = val;
      return existingValue;
    }
  }
  keyBucket.push(key);
  valBucket.push(val);
  this._size++;
  return null;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
Map.prototype.del = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < keyBucket.length - 1; j++) {
        keyBucket[j] = keyBucket[j+1];
        valBucket[j] = valBucket[j+1];
      }
      keyBucket.length = keyBucket.length - 1;
      valBucket.length = valBucket.length - 1;
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
Map.prototype.has = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
Map.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
Map.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets[i].length = 0;
    this._valBuckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(key, value) for each key-value pair in the map, in an unspecified
// order. Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
Map.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var keyBucket = this._keyBuckets[i];
    var valBucket = this._valBuckets[i];
    for (var j = 0; j < keyBucket.length; j++) {
      fn(keyBucket[j], valBucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Map;

},{"../util/mod":106}],32:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A set data structure for elements implementing hash() and equals().
// The capacity, if given, is just a hint; the set is allowed to exceed it, but
// performance may suffer.
function Set(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Set: invalid capacity');
  }
  this._capacity = this._capacity || defaultCapacity;

  this._buckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._buckets.push([]);
  }
  this._size = 0;
}

// Adds an element, replacing an existing element.
// Returns the replaced element, or null if no element was replaced.
Set.prototype.add = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      bucket[i] = element;
      return existingElement;
    }
  }
  bucket.push(element);
  this._size++;
  return null;
};

// Removes an element.
// Returns the removed element, or null if the element was not found.
Set.prototype.remove = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < bucket.length - 1; j++) {
        bucket[j] = bucket[j+1];
      }
      bucket.length = bucket.length - 1;
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
Set.prototype.has = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
Set.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
Set.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._buckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
Set.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var bucket = this._buckets[i];
    for (var j = 0; j < bucket.length; j++) {
      fn(bucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Set;

},{"../util/mod":106}],33:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WorkQueue = require('./WorkQueue');
var mod = require('../util/mod');


function WorkPool(opts) {
  this._concurrency = opts && opts.concurrency || 1;
  this._paused = opts && !!opts.paused || false;

  this._pool = [];
  for (var i = 0; i < this._concurrency; i++) {
    this._pool.push(new WorkQueue(opts));
  }

  this._next = 0;
}


WorkPool.prototype.length = function() {
  var len = 0;
  for (var i = 0; i < this._pool.length; i++) {
    len += this._pool[i].length();
  }
  return len;
};


WorkPool.prototype.push = function(fn, cb) {
  var i = this._next;
  var cancel = this._pool[i].push(fn, cb);
  this._next = mod(this._next + 1, this._concurrency);
  return cancel;
};


WorkPool.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].pause();
    }
  }
};


WorkPool.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].resume();
    }
  }
};


module.exports = WorkPool;

},{"../util/mod":106,"./WorkQueue":34}],34:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('../util/now');


function WorkTask(fn, cb) {
  this.fn = fn;
  this.cb = cb;
  this.cfn = null;
}


function WorkQueue(opts) {
  this._queue = [];
  this._delay = opts && opts.delay || 0;
  this._paused = opts && !!opts.paused || false;
  this._currentTask = null;
  this._lastFinished = null;
}


WorkQueue.prototype.length = function() {
  return this._queue.length;
};


WorkQueue.prototype.push = function(fn, cb) {

  var task = new WorkTask(fn, cb);

  var cancel = this._cancel.bind(this, task);

  // Push the task into the queue.
  this._queue.push(task);

  // Run the task if idle.
  this._next();

  return cancel;

};


WorkQueue.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
  }
};


WorkQueue.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    this._next();
  }
};


WorkQueue.prototype._start = function(task) {

  // Consistency check.
  if (this._currentTask) {
    throw new Error('WorkQueue: called start while running task');
  }

  // Mark queue as busy, so that concurrent tasks wait.
  this._currentTask = task;

  // Execute the task.
  var finish = this._finish.bind(this, task);
  task.cfn = task.fn(finish);

  // Detect when a non-cancellable function has been queued.
  if (typeof task.cfn !== 'function') {
    throw new Error('WorkQueue: function is not cancellable');
  }

};


WorkQueue.prototype._finish = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  // Consistency check.
  if (this._currentTask !== task) {
    throw new Error('WorkQueue: called finish on wrong task');
  }

  // Call the task callback on the return values.
  task.cb.apply(null, args);

  // Mark as not busy and record task finish time, then advance to next task.
  this._currentTask = null;
  this._lastFinished = now();
  this._next();

};


WorkQueue.prototype._cancel = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  if (this._currentTask === task) {

    // Cancel running task. Because cancel passes control to the _finish
    // callback we passed into fn, the cleanup logic will be handled there.
    task.cfn.apply(null, args);

  } else {

    // Remove task from queue.
    var pos = this._queue.indexOf(task);
    if (pos >= 0) {
      this._queue.splice(pos, 1);
      task.cb.apply(null, args);
    }

  }

};


WorkQueue.prototype._next = function() {

  if (this._paused) {
    // Do not start tasks while paused.
    return;
  }

  if (!this._queue.length) {
    // No tasks to run.
    return;
  }

  if (this._currentTask) {
    // Will be called again when the current task finishes.
    return;
  }

  if (this._lastFinished != null) {
    var elapsed = now() - this._lastFinished;
    var remaining = this._delay - elapsed;
    if (remaining > 0) {
      // Too soon. Run again after the inter-task delay.
      setTimeout(this._next.bind(this), remaining);
      return;
    }
  }

  // Run the next task.
  var task = this._queue.shift();
  this._start(task);

};


module.exports = WorkQueue;

},{"../util/now":108}],35:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var vec4 = require('gl-matrix').vec4;
var mat4 = require('gl-matrix').mat4;

/**
 * Helper functions for color transformation {@link Effects}.
 *
 * References:
 *
 *   - [ColorMatrix Guide](http://docs.rainmeter.net/tips/colormatrix-guide)
 *   - [Matrix Operations for Image Processing](http://www.graficaobscura.com/matrix/index.html)
 *   - [WebGLImageFilter](https://github.com/phoboslab/WebGLImageFilter)
 *   - [glfx.js](https://github.com/evanw/glfx.js)
 *
 * @namespace colorEffects
 */

/**
 * A vector and matrix corresponding to an identity transformation.
 *
 * @param {Object} result Object to store result
 * @param {vec4} result.colorOffset Array with zeroes.
 * @param {mat4} result.colorMatrix Identity matrix.
 *
 * @memberof colorEffects
 */
function identity(resultArg) {
  var result = resultArg || {};
  result.colorOffset = result.colorOffset || vec4.create();
  result.colorMatrix = result.colorMatrix || mat4.create();
  return result;
}

/**
 * Apply color effects to a single pixel
 *
 * @param {vec4} pixel Values in range [0,1]
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 * @param {vec4} result Object to store result
 *
 * @memberof colorEffects
 */
function applyToPixel(pixel, effect, result) {
  vec4TransformMat4Transposed(result, pixel, effect.colorMatrix);
  vec4.add(result, result, effect.colorOffset);
}

// Oddly, the colorTransform matrix needs to be transposed to be used with
// vec4.transformMat4. It is strange that transformMat4 dosn't work the same
// way as multiplying on the shader.
// TODO: investigate this further
function vec4TransformMat4Transposed(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
  out[1] = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
  out[2] = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
  out[3] = m[12] * x + m[13] * y + m[14] * z + m[15] * w;
  return out;
}

/**
 * Apply color effects to an ImageData
 *
 * @param {ImageData} imageData This object will be mutated
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 *
 * @memberof colorEffects
 */
var tmpPixel = vec4.create();
function applyToImageData(imageData, effect) {
  var width = imageData.width;
  var height = imageData.height;
  var data = imageData.data;

  for(var i = 0; i < width * height; i++) {
    vec4.set(tmpPixel, data[i*4+0]/255, data[i*4+1]/255, data[i*4+2]/255, data[i*4+3]/255);
    applyToPixel(tmpPixel, effect, tmpPixel);
    data[i*4+0] = tmpPixel[0]*255;
    data[i*4+1] = tmpPixel[1]*255;
    data[i*4+2] = tmpPixel[2]*255;
    data[i*4+3] = tmpPixel[3]*255;
  }
}

module.exports = {
  identity: identity,
  applyToPixel: applyToPixel,
  applyToImageData: applyToImageData
};

},{"gl-matrix":3}],36:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var now = require('../util/now');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ControlComposer
 * @classdesc
 *
 * Combines changes in parameters triggered by multiple {@link ControlMethod}
 * instances.
 *
 * @listens ControlMethod#parameterDynamics
 */
function ControlComposer(opts) {
  opts = opts || {};

  this._methods = [];

  this._parameters = [ 'x' ,'y', 'axisScaledX', 'axisScaledY', 'zoom', 'yaw', 'pitch', 'roll' ];

  this._now = opts.nowForTesting || now;

  this._composedOffsets = { };

  this._composeReturn = { offsets: this._composedOffsets, changing: null };
}

eventEmitter(ControlComposer);


ControlComposer.prototype.add = function(instance) {
  if (this.has(instance)) {
    return;
  }

  var dynamics = {};
  this._parameters.forEach(function(parameter) {
    dynamics[parameter] = {
      dynamics: new Dynamics(),
      time: null
    };
  });

  var parameterDynamicsHandler = this._updateDynamics.bind(this, dynamics);

  var method = {
    instance: instance,
    dynamics: dynamics,
    parameterDynamicsHandler: parameterDynamicsHandler
  };

  instance.addEventListener('parameterDynamics', parameterDynamicsHandler);

  this._methods.push(method);
};


ControlComposer.prototype.remove = function(instance) {
  var index = this._indexOfInstance(instance);
  if (index >= 0) {
    var method = this._methods.splice(index, 1)[0];
    method.instance.removeEventListener('parameterDynamics', method.parameterDynamicsHandler);
  }
};


ControlComposer.prototype.has = function(instance) {
  return this._indexOfInstance(instance) >= 0;
};


ControlComposer.prototype._indexOfInstance = function(instance) {
  for (var i = 0; i < this._methods.length; i++) {
    if (this._methods[i].instance === instance) {
      return i;
    }
  }
  return -1;
};


ControlComposer.prototype.list = function() {
  var instances = [];
  for (var i = 0; i < this._methods.length; i++) {
    instances.push(this._methods[i].instance);
  }
  return instances;
};


ControlComposer.prototype._updateDynamics = function(storedDynamics, parameter, dynamics) {
  var parameterDynamics = storedDynamics[parameter];

  if (!parameterDynamics) {
    throw new Error("Unknown control parameter " + parameter);
  }

  var newTime = this._now();
  parameterDynamics.dynamics.update(dynamics, (newTime - parameterDynamics.time)/1000);
  parameterDynamics.time = newTime;

  this.emit('change');
};


ControlComposer.prototype._resetComposedOffsets = function() {
  for (var i = 0; i < this._parameters.length; i++) {
    this._composedOffsets[this._parameters[i]] = 0;
  }
};


ControlComposer.prototype.offsets = function() {
  var parameter;
  var changing = false;

  var currentTime = this._now();

  this._resetComposedOffsets();

  for (var i = 0; i < this._methods.length; i++) {
    var methodDynamics = this._methods[i].dynamics;

    for (var p = 0; p < this._parameters.length; p++) {
      parameter = this._parameters[p];
      var parameterDynamics = methodDynamics[parameter];
      var dynamics = parameterDynamics.dynamics;


      // Add offset to composed offset
      if (dynamics.offset != null) {
        this._composedOffsets[parameter] += dynamics.offset;
        // Reset offset
        dynamics.offset = null;
      }

      // Calculate offset from velocity and add it
      var elapsed = (currentTime - parameterDynamics.time)/1000;
      var offsetFromVelocity = dynamics.offsetFromVelocity(elapsed);

      if(offsetFromVelocity) {
        this._composedOffsets[parameter] += offsetFromVelocity;
      }

      // Update velocity on dynamics
      var currentVelocity = dynamics.velocityAfter(elapsed);
      dynamics.velocity = currentVelocity;

      // If there is still a velocity, set changing
      if(currentVelocity) {
        changing = true;
      }

      parameterDynamics.time = currentTime;
    }
  }

  this._composeReturn.changing = changing;
  return this._composeReturn;
};


ControlComposer.prototype.destroy = function() {
  var instances = this.list();
  for (var i = 0; i < instances.length; i++) {
    this.remove(instances[i]);
  }

  clearOwnProperties(this);
};


module.exports = ControlComposer;

},{"../util/clearOwnProperties":91,"../util/now":108,"./Dynamics":40,"minimal-event-emitter":14}],37:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOpts = {
  active: 'move',
  inactive: 'default',
  disabled: 'default'
};

/**
 * @class ControlCursor
 * @classdesc
 *
 * Sets the CSS cursor on a DOM element according to the state of a
 * {@link ControlMethod}.
 *
 * @param {Controls} controls Controls instance containing the control method.
 * @param {string} id ID of the control method.
 * @param {Element} element DOM element where the cursor should be set.
 * @param {Object} opts The control cursors. Each field must be a valid value
 *     for the `cursor` CSS property.
 * @param {string} [opts.active='move'] Cursor to set when the control method
 *     is enabled and active.
 * @param {string} [opts.inactive='default'] Cursor to set when the control
 *     method is enabled and inactive.
 * @param {string} [opts.disabled='default'] Cursor to set when the control
 *     method is disabled.
 */
function ControlCursor(controls, id, element, opts) {
  opts = defaults(opts || {}, defaultOpts);

  // TODO: This class may misbehave if the control method is unregistered and a
  // different control method is registered under the same id.

  this._element = element;
  this._controls = controls;
  this._id = id;

  this._attached = false;

  this._setActiveCursor = this._setCursor.bind(this, opts.active);
  this._setInactiveCursor = this._setCursor.bind(this, opts.inactive);
  this._setDisabledCursor = this._setCursor.bind(this, opts.disabled);
  this._setOriginalCursor = this._setCursor.bind(this, this._element.style.cursor);

  this._updateAttachmentHandler = this._updateAttachment.bind(this);

  controls.addEventListener('methodEnabled', this._updateAttachmentHandler);
  controls.addEventListener('methodDisabled', this._updateAttachmentHandler);
  controls.addEventListener('enabled', this._updateAttachmentHandler);
  controls.addEventListener('disabled', this._updateAttachmentHandler);

  this._updateAttachment();
}

/**
 * Destructor.
 */
ControlCursor.prototype.destroy = function() {
  this._detachFromControlMethod(this._controls.method(this._id));
  this._setOriginalCursor();

  this._controls.removeEventListener('methodEnabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('methodDisabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('enabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('disabled',
      this._updateAttachmentHandler);

  clearOwnProperties(this);
};

ControlCursor.prototype._updateAttachment = function() {
  var controls = this._controls;
  var id = this._id;
  if (controls.enabled() && controls.method(id).enabled) {
    this._attachToControlMethod(controls.method(id));
  } else {
    this._detachFromControlMethod(controls.method(id));
  }
};

ControlCursor.prototype._attachToControlMethod = function(controlMethod) {
  if (!this._attached) {
    controlMethod.instance.addEventListener('active', this._setActiveCursor);
    controlMethod.instance.addEventListener('inactive', this._setInactiveCursor);

    if (controlMethod.active) {
      this._setActiveCursor();
    } else {
      this._setInactiveCursor();
    }

    this._attached = true;
  }
};

ControlCursor.prototype._detachFromControlMethod = function(controlMethod) {
  if (this._attached) {
    controlMethod.instance.removeEventListener('active', this._setActiveCursor);
    controlMethod.instance.removeEventListener('inactive', this._setInactiveCursor);

    this._setDisabledCursor();

    this._attached = false;
  }
};

ControlCursor.prototype._setCursor = function(cursor) {
  this._element.style.cursor = cursor;
}

module.exports = ControlCursor;

},{"../util/clearOwnProperties":91,"../util/defaults":96}],38:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Composer = require('./Composer');
var clearOwnProperties = require('../util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class Controls
 * @classdesc
 *
 * Set of controls which affect a view (e.g. keyboard, touch)
 *
 * {@link ControlMethod} instances can be registered on this class. The methods
 * are then combined to calculate the final parameters to change the {@link View}.
 *
 * Controls is attached to a {@link RenderLoop}. Currently it affects the
 * {@link view} of all {@link Layer} on the {@link Stage} of the
 * {@link RenderLoop} it is attached to. A more flexible API may be provided
 * in the future.
 *
 * The ControlMethod instances are registered with an id and may be enabled,
 * disabled and unregistered using that id. The whole Control can also be
 * enabled or disabled.
 *
 */
function Controls(opts) {
  opts = opts || {};

  this._methods = {};
  this._methodGroups = {};
  this._composer = new Composer();

  // Whether the controls are enabled.
  this._enabled = (opts && opts.enabled) ? !!opts.enabled : true;

  // How many control methods are enabled and in the active state.
  this._activeCount = 0;

  this.updatedViews_ = [];

  this._attachedRenderLoop = null;
}

eventEmitter(Controls);

/**
 * Destructor.
 */
Controls.prototype.destroy = function() {
  this.detach();
  this._composer.destroy();
  clearOwnProperties(this);
};


/**
 * @return {ControlMethod[]} List of registered @{link ControlMethod instances}
 */
Controls.prototype.methods = function() {
  var obj = {};
  for (var id in this._methods) {
    obj[id] = this._methods[id];
  }
  return obj;
};

/**
 * @param {String} id
 * @return {ControlMethod}
 */
Controls.prototype.method = function(id) {
  return this._methods[id];
};

/**
 * @param {String} id
 * @param {ControlMethod} instance
 * @param {Boolean} [enable=false]
 */
Controls.prototype.registerMethod = function(id, instance, enable) {
  if (this._methods[id]) {
    throw new Error('Control method already registered with id ' + id);
  }

  this._methods[id] = {
    instance: instance,
    enabled: false,
    active: false,
    activeHandler: this._handleActive.bind(this, id),
    inactiveHandler: this._handleInactive.bind(this, id)
  };

  if(enable) {
    this.enableMethod(id, instance);
  }
};


/**
 * @param {String} id
 */
Controls.prototype.unregisterMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    this.disableMethod(id);
  }
  delete this._methods[id];
};

/**
 * @param {String} id
 */
Controls.prototype.enableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    return;
  }
  method.enabled = true;
  if (method.active) {
    this._incrementActiveCount();
  }
  this._listen(id);
  this._updateComposer();
  this.emit('methodEnabled', id);
};


/**
 * @param {String} id
 */
Controls.prototype.disableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (!method.enabled) {
    return;
  }
  method.enabled = false;
  if (method.active) {
    this._decrementActiveCount();
  }
  this._unlisten(id);
  this._updateComposer();
  this.emit('methodDisabled', id);
};


/**
 * Create a method group, which can be used to more conveniently enable or
 * disable several control methods at once
 * @param {String} groupId
 * @param {String[]} methodIds
 */
Controls.prototype.addMethodGroup = function(groupId, methodIds) {
  this._methodGroups[groupId] = methodIds;
}

/**
 * @param {String} groupId
 */
Controls.prototype.removeMethodGroup = function(id) {
  delete this._methodGroups[id];
}

/**
 * @return {ControlMethodGroup[]} List of control method groups
 */
Controls.prototype.methodGroups = function() {
  var obj = {};
  for (var id in this._methodGroups) {
    obj[id] = this._methodGroups[id];
  }
  return obj;
}

/**
 * Enables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.enableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.enableMethod(methodId);
  });
}

/**
 * Disables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.disableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.disableMethod(methodId);
  });
}

/**
 * @returns {Boolean}
 */
Controls.prototype.enabled = function() {
  return this._enabled;
};

/**
 * Enables the controls
 */
Controls.prototype.enable = function() {
  if (this._enabled) {
    return;
  }
  this._enabled = true;
  if (this._activeCount > 0) {
    this.emit('active');
  }
  this.emit('enabled');
  this._updateComposer();
};


/**
 * Disables the controls
 */
Controls.prototype.disable = function() {
  if (!this._enabled) {
    return;
  }
  this._enabled = false;
  if (this._activeCount > 0) {
    this.emit('inactive');
  }
  this.emit('disabled');
  this._updateComposer();
};



/**
 * Attaches the controls to a {@link RenderLoop}. The RenderLoop will be woken
 * up when the controls are activated
 *
 * @param {RenderLoop}
 */
Controls.prototype.attach = function(renderLoop) {
  if (this._attachedRenderLoop) {
    this.detach();
  }

  this._attachedRenderLoop = renderLoop;
  this._beforeRenderHandler = this._updateViewsWithControls.bind(this);
  this._changeHandler = renderLoop.renderOnNextFrame.bind(renderLoop);

  this._attachedRenderLoop.addEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.addEventListener('change', this._changeHandler);
};

/**
 * Detaches the controls
 */
Controls.prototype.detach = function() {
  if (!this._attachedRenderLoop) {
    return;
  }

  this._attachedRenderLoop.removeEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.removeEventListener('change', this._changeHandler);

  this._beforeRenderHandler = null;
  this._changeHandler = null;
  this._attachedRenderLoop = null;
};

/**
 * @param {Boolean}
 */
Controls.prototype.attached = function() {
  return this._attachedRenderLoop != null;
};


Controls.prototype._listen = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.addEventListener('active', method.activeHandler);
  method.instance.addEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._unlisten = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.removeEventListener('active', method.activeHandler);
  method.instance.removeEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._handleActive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (!method.active) {
    method.active = true;
    this._incrementActiveCount();
  }
};


Controls.prototype._handleInactive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (method.active) {
    method.active = false;
    this._decrementActiveCount();
  }
};


Controls.prototype._incrementActiveCount = function() {
  this._activeCount++;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 1) {
    this.emit('active');
  }
};


Controls.prototype._decrementActiveCount = function() {
  this._activeCount--;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 0) {
    this.emit('inactive');
  }
};


Controls.prototype._checkActiveCount = function() {
  var count = 0;
  for (var id in this._methods) {
    var method = this._methods[id];
    if (method.enabled && method.active) {
      count++;
    }
  }
  if (count != this._activeCount) {
    throw new Error('Bad control state');
  }
};


Controls.prototype._updateComposer = function() {
  var composer = this._composer;

  for (var id in this._methods) {
    var method = this._methods[id];
    var enabled = this._enabled && method.enabled;

    if (enabled && !composer.has(method.instance)) {
      composer.add(method.instance);
    }
    if (!enabled && composer.has(method.instance)) {
      composer.remove(method.instance);
    }
  }
};


Controls.prototype._updateViewsWithControls = function() {
  var controlData = this._composer.offsets();
  if (controlData.changing) {
    this._attachedRenderLoop.renderOnNextFrame();
  }

  // Update each view at most once, even when shared by multiple layers.
  // The number of views is expected to be small, so use an array to keep track.
  this.updatedViews_.length = 0;

  var layers = this._attachedRenderLoop.stage().listLayers();
  for (var i = 0; i < layers.length; i++) {
    var view = layers[i].view();
    if (this.updatedViews_.indexOf(view) < 0) {
      layers[i].view().updateWithControlParameters(controlData.offsets);
      this.updatedViews_.push(view);
    }
  }
};


module.exports = Controls;

},{"../util/clearOwnProperties":91,"./Composer":36,"minimal-event-emitter":14}],39:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  friction: 6,
  maxFrictionTime: 0.3
};

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class DragControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by clicking/tapping and dragging.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 */
function DragControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._startEvent = null;
  this._lastEvent = null;

  this._active = false;

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer = HammerGestures.get(element, pointerType);

  this._hammer.on("hammer.input", this._handleHammerEvent.bind(this));

  this._hammer.on('panstart', this._handleStart.bind(this));
  this._hammer.on('panmove', this._handleMove.bind(this));
  this._hammer.on('panend', this._handleEnd.bind(this));
  this._hammer.on('pancancel', this._handleEnd.bind(this));

}

eventEmitter(DragControlMethod);

/**
 * Destructor.
 */
DragControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};

DragControlMethod.prototype._handleHammerEvent = function(e) {
  if (e.isFirst) {
    if (debug && this._active) {
      throw new Error('DragControlMethod active detected when already active');
    }
    this._active = true;
    this.emit('active');
  }
  if (e.isFinal) {
    if (debug && !this._active) {
      throw new Error('DragControlMethod inactive detected when already inactive');
    }
    this._active = false;
    this.emit('inactive');
  }
};

DragControlMethod.prototype._handleStart = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  this._startEvent = e;
};


DragControlMethod.prototype._handleMove = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsMove(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }
};


DragControlMethod.prototype._handleEnd = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsRelease(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }

  this._startEvent = false;
  this._lastEvent = false;
};


DragControlMethod.prototype._updateDynamicsMove = function(e) {
  var x = e.deltaX;
  var y = e.deltaY;

  // When a second finger touches the screen, panstart sometimes has a large
  // offset at start; subtract that offset to prevent a sudden jump.
  var eventToSubtract = this._lastEvent || this._startEvent;

  if (eventToSubtract) {
    x -= eventToSubtract.deltaX;
    y -= eventToSubtract.deltaY;
  }

  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  x /= width;
  y /= height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.offset = -x;
  this._dynamics.y.offset = -y;

  this._lastEvent = e;
};


var tmpReleaseFriction = [ null, null ];
DragControlMethod.prototype._updateDynamicsRelease = function(e) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  var x = 1000 * e.velocityX / width;
  var y = 1000 * e.velocityY / height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
  this._dynamics.x.friction = tmpReleaseFriction[0];
  this._dynamics.y.friction = tmpReleaseFriction[1];
};


module.exports = DragControlMethod;

},{"../util/clearOwnProperties":91,"../util/defaults":96,"./Dynamics":40,"./HammerGestures":42,"./util":50,"minimal-event-emitter":14}],40:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class Dynamics
 * @classdesc
 *
 * Represents how a control parameter changes. Used in the events emitted by
 * {@link ControlMethod}.
 *
 * @property {number} offset Parameter changed by a fixed value
 * @property {number} velocity Parameter is changing at this velocity
 * @property {number} friction The velocity will decrease at this rate
 */
function Dynamics() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
}

Dynamics.equals = function(d1, d2) {
  return d1.velocity === d2.velocity && d1.friction === d2.friction && d1.offset === d2.offset;
};

Dynamics.prototype.equals = function(other) {
  return Dynamics.equals(this, other);
};

Dynamics.prototype.update = function(other, elapsed) {
  if (other.offset) {
    // If other has an offset, make this.offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += other.offset;
  }

  var offsetFromVelocity = this.offsetFromVelocity(elapsed);
  if (offsetFromVelocity) {
    // If there is an offset to add from the velocity, make this offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += offsetFromVelocity;
  }

  this.velocity = other.velocity;
  this.friction = other.friction;
};

Dynamics.prototype.reset = function() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
};


Dynamics.prototype.velocityAfter = function(elapsed) {
  if (!this.velocity) {
    return null;
  }
  if (this.friction) {
    return decreaseAbs(this.velocity, this.friction *elapsed);
  }
  return this.velocity;
};

Dynamics.prototype.offsetFromVelocity = function(elapsed) {
  elapsed = Math.min(elapsed, this.nullVelocityTime());

  var velocityEnd = this.velocityAfter(elapsed);
  var averageVelocity = (this.velocity + velocityEnd) / 2;

  return averageVelocity * elapsed;
};


Dynamics.prototype.nullVelocityTime = function() {
  if (this.velocity == null) {
    return 0;
  }
  if (this.velocity && !this.friction) {
    return Infinity;
  }
  return Math.abs(this.velocity / this.friction);
};

function decreaseAbs(num, dec) {
  if (num < 0) {
    return Math.min(0, num + dec);
  }
  if (num > 0) {
    return Math.max(0, num - dec);
  }
  return 0;
}

module.exports = Dynamics;

},{}],41:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ElementPressControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a DOM element.
 *
 * @param {Element} element Element which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
*/
function ElementPressControlMethod(element, parameter, velocity, friction) {
  if(!element) {
    throw new Error("ElementPressControlMethod: element must be defined");
  }
  if(!parameter) {
    throw new Error("ElementPressControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("ElementPressControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("ElementPressControlMethod: friction must be defined");
  }

  this._element = element;

  this._pressHandler = this._handlePress.bind(this);
  this._releaseHandler = this._handleRelease.bind(this);

  element.addEventListener('mousedown', this._pressHandler);
  element.addEventListener('mouseup', this._releaseHandler);
  element.addEventListener('mouseleave', this._releaseHandler);
  element.addEventListener('touchstart', this._pressHandler);
  element.addEventListener('touchmove', this._releaseHandler);
  element.addEventListener('touchend', this._releaseHandler);

  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._dynamics = new Dynamics();

  this._pressing = false;
}
eventEmitter(ElementPressControlMethod);

/**
 * Destructor.
 */
ElementPressControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('mousedown', this._pressHandler);
  this._element.removeEventListener('mouseup', this._releaseHandler);
  this._element.removeEventListener('mouseleave', this._releaseHandler);
  this._element.removeEventListener('touchstart', this._pressHandler);
  this._element.removeEventListener('touchmove', this._releaseHandler);
  this._element.removeEventListener('touchend', this._releaseHandler);
  clearOwnProperties(this);
};

ElementPressControlMethod.prototype._handlePress = function() {
  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

ElementPressControlMethod.prototype._handleRelease = function() {
  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

module.exports = ElementPressControlMethod;

},{"../util/clearOwnProperties":91,"./Dynamics":40,"minimal-event-emitter":14}],42:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Hammer = require('hammerjs');
var browser = require('bowser');

var nextId = 1;
var idProperty = 'MarzipanoHammerElementId';
function getKeyForElementAndType(element, type) {
  if (!element[idProperty]) {
    element[idProperty] = nextId++;
  }
  return type + element[idProperty];
}


/**
 * @class HammerGestures
 * @classdesc
 *
 * Manages Hammer.js instances. One instance is created for each combination of
 * DOM element and pointer type.
 */
function HammerGestures() {
  this._managers = {};
  this._refCount = {};
}


HammerGestures.prototype.get = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (!this._managers[key]) {
    this._managers[key] = this._createManager(element, type);
    this._refCount[key] = 0;
  }
  this._refCount[key]++;
  return new HammerGesturesHandle(this, this._managers[key], element, type);
};


HammerGestures.prototype._createManager = function(element, type) {
  var manager = new Hammer.Manager(element);

  // Managers are created with different parameters for different pointer
  // types.
  if (type === 'mouse') {
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 0 }));
  }
  else if (type === 'touch' || type === 'pen' || type === 'kinect') {
    // On touch one wants to have both panning and pinching. The panning
    // recognizer needs a threshold to allow the pinch to be recognized.
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 20, pointers: 1 }));
    if (!(browser.msie && parseFloat(browser.version) < 10)) {
      // Do not add pinch to IE8-9 to prevent focus issues which prevent wheel scrolling from
      // working.
      manager.add(new Hammer.Pinch());
    }
  }

  return manager;
};


HammerGestures.prototype._releaseHandle = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (this._refCount[key]) {
    this._refCount[key]--;
    if (!this._refCount[key]) {
      this._managers[key].destroy();
      delete this._managers[key];
      delete this._refCount[key];
    }
  }
};


function HammerGesturesHandle(hammerGestures, manager, element, type) {
  this._manager = manager;
  this._element = element;
  this._type = type;
  this._hammerGestures = hammerGestures;
  this._eventHandlers = [];
}


HammerGesturesHandle.prototype.on = function(events, handler) {
  var type = this._type;
  var handlerFilteredEvents = function(e) {
    if (type === e.pointerType) {
      handler(e);
    }
  };

  this._eventHandlers.push({ events: events, handler: handlerFilteredEvents });
  this._manager.on(events, handlerFilteredEvents);
};


HammerGesturesHandle.prototype.release = function() {
  for (var i = 0; i < this._eventHandlers.length; i++) {
    var eventHandler = this._eventHandlers[i];
    this._manager.off(eventHandler.events, eventHandler.handler);
  }

  this._hammerGestures._releaseHandle(this._element, this._type);
  this._manager = null;
  this._element = null;
  this._type = null;
  this._hammerGestures = null;
};


HammerGesturesHandle.prototype.manager = function() {
  return this._manager;
};


module.exports = new HammerGestures();

},{"bowser":1,"hammerjs":13}],43:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class KeyControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a key.
 *
 * @param {number} keyCode Key which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
 * @param {Element} [element=document] DOM element where the key events are listened to
 */
function KeyControlMethod(keyCode, parameter, velocity, friction, element) {
  if(!keyCode) {
    throw new Error("KeyControlMethod: keyCode must be defined");
  }
  if(!parameter) {
    throw new Error("KeyControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("KeyControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("KeyControlMethod: friction must be defined");
  }

  element = element || document;

  this._keyCode = keyCode;
  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._element = element;

  this._keydownHandler = this._handlePress.bind(this);
  this._keyupHandler = this._handleRelease.bind(this);
  this._blurHandler = this._handleBlur.bind(this);

  this._element.addEventListener('keydown', this._keydownHandler);
  this._element.addEventListener('keyup', this._keyupHandler);
  window.addEventListener('blur', this._blurHandler);

  this._dynamics = new Dynamics();
  this._pressing = false;
}
eventEmitter(KeyControlMethod);

/**
 * Destructor.
 */
KeyControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('keydown', this._keydownHandler);
  this._element.removeEventListener('keyup', this._keyupHandler);
  window.removeEventListener('blur', this._blurHandler);
  clearOwnProperties(this);
};

KeyControlMethod.prototype._handlePress = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

KeyControlMethod.prototype._handleRelease = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

KeyControlMethod.prototype._handleBlur = function() {
  this._dynamics.velocity = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('inactive');

  this._pressing = false;
};

module.exports = KeyControlMethod;

},{"../util/clearOwnProperties":91,"./Dynamics":40,"minimal-event-emitter":14}],44:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class PinchZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Control the view fov/zoom by pinching with two fingers.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use
 * @param {Object} opts
 */
function PinchZoomControlMethod(element, pointerType, opts) {
  this._hammer = HammerGestures.get(element, pointerType);

  this._lastEvent = null;

  this._active = false;

  this._dynamics = new Dynamics();

  this._hammer.on('pinchstart', this._handleStart.bind(this));
  this._hammer.on('pinch', this._handleEvent.bind(this));
  this._hammer.on('pinchend', this._handleEnd.bind(this));
  this._hammer.on('pinchcancel', this._handleEnd.bind(this));
}

eventEmitter(PinchZoomControlMethod);

/**
 * Destructor.
 */
PinchZoomControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


PinchZoomControlMethod.prototype._handleStart = function() {
  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


PinchZoomControlMethod.prototype._handleEnd = function() {
  this._lastEvent = null;

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


PinchZoomControlMethod.prototype._handleEvent = function(e) {
  var scale = e.scale;

  if (this._lastEvent) {
    scale /= this._lastEvent.scale;
  }

  this._dynamics.offset = (scale - 1) * -1;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  this._lastEvent = e;
};


module.exports = PinchZoomControlMethod;

},{"../util/clearOwnProperties":91,"./Dynamics":40,"./HammerGestures":42,"minimal-event-emitter":14}],45:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');


var defaultOptions = {
  speed: 8,
  friction: 6,
  maxFrictionTime: 0.3
};


/**
 * @class QtvrControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by holding the mouse button down and moving it.
 * Also known as "QTVR" control mode.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.speed
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 */
// TODO: allow speed not change linearly with distance to click spot.
// Quadratic or other would allow a larger speed range.
function QtvrControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._active = false;

  this._hammer = HammerGestures.get(element, pointerType);

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer.on('panstart', this._handleStart.bind(this));
  this._hammer.on('panmove', this._handleMove.bind(this));
  this._hammer.on('panend', this._handleRelease.bind(this));
  this._hammer.on('pancancel', this._handleRelease.bind(this));
}

eventEmitter(QtvrControlMethod);

/**
 * Destructor.
 */
QtvrControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


QtvrControlMethod.prototype._handleStart = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


QtvrControlMethod.prototype._handleMove = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, false);
};


QtvrControlMethod.prototype._handleRelease = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, true);

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


var tmpReleaseFriction = [ null, null ];
QtvrControlMethod.prototype._updateDynamics = function(e, release) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;
  var maxDim = Math.max(width, height);

  var x = e.deltaX / maxDim * this._opts.speed;
  var y = e.deltaY / maxDim * this._opts.speed;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  if (release) {
    maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
    this._dynamics.x.friction = tmpReleaseFriction[0];
    this._dynamics.y.friction = tmpReleaseFriction[1];
  }

  this.emit('parameterDynamics', 'x', this._dynamics.x);
  this.emit('parameterDynamics', 'y', this._dynamics.y);
};


module.exports = QtvrControlMethod;

},{"../util/clearOwnProperties":91,"../util/defaults":96,"./Dynamics":40,"./HammerGestures":42,"./util":50,"minimal-event-emitter":14}],46:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var WheelListener = require('./WheelListener');
var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  frictionTime: 0.2,
  zoomDelta: 0.001
};

/**
 * @class ScrollZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the fov/zoom through the mouse wheel.
 *
 * @param {Element} element Element to listen for events.
 * @param {Object} opts
 * @param {number} [opts.frictionTime=0.2]
 * @param {number} [opts.zoomDelta=0.001]
 */
function ScrollZoomControlMethod(element, opts) {
  this._opts = defaults(opts || {}, defaultOptions);

  this._dynamics = new Dynamics();

  this._eventList = [];

  var fn = this._opts.frictionTime ? this.withSmoothing : this.withoutSmoothing;
  this._wheelListener = new WheelListener(element, fn.bind(this));
}

eventEmitter(ScrollZoomControlMethod);

/**
 * Destructor.
 */
ScrollZoomControlMethod.prototype.destroy = function() {
  this._wheelListener.destroy();
  clearOwnProperties(this);
};


ScrollZoomControlMethod.prototype.withoutSmoothing = function(e) {
  this._dynamics.offset = wheelEventDelta(e) * this._opts.zoomDelta;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


ScrollZoomControlMethod.prototype.withSmoothing = function(e) {
  var currentTime = e.timeStamp;

  // Record event.
  this._eventList.push(e);

  // Remove events whose smoothing has already expired.
  while (this._eventList[0].timeStamp < currentTime - this._opts.frictionTime*1000) {
    this._eventList.shift(0);
  }

  // Get the current velocity from the recorded events.
  // Each wheel movement causes a velocity of change/frictionTime during frictionTime.
  var velocity = 0;
  for (var i = 0; i < this._eventList.length; i++) {
    var zoomChangeFromEvent = wheelEventDelta(this._eventList[i]) * this._opts.zoomDelta;
    velocity += zoomChangeFromEvent / this._opts.frictionTime;
  }

  this._dynamics.velocity = velocity;
  this._dynamics.friction = Math.abs(velocity) / this._opts.frictionTime;

  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


function wheelEventDelta(e) {
  var multiplier = e.deltaMode == 1 ? 20 : 1;
  return e.deltaY * multiplier;
}


module.exports = ScrollZoomControlMethod;

},{"../util/clearOwnProperties":91,"../util/defaults":96,"./Dynamics":40,"./WheelListener":48,"minimal-event-emitter":14}],47:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class VelocityControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter.
 *
 * The user should emit 'active' and 'inactive' events if required.
 *
 * @param {String} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
*/
function VelocityControlMethod(parameter) {
  if(!parameter) {
    throw new Error("VelocityControlMethod: parameter must be defined");
  }

  this._parameter = parameter;
  this._dynamics = new Dynamics();
}
eventEmitter(VelocityControlMethod);

/**
 * Destructor.
 */
VelocityControlMethod.prototype.destroy = function() {
  clearOwnProperties(this);
};

/**
 * Set the parameter's velocity.
 * @param {Number} velocity
 */
VelocityControlMethod.prototype.setVelocity = function(velocity) {
  this._dynamics.velocity = velocity;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

/**
 * Set the parameter's friction.
 * @param {Number} friction
 */
VelocityControlMethod.prototype.setFriction = function(friction) {
  this._dynamics.friction = friction;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

module.exports = VelocityControlMethod;

},{"../util/clearOwnProperties":91,"./Dynamics":40,"minimal-event-emitter":14}],48:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var clearOwnProperties = require('../util/clearOwnProperties');

// Cross-browser mouse wheel event listener.
// Adapted from: https://developer.mozilla.org/en-US/docs/Web/Events/wheel
// This version requires eventShim.
function WheelListener(elem, callback, useCapture) {
  var eventName = getEventName();

  if (eventName === 'wheel') {
    this._fun = callback;
    this._elem = elem;
    this._elem.addEventListener('wheel', this._fun, useCapture);
  } else if (eventName === 'mousewheel') {
    this._fun = fallbackHandler(callback);
    this._elem = elem;
    this._elem.addEventListener('mousewheel', this._fun, useCapture);
  } else {
    throw new Error('Browser does not support mouse wheel events');
  }
}

/**
 * Destructor.
 */
WheelListener.prototype.destroy = function() {
  this._elem.removeEventListener(getEventName(), this._fun);
  clearOwnProperties(this);
};

function fallbackHandler(callback) {
  return function handleWheelEvent(originalEvent) {
    if (!originalEvent) {
      originalEvent = window.event;
    }

    // Create a normalized event object.
    var event = {
      originalEvent: originalEvent,
      target: originalEvent.target || originalEvent.srcElement,
      type: "wheel",
      deltaMode: 1,
      deltaX: 0,
      deltaZ: 0,
      timeStamp: originalEvent.timeStamp || Date.now(),
      preventDefault: originalEvent.preventDefault.bind(originalEvent)
    };

    // Calculate deltaY.
    event.deltaY = - 1/40 * originalEvent.wheelDelta;
    if (originalEvent.wheelDeltaX) {
      // Calculate deltaX.
      event.deltaX = - 1/40 * originalEvent.wheelDeltaX;
    }

    // Fire the callback.
    return callback(event);
  };
}

// Detect the supported wheel event name and cache the result.
var eventName;
function getEventName() {
  if (eventName !== undefined) {
    return eventName;
  }
  if ('onwheel' in document.createElement('div')) {
    // Modern browsers support 'wheel'.
    return (eventName = 'wheel');
  } else if (document.onmousewheel !== undefined) {
    // Webkit and IE support at least 'mousewheel'.
    return (eventName = 'mousewheel');
  } else {
    return (eventName = null);
  }
}

module.exports = WheelListener;

},{"../util/clearOwnProperties":91}],49:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var DragControlMethod = require('./Drag');
var QtvrControlMethod = require('./Qtvr');
var ScrollZoomControlMethod = require('./ScrollZoom');
var PinchZoomControlMethod = require('./PinchZoom');
var KeyControlMethod = require('./Key');

var defaultOptions = {
  mouseViewMode: 'drag'
};

/**
 * Instantiate and register some commonly used {@link ControlMethod} instances.
 *
 * The following instances are registered:
 *   - mouseViewDrag
 *   - mouseViewQtvr
 *   - touchView
 *   - pinch
 *   - arrowKeys
 *   - plusMinusKeys
 *   - wasdKeys
 *   - qeKeys
 *
 * @param {Controls} controls Where to register the instances.
 * @param {Element} element Element to listen for events.
 * @param {Object} opts
 * @param {'drag'|'qtvr'} mouseViewMode
 */
function registerDefaultControls(controls, element, opts) {
  opts = defaults(opts || {}, defaultOptions);

  var controlMethods = {
    mouseViewDrag: new DragControlMethod(element, 'mouse'),
    mouseViewQtvr: new QtvrControlMethod(element, 'mouse'),
    touchView: new DragControlMethod(element, 'touch'),
    pinch: new PinchZoomControlMethod(element, 'touch'),

    leftArrowKey: new KeyControlMethod(37, 'x', -0.7, 3),
    rightArrowKey: new KeyControlMethod(39, 'x', 0.7, 3),
    upArrowKey: new KeyControlMethod(38, 'y', -0.7, 3),
    downArrowKey: new KeyControlMethod(40, 'y', 0.7, 3),
    plusKey: new KeyControlMethod(107, 'zoom', -0.7, 3),
    minusKey: new KeyControlMethod(109, 'zoom', 0.7, 3),

    wKey: new KeyControlMethod(87, 'y', -0.7, 3),
    aKey: new KeyControlMethod(65, 'x', -0.7, 3),
    sKey: new KeyControlMethod(83, 'y', 0.7, 3),
    dKey: new KeyControlMethod(68, 'x', 0.7, 3),
    qKey: new KeyControlMethod(81, 'roll', 0.7, 3),
    eKey: new KeyControlMethod(69, 'roll', -0.7, 3)
  };

  if(opts.scrollZoom !== false) {
    controlMethods.scrollZoom = new ScrollZoomControlMethod(element); //{ frictionTime: 0 }
  }

  var controlMethodGroups = {
    arrowKeys: [ 'leftArrowKey', 'rightArrowKey', 'upArrowKey', 'downArrowKey' ],
    plusMinusKeys: [ 'plusKey', 'minusKey' ],
    wasdKeys: [ 'wKey', 'aKey', 'sKey', 'dKey' ],
    qeKeys: [ 'qKey', 'eKey' ]
  };


  var enabledControls = [ 'scrollZoom', 'touchView', 'pinch' ];
  switch (opts.mouseViewMode) {
    case 'drag':
      enabledControls.push('mouseViewDrag');
      break;
    case 'qtvr':
      enabledControls.push('mouseViewQtvr');
      break;
    default:
      throw new Error("Unknown mouse view mode: " + opts.mouseViewMode);
  }

  for (var id in controlMethods) {
    var method = controlMethods[id];
    controls.registerMethod(id, method);
    if (enabledControls.indexOf(id) >= 0) {
      controls.enableMethod(id);
    }
  }

  for (var groupId in controlMethodGroups) {
    var methodGroup = controlMethodGroups[groupId];
    controls.addMethodGroup(groupId, methodGroup);
  }

  return controlMethods;
}

module.exports = registerDefaultControls;
},{"../util/defaults":96,"./Drag":39,"./Key":43,"./PinchZoom":44,"./Qtvr":45,"./ScrollZoom":46}],50:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function maxFriction(friction, velocityX, velocityY, maxFrictionTime, result) {
  var velocity = Math.sqrt(Math.pow(velocityX,2) + Math.pow(velocityY,2));
  friction = Math.max(friction, velocity/maxFrictionTime);
  changeVectorNorm(velocityX, velocityY, friction, result);
  result[0] = Math.abs(result[0]);
  result[1] = Math.abs(result[1]);
}

function changeVectorNorm(x, y, n, result) {
  var theta = Math.atan(y/x);
  result[0] = n * Math.cos(theta);
  result[1] = n * Math.sin(theta);
}

module.exports = {
  maxFriction: maxFriction,
  changeVectorNorm: changeVectorNorm
};
},{}],51:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec3 = require('gl-matrix').vec3;
var vec4 = require('gl-matrix').vec4;

var neighborsCacheSize = 64;

// Some renderer implementations require tiles to be padded around with
// repeated pixels to prevent the appearance of visible seams between tiles.
//
// In order to prevent the padding from being visible, the tiles must be
// padded and stacked such that the padding on one of the sides, when present,
// stacks below the neighboring tile on that side.
//
// The padding rules are as follows:
// * Define a tile to be X-marginal if it contacts the X-edge of its cube face.
// * Pad top if the tile is top-marginal and the face is F or U.
// * Pad bottom unless the tile is bottom-marginal or the face is F or D.
// * Pad left if the tile is left-marginal and the face is F, L, U or D.
// * Pad right unless the tile is right-marginal or the face is F, R, U or D.
//
// The stacking rules are as follows:
// * Within an image, stack smaller zoom levels below larger zoom levels.
// * Within a level, stack tiles bottom to top in FUDLRB face order.
// * Within a face, stack tiles bottom to top in ascending Y coordinate order.
// * Within a row, stack tiles bottom to top in ascending X coordinate order.
//
// Crucially, these rules affect the implementation of the tile cmp() method,
// which determines the stacking order, and of the pad*() tile methods, which
// determine the amount of padding on each of the four sides of a tile.

// Initials for cube faces in stacking order.
var faceList = 'fudlrb';

// Rotation of each face, relative to the front face.
var faceRotation = {
  f: { x: 0, y: 0 },
  b: { x: 0, y: Math.PI },
  l: { x: 0, y: Math.PI/2 },
  r: { x: 0, y: -Math.PI/2 },
  u: { x: Math.PI/2, y: 0 },
  d: { x: -Math.PI/2, y: 0 }
};

// Zero vector.
var origin = vec3.create();

// Rotate a vector in ZXY order.
function rotateVector(vec, z, x, y) {
  if (z) {
    vec3.rotateZ(vec, vec, origin, z);
  }
  if (x) {
    vec3.rotateX(vec, vec, origin, x);
  }
  if (y) {
    vec3.rotateY(vec, vec, origin, y);
  }
}

// Normalized vectors pointing to the center of each face.
var faceVectors = {};
for (var i = 0; i < faceList.length; i++) {
  var face = faceList[i];
  var rotation = faceRotation[face];
  var v = vec3.fromValues(0,  0, -1);
  rotateVector(v, 0, rotation.x, rotation.y);
  faceVectors[face] = v;
}

// Map each face to its adjacent faces.
// The order is as suggested by the front face.
var adjacentFace = {
  f: [ 'l', 'r', 'u', 'd' ],
  b: [ 'r', 'l', 'u', 'd' ],
  l: [ 'b', 'f', 'u', 'd' ],
  r: [ 'f', 'b', 'u', 'd' ],
  u: [ 'l', 'r', 'b', 'f' ],
  d: [ 'l', 'r', 'f', 'b' ]
};

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class CubeTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a @{CubeGeometry}.
 */
function CubeTile(face, x, y, z, geometry) {
  this.face = face;
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


CubeTile.prototype.rotX = function() {
  return faceRotation[this.face].x;
};


CubeTile.prototype.rotY = function() {
  return faceRotation[this.face].y;
};


CubeTile.prototype.centerX = function() {
  return (this.x + 0.5) / this._level.numHorizontalTiles() - 0.5;
};


CubeTile.prototype.centerY = function() {
  return 0.5 - (this.y + 0.5) / this._level.numVerticalTiles();
};


CubeTile.prototype.scaleX = function() {
  return 1 / this._level.numHorizontalTiles();
};


CubeTile.prototype.scaleY = function() {
  return 1 / this._level.numVerticalTiles();
};


CubeTile.prototype.width = function() {
  return this._level.tileWidth();
};


CubeTile.prototype.height = function() {
  return this._level.tileHeight();
};


CubeTile.prototype.levelWidth = function() {
  return this._level.width();
};


CubeTile.prototype.levelHeight = function() {
  return this._level.height();
};


CubeTile.prototype.atTopLevel = function() {
  return this.z === 0;
};


CubeTile.prototype.atBottomLevel = function() {
  return this.z === this._geometry.levelList.length - 1;
};


CubeTile.prototype.atTopEdge = function() {
  return this.y === 0;
};


CubeTile.prototype.atBottomEdge = function() {
  return this.y === this._level.numVerticalTiles() - 1;
};


CubeTile.prototype.atLeftEdge = function() {
  return this.x === 0;
};


CubeTile.prototype.atRightEdge = function() {
  return this.x === this._level.numHorizontalTiles() - 1;
};


CubeTile.prototype.padTop = function() {
  return this.atTopEdge() && /[fu]/.test(this.face);
};


CubeTile.prototype.padBottom = function() {
  return !this.atBottomEdge() || /[fd]/.test(this.face);
};


CubeTile.prototype.padLeft = function() {
  return this.atLeftEdge() && /[flud]/.test(this.face);
};


CubeTile.prototype.padRight = function() {
  return !this.atRightEdge() || /[frud]/.test(this.face);
};


CubeTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
  }

  var rot = faceRotation[this.face];

  function makeVertex(vec, x, y) {
    vec3.set(vec, x, y, -0.5);
    rotateVector(vec, 0, rot.x, rot.y);
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  makeVertex(result[0], left, top);
  makeVertex(result[1], right, top);
  makeVertex(result[2], right, bottom);
  makeVertex(result[3], left, bottom);

  return result;
};


CubeTile.prototype.parent = function() {

  if (this.atTopLevel()) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var parentLevel = geometry.levelList[z-1];

  var tileX = Math.floor(x / level.numHorizontalTiles() * parentLevel.numHorizontalTiles());
  var tileY = Math.floor(y / level.numVerticalTiles() * parentLevel.numVerticalTiles());
  var tileZ = z-1;

  return new CubeTile(face, tileX, tileY, tileZ, geometry);

};


CubeTile.prototype.children = function(result) {

  if (this.atBottomLevel()) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var childLevel = geometry.levelList[z+1];

  var nHoriz = childLevel.numHorizontalTiles() / level.numHorizontalTiles();
  var nVert = childLevel.numVerticalTiles() / level.numVerticalTiles();

  result = result || [];

  for (var h = 0; h < nHoriz; h++) {
    for (var v = 0; v < nVert; v++) {
      var tileX = nHoriz * x + h;
      var tileY = nVert * y + v;
      var tileZ = z+1;
      result.push(new CubeTile(face, tileX, tileY, tileZ, geometry));
    }
  }

  return result;

};


CubeTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var vec = geometry._vec;

  var face = this.face;
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;
    var newFace = face;

    if (newX < 0 || newX >= numX || newY < 0 || newY >= numY) {

      // If the neighboring tile belongs to a different face, calculate a
      // vector pointing to the edge between the two faces at the point the
      // tile and its neighbor meet, and convert it into tile coordinates for
      // the neighboring face.

      var xCoord = this.centerX();
      var yCoord = this.centerY();

      // First, calculate the vector as if the initial tile belongs to the
      // front face, so that the tile x,y coordinates map directly into the
      // x,y axes.

      if (newX < 0) {
        vec3.set(vec, -0.5, yCoord, -0.5);
        newFace = adjacentFace[face][0];
      } else if (newX >= numX) {
        vec3.set(vec, 0.5, yCoord, -0.5);
        newFace = adjacentFace[face][1];
      } else if (newY < 0) {
        vec3.set(vec, xCoord, 0.5, -0.5);
        newFace = adjacentFace[face][2];
      } else if (newY >= numY) {
        vec3.set(vec, xCoord, -0.5, -0.5);
        newFace = adjacentFace[face][3];
      }

      var rot;

      // Then, rotate the vector into the actual face the initial tile
      // belongs to.

      rot = faceRotation[face];
      rotateVector(vec, 0, rot.x, rot.y);

      // Finally, rotate the vector from the neighboring face into the front
      // face. Again, this is so that the neighboring tile x,y coordinates
      // map directly into the x,y axes.

      rot = faceRotation[newFace];
      rotateVector(vec, 0, -rot.x, -rot.y);

      // Calculate the neighboring tile coordinates.

      newX = clamp(Math.floor((0.5 + vec[0]) * numX), 0, numX - 1);
      newY = clamp(Math.floor((0.5 - vec[1]) * numY), 0, numY - 1);
    }

    result.push(new CubeTile(newFace, newX, newY, newZ, geometry));
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


CubeTile.prototype.hash = function() {
  return hash(faceList.indexOf(this.face), this.z, this.y, this.x);
};


CubeTile.prototype.equals = function(that) {
  return (this.geometry === that.geometry &&
      this.face === that.face &&
      this.z === that.z &&
      this.y === that.y &&
      this.x === that.x);
};


CubeTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) ||
  cmp(faceList.indexOf(this.face), faceList.indexOf(that.face)) ||
  cmp(this.y, that.y) || cmp(this.x, that.x));
};


CubeTile.prototype.str = function() {
  return 'CubeTile(' + tile.face + ', ' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function CubeLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._size = levelProperties.size;
  this._tileSize = levelProperties.tileSize;

  if (this._size % this._tileSize !== 0) {
    throw new Error('Level size is not multiple of tile size: ' +
                    this._size + ' ' + this._tileSize);
  }
}

inherits(CubeLevel, Level);


CubeLevel.prototype.width = function() {
  return this._size;
};


CubeLevel.prototype.height = function() {
  return this._size;
};


CubeLevel.prototype.tileWidth = function() {
  return this._tileSize;
};


CubeLevel.prototype.tileHeight = function() {
  return this._tileSize;
};


CubeLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();
  var numHorizontal = this.numHorizontalTiles();
  var numVertical = this.numVerticalTiles();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();
  var parentNumHorizontal = parentLevel.numHorizontalTiles();
  var parentNumVertical = parentLevel.numVerticalTiles();

  if (width % parentWidth !== 0) {
    throw new Error('Level width must be multiple of parent level: ' +
                    width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    throw new Error('Level height must be multiple of parent level: ' +
                    height + ' vs. ' + parentHeight);
  }

  if (numHorizontal % parentNumHorizontal !== 0) {
    throw new Error('Number of horizontal tiles must be multiple of parent level: ' +
      numHorizontal + " (" + width + '/' + tileWidth + ')' + " vs. " +
      parentNumHorizontal + " (" + parentWidth + '/' + parentTileWidth + ')');
  }

  if (numVertical % parentNumVertical !== 0) {
    throw new Error('Number of vertical tiles must be multiple of parent level: ' +
      numVertical + " (" + height + '/' + tileHeight + ')' + " vs. " +
      parentNumVertical + " (" + parentHeight + '/' + parentTileHeight + ')');
  }

};


/**
 * @class CubeGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled cube images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles in a level must be square and form a rectangular grid;
 *   - The size of a level must be a multiple of the tile size;
 *   - The size of a level must be a multiple of the parent level size;
 *   - The number of tiles in a level must be a multiple of the number of tiles
 *     in the parent level.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].size Cube face size in pixels
 * @param {number} levelPropertiesList[].tileSize Tile size in pixels
 */
function CubeGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, CubeLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


CubeGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


CubeGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  result = result || [];

  for (var f = 0; f < faceList.length; f++) {
    var face = faceList[f];
    for (var x = 0; x <= maxX; x++) {
      for (var y = 0; y <= maxY; y++) {
        result.push(new CubeTile(face, x, y, levelIndex, this));
      }
    }
  }

  return result;

};


CubeGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 1, 1);
  vec4.transformMat4(ray, ray, view.inverseProjection());

  var minAngle = Infinity;
  var closestFace = null;

  // Find the face whose vector makes a minimal angle with the view ray.
  // This is the face into which the view ray points.
  for (var face in faceVectors) {
    var vector = faceVectors[face];
    // For a small angle between two normalized vectors, angle ~ 1-cos(angle).
    var angle = 1 - vec3.dot(vector, ray);
    if (angle < minAngle) {
      minAngle = angle;
      closestFace = face;
    }
  }

  // Project view ray onto cube, i.e., normalize the coordinate with
  // largest absolute value to 0.5.
  var max = Math.max(Math.abs(ray[0]), Math.abs(ray[1]), Math.abs(ray[2])) / 0.5;
  for (var i = 0; i < 3; i++) {
    ray[i] = ray[i] / max;
  }

  // Rotate view ray into front face.
  var rot = faceRotation[closestFace];
  rotateVector(ray, 0, -rot.x, -rot.y);

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor((0.5 + ray[0]) * numX), 0, numX - 1);
  var tileY = clamp(Math.floor((0.5 - ray[1]) * numY), 0, numY - 1);

  return new CubeTile(closestFace, tileX, tileY, tileZ, this);
};


CubeGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    throw new Error('Starting tile is not visible');
  }

  return result;
};


CubeGeometry.Tile = CubeGeometry.prototype.Tile = CubeTile;
CubeGeometry.type = CubeGeometry.prototype.type = 'cube';
CubeTile.type = CubeTile.prototype.type = 'cube';


module.exports = CubeGeometry;

},{"../TileSearcher":22,"../collections/LruMap":29,"../util/clamp":90,"../util/cmp":92,"../util/hash":103,"../util/inherits":104,"../util/type":116,"./Level":54,"./common":55,"gl-matrix":3}],52:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var cmp = require('../util/cmp');
var common = require('./common');
var Level = require('./Level');
var type = require('../util/type');


/**
 * @class EquirectTile
 * @implements Tile
 * @classdesc
 *
 * A tile in an @{EquirectGeometry}.
 */
function EquirectTile(z, geometry) {
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


EquirectTile.prototype.rotX = function() {
  return 0;
};


EquirectTile.prototype.rotY = function() {
  return 0;
};


EquirectTile.prototype.centerX = function() {
  return 0.5;
};


EquirectTile.prototype.centerY = function() {
  return 0.5;
};


EquirectTile.prototype.scaleX = function() {
  return 1;
};


EquirectTile.prototype.scaleY = function() {
  return 1;
};


EquirectTile.prototype.width = function() {
  return this._level.tileWidth();
};


EquirectTile.prototype.height = function() {
  return this._level.tileHeight();
};


EquirectTile.prototype.levelWidth = function() {
  return this._level.width();
};


EquirectTile.prototype.levelHeight = function() {
  return this._level.height();
};


EquirectTile.prototype.atTopLevel = function() {
  return this.z === 0;
};


EquirectTile.prototype.atBottomLevel = function() {
  return this.z === this._geometry.levelList.length - 1;
};


EquirectTile.prototype.atTopEdge = function() {
  return true;
};


EquirectTile.prototype.atBottomEdge = function() {
  return true;
};


EquirectTile.prototype.atLeftEdge = function() {
  return true;
};


EquirectTile.prototype.atRightEdge = function() {
  return true;
};


EquirectTile.prototype.padTop = function() {
  return false;
};


EquirectTile.prototype.padBottom = function() {
  return false;
};


EquirectTile.prototype.padLeft = function() {
  return false;
};


EquirectTile.prototype.padRight = function() {
  return false;
};


EquirectTile.prototype.parent = function() {
  if (this.atTopLevel()) {
    return null;
  }
  return new EquirectTile(this.z - 1, this._geometry);
};


EquirectTile.prototype.children = function(result) {
  if (this.atBottomLevel()) {
    return null;
  }
  result = result || [];
  result.push(new EquirectTile(this.z + 1, this._geometry));
  return result;
};


EquirectTile.prototype.neighbors = function() {
  return [];
};


EquirectTile.prototype.hash = function() {
  return hash(this.z);
};


EquirectTile.prototype.equals = function(that) {
  return this.geometry === that.geometry && this.z === that.z;
};


EquirectTile.prototype.cmp = function(that) {
  return cmp(this.z, that.z);
};


EquirectTile.prototype.str = function() {
  return 'EquirectTile(' + tile.z + ')';
};


function EquirectLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);
  this._width = levelProperties.width;
}

inherits(EquirectLevel, Level);


EquirectLevel.prototype.width = function() {
  return this._width;
};


EquirectLevel.prototype.height = function() {
  return this._width/2;
};


EquirectLevel.prototype.tileWidth = function() {
  return this._width;
};


EquirectLevel.prototype.tileHeight = function() {
  return this._width/2;
};


/**
 * @class EquirectGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for equirectangular images with a
 * 2:1 aspect ratio.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
*/
function EquirectGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = common.makeLevelList(levelPropertiesList, EquirectLevel);
  this.selectableLevelList = common.makeSelectableLevelList(this.levelList);
}


EquirectGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


EquirectGeometry.prototype.levelTiles = function(level, result) {
  var levelIndex = this.levelList.indexOf(level);
  result = result || [];
  result.push(new EquirectTile(levelIndex, this));
  return result;
};


EquirectGeometry.prototype.visibleTiles = function(view, level, result) {
  var tile = new EquirectTile(this.levelList.indexOf(level), this);
  result = result || [];
  result.length = 0;
  result.push(tile);
};


EquirectGeometry.Tile = EquirectGeometry.prototype.Tile = EquirectTile;
EquirectGeometry.type = EquirectGeometry.prototype.type = 'equirect';
EquirectTile.type = EquirectTile.prototype.type = 'equirect';


module.exports = EquirectGeometry;

},{"../util/cmp":92,"../util/hash":103,"../util/inherits":104,"../util/type":116,"./Level":54,"./common":55}],53:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var mod = require('../util/mod');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec2 = require('gl-matrix').vec2;
var vec4 = require('gl-matrix').vec4;

var neighborsCacheSize = 64;

// Some renderer implementations require tiles to be padded around with
// repeated pixels to prevent the appearance of visible seams between tiles.
//
// In order to prevent the padding from being visible, the tiles must be
// padded and stacked such that the padding on one of the sides, when present,
// stacks below the neighboring tile on that side.
//
// Padding rules:
// * Pad tiles on the right and on the bottom.
//
// Stacking rules:
// * Within an image, stack smaller zoom levels below larger zoom levels.
// * Within a level, stack tiles bottom to top in ascending Y coordinate order.
// * Within a row, stack tiles bottom to top in ascending X coordinate order.

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class FlatTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a {@link FlatGeometry}.
 */
function FlatTile(x, y, z, geometry) {
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


FlatTile.prototype.rotX = function() {
  return 0;
};


FlatTile.prototype.rotY = function() {
  return 0;
};


FlatTile.prototype.centerX = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  return (this.x * tileWidth + 0.5 * this.width()) / levelWidth - 0.5;
};


FlatTile.prototype.centerY = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  return 0.5 - (this.y * tileHeight + 0.5 * this.height()) / levelHeight;
};


FlatTile.prototype.scaleX = function() {
  var levelWidth = this._level.width();
  return this.width() / levelWidth;
};


FlatTile.prototype.scaleY = function() {
  var levelHeight = this._level.height();
  return this.height() / levelHeight;
};


FlatTile.prototype.width = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  if (this.atRightEdge()) {
    var widthRemainder = mod(levelWidth, tileWidth);
    return widthRemainder || tileWidth;
  } else {
    return tileWidth;
  }
};


FlatTile.prototype.height = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  if (this.atBottomEdge()) {
    var heightRemainder = mod(levelHeight, tileHeight);
    return heightRemainder || tileHeight;
  } else {
    return tileHeight;
  }
};


FlatTile.prototype.levelWidth = function() {
  return this._level.width();
};


FlatTile.prototype.levelHeight = function() {
  return this._level.height();
};


FlatTile.prototype.atTopLevel = function() {
  return this.z === 0;
};


FlatTile.prototype.atBottomLevel = function() {
  return this.z === this._geometry.levelList.length - 1;
};


FlatTile.prototype.atTopEdge = function() {
  return this.y === 0;
};


FlatTile.prototype.atBottomEdge = function() {
  return this.y === this._level.numVerticalTiles() - 1;
};


FlatTile.prototype.atLeftEdge = function() {
  return this.x === 0;
};


FlatTile.prototype.atRightEdge = function() {
  return this.x === this._level.numHorizontalTiles() - 1;
};


FlatTile.prototype.padTop = function() {
  return false;
};


FlatTile.prototype.padBottom = function() {
  return !this.atBottomEdge();
};


FlatTile.prototype.padLeft = function() {
  return false;
};


FlatTile.prototype.padRight = function() {
  return !this.atRightEdge();
};


FlatTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec2.create(), vec2.create(), vec2.create(), vec2.create()];
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  vec2.set(result[0], left, top);
  vec2.set(result[1], right, top);
  vec2.set(result[2], right, bottom);
  vec2.set(result[3], left, bottom);

  return result;
};


FlatTile.prototype.parent = function() {


  if (this.atTopLevel()) {
    return null;
  }

  var geometry = this._geometry;

  var z = this.z - 1;
  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  var x = Math.floor(this.x / 2);
  var y = Math.floor(this.y / 2);

  return new FlatTile(x, y, z, geometry);

};


FlatTile.prototype.children = function(result) {
  if (this.atBottomLevel()) {
    return null;
  }

  var geometry = this._geometry;
  var z = this.z + 1;

  result = result || [];

  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  result.push(new FlatTile(2*this.x  , 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x  , 2*this.y+1, z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y+1, z, geometry));

  return result;

};


FlatTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles() - 1;
  var numY = level.numVerticalTiles() - 1;

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;

    if (0 <= newX && newX <= numX && 0 <= newY && newY <= numY) {
      result.push(new FlatTile(newX, newY, newZ, geometry));
    }
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


FlatTile.prototype.hash = function() {
  return hash(this.z, this.y, this.x);
};


FlatTile.prototype.equals = function(that) {
  return (this.geometry === that.geometry &&
      this.z === that.z && this.y === that.y && this.x === that.x);
};


FlatTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) || cmp(this.y, that.y) || cmp(this.x, that.x));
};


FlatTile.prototype.str = function() {
  return 'FlatTile(' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function FlatLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._width = levelProperties.width;
  this._height = levelProperties.height;
  this._tileWidth = levelProperties.tileWidth;
  this._tileHeight = levelProperties.tileHeight;
}

inherits(FlatLevel, Level);


FlatLevel.prototype.width = function() {
  return this._width;
};


FlatLevel.prototype.height = function() {
  return this._height;
};


FlatLevel.prototype.tileWidth = function() {
  return this._tileWidth;
};


FlatLevel.prototype.tileHeight = function() {
  return this._tileHeight;
};


FlatLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();

  if (width % parentWidth !== 0) {
    return new Error('Level width must be multiple of parent level: ' +
                     width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    return new Error('Level height must be multiple of parent level: ' +
                     height + ' vs. ' + parentHeight);
  }

  if (tileWidth % parentTileWidth !== 0) {
    return new Error('Level tile width must be multiple of parent level: ' +
                     tileWidth + ' vs. ' + parentTileWidth);
  }

  if (tileHeight % parentTileHeight !== 0) {
    return new Error('Level tile height must be multiple of parent level: ' +
                     tileHeight + ' vs. ' + parentTileHeight);
  }

};


/**
 * @class FlatGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled flat images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles must be square, except when in the last row or column position,
 *     and must form a rectangular grid;
 *   - The width and height of a level must be multiples of the parent level
 *     width and height.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
 * @param {number} levelPropertiesList[].tileWidth Tile width in pixels for
 *                 square tiles
 * @param {number} levelPropertiesList[].height Level height in pixels
 * @param {number} levelPropertiesList[].tileHeight Tile height in pixels for
 *                 square tiles
 */
function FlatGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, FlatLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


FlatGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


FlatGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  if (!result) {
    result = [];
  }

  for (var x = 0; x <= maxX; x++) {
    for (var y = 0; y <= maxY; y++) {
      result.push(new FlatTile(x, y, levelIndex, this));
    }
  }

  return result;

};


FlatGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 1, 1);
  vec4.transformMat4(ray, ray, view.inverseProjection());

  // Compute the image coordinates that the view ray points into.
  var x = 0.5 + ray[0];
  var y = 0.5 - ray[1];

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var levelWidth = level.width();
  var levelHeight = level.height();
  var tileWidth = level.tileWidth();
  var tileHeight = level.tileHeight();
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor(x * levelWidth / tileWidth), 0, numX - 1);
  var tileY = clamp(Math.floor(y * levelHeight / tileHeight), 0, numY - 1);

  return new FlatTile(tileX, tileY, tileZ, this);
};


FlatGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    throw new Error('Starting tile is not visible');
  }

  return result;
};


FlatGeometry.Tile = FlatGeometry.prototype.Tile = FlatTile;
FlatGeometry.type = FlatGeometry.prototype.type = 'flat';
FlatTile.type = FlatTile.prototype.type = 'flat';


module.exports = FlatGeometry;

},{"../TileSearcher":22,"../collections/LruMap":29,"../util/clamp":90,"../util/cmp":92,"../util/hash":103,"../util/inherits":104,"../util/mod":106,"../util/type":116,"./Level":54,"./common":55,"gl-matrix":3}],54:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function Level(levelProperties) {
  this._fallbackOnly = !!levelProperties.fallbackOnly;
}

Level.prototype.numHorizontalTiles = function() {
  return Math.ceil(this.width() / this.tileWidth());
};

Level.prototype.numVerticalTiles = function() {
  return Math.ceil(this.height() / this.tileHeight());
};

Level.prototype.fallbackOnly = function() {
  return this._fallbackOnly;
};

module.exports = Level;
},{}],55:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var cmp = require('../util/cmp');

function makeLevelList(levelPropertiesList, LevelClass) {
  var list = [];

  for (var i = 0; i < levelPropertiesList.length; i++) {
    list.push(new LevelClass(levelPropertiesList[i]));
  }

  list.sort(function(level1, level2) {
    return cmp(level1.width(), level2.width());
  });

  return list;
}

function makeSelectableLevelList(levelList) {
  var list = [];

  for (var i = 0; i < levelList.length; i++) {
    if (!levelList[i]._fallbackOnly) {
      list.push(levelList[i]);
    }
  }

  if (!list.length) {
    throw new Error('No selectable levels in list');
  }

  return list;
}

module.exports = {
  makeLevelList: makeLevelList,
  makeSelectableLevelList: makeSelectableLevelList
};

},{"../util/cmp":92}],56:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = {

  // Stages.
  WebGlStage: require('./stages/WebGl'),
  CssStage: require('./stages/Css'),
  FlashStage: require('./stages/Flash'),

  // Renderers.
  WebGlCubeRenderer: require('./renderers/WebGlCube'),
  WebGlFlatRenderer: require('./renderers/WebGlFlat'),
  WebGlEquirectRenderer: require('./renderers/WebGlEquirect'),
  CssCubeRenderer: require('./renderers/CssCube'),
  CssFlatRenderer: require('./renderers/CssFlat'),
  FlashCubeRenderer: require('./renderers/FlashCube'),
  FlashFlatRenderer: require('./renderers/FlashFlat'),
  registerDefaultRenderers: require('./renderers/registerDefaultRenderers'),

  // Geometries.
  CubeGeometry: require('./geometries/Cube'),
  FlatGeometry: require('./geometries/Flat'),
  EquirectGeometry: require('./geometries/Equirect'),

  // Views.
  RectilinearView: require('./views/Rectilinear'),
  FlatView: require('./views/Flat'),

  // Sources.
  ImageUrlSource: require('./sources/ImageUrl'),
  SingleAssetSource: require('./sources/SingleAsset'),

  // Assets.
  StaticAsset: require('./assets/Static'),
  DynamicAsset: require('./assets/Dynamic'),

  // Texture store.
  TextureStore: require('./TextureStore'),

  // Layer.
  Layer: require('./Layer'),

  // Render loop.
  RenderLoop: require('./RenderLoop'),

  // Controls.
  KeyControlMethod: require('./controls/Key'),
  DragControlMethod: require('./controls/Drag'),
  QtvrControlMethod: require('./controls/Qtvr'),
  ScrollZoomControlMethod: require('./controls/ScrollZoom'),
  PinchZoomControlMethod: require('./controls/PinchZoom'),
  VelocityControlMethod: require('./controls/Velocity'),
  ElementPressControlMethod: require('./controls/ElementPress'),
  Controls: require('./controls/Controls'),
  Dynamics: require('./controls/Dynamics'),

  // High-level API.
  Viewer: require('./Viewer'),
  Scene: require('./Scene'),

  // Hotspots.
  Hotspot: require('./Hotspot'),
  HotspotContainer: require('./HotspotContainer'),

  // Effects.
  colorEffects: require('./colorEffects'),

  // Miscellaneous functions.
  registerDefaultControls: require('./controls/registerDefaultControls'),
  autorotate: require('./autorotate'),

  // Utility functions.
  util: {
    async: require('./util/async'),
    cancelize: require('./util/cancelize'),
    chain: require('./util/chain'),
    clamp: require('./util/clamp'),
    clearOwnProperties: require('./util/clearOwnProperties'),
    cmp: require('./util/cmp'),
    compose: require('./util/compose'),
    convertFov: require('./util/convertFov'),
    decimal: require('./util/decimal'),
    defaults: require('./util/defaults'),
    defer: require('./util/defer'),
    degToRad: require('./util/degToRad'),
    delay: require('./util/delay'),
    dom: require('./util/dom'),
    extend: require('./util/extend'),
    hash: require('./util/hash'),
    inherits: require('./util/inherits'),
    mod: require('./util/mod'),
    noop: require('./util/noop'),
    now: require('./util/now'),
    once: require('./util/once'),
    pixelRatio: require('./util/pixelRatio'),
    radToDeg: require('./util/radToDeg'),
    real: require('./util/real'),
    retry: require('./util/retry'),
    tween: require('./util/tween'),
    type: require('./util/type')
  },

  // Expose dependencies for clients to use.
  dependencies: {
    bowser: require('bowser'),
    glMatrix: require('gl-matrix'),
    eventEmitter: require('minimal-event-emitter'),
    hammerjs: require('hammerjs')
  }
};

},{"./Hotspot":15,"./HotspotContainer":16,"./Layer":17,"./RenderLoop":19,"./Scene":20,"./TextureStore":21,"./Viewer":24,"./assets/Dynamic":25,"./assets/Static":27,"./autorotate":28,"./colorEffects":35,"./controls/Controls":38,"./controls/Drag":39,"./controls/Dynamics":40,"./controls/ElementPress":41,"./controls/Key":43,"./controls/PinchZoom":44,"./controls/Qtvr":45,"./controls/ScrollZoom":46,"./controls/Velocity":47,"./controls/registerDefaultControls":49,"./geometries/Cube":51,"./geometries/Equirect":52,"./geometries/Flat":53,"./renderers/CssCube":60,"./renderers/CssFlat":61,"./renderers/FlashCube":63,"./renderers/FlashFlat":64,"./renderers/WebGlCube":67,"./renderers/WebGlEquirect":68,"./renderers/WebGlFlat":69,"./renderers/registerDefaultRenderers":70,"./sources/ImageUrl":75,"./sources/SingleAsset":76,"./stages/Css":77,"./stages/Flash":78,"./stages/WebGl":81,"./util/async":86,"./util/cancelize":88,"./util/chain":89,"./util/clamp":90,"./util/clearOwnProperties":91,"./util/cmp":92,"./util/compose":93,"./util/convertFov":94,"./util/decimal":95,"./util/defaults":96,"./util/defer":97,"./util/degToRad":98,"./util/delay":99,"./util/dom":100,"./util/extend":101,"./util/hash":103,"./util/inherits":104,"./util/mod":106,"./util/noop":107,"./util/now":108,"./util/once":109,"./util/pixelRatio":110,"./util/radToDeg":112,"./util/real":113,"./util/retry":114,"./util/tween":115,"./util/type":116,"./views/Flat":117,"./views/Rectilinear":118,"bowser":1,"gl-matrix":3,"hammerjs":13,"minimal-event-emitter":14}],57:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var FlashAsset = require('../assets/Flash');
var NetworkError = require('../NetworkError');
var once = require('../util/once');

// TODO: Move the load queue into the loader.

/**
 * @class FlashImageLoader
 * @implements ImageLoader
 * @classdesc
 *
 * A {@link Loader} for Flash images.
 *
 * @param {Stage} stage The stage which is going to request images to be loaded.
 */
function FlashImageLoader(stage) {
  if (stage.type !== 'flash') {
    throw new Error('Stage type incompatible with loader');
  }
  this._stage = stage;
}

/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
FlashImageLoader.prototype.loadImage = function(url, rect, done) {
  var stage = this._stage;
  var flashElement = stage.flashElement();

  var x = rect && rect.x || 0;
  var y = rect && rect.y || 0;
  var width = rect && rect.width || 1;
  var height = rect && rect.height || 1;

  var imageId = flashElement.loadImage(url, width, height, x, y);

  done = once(done);

  // TODO: use a single callback for all imageLoaded events.

  function callback(err, callbackId) {
    // There is a single callback for all load events, so make sure this
    // is the right one.
    if (callbackId !== imageId) {
      return;
    }

    stage.removeFlashCallbackListener('imageLoaded', callback);

    // TODO: is there any way to distinguish a network error from other
    // kinds of errors? For now we always return NetworkError since this
    // prevents images to be retried continuously while we are offline.
    if (err) {
      done(new NetworkError('Network error: ' + url));
    } else {
      done(null, new FlashAsset(flashElement, imageId));
    }
  }

  stage.addFlashCallbackListener('imageLoaded', callback);

  function cancel() {
    flashElement.cancelImage(imageId);
    stage.removeFlashCallbackListener('imageLoaded', callback);
    done.apply(null, arguments);
  }

  return cancel;
};

module.exports = FlashImageLoader;

},{"../NetworkError":18,"../assets/Flash":26,"../util/once":109}],58:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('../assets/Static');
var NetworkError = require('../NetworkError');
var once = require('../util/once');

// N.B. HtmlImageLoader is broken on IE8 for images that require resizing, due
// to the unavailable HTML5 canvas element and the naturalWidth/naturalHeight
// properties of image elements. This is currently not a problem because the
// HTML-based renderers (WebGL and CSS) do not work on IE8 anyway. It could
// become a problem in the future if we decide to support CSS rendering of flat
// panoramas on IE8.

// TODO: Move the load queue into the loader.

/**
 * @class HtmlImageLoader
 * @implements ImageLoader
 * @classdesc
 *
 * A {@link Loader} for HTML images.
 *
 * @param {Stage} stage The stage which is going to request images to be loaded.
 */
function HtmlImageLoader(stage) {
  if (stage.type !== 'webgl' && stage.type !== 'css') {
    throw new Error('Stage type incompatible with loader');
  }
  this._stage = stage;
}

/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
HtmlImageLoader.prototype.loadImage = function(url, rect, done) {
  var img = new Image();

  // Allow cross-domain image loading.
  // This is required to be able to create WebGL textures from images fetched
  // from a different domain. Note that setting the crossorigin attribute to
  // 'anonymous' will trigger a CORS preflight for cross-domain requests, but no
  // credentials (cookies or HTTP auth) will be sent; to do so, the attribute
  // would have to be set to 'use-credentials' instead. Unfortunately, this is
  // not a safe choice, as it causes requests to fail when the response contains
  // an Access-Control-Allow-Origin header with a wildcard. See the section
  // "Credentialed requests and wildcards" on:
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
  img.crossOrigin = 'anonymous';

  var x = rect && rect.x || 0;
  var y = rect && rect.y || 0;
  var width = rect && rect.width || 1;
  var height = rect && rect.height || 1;

  done = once(done);

  img.onload = function() {
    if (x === 0 && y === 0 && width === 1 && height === 1) {
      done(null, new StaticAsset(img));
    }
    else {
      x *= img.naturalWidth;
      y *= img.naturalHeight;
      width *= img.naturalWidth;
      height *= img.naturalHeight;

      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext('2d');

      context.drawImage(img, x, y, width, height, 0, 0, width, height);

      done(null, new StaticAsset(canvas));
    }
  };

  img.onerror = function() {
    // TODO: is there any way to distinguish a network error from other
    // kinds of errors? For now we always return NetworkError since this
    // prevents images to be retried continuously while we are offline.
    done(new NetworkError('Network error: ' + url));
  };

  img.src = url;

  function cancel() {
    img.onload = img.onerror = null;
    img.src = '';
    done.apply(null, arguments);
  }

  return cancel;
};

module.exports = HtmlImageLoader;

},{"../NetworkError":18,"../assets/Static":27,"../util/once":109}],59:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Map = require('../collections/Map');
var decimal = require('../util/decimal');
var setOverflowHidden = require('../util/dom').setOverflowHidden;
var setNoPointerEvents = require('../util/dom').setNoPointerEvents;
var setNullTransform = require('../util/dom').setNullTransform;
var setTransform = require('../util/dom').setTransform;
var clearOwnProperties = require('../util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.css;


function tileCmp(a, b) {
  return a.cmp(b);
}


function CssBaseRenderer(root, quirks, tileClass) {

  this._root = root;

  this._browserQuirks = quirks;

  // Create a container for this renderer's tiles, so we can style them
  // as a whole separately from other renderers in the same stage.
  var domElement = document.createElement('div');
  root.appendChild(domElement);

  domElement.style.position = 'absolute';

  // For some weird reason, this prevents flickering on Safari Desktop.
  setOverflowHidden(domElement);

  // Prevent touch events on tiles from messing up pinching gestures on iOS.
  setNoPointerEvents(domElement);

  if (this._browserQuirks.useNullTransform) {
    setNullTransform(domElement);
  }

  this.domElement = domElement;

  this._oldTileList = [];
  this._newTileList = [];

  this._textureMap = new Map();
}


CssBaseRenderer.prototype.destroy = function() {
  this._root.removeChild(this.domElement);
  clearOwnProperties(this);
};


CssBaseRenderer.prototype.startLayer = function(layer, rect) {
  var domElement = this.domElement;

  // Set viewport effect.
  var stageWidth = this._root.clientWidth;
  var stageHeight = this._root.clientHeight;
  domElement.style.left = decimal(stageWidth * rect.left) + 'px';
  domElement.style.top = decimal(stageHeight * rect.top) + 'px';
  domElement.style.width = decimal(stageWidth * rect.width) + 'px';
  domElement.style.height = decimal(stageHeight * rect.height) + 'px';

  // Set opacity effect.
  var opacity = 1.0;
  var effects = layer.effects();
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }
  domElement.style.opacity = opacity;

  // Clear temporary variables.
  this._newTileList.length = 0;
  this._textureMap.clear();
};


CssBaseRenderer.prototype.renderTile = function(tile, texture) {
  this._newTileList.push(tile);
  this._textureMap.set(tile, texture);
};


CssBaseRenderer.prototype.endLayer = function(layer, rect) {

  var domElement = this.domElement;
  var oldTileList = this._oldTileList;
  var newTileList = this._newTileList;
  var textureMap = this._textureMap;
  var oldIndex, newIndex, oldTile, newTile;
  var texture, canvas;
  var currentNode, nextNode;

  var view = layer.view();

  // Iterate the old and new tile lists in a consistent order and perform
  // insertions and removals as we go. This minimizes the number of DOM
  // operations performed.

  // Neither the tile list nor the texture list may contain duplicates,
  // otherwise this logic will fail.

  // Consistency check.
  if (domElement.children.length !== oldTileList.length) {
    throw new Error('DOM not in sync with tile list');
  }

  newTileList.sort(tileCmp);

  oldIndex = 0;
  oldTile = oldTileList[oldIndex];
  currentNode = domElement.firstChild;

  for (newIndex = 0; newIndex < newTileList.length; newIndex++) {

    newTile = newTileList[newIndex];

    // Iterate old list until it catches up with the new list.
    while (oldIndex < oldTileList.length) {

      if (oldTile.cmp(newTile) >= 0) {
        // Caught up.
        break;
      }

      // Tile is no longer visible.
      // Remove it from the DOM.
      nextNode = currentNode.nextSibling;
      domElement.removeChild(currentNode);
      currentNode = nextNode;
      oldTile = oldTileList[++oldIndex];
    }

    // Get the texture for the current tile.
    texture = textureMap.get(newTile);
    canvas = texture ? texture._canvas : null;

    // Consistency check.
    if (!canvas) {
      throw new Error('Rendering tile with missing texture');
    }

    if (oldTile && oldTile.cmp(newTile) === 0) {
      // The old and new tile are the same.

      // Consistency check.
      if (canvas != currentNode) {
        throw new Error('DOM not in sync with tile list');
      }

      currentNode = currentNode.nextSibling;
      oldTile = oldTileList[++oldIndex];

    } else {
      // The new tile comes before the old tile.
      // Insert it into the DOM.
      domElement.insertBefore(canvas, currentNode);
    }

    // Set the CSS transform on the current tile.
    setTransform(canvas, this.calculateTransform(newTile, texture, view));

    if (debug) {
      canvas.setAttribute('data-tile', newTile.str());
    }
  }

  // Remove trailing tiles that are no longer visible from the DOM.
  while (currentNode) {
    nextNode = currentNode.nextSibling;
    domElement.removeChild(currentNode);
    currentNode = nextNode;
  }

  // Consistenty check.
  if (domElement.children.length !== newTileList.length) {
    throw new Error('DOM not in sync with tile list');
  }

  // The old and new tile lists swap roles between iterations.
  var tmp = this._oldTileList;
  this._oldTileList = this._newTileList;
  this._newTileList = tmp;
};


module.exports = CssBaseRenderer;

},{"../collections/Map":31,"../util/clearOwnProperties":91,"../util/decimal":95,"../util/dom":100}],60:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var CubeTile = require('../geometries/Cube').Tile;
var CssBaseRenderer = require('./CssBase');
var decimal = require('../util/decimal');
var inherits = require('../util/inherits');


/**
 * @class CssCubeRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView}, appropriate
 * for a {@link CssStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function CssCubeRenderer(root, quirks) {
  this.constructor.super_.call(this, root, quirks, CubeTile);
}

inherits(CssCubeRenderer, CssBaseRenderer);


CssCubeRenderer.prototype.calculateTransform = function(tile, texture, view) {

  var padSize = this._browserQuirks.padSize;
  var reverseLevelDepth = this._browserQuirks.reverseLevelDepth;
  var perspectiveNudge = this._browserQuirks.perspectiveNudge;

  var transform = '';

  // Calculate the cube size for this level.
  var cubeSize = reverseLevelDepth ? 256 - tile.z : tile.levelWidth();

  // Place top left corner of tile at viewport center to serve as the center
  // of rotation.
  // We do not rotate about the center of the tile because, for some mysterious
  // reason, this seems to occasionally crash Chrome.
  var size = view.size();
  var viewportWidth = size.width;
  var viewportHeight = size.height;
  transform += 'translate3d(' + decimal(viewportWidth/2) + 'px, ' + decimal(viewportHeight/2) + 'px, 0px) ';

  // Set the perspective depth.
  var perspective = 0.5 * viewportHeight / Math.tan(view.fov() / 2);
  var distance = perspective + perspectiveNudge;
  transform += 'perspective(' + decimal(perspective) + 'px) translateZ(' + decimal(distance) + 'px) ';

  // Set the camera rotation.
  var viewRotZ = -view.roll();
  var viewRotX = -view.pitch();
  var viewRotY = view.yaw();
  transform += 'rotateZ(' + decimal(viewRotZ) + 'rad) rotateX(' + decimal(viewRotX) + 'rad) rotateY(' + decimal(viewRotY) + 'rad) ';

  // Set the cube face orientation.
  var tileRotX = -tile.rotX();
  var tileRotY = tile.rotY();
  transform += 'rotateX(' + decimal(tileRotX) + 'rad) rotateY(' + decimal(tileRotY) + 'rad) ';

  // Move tile into its position within the cube face.
  var cornerX = tile.centerX() - tile.scaleX() / 2;
  var cornerY = -(tile.centerY() + tile.scaleY() / 2);
  var translX = cornerX * cubeSize;
  var translY = cornerY * cubeSize;
  var translZ = -cubeSize / 2;
  transform += 'translate3d(' + decimal(translX) + 'px, ' + decimal(translY) + 'px, ' + decimal(translZ) + 'px) ';

  // Scale tile into correct size.
  if (reverseLevelDepth) {
    var scaleX = cubeSize * tile.scaleX() / tile.width();
    var scaleY = cubeSize * tile.scaleY() / tile.height();
    transform += 'scale(' + decimal(scaleX) + ', ' + decimal(scaleY) + ') ';
  }

  // Compensate for padding around the tile.
  var padLeft = tile.padLeft() ? padSize : 0;
  var padTop = tile.padTop() ? padSize : 0;
  if (padLeft !== 0 || padTop !== 0) {
    transform += 'translate3d(' + decimal(-padLeft) + 'px, ' + decimal(-padTop) + 'px, 0) ';
  }

  return transform;

};


module.exports = CssCubeRenderer;

},{"../geometries/Cube":51,"../util/decimal":95,"../util/inherits":104,"./CssBase":59}],61:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var FlatTile = require('../geometries/Flat').Tile;
var CssBaseRenderer = require('./CssBase');
var decimal = require('../util/decimal');
var inherits = require('../util/inherits');


/**
 * @class CssFlatRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link FlatGeometry} and {@link FlatView}, appropriate for a
 * {@link CssStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function CssFlatRenderer(root, quirks) {
  this.constructor.super_.call(this, root, quirks, FlatTile);
}

inherits(CssFlatRenderer, CssBaseRenderer);


CssFlatRenderer.prototype.calculateTransform = function(tile, texture, view) {

  var padSize = this._browserQuirks.padSize;

  var transform = '';

  // Place top left corner of tile at the center of the viewport.
  var viewportWidth = view.width();
  var viewportHeight = view.height();
  transform += 'translateX(' + decimal(viewportWidth/2) + 'px) translateY(' + decimal(viewportHeight/2) + 'px) ';

  // Determine the zoom factor.
  var zoomX = viewportWidth / view._zoomX();
  var zoomY = viewportHeight / view._zoomY();

  // Move tile into its position within the image.
  var cornerX = tile.centerX() - tile.scaleX() / 2 + 0.5;
  var cornerY = 0.5 - tile.centerY() - tile.scaleY() / 2;
  var translX = cornerX * zoomX;
  var translY = cornerY * zoomY;
  transform += 'translateX(' + decimal(translX) + 'px) translateY(' + decimal(translY) + 'px) ';

  // Apply view offsets.
  var offX = -view.x() * zoomX;
  var offY = -view.y() * zoomY;
  transform += 'translateX(' + decimal(offX) + 'px) translateY(' + decimal(offY) + 'px) ';

  // Compensate for padding around the tile.
  var padLeft = tile.padLeft() ? padSize : 0;
  var padTop = tile.padTop() ? padSize : 0;
  if (padLeft !== 0 || padTop !== 0) {
    transform += 'translateX(' + decimal(-padLeft) + 'px) translateY(' + decimal(-padTop) + 'px) ';
  }

  // Scale tile into correct size.
  var scaleX = zoomX / tile.levelWidth();
  var scaleY = zoomY / tile.levelHeight();
  transform += 'scale(' + decimal(scaleX) + ', ' + decimal(scaleY) + ') ';

  return transform;

};


module.exports = CssFlatRenderer;

},{"../geometries/Flat":53,"../util/decimal":95,"../util/inherits":104,"./CssBase":59}],62:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Map = require('../collections/Map');
var clearOwnProperties = require('../util/clearOwnProperties');


function tileCmp(a, b) {
  return a.cmp(b);
}


function FlashBaseRenderer(flashElement, layerId, quirks, tileClass) {

  this._flashElement = flashElement;
  this._layerId = layerId;
  this._quirks = quirks;

  this._tileList = [];

  this._textureMap = new Map();

  // Whether the Flash layer for this renderer has already been created
  // by calling flashElement.createLayer(). Note that we cannot do this
  // right here because Flash may not be initialized yet.
  this._layerCreated = false;
}


FlashBaseRenderer.prototype.destroy = function() {
  if (this._layerCreated) {
    this._flashElement.destroyLayer(this._layerId);
  }
  clearOwnProperties(this);
};


FlashBaseRenderer.prototype.startLayer = function(layer, rect) {
  if (!this._flashElement.isReady || !this._flashElement.isReady()) {
    return;
  }
  if (!this._layerCreated) {
    this._flashElement.createLayer(this._layerId);
    this._layerCreated = true;
  }
  this._tileList.length = 0;
  this._textureMap.clear();
};


FlashBaseRenderer.prototype.renderTile = function(tile, texture) {
  this._tileList.push(tile);
  this._textureMap.set(tile, texture);
};


FlashBaseRenderer.prototype.endLayer = function(layer, rect) {
  if (!this._flashElement.isReady || !this._flashElement.isReady()) {
    return;
  }

  // Sort tiles so they are rendered in an order coherent with their padding.
  var tileList = this._tileList;
  tileList.sort(tileCmp);

  this._renderOnFlash(layer, rect);
};


module.exports = FlashBaseRenderer;

},{"../collections/Map":31,"../util/clearOwnProperties":91}],63:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var FlashBaseRenderer = require('./FlashBase');
var CubeTile = require('../geometries/Cube').Tile;
var inherits = require('../util/inherits');

var radToDeg = require('../util/radToDeg');


/**
 * @class FlashCubeRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView}, appropriate
 * for a {@link FlashStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function FlashCubeRenderer(flashElement, layerId, quirks) {
  this.constructor.super_.call(this, flashElement, layerId, quirks, CubeTile);
  this._flashTileList = [];
}

inherits(FlashCubeRenderer, FlashBaseRenderer);


FlashCubeRenderer.prototype._renderOnFlash = function(layer, rect) {

  var flashElement = this._flashElement;
  var layerId = this._layerId;
  var padSize = this._quirks.padSize;

  var tileList = this._tileList;
  var textureMap = this._textureMap;

  var flashTileList = this._flashTileList;
  flashTileList.length = 0;

  for (var i = 0; i < tileList.length; i++) {
    var tile = tileList[i];
    var texture = textureMap.get(tile);
    if (!texture) {
      throw new Error('Rendering tile with missing texture');
    }

    // Get padding sizes.
    var padTop = tile.padTop() ? padSize : 0;
    var padBottom = tile.padBottom() ? padSize : 0;
    var padLeft = tile.padLeft() ? padSize : 0;
    var padRight = tile.padRight() ? padSize : 0;

    flashTileList.push({
      textureId: texture._textureId,
      face: tile.face,
      width: tile.width(),
      height: tile.height(),
      centerX: tile.centerX(),
      centerY: tile.centerY(),
      rotX: radToDeg(tile.rotX()),
      rotY: radToDeg(tile.rotY()),
      levelSize: tile.levelWidth(),
      padTop: padTop,
      padBottom: padBottom,
      padLeft: padLeft,
      padRight: padRight
    });
  }

  // Get viewport position and size.
  var stageWidth = this._flashElement.clientWidth;
  var stageHeight = this._flashElement.clientHeight;
  var viewportX = stageWidth * rect.x;
  var viewportY = stageHeight * rect.y;
  var viewportWidth = stageWidth * rect.width;
  var viewportHeight = stageHeight * rect.height;

  // Get opacity value.
  var opacity = 1.0;
  var effects = layer.effects();
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }

  // Get view parameters.
  var view = layer.view();
  var yaw = view.yaw();
  var pitch = view.pitch();
  var roll = view.roll();
  var fov = view.fov();

  flashElement.drawCubeTiles(
      layerId, viewportWidth, viewportHeight, viewportX, viewportY, opacity,
      yaw, pitch, roll, fov, flashTileList);
};


module.exports = FlashCubeRenderer;

},{"../geometries/Cube":51,"../util/inherits":104,"../util/radToDeg":112,"./FlashBase":62}],64:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var FlashBaseRenderer = require('./FlashBase');
var FlatTile = require('../geometries/Flat').Tile;
var inherits = require('../util/inherits');


/**
 * @class FlashFlatRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link FlatGeometry} and {@link FlatView}, appropriate for a
 * {@link FlashStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function FlashFlatRenderer(flashElement, layerId, quirks) {
  this.constructor.super_.call(this, flashElement, layerId, quirks, FlatTile);
  this._flashTileList = [];
}

inherits(FlashFlatRenderer, FlashBaseRenderer);


FlashFlatRenderer.prototype._renderOnFlash = function(layer, rect) {

  var flashElement = this._flashElement;
  var layerId = this._layerId;
  var padSize = this._quirks.padSize;

  var tileList = this._tileList;
  var textureMap = this._textureMap;

  var flashTileList = this._flashTileList;
  flashTileList.length = 0;

  for (var i = 0; i < tileList.length; i++) {
    var tile = tileList[i];
    var texture = textureMap.get(tile);
    if (!texture) {
      throw new Error('Rendering tile with missing texture');
    }

    // Get padding sizes.
    var padTop = tile.padTop() ? padSize : 0;
    var padBottom = tile.padBottom() ? padSize : 0;
    var padLeft = tile.padLeft() ? padSize : 0;
    var padRight = tile.padRight() ? padSize : 0;

    flashTileList.push({
      textureId: texture._textureId,
      width: tile.width(),
      height: tile.height(),
      centerX: tile.centerX(),
      centerY: tile.centerY(),
      scaleX: tile.scaleX(),
      scaleY: tile.scaleY(),
      levelWidth: tile.levelWidth(),
      levelHeight: tile.levelHeight(),
      padTop: padTop,
      padBottom: padBottom,
      padLeft: padLeft,
      padRight: padRight
    });
  }

  // Get viewport position and size.
  var stageWidth = this._flashElement.clientWidth;
  var stageHeight = this._flashElement.clientHeight;
  var viewportX = stageWidth * rect.x;
  var viewportY = stageHeight * rect.y;
  var viewportWidth = stageWidth * rect.width;
  var viewportHeight = stageHeight * rect.height;

  // Get opacity value.
  var opacity = 1.0;
  var effects = layer.effects();
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }

  // Get view parameters.
  var view = layer.view();
  var x = view.x();
  var y = view.y();
  var zoomX = view._zoomX();
  var zoomY = view._zoomY();

  flashElement.drawFlatTiles(
      layerId, viewportWidth, viewportHeight, viewportX, viewportY, opacity,
      x, y, zoomX, zoomY, flashTileList);
};


module.exports = FlashFlatRenderer;

},{"../geometries/Flat":53,"../util/inherits":104,"./FlashBase":62}],65:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexNormal');
var fragmentSrc = require('../shaders/fragmentNormal');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition', 'aTextureCoord'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uProjMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix'
];


function WebGlBaseRenderer(gl) {
  this.gl = gl;

  // The projection matrix positions the tiles in world space.
  // We compute it in Javascript because lack of precision in the vertex shader
  // causes seams to appear between adjacent tiles at large zoom levels.
  this.projMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  // Translation and scale vectors for tiles.
  this.translateVector = vec3.create();
  this.scaleVector = vec3.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlBaseRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};

WebGlBaseRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
  gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlBaseRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlBaseRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var projMatrix = this.projMatrix;
  var translateVector = this.translateVector;
  var scaleVector = this.scaleVector;

  translateVector[0] = tile.centerX();
  translateVector[1] = tile.centerY();
  translateVector[2] = -0.5;

  scaleVector[0] = tile.scaleX();
  scaleVector[1] = tile.scaleY();
  scaleVector[2] = 1.0;

  mat4.copy(projMatrix, layer.view().projection());
  mat4.rotateX(projMatrix, projMatrix, tile.rotX());
  mat4.rotateY(projMatrix, projMatrix, tile.rotY());
  mat4.translate(projMatrix, projMatrix, translateVector);
  mat4.scale(projMatrix, projMatrix, scaleVector);

  gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);

  setDepth(gl, shaderProgram, layerZ, tile.z);

  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlBaseRenderer;

},{"../shaders/fragmentNormal":72,"../shaders/vertexNormal":74,"../util/clearOwnProperties":91,"./WebGlCommon":66,"gl-matrix":3}],66:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// These are used to set the WebGl depth for a tile.
var MAX_LAYERS = 256; // Max number of layers per stage.
var MAX_LEVELS = 256; // Max number of levels per layer.

var clamp = require('../util/clamp');
var vec4 = require('gl-matrix').vec4;
var vec3 = require('gl-matrix').vec3;
var mat4 = require('gl-matrix').mat4;


function createShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw gl.getShaderInfoLog(shader);
  }
  return shader;
}


function createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList) {

  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

  var shaderProgram = gl.createProgram();

  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    throw gl.getProgramInfoLog(shaderProgram);
  }

  for (var i = 0; i < attribList.length; i++) {
    var attrib = attribList[i];
    shaderProgram[attrib] = gl.getAttribLocation(shaderProgram, attrib);
    if (shaderProgram[attrib] === -1) {
      throw new Error('Shader program has no ' + attrib + ' attribute');
    }
  }

  for (var j = 0; j < uniformList.length; j++) {
    var uniform = uniformList[j];
    shaderProgram[uniform] = gl.getUniformLocation(shaderProgram, uniform);
    if (shaderProgram[uniform] === -1) {
      throw new Error('Shader program has no ' + uniform + ' uniform');
    }
  }

  return shaderProgram;
}


function destroyShaderProgram(gl, shaderProgram) {
  var shaderList = gl.getAttachedShaders(shaderProgram);
  for (var i = 0; i < shaderList.length; i++) {
    var shader = shaderList[i];
    gl.detachShader(shaderProgram, shader);
    gl.deleteShader(shader);
  }
  gl.deleteProgram(shaderProgram);
}


function createConstantBuffer(gl, target, usage, value) {
  var buffer = gl.createBuffer();
  gl.bindBuffer(target, buffer);
  gl.bufferData(target, value, usage);
  return buffer;
}


function createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords) {
  return {
    vertexIndices: createConstantBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, new Uint16Array(vertexIndices)),
    vertexPositions: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(vertexPositions)),
    textureCoords: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(textureCoords))
  };
}


function destroyConstantBuffers(gl, constantBuffers) {
  gl.deleteBuffer(constantBuffers.vertexIndices);
  gl.deleteBuffer(constantBuffers.vertexPositions);
  gl.deleteBuffer(constantBuffers.textureCoords);
}


function enableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.enableVertexAttribArray(i);
  }
}


function disableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.disableVertexAttribArray(i);
  }
}


function setTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture._texture);
  gl.uniform1i(shaderProgram.uSampler, 0);
}


function setDepth(gl, shaderProgram, layerZ, tileZ) {
  var depth = (((layerZ + 1) * MAX_LEVELS) - tileZ) / (MAX_LEVELS * MAX_LAYERS);
  gl.uniform1f(shaderProgram.uDepth, depth);
}


var defaultOpacity = 1.0;
var defaultColorOffset = vec4.create();
var defaultColorMatrix = mat4.create();
mat4.identity(defaultColorMatrix);

function setupPixelEffectUniforms(gl, effects, uniforms) {
  var opacity = defaultOpacity;
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }
  gl.uniform1f(uniforms.opacity, opacity);

  var colorOffset = defaultColorOffset;
  if (effects && effects.colorOffset) {
    colorOffset = effects.colorOffset;
  }
  gl.uniform4fv(uniforms.colorOffset, colorOffset);

  var colorMatrix = defaultColorMatrix;
  if (effects && effects.colorMatrix) {
    colorMatrix = effects.colorMatrix;
  }
  gl.uniformMatrix4fv(uniforms.colorMatrix, false, colorMatrix);
}


// Temporary vectors for setViewport.
var translateVector = vec3.create();
var scaleVector = vec3.create();


// Sets the WebGL viewport and returns a viewport clamping compensation matrix.
//
// Negative viewport origin coordinates cause rendering issues. Letting the
// viewport dimensions extend beyond the visible area do not seem to cause
// rendering issues, but they may still have an impact on performance.
// Therefore, when the scene's rect is not fully contained in the rendering
// area, we clamp the viewport to the rendering area, and return a compensation
// matrix to scale and translate vertices accordingly.
function setViewport(gl, layer, rect, viewportMatrix) {
  if (rect.x === 0 && rect.width === 1 && rect.y === 0 && rect.height === 1) {
    // Fast path for full rect.
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    mat4.identity(viewportMatrix);
    return;
  }

  var offsetX = rect.x;
  var clampedOffsetX = clamp(offsetX, 0, 1);
  var leftExcess = clampedOffsetX - offsetX;
  var maxClampedWidth = 1 - clampedOffsetX;
  var clampedWidth = clamp(rect.width - leftExcess, 0, maxClampedWidth);
  var rightExcess = rect.width - clampedWidth;

  var offsetY = 1 - rect.height - rect.y;
  var clampedOffsetY = clamp(offsetY, 0, 1);
  var bottomExcess = clampedOffsetY - offsetY;
  var maxClampedHeight = 1 - clampedOffsetY;
  var clampedHeight = clamp(rect.height - bottomExcess, 0, maxClampedHeight);
  var topExcess = rect.height - clampedHeight;

  vec3.set(
    scaleVector,
    rect.width / clampedWidth,
    rect.height / clampedHeight,
    1);

  vec3.set(
    translateVector,
    (rightExcess - leftExcess) / clampedWidth,
    (topExcess - bottomExcess) / clampedHeight,
    0);

  mat4.identity(viewportMatrix);
  mat4.translate(viewportMatrix, viewportMatrix, translateVector);
  mat4.scale(viewportMatrix, viewportMatrix, scaleVector);

  gl.viewport(gl.drawingBufferWidth * clampedOffsetX,
              gl.drawingBufferHeight * clampedOffsetY,
              gl.drawingBufferWidth * clampedWidth,
              gl.drawingBufferHeight * clampedHeight);
}

module.exports = {
  createShaderProgram: createShaderProgram,
  destroyShaderProgram: destroyShaderProgram,
  createConstantBuffers: createConstantBuffers,
  destroyConstantBuffers: destroyConstantBuffers,
  enableAttributes: enableAttributes,
  disableAttributes: disableAttributes,
  setTexture: setTexture,
  setDepth: setDepth,
  setViewport: setViewport,
  setupPixelEffectUniforms: setupPixelEffectUniforms
};

},{"../util/clamp":90,"gl-matrix":3}],67:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlCubeRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView}, appropriate
 * for a {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlCubeRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlCubeRenderer, WebGlBaseRenderer);

module.exports = WebGlCubeRenderer;

},{"../util/inherits":104,"./WebGlBase":65}],68:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexEquirect');
var fragmentSrc = require('../shaders/fragmentEquirect');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uInvProjMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix', 'uTextureX', 'uTextureY', 'uTextureWidth',
  'uTextureHeight'
];


/**
 * @class WebGlEquirectRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link EquirectGeometry} and {@link RectilinearView},
 * appropriate for {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlEquirectRenderer(gl) {
  this.gl = gl;

  // The inverse projection matrix.
  this.invProjMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlEquirectRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};


WebGlEquirectRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var invProjMatrix = this.invProjMatrix;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);

  // Compute and set the inverse projection matrix.
  mat4.copy(invProjMatrix, layer.view().projection());
  mat4.invert(invProjMatrix, invProjMatrix);

  gl.uniformMatrix4fv(shaderProgram.uInvProjMatrix, false, invProjMatrix);

  // Compute and set the texture scale and crop offsets.
  var textureCrop = layer.effects().textureCrop || {};
  var textureX = textureCrop.x != null ? textureCrop.x : 0;
  var textureY = textureCrop.y != null ? textureCrop.y : 0;
  var textureWidth = textureCrop.width != null ? textureCrop.width : 1;
  var textureHeight = textureCrop.height != null ? textureCrop.height : 1;

  gl.uniform1f(shaderProgram.uTextureX, textureX);
  gl.uniform1f(shaderProgram.uTextureY, textureY);
  gl.uniform1f(shaderProgram.uTextureWidth, textureWidth);
  gl.uniform1f(shaderProgram.uTextureHeight, textureHeight);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlEquirectRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlEquirectRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;

  setDepth(gl, shaderProgram, layerZ, tile.z);

  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlEquirectRenderer;

},{"../shaders/fragmentEquirect":71,"../shaders/vertexEquirect":73,"../util/clearOwnProperties":91,"./WebGlCommon":66,"gl-matrix":3}],69:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlFlatRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link FlatGeometry} and {@link FlatView}, appropriate for a
 * {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlFlatRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlFlatRenderer, WebGlBaseRenderer);

module.exports = WebGlFlatRenderer;

},{"../util/inherits":104,"./WebGlBase":65}],70:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlCube = require('./WebGlCube');
var WebGlFlat = require('./WebGlFlat');
var WebGlEquirect = require('./WebGlEquirect');

var CssCube = require('./CssCube');
var CssFlat = require('./CssFlat');

var FlashCube = require('./FlashCube');
var FlashFlat = require('./FlashFlat');

/**
 * Registers all known renderers for the given stage type into that stage.
 * Most users will not need to register renderers, as {@link Viewer} does it for
 * them.
 *
 * @param {Stage} stage The stage where the renderers are to be registered.
 * @throws An error if the stage type is unknown.
 */
function registerDefaultRenderers(stage) {
  switch (stage.type) {
    case 'webgl':
      stage.registerRenderer('flat', 'flat', WebGlFlat);
      stage.registerRenderer('cube', 'rectilinear', WebGlCube);
      stage.registerRenderer('equirect', 'rectilinear', WebGlEquirect);
      break;
    case 'css':
      stage.registerRenderer('flat', 'flat', CssFlat);
      stage.registerRenderer('cube', 'rectilinear', CssCube);
      break;
    case 'flash':
      stage.registerRenderer('flat', 'flat', FlashFlat);
      stage.registerRenderer('cube', 'rectilinear', FlashCube);
      break;
    default:
      throw new Error('Unknown stage type: ' + stage.type);
  }
}

module.exports = registerDefaultRenderers;

},{"./CssCube":60,"./CssFlat":61,"./FlashCube":63,"./FlashFlat":64,"./WebGlCube":67,"./WebGlEquirect":68,"./WebGlFlat":69}],71:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform float uTextureX;',
'uniform float uTextureY;',
'uniform float uTextureWidth;',
'uniform float uTextureHeight;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec4 vRay;',

'const float PI = 3.14159265358979323846264;',

'void main(void) {',
'  float r = inversesqrt(vRay.x * vRay.x + vRay.y * vRay.y + vRay.z * vRay.z);',
'  float phi  = acos(vRay.y * r);',
'  float theta = atan(vRay.x, -1.0*vRay.z);',
'  float s = 0.5 + 0.5 * theta / PI;',
'  float t = 1.0 - phi / PI;',

'  s = s * uTextureWidth + uTextureX;',
'  t = t * uTextureHeight + uTextureY;',

'  vec4 color = texture2D(uSampler, vec2(s, t)) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],72:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float;',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',
'  vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],73:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uInvProjMatrix;',

'varying vec4 vRay;',

'void main(void) {',
'  vRay = uInvProjMatrix * vec4(aVertexPosition.xy, 1.0, 1.0);',
'  gl_Position = uViewportMatrix * vec4(aVertexPosition.xy, uDepth, 1.0);',
'}'
].join('\n');

},{}],74:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',
'attribute vec2 aTextureCoord;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uProjMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',
'  gl_Position = uViewportMatrix * uProjMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);',
'  gl_Position.z = uDepth * gl_Position.w;',
'  vTextureCoord = aTextureCoord;',
'}'
].join('\n');

},{}],75:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var NetworkError = require('../NetworkError');
var WorkPool = require('../collections/WorkPool');
var chain = require('../util/chain');
var delay = require('../util/delay');
var now = require('../util/now');


// Map template properties to their corresponding tile properties.
var templateProperties = {
  x: 'x',
  y: 'y',
  z: 'z',
  f: 'face'
};

// Default face order for cube maps.
var defaultCubeMapFaceOrder = 'bdflru';

// Default maximum number of concurrent requests.
var defaultConcurrency = 4;

// Default milliseconds to wait before retrying failed requests.
var defaultRetryDelay = 10000;


/**
 * @class ImageUrlSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that loads {@link Asset assets} from images given a URL and
 * a crop rectangle.
 *
 * @param {Function} sourceFromTile Function that receives a tile and returns
 * a `{ url, rect }` object, where `url` is an image URL and `rect`, when
 * present, is an `{ x, y, width, height }` object in normalized coordinates
 * denoting the portion of the image to use.
 * @param {Object} opts
 * @param {number} [opts.concurrency=4] Maximum number of tiles to request at
 *     the same time. The limit is per {@link ImageSourceUrl} instance.
 * @param {number} [opts.retryDelay=10000] Time in milliseconds to wait before
 *     retrying a failed request.
 */
function ImageUrlSource(sourceFromTile, opts) {

  opts = opts ? opts : {};

  this._loadPool = new WorkPool({
    concurrency: opts.concurrency || defaultConcurrency
  });

  this._retryDelay = opts.retryDelay || defaultRetryDelay;
  this._retryMap = {};

  this._sourceFromTile = sourceFromTile;
}

eventEmitter(ImageUrlSource);


ImageUrlSource.prototype.loadAsset = function(stage, tile, done) {

  var self = this;

  var retryDelay = this._retryDelay;
  var retryMap = this._retryMap;

  var tileSource = this._sourceFromTile(tile);
  var url = tileSource.url;
  var rect = tileSource.rect;

  var loadImage = stage.loadImage.bind(stage, url, rect);

  var loadFn = function(done) {
    // TODO: Deduplicate load requests for the same URL. Although the browser
    // might be smart enough to avoid duplicate requests, they are still unduly
    // impacted by the concurrency parameter.
    return self._loadPool.push(loadImage, function(err, asset) {
      if (err) {
        if (err instanceof NetworkError) {
          // If a network error occurred, wait before retrying.
          retryMap[url] = now();
          self.emit('networkError', asset, err);
        }
        done(err, tile);
      } else {
        // On a successful fetch, forget the previous timeout.
        delete retryMap[url];
        done(null, tile, asset);
      }
    });
  };

  // Check whether we are retrying a failed request.
  var delayAmount;
  var lastTime = retryMap[url];
  if (lastTime != null) {
    var currentTime = now();
    var elapsed = currentTime - lastTime;
    if (elapsed < retryDelay) {
      // Wait before retrying.
      delayAmount = retryDelay - elapsed;
    } else {
      // Retry timeout expired; perform the request at once.
      delayAmount = 0;
      delete retryMap[url];
    }
  }

  var delayFn = delay.bind(null, delayAmount);

  return chain(delayFn, loadFn)(done);
};


/**
 * Creates an ImageUrlSource from a string template.
 *
 * @param {String} url Tile URL template, which may contain the following
 *    placeholders:
 *    - `{f}` : tile face (one of `b`, `d`, `f`, `l`, `r`, `u`)
 *    - `{z}` : tile level index (0 is the smallest level)
 *    - `{x}` : tile horizontal index
 *    - `{y}` : tile vertical index
 * @param {Object} opts In addition to the options already supported by the
 *     {@link ImageUrlSource} constructor.
 * @param {String} opts.cubeMapPreviewUrl URL to use as the preview level.
 *     This must be a single image containing six cube faces laid out
 *     vertically according to the face order parameter.
 * @param {String} [opts.cubeMapPreviewFaceOrder='bdflru'] Face order within
 *     the preview image.
 */
ImageUrlSource.fromString = function(url, opts) {
  opts = opts || {};

  var faceOrder = opts && opts.cubeMapPreviewFaceOrder || defaultCubeMapFaceOrder;

  var urlFn = opts.cubeMapPreviewUrl ? withPreview : withoutPreview;

  return new ImageUrlSource(urlFn, opts);

  function withoutPreview(tile) {
    var tileUrl = url;

    for (var property in templateProperties) {
      var templateProperty = templateProperties[property];
      var regExp = propertyRegExp(property);
      var valueFromTile = tile.hasOwnProperty(templateProperty) ? tile[templateProperty] : '';
      tileUrl = tileUrl.replace(regExp, valueFromTile);
    }

    return { url: tileUrl };
  }

  function withPreview(tile) {
    if (tile.z === 0) {
      return cubeMapUrl(tile);
    }
    else {
      return withoutPreview(tile);
    }
  }

  function cubeMapUrl(tile) {
    var y = faceOrder.indexOf(tile.face) / 6;
    return {
      url: opts.cubeMapPreviewUrl,
      rect: { x: 0, y: y, width: 1, height: 1/6 }
    };
  }
};

function propertyRegExp(property) {
  var regExpStr = '\\{(' + property + ')\\}';
  return new RegExp(regExpStr, 'g');
}

module.exports = ImageUrlSource;

},{"../NetworkError":18,"../collections/WorkPool":33,"../util/chain":89,"../util/delay":99,"../util/now":108,"minimal-event-emitter":14}],76:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class SingleAssetSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that always provides the same {@link Asset}.
 *
 * @param {Asset} asset The asset.
*/
function SingleAssetSource(asset) {
  this._asset = asset;
}

SingleAssetSource.prototype.asset = function() {
  return this._asset;
};

SingleAssetSource.prototype.loadAsset = function(stage, tile, done) {
  var self = this;

  var timeout = setTimeout(function() {
    done(null, tile, self._asset);
  }, 0);

  function cancel() {
    clearTimeout(timeout);
    done.apply(null, arguments);
  }

  return cancel;
};

module.exports = SingleAssetSource;

},{}],77:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Stage = require('./Stage');
var HtmlImageLoader = require('../loaders/HtmlImage');
var cssSupported = require('../support/Css');
var browser = require('bowser');
var inherits = require('../util/inherits');
var setAbsolute = require('../util/dom').setAbsolute;
var setFullSize = require('../util/dom').setFullSize;
var setNullTransformOrigin = require('../util/dom').setNullTransformOrigin;
var clearOwnProperties = require('../util/clearOwnProperties');


// Browser-specific workarounds.
var browserQuirks = {

  // On most browsers we need to pad the tile edges with repeated pixels so
  // that the borders between neighboring tiles aren't apparent.
  // On iOS this isn't required, but we must disable it because the padding is
  // incorrectly rendered on top of the neighboring tile.
  padSize: browser.ios ? 0 : 3,

  // In order to prevent fallback tiles from overlapping their children, iOS
  // requires smaller zoom levels to be placed below larger zoom levels in
  // the CSS 3D coordinate space.
  reverseLevelDepth: browser.ios,

  // A null transform on the layer element is required so that transitions
  // between layers work on iOS.
  useNullTransform: browser.ios,

  // On Webkit and Gecko browsers, some tiles become invisible at certain
  // angles, usually non-floor tiles when looking straight down. Setting the
  // translateZ following the perspective transform to a slightly larger value
  // than the latter seems to work around this glitch.
  perspectiveNudge: browser.webkit || browser.gecko ? 0.001 : 0

};


/**
 * @class CssStage
 * @extends Stage
 * @classdesc
 *
 * A {@link Stage} implementation using CSS 3D Transforms.
 *
 * @param {Object} opts
 *
 * Also see the available {@link Stage} options.
 */
function CssStage(opts) {
  this.constructor.super_.call(this, opts);

  this._loader = new HtmlImageLoader(this);

  this._domElement = document.createElement('div');

  setAbsolute(this._domElement);
  setFullSize(this._domElement);

  // N.B. the CSS stage requires device adaptation to be configured through
  // the <meta name="viewport"> tag on the containing document.
  // Failure to do so will cause clipping and padding bugs to occur,
  // at least on iOS <= 7.
}

inherits(CssStage, Stage);


/**
 * Destructor.
 */
CssStage.prototype.destroy = function() {
  // Delegate clearing own properties to the Stage destructor.
  this.constructor.super_.prototype.destroy.call(this);
};


CssStage.supported = function() {
  return cssSupported();
};


/**
 * Returns the underlying DOM element.
 *
 * @return {Element}
 */
CssStage.prototype.domElement = function() {
  return this._domElement;
};


CssStage.prototype.setSizeForType = function() {};


CssStage.prototype.loadImage = function(url, rect, done) {
  return this._loader.loadImage(url, rect, done);
};


CssStage.prototype.validateLayer = function(layer) {
  return; // always valid
};


CssStage.prototype.createRenderer = function(Renderer) {
  return new Renderer(this._domElement, browserQuirks);
};

CssStage.prototype.destroyRenderer = function(renderer) {
  renderer.destroy();
};


CssStage.prototype.startFrame = function() {};


CssStage.prototype.endFrame = function() {};


CssStage.prototype.takeSnapshot = function() {
  throw new Error('CssStage: takeSnapshot not implemented');
};


CssStage.type = CssStage.prototype.type = 'css';


function CssTexture(stage, tile, asset) {

  var canvas = document.createElement('canvas');
  setAbsolute(canvas);
  setNullTransformOrigin(canvas);

  this._canvas = canvas;
  this._timestamp = null;
  this.refresh(tile, asset);

}


CssTexture.prototype.refresh = function(tile, asset) {

  // Check whether the texture needs to be updated.
  var timestamp = asset.timestamp();
  if (timestamp === this._timestamp) {
    return;
  }
  this._timestamp = timestamp;

  var canvas = this._canvas;
  var ctx = canvas.getContext('2d');

  // Get asset element.
  var element = asset.element();

  // Get tile dimensions.
  var tileWidth = tile.width();
  var tileHeight = tile.height();

  // Get padding sizes.
  var padSize = browserQuirks.padSize;
  var padTop = tile.padTop() ? padSize : 0;
  var padBottom = tile.padBottom() ? padSize : 0;
  var padLeft = tile.padLeft() ? padSize : 0;
  var padRight = tile.padRight() ? padSize : 0;

  // Set canvas size.
  canvas.width = padLeft + tileWidth + padRight;
  canvas.height = padTop + tileHeight + padBottom;

  // Draw image.
  ctx.drawImage(element, padLeft, padTop, tileWidth, tileHeight);

  var i;

  // Draw top padding.
  for (i = 0; i < padTop; i++) {
    ctx.drawImage(canvas, padLeft, padTop, tileWidth, 1,
                          padLeft, i, tileWidth, 1);
  }

  // Draw left padding.
  for (i = 0; i < padLeft; i++) {
    ctx.drawImage(canvas, padLeft, padTop, 1, tileHeight,
                          i, padTop, 1, tileHeight);
  }

  // Draw bottom padding.
  for (i = 0; i < padBottom; i++) {
    ctx.drawImage(canvas, padLeft, padTop + tileHeight - 1, tileWidth, 1,
                          padLeft, padTop + tileHeight + i, tileWidth, 1);
  }

  // Draw right padding.
  for (i = 0; i < padRight; i++) {
    ctx.drawImage(canvas, padLeft + tileWidth - 1, padTop, 1, tileHeight,
                          padLeft + tileWidth + i, padTop, 1, tileHeight);
  }

};


CssTexture.prototype.destroy = function() {
  // TODO: investigate whether keeping a pool of canvases instead of
  // creating new ones on demand improves performance.
  clearOwnProperties(this);
};


CssStage.TextureClass = CssStage.prototype.TextureClass = CssTexture;


module.exports = CssStage;

},{"../loaders/HtmlImage":58,"../support/Css":82,"../util/clearOwnProperties":91,"../util/dom":100,"../util/inherits":104,"./Stage":80,"bowser":1}],78:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Stage = require('./Stage');
var FlashImageLoader = require('../loaders/FlashImage');
var flashSupported = require('../support/Flash');
var WorkQueue = require('../collections/WorkQueue');
var inherits = require('../util/inherits');
var defer = require('../util/defer');
var setAbsolute = require('../util/dom').setAbsolute;
var setFullSize = require('../util/dom').setFullSize;
var setBlocking = require('../util/dom').setBlocking;
var clearOwnProperties = require('../util/clearOwnProperties');

// Default Flash wmode.
var defaultWMode = 'transparent';

// Default Flash SWF path. By default, expect the SWF to be named marzipano.swf
// and located in the same directory as the current script. The default path
// may be overridden by passing the `swfPath` option into the Viewer or Stage
// constructor.
var defaultSwfPath = function() {
  var script = document.currentScript;
  if (!script) {
    // This will produce the wrong result if the current script is loaded with
    // the `async` or `defer` options, or exec'ed from a string. The user is
    // expected to supply a custom `swfPath` in these cases.
    var scripts = document.getElementsByTagName('script');
    script = scripts.length ? scripts[scripts.length-1] : null;
  }
  if (!script) {
    return null;
  }
  var path = script.src;
  var slash = path.lastIndexOf('/');
  if (slash >= 0) {
    path = path.slice(0, slash + 1);
  } else {
    path = '';
  }
  return path + 'marzipano.swf';
}();

// Callbacks must be exposed in a global object to be called from Flash.
// The global object maps each stage ID into the respective callbacks.
// To prevent multiple Marzipano instances from clobbering the callbacks
// for each other's stages, the next available stage ID must be shared among
// the instances. We cache this value in a special property of the global
// callback object.
var callbackObjectName = 'MarzipanoFlashCallbackMap';
if (!(callbackObjectName in window)) {
  window[callbackObjectName] = { __next: 0 };
}

// Get the next available Flash stage ID.
function nextFlashStageId() {
  return window[callbackObjectName].__next++;
}

// Names of the callbacks called from Flash. Presently there is only one.
var callbackNames = [ 'imageLoaded' ];

// Browser-specific workarounds.
var flashQuirks = {
  // How many repeated pixels to add around tile edges to suppress visible seams.
  padSize: 3
};

/**
 * @class FlashStage
 * @extends Stage
 * @classdesc
 *
 * A {@link Stage} implementation using Flash.
 *
 * @param {Object} opts
 * @param {string} [opts.wmode='transparent']
 * @param {string} [opts.swfPath]
 *
 * The `wmode` option controls transparency, layering and compositing of the
 * Flash element into the web page. For more information see:
 * http://helpx.adobe.com/flash/kb/flash-object-embed-tag-attributes.html
 *
 * The `swfPath` option denotes the path to the `marzipano.swf` file. It
 * defaults to the location of `marzipano.js` by looking for a script tag with
 * that name.
 *
 * Also see the available {@link Stage} options.
 */
function FlashStage(opts) {
  this.constructor.super_.call(this, opts);

  this._wmode = opts && opts.wmode || defaultWMode;
  this._swfPath = opts && opts.swfPath || defaultSwfPath;

  if (!defaultSwfPath) {
    throw new Error('Missing SWF path');
  }

  // Setup JavaScript callbacks to be called from Flash land when
  // asynchronous operations terminate.
  this._flashStageId = nextFlashStageId();
  this._callbacksObj = window[callbackObjectName][this._flashStageId] = {};
  this._stageCallbacksObjVarName = callbackObjectName + '[' + this._flashStageId + ']';
  this._callbackListeners = {};
  for (var i = 0; i < callbackNames.length; i++) {
    this._callbacksObj[callbackNames[i]] = this._callListeners(callbackNames[i]);
  }

  this._loader = new FlashImageLoader(this);

  // Queue for loadImage calls.
  // The queue starts paused so that loadImage calls occurring before Flash
  // is ready do not start right away (as they would fail).
  // TODO: This is awkward. The stage must signal that it's ready to load
  // images, but queuing should otherwise be implemented by the loader.
  this._loadImageQueue = new WorkQueue();
  this._loadImageQueue.pause();

  // Whether flash is ready to be called from JavaScript.
  this._flashReady = false;

  // Add an ID to each renderer/layer, so that it can be identified within
  // the ActionScript program.
  this._nextLayerId = 0;

  // Create the DOM elements.
  var elements = createDomElements(this._swfPath, this._flashStageId, this._stageCallbacksObjVarName);
  this._domElement = elements.root;
  this._blockingElement = elements.blocking;
  this._flashElement = elements.flash;

  // Wake up the render loop when we are ready (only after element is added to the DOM)
  this._checkReadyTimer = setInterval(this._checkReady.bind(this), 50);
}

inherits(FlashStage, Stage);


/**
 * Destructor.
 */
FlashStage.prototype.destroy = function() {
  window[callbackObjectName][this._flashStageId] = null;
  if (this._checkReadyTimer != null) {
    clearInterval(this._checkReadyTimer);
  }
  // Delegate clearing own properties to the Stage destructor.
  this.constructor.super_.prototype.destroy.call(this);
};


FlashStage.supported = function() {
  return flashSupported();
};


/**
 * Returns the underlying DOM element.
 * @return {Element}
 */
FlashStage.prototype.domElement = function() {
  return this._domElement;
};


/**
 * Returns the underlying Flash element.
 * @return {Element}
 */
FlashStage.prototype.flashElement = function() {
  return this._flashElement;
};


FlashStage.prototype.setSizeForType = function() {};


FlashStage.prototype.loadImage = function(url, rect, done) {
  // TODO: Move the queuing into the loader, which avoids this nonsense.
  var loadFn = this._loader.loadImage.bind(this._loader, url, rect);
  return this._loadImageQueue.push(loadFn, done);
};


FlashStage.prototype.validateLayer = function(layer) {
  return; // always valid
};


FlashStage.prototype.addFlashCallbackListener = function(callbackName, f) {
  this._callbackListeners[callbackName] = this._callbackListeners[callbackName] || [];
  this._callbackListeners[callbackName].push(f);
};


FlashStage.prototype.removeFlashCallbackListener = function(callbackName, f) {
  var listeners = this._callbackListeners[callbackName] || [];
  var index = listeners.indexOf(f);
  if (index >= 0) {
    listeners.splice(index, 1);
  }
};


FlashStage.prototype._callListeners = function(callbackName) {

  var self = this;

  return function callListeners() {
    var listeners = self._callbackListeners[callbackName] || [];
    for (var i = 0; i < listeners.length; i++) {
      // JavaScript executed on calls from Flash does not throw exceptions.
      // Executing the callback in a new stack frame fixes this.
      var listener = listeners[i];
      defer(listener, arguments);
    }
  };
};


FlashStage.prototype._checkReady = function() {
  if (!this._flashElement ||
      !this._flashElement.isReady ||
      !this._flashElement.isReady()) {
    // Not ready yet.
    return false;
  }

  // Mark as ready.
  this._flashReady = true;

  // Disable interval timer.
  clearTimeout(this._checkReadyTimer);
  this._checkReadyTimer = null;

  // Resume image loading queue.
  this._loadImageQueue.resume();

  // Force next render.
  this.emit('renderInvalid');

  return true;
};


function createDomElements(swfPath, id, stageCallbacksObjVarName) {
  var rootElement = document.createElement('div');
  setAbsolute(rootElement);
  setFullSize(rootElement);

  // The Flash object must have `id` and `name` attributes, otherwise
  // ExternalInterface calls will not work.
  var elementId = "marzipano-flash-stage-" + id;

  var objectStr = '<object id="' + elementId + '" name="' + elementId + '" type="application/x-shockwave-flash" data="' + swfPath + '">';

  var paramsStr = '';
  paramsStr += '<param name="movie" value="' + swfPath + '" />';
  paramsStr += '<param name="allowscriptaccess" value="always" />';
  paramsStr += '<param name="flashvars" value="callbacksObjName=' + stageCallbacksObjVarName + '" />';
  paramsStr += '<param name="wmode" value="transparent" />';

  objectStr += paramsStr;
  objectStr += '</object>';

  // Embed Flash into the DOM.
  // Adding children into an <object> element doesn't work, so we create a
  // temporary element and set its innerHTML.
  var tmpElement = document.createElement('div');
  tmpElement.innerHTML = objectStr;
  var flashElement = tmpElement.firstChild;
  setAbsolute(flashElement);
  setFullSize(flashElement);
  rootElement.appendChild(flashElement);

  // Create blocking element to prevent events from being caught by Flash.
  var blockingElement = document.createElement('div');
  setAbsolute(blockingElement);
  setFullSize(blockingElement);
  setBlocking(blockingElement);
  rootElement.appendChild(blockingElement);

  return { root: rootElement, flash: flashElement, blocking: blockingElement };
}


FlashStage.prototype.createRenderer = function(Renderer) {
  return new Renderer(this._flashElement, ++this._nextLayerId, flashQuirks);
};


FlashStage.prototype.destroyRenderer = function(renderer) {
  renderer.destroy();
};


FlashStage.prototype.startFrame = function() {};


FlashStage.prototype.endFrame = function() {};


FlashStage.prototype.takeSnapshot = function (options) {
  // Validate argument.
  if (typeof options !== 'object' || options == null) {
    options = {};
  }

  var quality = options.quality;

  // Set default quality if it is not passed in.
  if (typeof quality == 'undefined') {
    quality = 75;
  }

  // Throw if quality is of invlid type or out of bounds.
  if (typeof quality !== 'number' || quality < 0 || quality > 100) {
    throw new Error('FlashStage: Snapshot quality needs to be a number between 0 and 100');
  }

  // Return the snapshot by executing a flash-exported method.
  return this._flashElement.takeSnapshot(quality);
};


FlashStage.type = FlashStage.prototype.type = 'flash';


function FlashTexture(stage, tile, asset) {

  // Get image id.
  var imageId = asset.element();

  // Get tile dimensions.
  var tileWidth = tile.width();
  var tileHeight = tile.height();

  // Get padding sizes.
  var padSize = flashQuirks.padSize;
  var padTop = tile.padTop() ? padSize : 0;
  var padBottom = tile.padBottom() ? padSize : 0;
  var padLeft = tile.padLeft() ? padSize : 0;
  var padRight = tile.padRight() ? padSize : 0;

  var textureId = stage._flashElement.createTexture(imageId, tileWidth, tileHeight, padTop, padBottom, padLeft, padRight);

  this._stage = stage;
  this._textureId = textureId;
}


FlashTexture.prototype.refresh = function(tile, asset) {
  // TODO: This is required for the Flash stage to support dynamic textures.
  // However, there are currently no dynamic textures that work with the
  // Flash stage.
};


FlashTexture.prototype.destroy = function() {
  this._stage._flashElement.destroyTexture(this._textureId);
  clearOwnProperties(this);
};


FlashStage.TextureClass = FlashStage.prototype.TextureClass = FlashTexture;


module.exports = FlashStage;

},{"../collections/WorkQueue":34,"../loaders/FlashImage":57,"../support/Flash":83,"../util/clearOwnProperties":91,"../util/defer":97,"../util/dom":100,"../util/inherits":104,"./Stage":80}],79:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class RendererRegistry
 * @classdesc
 *
 * A RendererRegistry maps pairs of {@link Geometry} and {@link View} type into
 * the appropriate {@link Renderer} class. It is used by a {@link Stage} to
 * determine the appropriate renderer for a {@link Layer}.
 *
 * See also {@link Stage#registerRenderer}.
 */
function RendererRegistry() {
  this._renderers = {};
}

/**
 * Registers a renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
RendererRegistry.prototype.set = function(geometryType, viewType, Renderer) {
  if (!this._renderers[geometryType]) {
    this._renderers[geometryType] = {};
  }
  this._renderers[geometryType][viewType] = Renderer;
};

/**
 * Retrieves the renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class, or null if no such renderer has been
 * registered.
 */
RendererRegistry.prototype.get = function(geometryType, viewType) {
  var Renderer = this._renderers[geometryType] &&
      this._renderers[geometryType][viewType];
  return Renderer || null;
};

module.exports = RendererRegistry;

},{}],80:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var WorkQueue = require('../collections/WorkQueue');
var calcRect = require('../util/calcRect');
var async = require('../util/async');
var cancelize = require('../util/cancelize');
var clearOwnProperties = require('../util/clearOwnProperties');

var RendererRegistry = require('./RendererRegistry');

function forwardTileCmp(t1, t2) {
  return t1.cmp(t2);
}

function reverseTileCmp(t1, t2) {
  return -t1.cmp(t2);
}

/**
 * Signals that the stage has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Stage#renderComplete
 */

/**
 * Signals that the contents of the stage have been invalidated and must be
 * rendered again.
 *
 * This is used by the {@link RenderLoop} implementation.
 *
 * @event Stage#renderInvalid
 */

/**
 * @interface Stage
 * @classdesc
 *
 * A Stage is a container with the ability to render a stack of
 * {@link Layer layers}.
 *
 * This is a superclass containing logic that is common to all implementations;
 * it should never be instantiated directly. Instead, use one of the
 * subclasses: {@link WebGlStage}, {@link CssStage} or {@link FlashStage}.
 *
 * @param {Object} opts
 * @param {boolean} [opts.progressive=false]
 *
 * Options listed here may be passed into the `opts` constructor argument of
 * subclasses.
 *
 * The `progressive` option controls whether resolution levels are loaded in
 * order, from lowest to highest. This results in a more pleasing effect when
 * zooming past several levels in a large panoramas, but consumes additional
 * bandwidth.
 */
function Stage(opts) {
  this._progressive = !!(opts && opts.progressive);

  // The list of layers in display order (background to foreground).
  this._layers = [];

  // The list of renderers; the i-th renderer is for the i-th layer.
  this._renderers = [];

  // The lists of tiles to load and render, populated during render().
  this._tilesToLoad = [];
  this._tilesToRender = [];

  // Temporary tile lists.
  this._tmpVisible = [];
  this._tmpChildren = [];

  // Cached stage dimensions.
  // Start with zero, which inhibits rendering until setSize() is called.
  this._width = 0;
  this._height = 0;

  // Temporary variable for rect.
  this._tmpRect = {};

  // Temporary variable for size.
  this._tmpSize = {};

  // Work queue for createTexture.
  this._createTextureWorkQueue = new WorkQueue();

  // Function to emit event when render parameters have changed.
  this._emitRenderInvalid = this._emitRenderInvalid.bind(this);

  // The renderer registry maps each geometry/view pair into the respective
  // Renderer class.
  this._rendererRegistry = new RendererRegistry();
}

eventEmitter(Stage);


/**
 * Destructor.
 */
Stage.prototype.destroy = function() {
  this.removeAllLayers();
  clearOwnProperties(this);
};


/**
 * Registers a {@link Renderer} for the given {@link Geometry} and {@link View}
 * type.
 *
 * The {@link registerDefaultRenderers} utility function may be used to
 * register all known renderers for a stage type into that stage. Most users
 * will not need to register renderers, as {@link Viewer} does it for them.
 *
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
Stage.prototype.registerRenderer = function(geometryType, viewType, Renderer) {
  return this._rendererRegistry.set(geometryType, viewType, Renderer);
};


/**
 * Returns the underlying DOM element.
 *
 * Must be overridden by subclasses.
 *
 * @return {Element}
 */
Stage.prototype.domElement = function() {
  throw new Error('Stage implementation must override domElement');
};


/**
 * Get the stage width.
 * @return {number}
 */
Stage.prototype.width = function() {
  return this._width;
};


/**
 * Get the stage height.
 * @return {number}
 */
Stage.prototype.height = function() {
  return this._height;
};


/**
 * Get the stage dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 *
 * @param {Size=} size
 */
Stage.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Set the stage dimensions.
 *
 * This contains the size update logic common to all stage types. Subclasses
 * must define the {@link Stage#setSizeForType} method to perform their own
 * logic.
 *
 * @param {Size} size
 */
Stage.prototype.setSize = function(size) {
  this._width = size.width;
  this._height = size.height;

  this.setSizeForType(); // must be defined by subclasses.

  this.emit('resize');
  this._emitRenderInvalid();
};


/**
 * Call {@link Stage#setSize} instead.
 *
 * This contains the size update logic specific to a stage type. It is called by
 * {@link Stage#setSize} after the base class has been updated to reflect the
 * new size, but before any events are emitted.
 *
 * @param {Size} size
 */
Stage.prototype.setSizeForType = function(size) {
  throw new Error('Stage implementation must override setSizeForType');
};


/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
Stage.prototype.loadImage = function() {
  throw new Error('Stage implementation must override loadImage');
};


Stage.prototype._emitRenderInvalid = function() {
  this.emit('renderInvalid');
};


/**
 * Verifies that the layer is valid for this stage, throwing an exception
 * otherwise.
 *
 * @param {Layer} layer
 * @throws {Error} If the layer is not valid for this stage.
 */
Stage.prototype.validateLayer = function(layer) {
  throw new Error('Stage implementation must override validateLayer');
};


/**
 * Returns a list of all {@link Layer layers} belonging to the stage. The
 * returned list is in display order, background to foreground.
 * @return {Layer[]}
 */
Stage.prototype.listLayers = function() {
  // Return a copy to prevent unintended mutation by the caller.
  return [].concat(this._layers);
};


/**
 * Return whether a {@link Layer layer} belongs to the stage.
 * @param {Layer} layer
 * @return {boolean}
 */
Stage.prototype.hasLayer = function(layer) {
  return this._layers.indexOf(layer) >= 0;
};


/**
 * Adds a {@link Layer layer} into the stage.
 * @param {Layer} layer The layer to add.
 * @param {number|undefined} i The optional position, where 0  i  n and n is
 *     the current number of layers. The default is n, which inserts at the
 *     top of the display stack.
 * @throws An error if the layer already belongs to the stage or if the position
 *     is invalid.
 */
Stage.prototype.addLayer = function(layer, i) {
  if (this._layers.indexOf(layer) >= 0) {
    throw new Error('Layer already in stage');
  }

  if (i == null) {
    i = this._layers.length;
  }
  if (i < 0 || i > this._layers.length) {
    throw new Error('Invalid layer position');
  }

  this.validateLayer(layer); // must be defined by subclasses.

  var geometryType = layer.geometry().type;
  var viewType = layer.view().type;
  var rendererClass = this._rendererRegistry.get(geometryType, viewType);
  if (!rendererClass) {
    throw new Error('No ' + this.type + ' renderer avaiable for ' +
        geometryType + ' geometry and ' + viewType + ' view');
  }
  var renderer = this.createRenderer(rendererClass);

  this._layers.splice(i, 0, layer);
  this._renderers.splice(i, 0, renderer);

  // Listeners for render invalid.
  layer.addEventListener('viewChange', this._emitRenderInvalid);
  layer.addEventListener('effectsChange', this._emitRenderInvalid);
  layer.addEventListener('fixedLevelChange', this._emitRenderInvalid);
  layer.addEventListener('textureStoreChange', this._emitRenderInvalid);

  this._emitRenderInvalid();
};


/**
 * Moves a {@link Layer layer} into a different position in the display stack.
 * @param {Layer} layer The layer to move.
 * @param {number} i The position, where 0  i  n-1 and n is the current number
 *     of layers.
 * @throws An error if the layer does not belong to the stage or if the position
 *     is invalid.
 */
Stage.prototype.moveLayer = function(layer, i) {
  var index = this._layers.indexOf(layer);
  if (index < 0) {
    throw new Error('No such layer in stage');
  }

  if (i < 0 || i >= this._layers.length) {
    throw new Error('Invalid layer position');
  }

  layer = this._layers.splice(index, 1)[0];
  var renderer = this._renderers.splice(index, 1)[0];

  this._layers.splice(i, 0, layer);
  this._renderers.splice(i, 0, renderer);

  this._emitRenderInvalid();
};


/**
 * Removes a {@link Layer} from the stage.
 * @param {Layer} layer The layer to remove.
 * @throws An error if the layer does not belong to the stage.
 */
Stage.prototype.removeLayer = function(layer) {
  var index = this._layers.indexOf(layer);
  if (index < 0) {
    throw new Error('No such layer in stage');
  }

  var removedLayer = this._layers.splice(index, 1)[0];
  var renderer = this._renderers.splice(index, 1)[0];

  this.destroyRenderer(renderer);

  removedLayer.removeEventListener('viewChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('effectsChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('fixedLevelChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('textureStoreChange', this._emitRenderInvalid);

  this._emitRenderInvalid();
};


/**
 * Removes all {@link Layer layers} from the stage.
 */
Stage.prototype.removeAllLayers = function() {
  while (this._layers.length > 0) {
    this.removeLayer(this._layers[0]);
  }
};


/**
 * Called before a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.startFrame = function() {
  throw new Error('Stage implementation must override startFrame');
};


/**
 * Called after a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.endFrame = function() {
  throw new Error('Stage implementation must override endFrame');
};


/**
 * Render the current frame. Usually called from a {@link RenderLoop}.
 *
 * This contains the rendering logic common to all stage types. Subclasses
 * define the startFrame() and endFrame() methods to perform their own logic.
 */
Stage.prototype.render = function() {
  var i, j;

  var tilesToLoad = this._tilesToLoad;
  var tilesToRender = this._tilesToRender;

  var stableStage = true;
  var stableLayer;

  // Get the stage dimensions.
  var width = this._width;
  var height = this._height;

  var rect = this._tmpRect;
  var size = this._tmpSize;

  if (width <= 0 || height <= 0) {
    return;
  }

  this.startFrame(); // defined by subclasses

  // Signal start of frame to the texture stores.
  for (i = 0; i < this._layers.length; i++) {
    this._layers[i].textureStore().startFrame();
  }

  // Render layers.
  for (i = 0; i < this._layers.length; i++) {
    var layer = this._layers[i];
    var effects = layer.effects();
    var view = layer.view();
    var textureStore = layer.textureStore();
    var renderer = this._renderers[i];
    var depth = this._layers.length - i;
    var tile, texture;

    // Convert the rect effect into a normalized rect.
    // TODO: avoid doing this on every frame.
    calcRect(width, height, effects && effects.rect, rect);

    if (rect.width <= 0 || rect.height <= 0) {
      // Skip rendering on a null viewport.
      continue;
    }

    // Update the view size.
    size.width = rect.width * this._width;
    size.height = rect.height * this._height;
    view.setSize(size);

    // Signal start of layer to the renderer.
    renderer.startLayer(layer, rect);

    // We render with both alpha blending and depth testing enabled. Thus, when
    // rendering a subsequent pixel at the same location than an existing one,
    // the subsequent pixel gets discarded unless it has smaller depth, and is
    // otherwise composited with the existing pixel.
    //
    // When using fallback tiles to fill a gap in the preferred resolution
    // level, we prefer higher resolution fallbacks to lower resolution ones.
    // However, where fallbacks overlap, we want higher resolution ones to
    // prevail, and we don't want multiple fallbacks to be composited with each
    // other, as that would produce a bad result when semitransparent textures
    // are involved.
    //
    // In order to achieve this within the constraints of alpha blending and
    // depth testing, the depth of a tile must be inversely proportional to its
    // resolution, and higher-resolution tiles must be rendered before lower-
    // resolution ones.

    // Collect the lists of tiles to load and render.
    stableLayer = this._collectTiles(layer, textureStore);

    // Mark all the tiles whose textures must be loaded.
    // This will either trigger loading (for textures not yet loaded) or
    // prevent unloading (for textures already loaded).
    for (j = 0; j < tilesToLoad.length; j++) {
      tile = tilesToLoad[j];
      textureStore.markTile(tile);
    }

    // Render tiles.
    for (j = 0; j < tilesToRender.length; j++) {
      tile = tilesToRender[j];
      texture = textureStore.texture(tile);
      renderer.renderTile(tile, texture, layer, depth);
    }

    layer.emit('renderComplete', stableLayer);
    if (!stableLayer) {
      stableStage = false;
    }

    // Signal end of layer to the renderer.
    renderer.endLayer(layer, rect);
  }

  // Signal end of frame to the texture stores.
  for (i = 0; i < this._layers.length; i++) {
    this._layers[i].textureStore().endFrame();
  }

  this.endFrame(); // defined by subclasses

  this.emit('renderComplete', stableStage);
};

Stage.prototype._collectTiles = function(layer, textureStore) {
  var tilesToLoad = this._tilesToLoad;
  var tilesToRender = this._tilesToRender;
  var tmpVisible = this._tmpVisible;

  tilesToLoad.length = 0;
  tilesToRender.length = 0;
  tmpVisible.length = 0;

  layer.visibleTiles(tmpVisible);

  var isStable = true;

  for (var i = 0; i < tmpVisible.length; i++) {
    var tile = tmpVisible[i];
    var needsFallback;
    this._collectTileToLoad(tile);
    if (textureStore.texture(tile)) {
      // The preferred texture is available.
      // No fallback is required.
      needsFallback = false;
      this._collectTileToRender(tile);
    } else {
      // The preferred texture is unavailable.
      // Collect children for rendering as a fallback.
      needsFallback = this._collectChildren(tile, textureStore);
      isStable = false;
    }
    // Collect all parents for loading, and the closest parent for rendering if
    // a fallback is required.
    this._collectParents(tile, textureStore, needsFallback);
  }

  // Sort tiles to load in ascending resolution order.
  tilesToLoad.sort(forwardTileCmp);

  // Sort tiles to render in descending resolution order.
  tilesToRender.sort(reverseTileCmp);

  return isStable;
};

Stage.prototype._collectChildren = function(tile, textureStore) {
  var tmpChildren = this._tmpChildren;

  var needsFallback = true;

  // Fall back as many levels as necessary on single-child geometries, but do
  // not go beyond immediate children on multiple-child geometries, to avoid
  // exploring an exponential number of tiles.
  do {
    tmpChildren.length = 0;
    if (!tile.children(tmpChildren)) {
      break;
    }
    needsFallback = false;
    for (var i = 0; i < tmpChildren.length; i++) {
      tile = tmpChildren[i];
      if (textureStore.texture(tile)) {
        this._collectTileToLoad(tile);
        this._collectTileToRender(tile);
      } else {
        needsFallback = true;
      }
    }
  } while (needsFallback && tmpChildren.length === 1)

  return needsFallback;
};

Stage.prototype._collectParents = function(tile, textureStore, needsFallback) {
  // Recursively visit parent tiles until:
  //   - all parents have been marked for loading, if progressive rendering is
  //     enabled; and
  //   - at least one parent has been marked for both loading and rendering, if
  //     a fallback is required.
  var needsLoading = this._progressive;
  while ((needsLoading || needsFallback) && (tile = tile.parent()) != null) {
    if (needsFallback) {
      if (textureStore.texture(tile)) {
        this._collectTileToRender(tile);
        needsFallback = false;
      } else if (!this._progressive) {
        continue;
      }
    }
    if (!this._collectTileToLoad(tile)) {
      needsLoading = false;
    }
  }
  return needsFallback;
};

Stage.prototype._collectTileToLoad = function(tile) {
  return this._collectTileIntoList(tile, this._tilesToLoad);
};

Stage.prototype._collectTileToRender = function(tile) {
  return this._collectTileIntoList(tile, this._tilesToRender);
};

Stage.prototype._collectTileIntoList = function(tile, tileList) {
  // TODO: Investigate whether it's worth it to make this better than O(n).
  var found = false;
  for (var i = 0; i < tileList.length; i++) {
    if (tile.equals(tileList[i])) {
      found = true;
      break;
    }
  }
  if (!found) {
    tileList.push(tile);
  }
  return !found;
};

/**
 * Create a texture for the given tile and asset. Called by {@link TextureStore}.
 * @param {Tile} tile
 * @param {Asset} asset
 * @param {Function} done
 */
Stage.prototype.createTexture = function(tile, asset, done) {

  var self = this;

  function makeTexture() {
    return new self.TextureClass(self, tile, asset);
  }

  var fn = cancelize(async(makeTexture));

  return this._createTextureWorkQueue.push(fn, function(err, texture) {
    done(err, tile, asset, texture);
  });

};

/**
 * The stage type, used to determine the appropriate renderer for a given
 * geometry and view.
 *
 * Known values are `"webgl"`, `"css"` and `"flash"`.
 *
 * See also {@link Stage#registerRenderer}.
 *
 * @property {string}
 * @name Stage#type
 */

module.exports = Stage;

},{"../collections/WorkQueue":34,"../util/async":86,"../util/calcRect":87,"../util/cancelize":88,"../util/clearOwnProperties":91,"./RendererRegistry":79,"minimal-event-emitter":14}],81:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Stage = require('./Stage');
var HtmlImageLoader = require('../loaders/HtmlImage');
var webGlSupported = require('../support/WebGl');
var browser = require('bowser');
var inherits = require('../util/inherits');
var pixelRatio = require('../util/pixelRatio');
var ispot = require('../util/ispot');
var setAbsolute = require('../util/dom').setAbsolute;
var setFullSize = require('../util/dom').setFullSize;
var clearOwnProperties = require('../util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.webGl;


// Browser-specific workarounds.
var browserQuirks = {
  // Whether to use texImage2D instead of texSubImage2D when repainting an
  // existing texture from a video element. On most browsers texSubImage2D is
  // faster, but on Chrome the performance degrades significantly. See:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=612542
  videoUseTexImage2D: browser.chrome
};


function initWebGlContext(canvas, opts) {
  var options = {
    alpha: true,
    premultipliedAlpha: true,
    antialias: !!(opts && opts.antialias),
    preserveDrawingBuffer: !!(opts && opts.preserveDrawingBuffer)
  };

  if (debug && typeof WebGLDebugUtils !== 'undefined') {
    console.log('Using WebGL lost context simulator');
    canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas);
  }

  // Keep support/WebGl.js in sync with this.
  var gl = (canvas.getContext) && (canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options));

  if (!gl) {
    throw new Error('Could not get WebGL context');
  }

  if (debug && typeof WebGLDebugUtils !== "undefined") {
    gl = WebGLDebugUtils.makeDebugContext(gl);
    console.log('Using WebGL debug context');
  }

  return gl;
}

/**
 * @class WebGlStage
 * @extends Stage
 * @classdesc
 *
 * A {@link Stage} implementation using WebGl.
 *
 * @param {Object} opts
 * @param {boolean} [opts.antialias=false]
 * @param {boolean} [opts.preserveDrawingBuffer=false]
 * @param {boolean} [opts.generateMipmaps=false]
 *
 * The `antialias` and `preserveDrawingBuffer` options control the WebGL
 * context attributes of the same name. The `alpha` and `premultipliedAlpha`
 * WebGL context attributes are set to their default true value and cannot
 * be overriden; this allows semitransparent textures to be composited with
 * the page. See:
 * https://www.khronos.org/registry/webgl/specs/1.0/#WEBGLCONTEXTATTRIBUTES
 *
 * The `generateMipmaps` option controls texture mipmap generation. Mipmaps
 * may improve rendering quality, at the cost of increased memory usage.
 * Due to technical limitations, they are only generated for textures whose
 * dimensions are a power of two. See:
 * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
 *
 * Also see the available {@link Stage} options.
 */
function WebGlStage(opts) {
  opts = opts || {};

  var self = this;

  this.constructor.super_.call(this, opts);

  this._generateMipmaps = opts.generateMipmaps != null ?
    opts.generateMipmaps : false;

  this._loader = new HtmlImageLoader(this);

  this._domElement = document.createElement('canvas');

  setAbsolute(this._domElement);
  setFullSize(this._domElement);

  this._gl = initWebGlContext(this._domElement, opts);

  this._handleContextLoss = function() {
    self.emit('webglcontextlost');
    self._gl = null;
  };

  // Handle WebGl context loss.
  this._domElement.addEventListener('webglcontextlost', this._handleContextLoss);

  // WebGl renderers are singletons for a given stage. This list stores the
  // existing renderers so they can be reused across layers with the same
  // geometry and view type.
  this._rendererInstances = [];
}

inherits(WebGlStage, Stage);


/**
 * Destructor.
 */
WebGlStage.prototype.destroy = function() {
  this._domElement.removeEventListener('webglcontextlost', this._handleContextLoss);
  // Delegate clearing own properties to the Stage destructor.
  this.constructor.super_.prototype.destroy.call(this);
};


WebGlStage.supported = function() {
  return webGlSupported();
};


/**
 * Returns the underlying DOM element.
 *
 * @return {Element}
 */
WebGlStage.prototype.domElement = function() {
  return this._domElement;
};


/**
 * Returns the underlying WebGL rendering context.
 *
 * @return {WebGLRenderingContext }
 */
WebGlStage.prototype.webGlContext = function() {
  return this._gl;
};


WebGlStage.prototype.setSizeForType = function() {
  // Update the size of the canvas coordinate space.
  //
  // The size is obtained by taking the stage dimensions, which are set in CSS
  // pixels, and multiplying them by the device pixel ratio. Crucially, this
  // must be the only place where the WebGL rendering pipeline accesses the
  // pixel ratio; subsequent uses should reference the `drawingBufferWidth` and
  // `drawingBufferHeight` properties on the WebGLRenderingContext. Failing to
  // do so will break the rendering if the pixel ratio changes but the stage
  // size does not, e.g. when moving the window across screens.
  var ratio = pixelRatio();
  this._domElement.width = ratio * this._width;
  this._domElement.height = ratio * this._height;
};


WebGlStage.prototype.loadImage = function(url, rect, done) {
  return this._loader.loadImage(url, rect, done);
};


WebGlStage.prototype.maxTextureSize = function() {
  return this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);
};


WebGlStage.prototype.validateLayer = function(layer) {
  var tileSize = layer.geometry().maxTileSize();
  var maxTextureSize = this.maxTextureSize();
  if (tileSize > maxTextureSize) {
    throw new Error('Layer has level with tile size larger than maximum texture size (' + tileSize + ' vs. ' + maxTextureSize + ')');
  }
};


WebGlStage.prototype.createRenderer = function(Renderer) {
  var rendererInstances = this._rendererInstances;
  for (var i = 0; i < rendererInstances.length; i++) {
    if (rendererInstances[i] instanceof Renderer) {
      return rendererInstances[i];
    }
  }
  var renderer = new Renderer(this._gl);
  rendererInstances.push(renderer);
  return renderer;
};


WebGlStage.prototype.destroyRenderer = function(renderer) {
  var rendererInstances = this._rendererInstances;
  if (this._renderers.indexOf(renderer) < 0) {
    renderer.destroy();
    var index = rendererInstances.indexOf(renderer);
    if (index >= 0) {
      rendererInstances.splice(index, 1);
    }
  }
};


WebGlStage.prototype.startFrame = function() {

  var gl = this._gl;

  if (!gl) {
    throw new Error('Bad WebGL context - maybe context was lost?');
  }

  // Set the WebGL viewport.
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

  // Clear framebuffer.
  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Enable depth testing.
  gl.enable(gl.DEPTH_TEST);

  // Enable blending. ONE and ONE_MINUS_SRC_ALPHA are the right choices for
  // premultiplied textures.
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

};


WebGlStage.prototype.endFrame = function() {};


WebGlStage.prototype.takeSnapshot = function (options) {

  // Validate passed argument
  if (typeof options !== 'object' || options == null) {
    options = {};
  }

  var quality = options.quality;

  // Set default quality if it is not passed
  if (typeof quality == 'undefined') {
    quality = 75;
  }

  // Throw if quality is of invlid type or out of bounds
  if (typeof quality !== 'number' || quality < 0 || quality > 100) {
    throw new Error('WebGLStage: Snapshot quality needs to be a number between 0 and 100');
  }

  // Canvas method "toDataURL" needs to be called in the same
  // context as where the actual rendering is done. Hence this.
  this.render();

  // Return the snapshot
  return this._domElement.toDataURL('image/jpeg',quality/100);
}


WebGlStage.type = WebGlStage.prototype.type = 'webgl';


function WebGlTexture(stage, tile, asset) {
  this._stage = stage;
  this._gl = stage._gl;
  this._texture = null;
  this._timestamp = null;
  this._width = this._height = null;
  this.refresh(tile, asset);
}


WebGlTexture.prototype.refresh = function(tile, asset) {

  var gl = this._gl;
  var stage = this._stage;
  var texture;

  // Check whether the texture needs to be updated.
  var timestamp = asset.timestamp();
  if (timestamp === this._timestamp) {
    return;
  }

  // Get asset element.
  var element = asset.element();

  // Get asset dimensions.
  var width = asset.width();
  var height = asset.height();

  if (width !== this._width || height !== this._height) {

    // If the texture dimensions have changed since the last refresh, create
    // a new texture with the correct size.

    // Check if texture dimensions would exceed the maximum texture size.
    var maxSize = stage.maxTextureSize();
    if (width > maxSize) {
      throw new Error('Texture width larger than max size (' + width + ' vs. ' + maxSize + ')');
    }
    if (height > maxSize) {
      throw new Error('Texture height larger than max size (' + height + ' vs. ' + maxSize + ')');
    }

    // Delete the current texture if it exists.
    // This is necessary for Chrome on Android. If it isn't done the textures
    // do not render when the size changes.
    if (this._texture) {
      gl.deleteTexture(texture);
    }

    // The texture must be premultiplied by alpha to ensure correct blending of
    // semitransparent textures. For details, see:
    // http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
    texture = this._texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);

  } else {

    // If the texture dimensions remain the same, repaint the existing texture.
    // Repainting with texSubImage2D is usually faster than with texImage2D,
    // except in the case noted in browserQuirks.

    texture = this._texture;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    if (element instanceof HTMLVideoElement && browserQuirks.videoUseTexImage2D) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, element);
    }

  }

  // Generate mipmap if the corresponding stage option is set and the texture
  // dimensions are powers of two.
  if (stage._generateMipmaps && ispot(width) && ispot(height)) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.generateMipmap(gl.TEXTURE_2D);
  } else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  }

  // Clamp texture to edges.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // Unbind texture.
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Update texture dimensions and timestamp.
  this._timestamp = timestamp;
  this._width = width;
  this._height = height;

};


WebGlTexture.prototype.destroy = function() {
  if (this._texture) {
    this._gl.deleteTexture(this._texture);
  }
  clearOwnProperties(this);
};


WebGlStage.TextureClass = WebGlStage.prototype.TextureClass = WebGlTexture;


module.exports = WebGlStage;

},{"../loaders/HtmlImage":58,"../support/WebGl":84,"../util/clearOwnProperties":91,"../util/dom":100,"../util/inherits":104,"../util/ispot":105,"../util/pixelRatio":110,"./Stage":80,"bowser":1}],82:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var prefixProperty = require('../util/dom').prefixProperty;

// Detect CSS 3D transforms support. Adapted from Modernizr.
function checkCssSupported() {
  // First, check if the 'perspective' CSS property or a vendor-prefixed
  // variant is available.
  var perspectiveProperty = prefixProperty('perspective');
  var el = document.createElement('div');
  var supported = typeof el.style[perspectiveProperty] !== 'undefined';

  // Certain versions of Chrome disable 3D transforms even though the CSS
  // property exists. In those cases, we use the following media query,
  // which only succeeds if the feature is indeed enabled.
  if (supported && perspectiveProperty === 'WebkitPerspective') {
    var id = '__marzipano_test_css3d_support__';
    var st = document.createElement('style');
    st.textContent = '@media(-webkit-transform-3d){#' + id + '{height: 3px;})';
    document.getElementsByTagName('head')[0].appendChild(st);
    el.id = id;
    document.body.appendChild(el);
    // The offsetHeight seems to be different than 3 at some zoom levels on
    // Chrome (and maybe other browsers). Test for > 0 instead.
    supported = el.offsetHeight > 0;
    st.parentNode.removeChild(st);
    el.parentNode.removeChild(el);
  }

  return supported;
}

// Cache result.
var supported;
function cssSupported() {
  if (supported !== undefined) {
    return supported;
  }
  return (supported = checkCssSupported());
}

module.exports = cssSupported;

},{"../util/dom":100}],83:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Detect supported Flash version. Returns [major, minor, rev] or null.
// Adapted from https://code.google.com/p/swfobject
function detectFlashVersion() {
  var playerVersion = null;

  var plugins = navigator.plugins;
  var mimeTypes = navigator.mimeTypes;

  var d = null;

  if (plugins && plugins['Shockwave Flash'] && mimeTypes &&
      mimeTypes['application/x-shockwave-flash'] &&
      mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
    d = plugins['Shockwave Flash'].description;
    d = d.replace(/^.*\s+(\S+\s+\S+$)/, '$1');
    playerVersion = [0, 0, 0];
    playerVersion[0] = parseInt(d.replace(/^(.*)\..*$/, '$1'), 10);
    playerVersion[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, '$1'), 10);
    playerVersion[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, '$1'), 10) : 0;
  }
  else if (window.ActiveXObject) {
    try {
      var a = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
      if (a && (d = a.GetVariable('$version'))) {
        d = d.split(' ')[1].split(',');
        playerVersion = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
      }
    }
    catch (e) {}
  }

  return playerVersion;
}

// Flash support detection.
function checkFlashSupported() {
  var version = detectFlashVersion();
  // Only support 10.1 and above. Flash 10.0 does not work for some reason.
  return version && (version[0] >= 11 || (version[0] === 10 && version[1] >= 1));
}

// Cache result.
var supported;
function flashSupported() {
  if (supported !== undefined) {
    return supported;
  }
  return (supported = checkFlashSupported());
}

module.exports = flashSupported;

},{}],84:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Detect WebGl support.
// Keep stages/WebGl.js in sync with this.
function checkWebGlSupported() {
  var canvas = document.createElement('canvas');
  var gl = canvas.getContext && (canvas.getContext('webgl') ||
                                 canvas.getContext('experimental-webgl'));
  return !!gl;
}

// Cache result.
var supported;
function webGlSupported() {
  if (supported !== undefined) {
    return supported;
  }
  return (supported = checkWebGlSupported());
}

module.exports = webGlSupported;

},{}],85:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var browser = require('bowser');

// Detect CSS pointer-events support.
function checkCssPointerEventsSupported() {

  // Check for existence of CSS property.
  var style = document.createElement('a').style;
  style.cssText = 'pointer-events:auto';
  var hasCssProperty = style.pointerEvents === 'auto';

  // The above result is spurious on emulation mode for IE 8-10.
  var isOldIE = browser.msie && parseFloat(browser.version) < 11;

  return hasCssProperty && !isOldIE;
}

// Cache result.
var supported;
function cssPointerEventsSupported() {
  if (supported !== undefined) {
    return supported;
  }
  return (supported = checkCssPointerEventsSupported());
}

module.exports = cssPointerEventsSupported;

},{"bowser":1}],86:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Transform a synchronous function into an asynchronous one.
function async(fn) {
  return function asynced(done) {
    var err, ret;
    try {
      ret = fn();
    } catch (e) {
      err = e;
    } finally {
      if (err) {
        done(err);
      } else {
        done(null, ret);
      }
    }
  };
}

module.exports = async;

},{}],87:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Converts a {@link RectSpec} into an equivalent {@link Rect}.
 *
 * A {@link RectSpec} is a convenient user API format, providing default values
 * and the flexibility of specifying absolute, relative or mixed dimensions.
 *
 * A {@link Rect} is a more convenient format for the rendering pipeline. It is
 * always expressed in normalized coordinates, and all its properties are
 * guaranteed to be present.
 *
 * @param {number} totalWidth The total width of the rendering area in pixels.
 * @param {number} totalHeight The total height of the rendering area in pixels.
 * @param {RectSpec} spec The input spec, defaulting to the full rendering area
 *     if null or undefined.
 * @param {Rect} result The output spec. If the argument is present, it is
 *     filled in and returned; otherwise, a fresh object is returned.
 */
function calcRect(totalWidth, totalHeight, spec, result) {

  result = result || {};

  var width;
  if (spec != null && spec.absoluteWidth != null) {
    width = spec.absoluteWidth / totalWidth;
  } else if (spec != null && spec.relativeWidth != null) {
    width = spec.relativeWidth;
  } else {
    width = 1;
  }

  var height;
  if (spec && spec.absoluteHeight != null) {
    height = spec.absoluteHeight / totalHeight;
  } else if (spec != null && spec.relativeHeight != null) {
    height = spec.relativeHeight;
  } else {
    height = 1;
  }

  var x;
  if (spec != null && spec.absoluteX != null) {
    x = spec.absoluteX / totalWidth;
  } else if (spec != null && spec.relativeX != null) {
    x = spec.relativeX;
  } else {
    x = 0;
  }

  var y;
  if (spec != null && spec.absoluteY != null) {
    y = spec.absoluteY / totalHeight;
  } else if (spec != null && spec.relativeY != null) {
    y = spec.relativeY;
  } else {
    y = 0;
  }

  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;

  return result;
}

module.exports = calcRect;

},{}],88:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var once = require('./once');

// A cancelable function is an asynchronous function (i.e., one whose last
// argument is a callback receiving an error plus zero or more return values)
// that (synchronously) returns a cancel() function. Calling cancel() should
// abort the asynchronous operation and call the callback with the arguments
// that were passed into cancel(). Calling cancel() twice, as with callbacks,
// is not guaranteed to be safe.

// Wrap a non-cancellable asynchronous function into a cancelable one.
//
// Calling cancel() on the returned function will not interrupt the execution
// of the original function; it will merely ignore its return value.
//
// Usually, instead of wrapping your function, you want to implement cancel()
// yourself in order to have some abort logic. This utility function provides a
// straighforward solution for cases in which no custom abort logic is required.
function cancelize(fn) {
  return function cancelized() {
    if (!arguments.length) {
      throw new Error('cancelized: expected at least one argument');
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var done = args[args.length - 1] = once(args[args.length - 1]);

    function cancel() {
      done.apply(null, arguments);
    }

    fn.apply(null, args);

    return cancel;
  };
}

module.exports = cancelize;

},{"./once":109}],89:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a function that executes its arguments (which should be cancelables)
// in sequence, so that each of them passes its return values to the next.
// Execution is aborted if one of the functions returns an error; in that case
// the last function in the sequence is called with the error.
// See util/cancelize.js for an explanation of what cancelables are.
function chain() {

  // The list of functions to chain together.
  var argList = Array.prototype.slice.call(arguments, 0);

  return function chained() {

    // List of remaining functions to be executed.
    // Make a copy of the original list so we can mutate the former while
    // preserving the latter intact for future invocations of the chain.
    var fnList = argList.slice(0);

    // Currently executing function.
    var fn = null;

    // Cancel method for the currently executing function.
    var cfn = null;

    // Arguments for the first function.
    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];

    // Callback for the chain.
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    // Execute the next function in the chain.
    // Receives the error and return values from the previous function.
    function exec() {

      // Extract error from arguments.
      var err = arguments[0];

      // Abort chain on error.
      if (err) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Terminate if there are no functions left in the chain.
      if (!fnList.length) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Advance to the next function in the chain.
      fn = fnList.shift();
      var _fn = fn;

      // Extract arguments to pass into the next function.
      var ret = Array.prototype.slice.call(arguments, 1);

      // Call next function with previous return value and call back exec.
      ret.push(exec);
      var _cfn = fn.apply(null, ret); // fn(null, ret..., exec)

      // Detect when fn has completed synchronously and do not clobber the
      // internal state in that case. You're not expected to understand this.
      if (_fn !== fn) {
        return;
      }

      // Remember the cancel method for the currently executing function.
      // Detect chaining on non-cancellable function.
      if (typeof _cfn !== 'function') {
        throw new Error('chain: chaining on non-cancellable function');
      } else {
        cfn = _cfn;
      }

    }

    // Cancel chain execution.
    function cancel() {
      if (cfn) {
        cfn.apply(null, arguments);
      }
    }

    // Start chain execution.
    // We call exec as if linking from a previous function in the chain,
    // except that the error is always null. As a consequence, chaining on an
    // empty list yields the identity function.
    args.unshift(null);
    exec.apply(null, args); // exec(null, args...)

    return cancel;

  };

}

module.exports = chain;

},{"./noop":107}],90:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

module.exports = clamp;
},{}],91:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Sets an object's own properties to undefined. This may be called by
// destructors to avoid retaining references and help detect incorrect use of
// destroyed instances.
function clearOwnProperties(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      obj[prop] = undefined;
    }
  }
}

module.exports = clearOwnProperties;

},{}],92:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function cmp(x, y) {
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
}

module.exports = cmp;
},{}],93:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
  * Compose multiple functions
  *
  * `compose(f, g)` returns `function(x) { return f(g(x)); }`
  *
  * @memberof util
  * @param {Function[]} functions The functions to compose
  * @return {Function}
  */
function compose() {
  var fnList = arguments;
  return function composed(initialArg) {
    var ret = initialArg;
    for (var i = 0; i < fnList.length; i++) {
      var fn = fnList[i];
      ret = fn.call(null, ret);
    }
    return ret;
  };
}

module.exports = compose;
},{}],94:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Convert fov
 *
 * For example, to convert from hfov to vfov one would call 
 * `convert(hfov, width, height)`
 *
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function convert(fov, fromDimension, toDimension) {
  return 2 * Math.atan(toDimension * Math.tan(fov / 2) / fromDimension);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htov(fov, width, height) {
  return convert(fov, width, height);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htod(fov, width, height) {
  return convert(fov, width, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtoh(fov, width, height) {
  return convert(fov, height, width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtod(fov, width, height) {
  return convert(fov, height, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtoh(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtov(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), height);
}

/**
 * @namespace util.convertFov
 */
module.exports = {
  convert: convert,
  htov: htov,
  htod: htod,
  vtoh: vtoh,
  vtod: vtod,
  dtoh: dtoh,
  dtov: dtov
};

},{}],95:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Convert a number to a string in decimal notation.
function decimal(x) {
  // Double-precision floats have 15 significant decimal digits.
  return x.toPrecision(15);
}

module.exports = decimal;
},{}],96:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defaults(obj, defaultsObj) {
  for (var key in defaultsObj) {
    if (!(key in obj)) {
      obj[key] = defaultsObj[key];
    }
  }
  return obj;
}

module.exports = defaults;
},{}],97:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defer(fn, args) {
  function deferred() {
    if (args && args.length > 0) {
      fn.apply(null, args);
    } else {
      fn();
    }
  }
  setTimeout(deferred, 0);
}

module.exports = defer;
},{}],98:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} deg
 * @return {number}
 */
function degToRad(deg) {
  return deg * Math.PI / 180;
}

module.exports = degToRad;
},{}],99:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Perform a cancelable delay.
// See util/cancelize.js for an explanation of what cancelables are.
function delay(ms, done) {

  // Work around IE8 bug whereby a setTimeout callback may still be called
  // after the corresponding clearTimeout is invoked.
  var timer = null;

  function finish() {
    if (timer != null) {
      timer = null;
      done(null);
    }
  }

  function cancel() {
    if (timer != null) {
      clearTimeout(timer);
      timer = null;
      done.apply(null, arguments);
    }
  }

  timer = setTimeout(finish, ms);

  return cancel;

}

module.exports = delay;

},{}],100:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


function prefixProperty(property) {

  var style = document.documentElement.style;
  var prefixList = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

  for (var i = 0; i < prefixList.length; i++) {
    var prefix = prefixList[i];
    var capitalizedProperty = property[0].toUpperCase() + property.slice(1);
    var prefixedProperty = prefix + capitalizedProperty;

    if (prefixedProperty in style) {
      return prefixedProperty;
    }
  }

  return property;

}


function getWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function getPropertyWithVendorPrefix(element) {
    return element.style[prefixedProperty];
  };

}


function setWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function setPropertyWithVendorPrefix(element, val) {
    return (element.style[prefixedProperty] = val);
  };
}


var setTransform = setWithVendorPrefix('transform');
var setTransformOrigin = setWithVendorPrefix('transformOrigin');


function setNullTransform(element) {
  setTransform(element, 'translateZ(0)');
}


function setNullTransformOrigin(element) {
  setTransformOrigin(element, '0 0 0');
}


function setAbsolute(element) {
  element.style.position = 'absolute';
}


function setPixelPosition(element, x, y) {
  element.style.left = x + 'px';
  element.style.top = y + 'px';
}


function setPixelSize(element, width, height) {
  element.style.width = width + 'px';
  element.style.height = height + 'px';
}


function setNullSize(element) {
  element.style.width = element.style.height = 0;
}


function setFullSize(element) {
  element.style.width = element.style.height = '100%';
}


function setOverflowHidden(element) {
  element.style.overflow = 'hidden';
}


function setOverflowVisible(element) {
  element.style.overflow = 'visible';
}


function setNoPointerEvents(element) {
  element.style.pointerEvents = 'none';
}


function setBlocking(element) {
  element.style.backgroundColor = '#000';
  element.style.opacity = '0';
  element.style.filter = 'alpha(opacity=0)';
}


module.exports = {
  prefixProperty: prefixProperty,
  getWithVendorPrefix: getWithVendorPrefix,
  setWithVendorPrefix: setWithVendorPrefix,
  setTransform: setTransform,
  setTransformOrigin: setTransformOrigin,
  setNullTransform: setNullTransform,
  setNullTransformOrigin: setNullTransformOrigin,
  setAbsolute: setAbsolute,
  setPixelPosition: setPixelPosition,
  setPixelSize: setPixelSize,
  setNullSize: setNullSize,
  setFullSize: setFullSize,
  setOverflowHidden: setOverflowHidden,
  setOverflowVisible: setOverflowVisible,
  setNoPointerEvents: setNoPointerEvents,
  setBlocking: setBlocking
};

},{}],101:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function extend(obj, sourceObj) {
  for (var key in sourceObj) {
    obj[key] = sourceObj[key];
  }
  return obj;
}

module.exports = extend;
},{}],102:[function(require,module,exports){
(function (global){(function (){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// The global object.
var globalObject = (function() {
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  return null;
})();

module.exports = globalObject;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],103:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Jenkins one-at-a-time hash
// http://www.burtleburtle.net/bob/hash/doobs.html
// Input: an array of integers
// Output: an integer

function hash() {
  var h = 0;
  for (var i = 0; i < arguments.length; i++) {
    var k = arguments[i];
    h += k;
    h += k << 10;
    h ^= k >> 6;
  }
  h += h << 3;
  h ^= h >> 11;
  h += h << 15;
  return h >= 0 ? h : -h;
}

module.exports = hash;
},{}],104:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Make ctor a subclass of superCtor.
// Do not depend on ES5 Object.create semantics because of older browsers.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

module.exports = inherits;
},{}],105:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Returns whether n is a power of two.
function ispot(n) {
  return (n & (n - 1)) == 0;
}

module.exports = ispot;
},{}],106:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Modulo operation
 *
 * @memberof util
 * @param {Number} dividend
 * @param {Number} divisor
 * @returns {Number} Value in range `[0,divisor[`
 */
function mod(a, b) {
  return (+a % (b = +b) + b) % b;
}

module.exports = mod;
},{}],107:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function noop() {}

module.exports = noop;
},{}],108:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function getNow() {
  if (typeof performance !== 'undefined' && performance.now) {
    return function performanceNow() {
      return performance.now();
    };
  }
  return function dateNow() {
    return Date.now();
  };
}

module.exports = getNow();

},{}],109:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function once(fn) {
  var called = false;
  var value;
  return function onced() {
    if (!called) {
      called = true;
      value = fn.apply(null, arguments);
    }
    return value;
  };
}

module.exports = once;
},{}],110:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaultPixelRatio = 1;

function pixelRatio() {
  if (typeof window !== 'undefined') {
    if (window.devicePixelRatio) {
      return window.devicePixelRatio;
    }
    else {
      var screen = window.screen;
      if (screen && screen.deviceXDPI && screen.logicalXDPI) {
        return screen.deviceXDPI / screen.logicalXDPI;
      } else if (screen && screen.systemXDPI && screen.logicalXDPI) {
        return screen.systemXDPI / screen.logicalXDPI;
      }
    }
  }
  return defaultPixelRatio;
}

module.exports = pixelRatio;

},{}],111:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var cssSupported = require('../support/Css');
var setTransform = require('./dom').setTransform;
var setPixelPosition = require('./dom').setPixelPosition;
var decimal = require('./decimal');

// This cannot belong in util/dom.js because support/Css also depends on it
// and it would cause a circular dependency.

function positionAbsolutely(element, x, y, extraTransforms) {
  extraTransforms = extraTransforms || '';
  if (cssSupported()) {
    // Use CSS 3D transforms when the browser supports them.
    // A translateZ(0) transform improves performance on Chrome by creating a
    // new layer for the element, which prevents unnecessary repaints.
    var transform = 'translateX(' + decimal(x) + 'px) translateY(' + decimal(y) + 'px) translateZ(0) ' + extraTransforms;
    setTransform(element, transform);
  } else {
    // Fall back to absolute positioning.
    setPixelPosition(element, x, y);
  }
}

module.exports = positionAbsolutely;

},{"../support/Css":82,"./decimal":95,"./dom":100}],112:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} rad
 * @return {number}
 */
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

module.exports = radToDeg;
},{}],113:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function real(x) {
  return typeof x === 'number' && isFinite(x);
}

module.exports = real;
},{}],114:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a cancelable function that executes fn in a loop until it returns
// successfully.
function retry(fn) {

  return function retried() {

    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    var cfn = null;
    var canceled = false;

    function exec() {
      var err = arguments[0];
      if (!err || canceled) {
        done.apply(null, arguments);
      } else {
        cfn = fn.apply(null, args);
      }
    }

    args.push(exec);
    exec(true);

    return function cancel() {
      canceled = true;
      cfn.apply(null, arguments);
    };

  };

}

module.exports = retry;

},{"./noop":107}],115:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('./now');

function tween(duration, update, done) {
  var cancelled = false;

  var startTime = now();

  function runUpdate() {
    if(cancelled) { return; }
    var tweenVal = (now() - startTime)/duration;
    if(tweenVal < 1) {
      update(tweenVal);
      requestAnimationFrame(runUpdate);
    }
    else {
      update(1);
      done();
    }
  }

  update(0);
  requestAnimationFrame(runUpdate);

  return function cancel() {
    cancelled = true;
    done.apply(null, arguments);
  }
}

module.exports = tween;
},{"./now":108}],116:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function type(x) {
  var typ = typeof x;
  if (typ === 'object') {
    if (x === null) {
      return 'null';
    }
    if (Object.prototype.toString.call(x) === '[object Array]') {
      return 'array';
    }
    if (Object.prototype.toString.call(x) === '[object RegExp]') {
      return 'regexp';
    }
  }
  return typ;
}

module.exports = type;

},{}],117:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var pixelRatio = require('../util/pixelRatio');
var real = require('../util/real');
var clamp = require('../util/clamp');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultX = 0.5;
var defaultY = 0.5;
var defaultZoom = 1;

// Constant values used to simplify the frustum culling logic.
// planeAxes[i] indicates the coordinate value that defines a frustum plane.
// planeCmp[i] indicates how point and plane coordinates should be compared
// to determine whether the point is on the outer side of the plane.
var planeAxes = [
  1, // top
  0, // right
  1, // bottom
  0  // left
];
var planeCmp = [
  -1, // top
  -1, // right
   1, // bottom
   1  // left
];

// A zoom of exactly 0 breaks some computations, so we force a minimum positive
// value. We use 6 decimal places for the epsilon value to avoid broken
// rendering due to loss of precision in floating point computations.
var zoomLimitEpsilon = 0.000001;


/**
 * @interface FlatViewParams
 *
 * A camera configuration for a {@link FlatView}.
 *
 * @property {number} x The horizontal coordinate of the image point displayed
 *     at the viewport center, in the [0, 1] range.
 *     When `x === 0.5`, the image is centered horizontally.
 *     When `x === 0`, the left edge of the image is at the viewport center.
 *     When `x === 1`, the right edge of the image is at the viewport center.
 * @property {number} y The vertical coordinate of the image point displayed at
 *     the viewport center, in the [0, 1] range.
 *     When `y === 0.5`, the image is centered vertically.
 *     When `y === 0`, the top edge of the image is at the viewport center.
 *     When `y === 1`, the bottom edge of the image is at the viewport center.
 * @property {number} zoom The horizontal zoom, in the [0, ) range.
 *     When `zoom === 1`, the viewport is as wide as the image.
 *     When `zoom < 1`, the image is zoomed in.
 *     When `zoom > 1`, the image is zoomed out.
 * @property {number} mediaAspectRatio The image aspect ratio.
 *     When `mediaAspectRatio === 1`, the image width equals its height.
 *     When `mediaAspectRatio < 1`, the image width is less than its height.
 *     When `mediaAspectRatio > 1`, the image height is less than its width.
 */


/**
 * @interface FlatViewCoords
 *
 * The position of a point in a flat image.
 *
 * @property {number} x The horizontal coordinate, in the [0, 1] range.
 * @property {number} y The vertical coordinate, in the [0, 1] range.
 */


/**
 * @typedef {function} FlatViewLimiter
 *
 * View limiter for a {@link FlatView}.
 *
 * A view limiter is a function that receives a {@link FlatViewParams} object,
 * optionally modifies it in place, and returns it. It can be used to enforce
 * constraints on the view parameters.
 *
 * See {@link FlatView.limit} for commonly used limiters. They may be composed
 * together or with user-defined limiters with {@link util.compose}.
 *
 * @param {FlatViewParams} params
 * @return {FlatViewParams}
 */


/**
 * @class FlatView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing an orthogonal projection for flat images.
 *
 * @param {FlatViewParams} params The initial view parameters. The
 *     `mediaAspectRatio` parameter must always be set. The other parameters
 *     default to `{x: 0.5, y: 0.5, z: 1 }` if unspecified.
 * @param {FlatViewLimiter=} limiter The view limiter. If unspecified, no view
 *     limiting is applied. See {@link FlatView.limit} for commonly used
 *     limiters.
 */
function FlatView(params, limiter) {
  // Require an aspect ratio to be specified.
  if (!(params && params.mediaAspectRatio != null)) {
    throw new Error('mediaAspectRatio must be defined');
  }

  // The initial values for the view parameters.
  this._x = params && params.x != null ? params.x : defaultX;
  this._y = params && params.y != null ? params.y : defaultY;
  this._zoom = params && params.zoom != null ? params.zoom : defaultZoom;
  this._mediaAspectRatio = params.mediaAspectRatio;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    0, // top
    0, // right
    0, // bottom
    0  // left
  ];

  // Whether the projection matrices and view frustum need to be updated.
  this._projectionChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._vec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(FlatView);


/**
 * Destructor.
 */
FlatView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the x parameter.
 * @return {number}
 */
FlatView.prototype.x = function() {
  return this._x;
};


/**
 * Get the y parameter.
 * @return {number}
 */
FlatView.prototype.y = function() {
  return this._y;
};


/**
 * Get the zoom value.
 * @return {number}
 */
FlatView.prototype.zoom = function() {
  return this._zoom;
};


/**
 * Get the media aspect ratio.
 * @return {number}
 */
FlatView.prototype.mediaAspectRatio = function() {
  return this._mediaAspectRatio;
};


/**
 * Get the viewport width.
 * @return {number}
 */
FlatView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
FlatView.prototype.height = function() {
  return this._height;
};


/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
FlatView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {FlatViewParams=} params
 * @return {FlatViewParams}
 */
FlatView.prototype.parameters = function(params) {
  params = params || {};
  params.x = this._x;
  params.y = this._y;
  params.zoom = this._zoom;
  params.mediaAspectRatio = this._mediaAspectRatio;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?FlatViewLimiter}
 */
FlatView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the x parameter.
 * @param {number} x
 */
FlatView.prototype.setX = function(x) {
  this._resetParams();
  this._params.x = x;
  this._update(this._params);
};


/**
 * Set the y parameter.
 * @param {number} y
 */
FlatView.prototype.setY = function(y) {
  this._resetParams();
  this._params.y = y;
  this._update(this._params);
};


/**
 * Set the zoom value.
 * @param {number} zoom
 */
FlatView.prototype.setZoom = function(zoom) {
  this._resetParams();
  this._params.zoom = zoom;
  this._update(this._params);
};


/**
 * Add xOffset to the x parameter.
 * @param {number} xOffset
 */
FlatView.prototype.offsetX = function(xOffset) {
  this.setX(this._x + xOffset);
};


/**
 * Add yOffset to the y parameter.
 * @param {number} yOffset
 */
FlatView.prototype.offsetY = function(yOffset)
{
  this.setY(this._y + yOffset);
};


/**
 * Add zoomOffset to the zoom value.
 * @param {number} zoomOffset
 */
FlatView.prototype.offsetZoom = function(zoomOffset) {
  this.setZoom(this._zoom + zoomOffset);
};


/**
 * Set the media aspect ratio.
 * @param {number} mediaAspectRatio
 */
FlatView.prototype.setMediaAspectRatio = function(mediaAspectRatio) {
  this._resetParams();
  this._params.mediaAspectRatio = mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
FlatView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};


/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {FlatViewParameters} params
 */
FlatView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.x = params.x;
  this._params.y = params.y;
  this._params.zoom = params.zoom;
  this._params.mediaAspectRatio = params.mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?FlatViewLimiter} limiter The new limiter, or null to unset.
 */
FlatView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


FlatView.prototype._resetParams = function() {
  var params = this._params;
  params.x = null;
  params.y = null;
  params.zoom = null;
  params.mediaAspectRatio = null;
  params.width = null;
  params.height = null;
};


FlatView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldX = this._x;
  var oldY = this._y;
  var oldZoom = this._zoom;
  var oldMediaAspectRatio = this._mediaAspectRatio;
  var oldWidth = this._width;
  var oldHeight = this._height;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.x = params.x != null ? params.x : oldX;
  params.y = params.y != null ? params.y : oldY;
  params.zoom = params.zoom != null ? params.zoom : oldZoom;
  params.mediaAspectRatio = params.mediaAspectRatio != null ?
    params.mediaAspectRatio : oldMediaAspectRatio;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Grab the limited parameters.
  var newX = params.x;
  var newY = params.y;
  var newZoom = params.zoom;
  var newMediaAspectRatio = params.mediaAspectRatio;
  var newWidth = params.width;
  var newHeight = params.height;

  // Consistency check.
  if (!real(newX) || !real(newY) || !real(newZoom) ||
      !real(newMediaAspectRatio) || !real(newWidth) || !real(newHeight)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Constrain zoom.
  newZoom = clamp(newZoom, zoomLimitEpsilon, Infinity);

  // Update parameters.
  this._x = newX;
  this._y = newY;
  this._zoom = newZoom;
  this._mediaAspectRatio = newMediaAspectRatio;
  this._width = newWidth;
  this._height = newHeight;

  // Check whether the parameters changed and emit the corresponding events.
  if (newX !== oldX || newY !== oldY || newZoom !== oldZoom ||
      newMediaAspectRatio !== oldMediaAspectRatio ||
      newWidth !== oldWidth || newHeight !== oldHeight) {
    this._projectionChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }

};


FlatView.prototype._zoomX = function() {
  return this._zoom;
};


FlatView.prototype._zoomY = function() {
  var mediaAspectRatio = this._mediaAspectRatio;
  var aspect = this._width / this._height;
  var zoomX = this._zoom;
  var zoomY = zoomX * mediaAspectRatio / aspect;
  if (isNaN(zoomY)) {
    zoomY = zoomX;
  }
  return zoomY;
};


FlatView.prototype.updateWithControlParameters = function(parameters) {
  var scale = this.zoom();
  var zoomX = this._zoomX();
  var zoomY = this._zoomY();

  // TODO: should the scale be the same for both axes?
  this.offsetX(parameters.axisScaledX * zoomX + parameters.x * scale);
  this.offsetY(parameters.axisScaledY * zoomY + parameters.y * scale);
  this.offsetZoom(parameters.zoom * scale);
};


FlatView.prototype._updateProjection = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var frustum = this._frustum;

  // Recalculate projection matrix when required.
  if (this._projectionChanged) {
    var x = this._x;
    var y = this._y;
    var zoomX = this._zoomX();
    var zoomY = this._zoomY();

    // Recalculate view frustum.
    var top     = frustum[0] = (0.5 - y) + 0.5 * zoomY;
    var right   = frustum[1] = (x - 0.5) + 0.5 * zoomX;
    var bottom  = frustum[2] = (0.5 - y) - 0.5 * zoomY;
    var left    = frustum[3] = (x - 0.5) - 0.5 * zoomX;

    // Recalculate projection matrix and its inverse.
    mat4.ortho(projMatrix, left, right, bottom, top, -1, 1);
    mat4.invert(invProjMatrix, projMatrix);

    this._projectionChanged = false;
  }
};


/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.projection = function() {
  this._updateProjection();
  return this._projMatrix;
};


/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.inverseProjection = function() {
  this._updateProjection();
  return this._invProjMatrix;
};


/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec3[]} rectangle The vertices of the rectangle.
 */
FlatView.prototype.intersects = function(rectangle) {
  this._updateProjection();

  var frustum = this._frustum;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the fruouter
  for (var i = 0; i < frustum.length; i++) {
    var limit = frustum[i];
    var axis = planeAxes[i];
    var cmp = planeCmp[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var vertex = rectangle[j];
      if (cmp < 0 && vertex[axis] < limit || cmp > 0 && vertex[axis] > limit) {
        inside = true;
        break;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
FlatView.prototype.selectLevel = function(levels) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of the image that would be visible at the current
  // zoom value. Then, for each level, multiply by the level width to get the
  // width in pixels of the portion that would be visible.
  //
  // Search for the smallest level that satifies the the required width,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this.width();
  var zoomFactor = this._zoom;

  for (var i = 0; i < levels.length; i++) {
    var level = levels[i];
    if (zoomFactor * level.width() >= requiredPixels) {
      return level;
    }
  }

  return levels[levels.length - 1];

};


/**
 * Convert view coordinates into screen coordinates. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {FlatViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
FlatView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Extract coordinates from argument, filling in default values.
  var x = coords && coords.x != null ? coords.x : defaultX;
  var y = coords && coords.y != null ? coords.y : defaultY;

  // Project view ray onto clip space.
  vec4.set(ray, x - 0.5, 0.5 - y, -1, 1);
  vec4.transformMat4(ray, ray, this.projection());

  // Calculate perspective divide.
  for (var i = 0; i < 3; i++) {
    ray[i] /= ray[3];
  }

  // Convert to viewport coordinates and return.
  result.x = width * (ray[0] + 1) / 2;
  result.y = height * (1 - ray[1]) / 2;

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {FlatViewCoords=} result The result argument for the view coordinates.
 * @return {FlatViewCoords}
 */
FlatView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to flat coordinates.
  result.x = 0.5 + ray[0];
  result.y = 0.5 - ray[1];

  return result;
};


/**
 * Factory functions for view limiters. See {@link FlatViewLimiter}.
 * @namespace
 */
FlatView.limit = {

  /**
   * Returns a view limiter that constrains the x parameter.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  x: function(min, max) {
    return function limitX(params) {
      params.x = clamp(params.x, min, max);
      return params;
    };
  },

  /**
   * Return a view limiter that constrains the y parameter.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  y: function(min, max) {
    return function limitY(params) {
      params.y = clamp(params.y, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter than constrains the zoom parameter.
   * @param {number} min The minimum zoom value.
   * @param {number} max The maximum zoom value.
   * @return {FlatViewLimiter}
   */
  zoom: function(min, max) {
    return function limitZoom(params) {
      params.zoom = clamp(params.zoom, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The image width in pixels.
   * @return {FlatViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }
      var width = params.width;
      var minZoom = pixelRatio() * width / size;
      params.zoom = clamp(params.zoom, minZoom, Infinity);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the x parameter that
   * are inside the viewport.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum x value.
   * @return {FlatViewLimiter}
   */
  visibleX: function(min, max) {
    return function limitVisibleX(params) {
      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = max - min;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound X such that the image is visible up to the range edges.
      var minX = min + 0.5 * params.zoom;
      var maxX = max - 0.5 * params.zoom;
      params.x = clamp(params.x, minX, maxX);

      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the y parameter that
   * are inside the viewport.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  visibleY: function(min, max) {
    return function limitVisibleY(params) {

      // Do nothing for a null viewport.
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }

      // Calculate the X to Y conversion factor.
      var viewportAspectRatio = params.width / params.height;
      var factor = viewportAspectRatio / params.mediaAspectRatio;

      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = (max - min) * factor;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound Y such that the image is visible up to the range edges.
      var minY = min + 0.5 * params.zoom / factor;
      var maxY = max - 0.5 * params.zoom / factor;
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  },


  /**
   * Returns a view limiter that constrains the zoom parameter such that
   * zooming out is prevented beyond the point at which the image is fully
   * visible. Unless the image and the viewport have the same aspect ratio,
   * this will cause bands to appear around the image.
   * @return {FlatViewLimiter}
   */
  letterbox: function() {
    return function limitLetterbox(params) {
      if(params.width <= 0 || params.height <= 0) {
        return params;
      }
      var viewportAspectRatio = params.width / params.height;

      var fullWidthZoom = 1.0;
      var fullHeightZoom = viewportAspectRatio / params.mediaAspectRatio;

      // If the image is wider than the viewport, limit the horizontal zoom to
      // the image width.
      if (params.mediaAspectRatio >= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullWidthZoom);
      }

      // If the image is narrower than the viewport, limit the vertical zoom to
      // the image height.
      if (params.mediaAspectRatio <= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullHeightZoom);
      }

      // If the full image width is visible, limit x to the central point.
      // Else, bound x such that image is visible up to the horizontal edges.
      var minX, maxX;
      if (params.zoom > fullWidthZoom) {
        minX = maxX = 0.5;
      } else {
        minX = 0.0 + 0.5 * params.zoom / fullWidthZoom;
        maxX = 1.0 - 0.5 * params.zoom / fullWidthZoom;
      }

      // If the full image height is visible, limit y to the central point.
      // Else, bound y such that image is visible up to the vertical edges.
      var minY, maxY;
      if (params.zoom > fullHeightZoom) {
        minY = maxY = 0.5;
      } else {
        minY = 0.0 + 0.5 * params.zoom / fullHeightZoom;
        maxY = 1.0 - 0.5 * params.zoom / fullHeightZoom;
      }

      // Clamp x and y into the calculated bounds.
      params.x = clamp(params.x, minX, maxX);
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  }

};


FlatView.type = FlatView.prototype.type = 'flat';


module.exports = FlatView;

},{"../util/clamp":90,"../util/clearOwnProperties":91,"../util/pixelRatio":110,"../util/real":113,"gl-matrix":3,"minimal-event-emitter":14}],118:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var pixelRatio = require('../util/pixelRatio');
var convertFov = require('../util/convertFov');
var mod = require('../util/mod');
var real = require('../util/real');
var clamp = require('../util/clamp');
var decimal = require('../util/decimal');
var compose = require('../util/compose');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultYaw = 0;
var defaultPitch = 0;
var defaultRoll = 0;
var defaultFov = Math.PI/4;
var defaultProjectionCenterX = 0;
var defaultProjectionCenterY = 0;

// A fov of exactly 0 or  breaks some computations, so we constrain it to the
// [fovLimitEpsilon,  - fovLimitEpsilon] interval. We use 6 decimal places for
// the epsilon value to avoid broken rendering due to loss of precision in
// floating point computations.
var fovLimitEpsilon = 0.000001;


/**
 * @interface RectilinearViewParams
 *
 * A camera configuration for a {@link RectilinearView}.
 *
 * @property {number} yaw The yaw angle, in the [-, ] range.
 *     When `yaw < 0`, the view rotates to the left.
 *     When `yaw > 0`, the view rotates to the right.
 *
 * @property {number} pitch The pitch angle, in the [-, ] range.
 *     When `pitch < 0`, the view rotates downwards.
 *     When `pitch > 0`, the view rotates upwards.
 *
 * @property {number} roll The roll angle, in the [-, ] range.
 *     When `roll < 0`, the view rotates clockwise.
 *     When `roll > 0`, the view rotates counter-clockwise.
 *
 * @property {fov} fov The vertical field of view, in the [0, ] range.
 */


/**
 * @interface RectilinearViewCoords
 *
 * The position of a point in a 360 image.
 *
 * @property {number} yaw The yaw angle, in the [-, ] range.
 * @property {number} pitch The pitch angle, in the [-, ] range.
 */


/**
 * @typedef {function} RectilinearViewLimiter
 *
 * View limiter for a {@link RectilinearView}.
 *
 * A view limiter is a function that receives a {@link RectilinearViewParams}
 * object, optionally modifies it in place, and returns it. It can be used to
 * enforce constraints on the view parameters.
 *
 * See {@link RectilinearView.limit} for commonly used limiters. They may be
 * composed together or with user-defined limiters with {@link util.compose}.
 *
 * @param {RectilinearViewParams} params
 * @return {RectilinearViewParams}
 */

/**
 * @class RectilinearView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing a rectilinear projection for 360 images.
 *
 * @param {RectilinearViewParams=} params The initial view parameters. If
 *     unspecified, defaults to `{yaw: 0, pitch: 0, roll: 0, fov: Math.PI/4 }`.
 * @param {RectilinearViewLimiter=} limiter The view limiter. If unspecified,
 *     no view limiting is applied. See {@link RectilinearView.limit} for
 *     commonly used limiters.
 */
function RectilinearView(params, limiter) {
  // The initial values for the view parameters.
  this._yaw = params && params.yaw != null ? params.yaw : defaultYaw;
  this._pitch = params && params.pitch != null ? params.pitch : defaultPitch;
  this._roll = params && params.roll != null ? params.roll : defaultRoll;
  this._fov = params && params.fov != null ? params.fov : defaultFov;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;
  this._projectionCenterX = params && params.projectionCenterX != null ?
    params.projectionCenterX : defaultProjectionCenterX;
  this._projectionCenterY = params && params.projectionCenterY != null ?
    params.projectionCenterY : defaultProjectionCenterY;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    vec4.create(), // left
    vec4.create(), // right
    vec4.create(), // bottom
    vec4.create(), // top
    vec4.create()  // camera
  ];

  // Whether the projection matrices and the view frustum need to be updated.
  this._projectionChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._fovs = {};
  this._tmpVec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(RectilinearView);


/**
 * Destructor.
 */
RectilinearView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the yaw angle.
 * @return {number}
 */
RectilinearView.prototype.yaw = function() {
  return this._yaw;
};


/**
 * Get the pitch angle.
 * @return {number}
 */
RectilinearView.prototype.pitch = function() {
  return this._pitch;
};


/**
 * Get the roll angle.
 * @return {number}
 */
RectilinearView.prototype.roll = function() {
  return this._roll;
};


RectilinearView.prototype.projectionCenterX = function() {
  return this._projectionCenterX;
};


RectilinearView.prototype.projectionCenterY = function() {
  return this._projectionCenterY;
};


/**
 * Get the fov value.
 * @return {number}
 */
RectilinearView.prototype.fov = function() {
  return this._fov;
};


/**
 * Get the viewport width.
 * @return {number}
 */
RectilinearView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
RectilinearView.prototype.height = function() {
  return this._height;
};


/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
RectilinearView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {RectilinearViewParams=} obj
 * @return {RectilinearViewParams}
 */
RectilinearView.prototype.parameters = function(params) {
  params = params || {};
  params.yaw = this._yaw;
  params.pitch = this._pitch;
  params.roll = this._roll;
  params.fov = this._fov;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?RectilinearViewLimiter}
 */
RectilinearView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the yaw angle.
 * @param {number} yaw
 */
RectilinearView.prototype.setYaw = function(yaw) {
  this._resetParams();
  this._params.yaw = yaw;
  this._update(this._params);
};


/**
 * Set the pitch angle.
 * @param {number} pitch
 */
RectilinearView.prototype.setPitch = function(pitch) {
  this._resetParams();
  this._params.pitch = pitch;
  this._update(this._params);
};


/**
 * Set the roll angle.
 * @param {number} roll
 */
RectilinearView.prototype.setRoll = function(roll) {
  this._resetParams();
  this._params.roll = roll;
  this._update(this._params);
};


/**
 * Set the fov value.
 * @param {number} fov
 */
RectilinearView.prototype.setFov = function(fov) {
  this._resetParams();
  this._params.fov = fov;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterX = function(projectionCenterX) {
  this._resetParams();
  this._params.projectionCenterX = projectionCenterX;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterY = function(projectionCenterY) {
  this._resetParams();
  this._params.projectionCenterY = projectionCenterY;
  this._update(this._params);
};


/**
 * Add yawOffset to the current yaw value.
 * @param {number} yawOffset
 */
RectilinearView.prototype.offsetYaw = function(yawOffset) {
  this.setYaw(this._yaw + yawOffset);
};


/**
 * Add pitchOffset to the current pitch value.
 * @param {number} pitchOffset
 */
RectilinearView.prototype.offsetPitch = function(pitchOffset) {
  this.setPitch(this._pitch + pitchOffset);
};


/**
 * Add rollOffset to the current roll value.
 * @param {number} rollOffset
 */
RectilinearView.prototype.offsetRoll = function(rollOffset) {
  this.setRoll(this._roll + rollOffset);
};


/**
 * Add fovOffset to the current fov value.
 * @param {number} fovOffset
 */
RectilinearView.prototype.offsetFov = function(fovOffset) {
  this.setFov(this._fov + fovOffset);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
RectilinearView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};


/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {RectilinearViewParameters} params
 */
RectilinearView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.yaw = params.yaw;
  this._params.pitch = params.pitch;
  this._params.roll = params.roll;
  this._params.fov = params.fov;
  this._params.projectionCenterX = params.projectionCenterX;
  this._params.projectionCenterY = params.projectionCenterY;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?RectilinearViewLimiter} limiter The new limiter, or null to unset.
 */
RectilinearView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


RectilinearView.prototype._resetParams = function() {
  var params = this._params;
  params.yaw = null;
  params.pitch = null;
  params.roll = null;
  params.fov = null;
  params.width = null;
  params.height = null;
};


RectilinearView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldYaw = this._yaw;
  var oldPitch = this._pitch;
  var oldRoll = this._roll;
  var oldFov = this._fov;
  var oldProjectionCenterX = this._projectionCenterX;
  var oldProjectionCenterY = this._projectionCenterY;
  var oldWidth = this._width;
  var oldHeight = this._height;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.yaw = params.yaw != null ? params.yaw : oldYaw;
  params.pitch = params.pitch != null ? params.pitch : oldPitch;
  params.roll = params.roll != null ? params.roll : oldRoll;
  params.fov = params.fov != null ? params.fov : oldFov;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;
  params.projectionCenterX = params.projectionCenterX != null ?
    params.projectionCenterX : oldProjectionCenterX;
  params.projectionCenterY = params.projectionCenterY != null ?
    params.projectionCenterY : oldProjectionCenterY;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Normalize parameters.
  params = this._normalize(params);

  // Grab the limited parameters.
  var newYaw = params.yaw;
  var newPitch = params.pitch;
  var newRoll = params.roll;
  var newFov = params.fov;
  var newWidth = params.width;
  var newHeight = params.height;
  var newProjectionCenterX = params.projectionCenterX;
  var newProjectionCenterY = params.projectionCenterY;

  // Consistency check.
  if (!real(newYaw) || !real(newPitch) || !real(newRoll) ||
      !real(newFov) || !real(newWidth) || !real(newHeight) ||
      !real(newProjectionCenterX) || !real(newProjectionCenterY)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Update parameters.
  this._yaw = newYaw;
  this._pitch = newPitch;
  this._roll = newRoll;
  this._fov = newFov;
  this._width = newWidth;
  this._height = newHeight;
  this._projectionCenterX = newProjectionCenterX;
  this._projectionCenterY = newProjectionCenterY;

  // Check whether the parameters changed and emit the corresponding events.
  if (newYaw !== oldYaw || newPitch !== oldPitch || newRoll !== oldRoll ||
      newFov !== oldFov || newWidth !== oldWidth || newHeight !== oldHeight ||
      newProjectionCenterX !== oldProjectionCenterX ||
      newProjectionCenterY !== oldProjectionCenterY) {
    this._projectionChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }

};


RectilinearView.prototype._normalize = function(params) {

  this._normalizeCoordinates(params);

  // Make sure that neither the horizontal nor the vertical fields of view
  // exceed  - fovLimitEpsilon.
  var hfovPi = convertFov.htov(Math.PI, params.width, params.height);
  var maxFov = isNaN(hfovPi) ? Math.PI : Math.min(Math.PI, hfovPi);
  params.fov = clamp(params.fov, fovLimitEpsilon, maxFov - fovLimitEpsilon);

  return params;
};


RectilinearView.prototype._normalizeCoordinates = function(params) {
  // Constrain yaw, pitch and roll to the [-, ] interval.
  if ('yaw' in params) {
    params.yaw = mod(params.yaw - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('pitch' in params) {
    params.pitch = mod(params.pitch - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('roll' in params) {
    params.roll = mod(params.roll - Math.PI, -2*Math.PI) + Math.PI;
  }
  return params;
};


/**
 * Normalize view coordinates so that they are the closest to the current view.
 * Useful for tweening the view through the shortest path. If a result argument
 * is supplied, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {RectilinearViewCoords} result The result argument for the normalized
 *     view coordinates.
 */
RectilinearView.prototype.normalizeToClosest = function(coords, result) {

  var viewYaw = this._yaw;
  var viewPitch = this._pitch;

  var coordYaw = coords.yaw;
  var coordPitch = coords.pitch;

  // Check if the yaw is closer after subtracting or adding a full circle.
  var prevYaw = coordYaw - 2*Math.PI;
  var nextYaw = coordYaw + 2*Math.PI;
  if (Math.abs(prevYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = prevYaw;
  }
  else if (Math.abs(nextYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = nextYaw;
  }

  // Check if the pitch is closer after subtracting or adding a full circle.
  var prevPitch = coordPitch - 2*Math.PI;
  var nextPitch = coordPitch + 2*Math.PI;
  if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = prevPitch;
  }
  else if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = nextPitch;
  }

  result = result || {};
  result.yaw = coordYaw;
  result.pitch = coordPitch;
  return result;

};


RectilinearView.prototype.updateWithControlParameters = function(parameters) {
  // axisScaledX and axisScaledY are scaled according to their own axis
  // x and y are scaled by the same value

  // If the viewport dimensions are zero, assume a square viewport
  // when converting from hfov to vfov.
  var vfov = this._fov;
  var hfov = convertFov.vtoh(vfov, this._width, this._height);
  if (isNaN(hfov)) {
    hfov = vfov;
  }

  // TODO: revisit this after we rethink the control parameters.
  this.offsetYaw(parameters.axisScaledX * hfov + parameters.x * 2 * hfov + parameters.yaw);
  this.offsetPitch(parameters.axisScaledY * vfov + parameters.y * 2 * hfov + parameters.pitch);
  this.offsetRoll(-parameters.roll);
  this.offsetFov(parameters.zoom * vfov);
};


RectilinearView.prototype._updateProjection = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var frustum = this._frustum;

  if (this._projectionChanged) {
    var width = this._width;
    var height = this._height;

    var vfov = this._fov;
    var hfov = convertFov.vtoh(vfov, width, height);
    var aspect = width / height;

    var projectionCenterX = this._projectionCenterX;
    var projectionCenterY = this._projectionCenterY;

    if (projectionCenterX !== 0 || projectionCenterY !== 0) {
      var offsetAngleX = Math.atan(projectionCenterX * 2 * Math.tan(hfov/2));
      var offsetAngleY = Math.atan(projectionCenterY * 2 * Math.tan(vfov/2));
      var fovs = this._fovs;
      fovs.leftDegrees = (hfov/2 + offsetAngleX) * 180/Math.PI;
      fovs.rightDegrees = (hfov/2 - offsetAngleX) * 180/Math.PI;
      fovs.upDegrees = (vfov/2 + offsetAngleY) * 180/Math.PI;
      fovs.downDegrees = (vfov/2 - offsetAngleY) * 180/Math.PI;
      mat4.perspectiveFromFieldOfView(projMatrix, fovs, -1, 1);
    } else {
      mat4.perspective(projMatrix, vfov, aspect, -1, 1);
    }

    mat4.rotateZ(projMatrix, projMatrix, this._roll);
    mat4.rotateX(projMatrix, projMatrix, this._pitch);
    mat4.rotateY(projMatrix, projMatrix, this._yaw);

    mat4.invert(invProjMatrix, projMatrix);

    this._matrixToFrustum(projMatrix, frustum);

    this._projectionChanged = false;
  }
};


RectilinearView.prototype._matrixToFrustum = function(p, f) {
  // Extract frustum planes from projection matrix.
  // http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
  vec4.set(f[0], p[3] + p[0], p[7] + p[4], p[11] + p[8],  0); // left
  vec4.set(f[1], p[3] - p[0], p[7] - p[4], p[11] - p[8],  0); // right
  vec4.set(f[2], p[3] + p[1], p[7] + p[5], p[11] + p[9],  0); // top
  vec4.set(f[3], p[3] - p[1], p[7] - p[5], p[11] - p[9],  0); // bottom
  vec4.set(f[4], p[3] + p[2], p[7] + p[6], p[11] + p[10], 0); // camera
};


/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.projection = function() {
  this._updateProjection();
  return this._projMatrix;
};


/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.inverseProjection = function() {
  this._updateProjection();
  return this._invProjMatrix;
};


/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec2[]} rectangle The vertices of the rectangle.
 */
RectilinearView.prototype.intersects = function(rectangle) {
  this._updateProjection();

  var frustum = this._frustum;
  var vertex = this._tmpVec;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the frustum.
  for (var i = 0; i < frustum.length; i++) {
    var plane = frustum[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var corner = rectangle[j];
      vec4.set(vertex, corner[0], corner[1], corner[2], 0);
      if (vec4.dot(plane, vertex) >= 0) {
        inside = true;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
RectilinearView.prototype.selectLevel = function(levelList) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of a cube face that would be visible given the
  // current vertical field of view. Then, for each level, multiply by the
  // level height to get the height in pixels of the portion that would be
  // visible.
  //
  // Search for the smallest level that satifies the the required height,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this._height;
  var coverFactor = Math.tan(0.5 * this._fov);

  for (var i = 0; i < levelList.length; i++) {
    var level = levelList[i];
    if (coverFactor * level.height() >= requiredPixels) {
      return level;
    }
  }

  return levelList[levelList.length - 1];

};


/**
 * Convert view parameters into screen position. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
RectilinearView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Compute view ray pointing into the (yaw, pitch) direction.
  var yaw = coords.yaw;
  var pitch = coords.pitch;
  var x = Math.sin(yaw) * Math.cos(pitch);
  var y = -Math.sin(coords.pitch);
  var z = -Math.cos(yaw) * Math.cos(pitch);
  vec4.set(ray, x, y, z, 1);

  // Project view ray onto clip space.
  vec4.transformMat4(ray, ray, this.projection());

  // w in clip space equals -z in camera space.
  if (ray[3] >= 0) {
    // Point is in front of camera.
    // Convert to viewport coordinates.
    result.x = width * (ray[0] / ray[3] + 1) / 2;
    result.y = height * (1 - ray[1] / ray[3]) / 2;
  } else {
    // Point is behind camera.
    result.x = null;
    result.y = null;
    return null;
  }

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {RectilinearViewCoords=} result The view coordinates.
 * @return {RectilinearViewCoords}
 */
RectilinearView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to spherical coordinates.
  var r = Math.sqrt(ray[0] * ray[0] + ray[1] * ray[1] + ray[2] * ray[2]);
  result.yaw = Math.atan2(ray[0], -ray[2]);
  result.pitch = Math.acos(ray[1] / r) - Math.PI/2;

  this._normalizeCoordinates(result);

  return result;
};


/**
 * Calculate the perspective transform required to position an element with
 * perspective.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {number} radius Radius of the sphere embedding the element.
 * @param {string} extraTransforms Extra transformations to be applied after
 *     the element is positioned. This may be used to rotate the element.
 * @return {string} The CSS 3D transform to be applied to the element.
 */
RectilinearView.prototype.coordinatesToPerspectiveTransform = function(
    coords, radius, extraTransforms) {
  extraTransforms = extraTransforms || "";

  var height = this._height;
  var width = this._width;
  var fov = this._fov;
  var perspective = 0.5 * height / Math.tan(fov / 2);

  var transform = '';

  // Center hotspot in screen.
  transform += 'translateX(' + decimal(width/2) + 'px) ';
  transform += 'translateY(' + decimal(height/2) + 'px) ';
  transform += 'translateX(-50%) translateY(-50%) ';

  // Set the perspective depth.
  transform += 'perspective(' + decimal(perspective) + 'px) ';
  transform += 'translateZ(' + decimal(perspective) + 'px) ';

  // Set the camera rotation.
  transform += 'rotateZ(' + decimal(-this._roll) + 'rad) ';
  transform += 'rotateX(' + decimal(-this._pitch) + 'rad) ';
  transform += 'rotateY(' + decimal(this._yaw) + 'rad) ';

  // Set the hotspot rotation.
  transform += 'rotateY(' + decimal(-coords.yaw) + 'rad) ';
  transform += 'rotateX(' + decimal(coords.pitch) + 'rad) ';

  // Move back to sphere.
  transform += 'translateZ(' + decimal(-radius) + 'px) ';

  // Apply the extra transformations
  transform += extraTransforms + ' ';

  return transform;
};


/**
 * Factory functions for view limiters. See {@link RectilinearViewLimiter}.
 * @namespace
 */
RectilinearView.limit = {

  /**
   * Returns a view limiter that constrains the yaw angle.
   * @param {number} min The minimum yaw value.
   * @param {number} max The maximum yaw value.
   * @return {RectilinearViewLimiter}
   */
  yaw: function(min, max) {
    return function limitYaw(params) {
      params.yaw = clamp(params.yaw, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the pitch angle.
   * @param {number} min The minimum pitch value.
   * @param {number} max The maximum pitch value.
   * @return {RectilinearViewLimiter}
   */
  pitch: function(min, max) {
    return function limitPitch(params) {
      params.pitch = clamp(params.pitch, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the roll angle.
   * @param {number} min The minimum roll value.
   * @param {number} max The maximum roll value.
   * @return {RectilinearViewLimiter}
   */
  roll: function(min, max) {
    return function limitRoll(params) {
      params.roll = clamp(params.roll, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the horizontal field of view.
   * @param {number} min The minimum horizontal field of view.
   * @param {number} max The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  hfov: function(min, max) {
    return function limitHfov(params) {
      var width = params.width;
      var height = params.height;
      if (width > 0 && height > 0) {
        var vmin = convertFov.htov(min, width, height);
        var vmax = convertFov.htov(max, width, height);
        params.fov = clamp(params.fov, vmin, vmax);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the vertical field of view.
   * @param {number} min The minimum vertical field of view.
   * @param {number} max The maximum vertical field of view.
   * @return {RectilinearViewLimiter}
   */
  vfov: function(min, max) {
    return function limitVfov(params) {
      params.fov = clamp(params.fov, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The cube face width in pixels or, equivalently, one
   *     fourth of the equirectangular width in pixels.
   * @return {RectilinearViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      var height = params.height;
      if (height) {
        var requiredPixels = pixelRatio() * height;
        var minFov = 2 * Math.atan(requiredPixels / size);
        params.fov = clamp(params.fov, minFov, Infinity);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that limits the horizontal and vertical field of
   * view, prevents zooming in past the image resolution, and limits the pitch
   * range to prevent the camera wrapping around at the poles. These are the
   * most common view constraints for a 360 panorama.
   * @param {number} maxResolution The cube face width in pixels or,
   *     equivalently, one fourth of the equirectangular width in pixels.
   * @param {number} maxVFov The maximum vertical field of view.
   * @param {number} [maxHFov=maxVFov] The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  traditional: function(maxResolution, maxVFov, maxHFov) {
    maxHFov = maxHFov != null ? maxHFov : maxVFov;

    return compose(
      RectilinearView.limit.resolution(maxResolution),
      RectilinearView.limit.vfov(0, maxVFov),
      RectilinearView.limit.hfov(0, maxHFov),
      RectilinearView.limit.pitch(-Math.PI/2, Math.PI/2));
  }

};


RectilinearView.type = RectilinearView.prototype.type = 'rectilinear';


module.exports = RectilinearView;

},{"../util/clamp":90,"../util/clearOwnProperties":91,"../util/compose":93,"../util/convertFov":94,"../util/decimal":95,"../util/mod":106,"../util/pixelRatio":110,"../util/real":113,"gl-matrix":3,"minimal-event-emitter":14}]},{},[56])(56)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYm93c2VyL2VzNS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvbWF0Mi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDJkLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9xdWF0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvcXVhdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy92ZWMyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvdmVjMy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL3ZlYzQuanMiLCJub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzIiwibm9kZV9tb2R1bGVzL21pbmltYWwtZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsInNyYy9Ib3RzcG90LmpzIiwic3JjL0hvdHNwb3RDb250YWluZXIuanMiLCJzcmMvTGF5ZXIuanMiLCJzcmMvTmV0d29ya0Vycm9yLmpzIiwic3JjL1JlbmRlckxvb3AuanMiLCJzcmMvU2NlbmUuanMiLCJzcmMvVGV4dHVyZVN0b3JlLmpzIiwic3JjL1RpbGVTZWFyY2hlci5qcyIsInNyYy9UaW1lci5qcyIsInNyYy9WaWV3ZXIuanMiLCJzcmMvYXNzZXRzL0R5bmFtaWMuanMiLCJzcmMvYXNzZXRzL0ZsYXNoLmpzIiwic3JjL2Fzc2V0cy9TdGF0aWMuanMiLCJzcmMvYXV0b3JvdGF0ZS5qcyIsInNyYy9jb2xsZWN0aW9ucy9McnVNYXAuanMiLCJzcmMvY29sbGVjdGlvbnMvTHJ1U2V0LmpzIiwic3JjL2NvbGxlY3Rpb25zL01hcC5qcyIsInNyYy9jb2xsZWN0aW9ucy9TZXQuanMiLCJzcmMvY29sbGVjdGlvbnMvV29ya1Bvb2wuanMiLCJzcmMvY29sbGVjdGlvbnMvV29ya1F1ZXVlLmpzIiwic3JjL2NvbG9yRWZmZWN0cy5qcyIsInNyYy9jb250cm9scy9Db21wb3Nlci5qcyIsInNyYy9jb250cm9scy9Db250cm9sQ3Vyc29yLmpzIiwic3JjL2NvbnRyb2xzL0NvbnRyb2xzLmpzIiwic3JjL2NvbnRyb2xzL0RyYWcuanMiLCJzcmMvY29udHJvbHMvRHluYW1pY3MuanMiLCJzcmMvY29udHJvbHMvRWxlbWVudFByZXNzLmpzIiwic3JjL2NvbnRyb2xzL0hhbW1lckdlc3R1cmVzLmpzIiwic3JjL2NvbnRyb2xzL0tleS5qcyIsInNyYy9jb250cm9scy9QaW5jaFpvb20uanMiLCJzcmMvY29udHJvbHMvUXR2ci5qcyIsInNyYy9jb250cm9scy9TY3JvbGxab29tLmpzIiwic3JjL2NvbnRyb2xzL1ZlbG9jaXR5LmpzIiwic3JjL2NvbnRyb2xzL1doZWVsTGlzdGVuZXIuanMiLCJzcmMvY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvdXRpbC5qcyIsInNyYy9nZW9tZXRyaWVzL0N1YmUuanMiLCJzcmMvZ2VvbWV0cmllcy9FcXVpcmVjdC5qcyIsInNyYy9nZW9tZXRyaWVzL0ZsYXQuanMiLCJzcmMvZ2VvbWV0cmllcy9MZXZlbC5qcyIsInNyYy9nZW9tZXRyaWVzL2NvbW1vbi5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXJzL0ZsYXNoSW1hZ2UuanMiLCJzcmMvbG9hZGVycy9IdG1sSW1hZ2UuanMiLCJzcmMvcmVuZGVyZXJzL0Nzc0Jhc2UuanMiLCJzcmMvcmVuZGVyZXJzL0Nzc0N1YmUuanMiLCJzcmMvcmVuZGVyZXJzL0Nzc0ZsYXQuanMiLCJzcmMvcmVuZGVyZXJzL0ZsYXNoQmFzZS5qcyIsInNyYy9yZW5kZXJlcnMvRmxhc2hDdWJlLmpzIiwic3JjL3JlbmRlcmVycy9GbGFzaEZsYXQuanMiLCJzcmMvcmVuZGVyZXJzL1dlYkdsQmFzZS5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xDb21tb24uanMiLCJzcmMvcmVuZGVyZXJzL1dlYkdsQ3ViZS5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xFcXVpcmVjdC5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xGbGF0LmpzIiwic3JjL3JlbmRlcmVycy9yZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMuanMiLCJzcmMvc2hhZGVycy9mcmFnbWVudEVxdWlyZWN0LmpzIiwic3JjL3NoYWRlcnMvZnJhZ21lbnROb3JtYWwuanMiLCJzcmMvc2hhZGVycy92ZXJ0ZXhFcXVpcmVjdC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleE5vcm1hbC5qcyIsInNyYy9zb3VyY2VzL0ltYWdlVXJsLmpzIiwic3JjL3NvdXJjZXMvU2luZ2xlQXNzZXQuanMiLCJzcmMvc3RhZ2VzL0Nzcy5qcyIsInNyYy9zdGFnZXMvRmxhc2guanMiLCJzcmMvc3RhZ2VzL1JlbmRlcmVyUmVnaXN0cnkuanMiLCJzcmMvc3RhZ2VzL1N0YWdlLmpzIiwic3JjL3N0YWdlcy9XZWJHbC5qcyIsInNyYy9zdXBwb3J0L0Nzcy5qcyIsInNyYy9zdXBwb3J0L0ZsYXNoLmpzIiwic3JjL3N1cHBvcnQvV2ViR2wuanMiLCJzcmMvc3VwcG9ydC9jc3NQb2ludGVyRXZlbnRzLmpzIiwic3JjL3V0aWwvYXN5bmMuanMiLCJzcmMvdXRpbC9jYWxjUmVjdC5qcyIsInNyYy91dGlsL2NhbmNlbGl6ZS5qcyIsInNyYy91dGlsL2NoYWluLmpzIiwic3JjL3V0aWwvY2xhbXAuanMiLCJzcmMvdXRpbC9jbGVhck93blByb3BlcnRpZXMuanMiLCJzcmMvdXRpbC9jbXAuanMiLCJzcmMvdXRpbC9jb21wb3NlLmpzIiwic3JjL3V0aWwvY29udmVydEZvdi5qcyIsInNyYy91dGlsL2RlY2ltYWwuanMiLCJzcmMvdXRpbC9kZWZhdWx0cy5qcyIsInNyYy91dGlsL2RlZmVyLmpzIiwic3JjL3V0aWwvZGVnVG9SYWQuanMiLCJzcmMvdXRpbC9kZWxheS5qcyIsInNyYy91dGlsL2RvbS5qcyIsInNyYy91dGlsL2V4dGVuZC5qcyIsInNyYy91dGlsL2dsb2JhbC5qcyIsInNyYy91dGlsL2hhc2guanMiLCJzcmMvdXRpbC9pbmhlcml0cy5qcyIsInNyYy91dGlsL2lzcG90LmpzIiwic3JjL3V0aWwvbW9kLmpzIiwic3JjL3V0aWwvbm9vcC5qcyIsInNyYy91dGlsL25vdy5qcyIsInNyYy91dGlsL29uY2UuanMiLCJzcmMvdXRpbC9waXhlbFJhdGlvLmpzIiwic3JjL3V0aWwvcG9zaXRpb25BYnNvbHV0ZWx5LmpzIiwic3JjL3V0aWwvcmFkVG9EZWcuanMiLCJzcmMvdXRpbC9yZWFsLmpzIiwic3JjL3V0aWwvcmV0cnkuanMiLCJzcmMvdXRpbC90d2Vlbi5qcyIsInNyYy91dGlsL3R5cGUuanMiLCJzcmMvdmlld3MvRmxhdC5qcyIsInNyYy92aWV3cy9SZWN0aWxpbmVhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNycUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5ib3dzZXI9dCgpOmUuYm93c2VyPXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihpKXtpZih0W2ldKXJldHVybiB0W2ldLmV4cG9ydHM7dmFyIG49dFtpXT17aTppLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbaV0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsciksbi5sPSEwLG4uZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxpKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6aX0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbiBpbiBlKXIuZChpLG4sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxuKSk7cmV0dXJuIGl9LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz05MCl9KHsxNzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIGk9cigxOCksbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUuZ2V0Rmlyc3RNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjAmJnJbMV18fFwiXCJ9LGUuZ2V0U2Vjb25kTWF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10Lm1hdGNoKGUpO3JldHVybiByJiZyLmxlbmd0aD4xJiZyWzJdfHxcIlwifSxlLm1hdGNoQW5kUmV0dXJuQ29uc3Q9ZnVuY3Rpb24oZSx0LHIpe2lmKGUudGVzdCh0KSlyZXR1cm4gcn0sZS5nZXRXaW5kb3dzVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIk5UXCI6cmV0dXJuXCJOVFwiO2Nhc2VcIlhQXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMFwiOnJldHVyblwiMjAwMFwiO2Nhc2VcIk5UIDUuMVwiOnJldHVyblwiWFBcIjtjYXNlXCJOVCA1LjJcIjpyZXR1cm5cIjIwMDNcIjtjYXNlXCJOVCA2LjBcIjpyZXR1cm5cIlZpc3RhXCI7Y2FzZVwiTlQgNi4xXCI6cmV0dXJuXCI3XCI7Y2FzZVwiTlQgNi4yXCI6cmV0dXJuXCI4XCI7Y2FzZVwiTlQgNi4zXCI6cmV0dXJuXCI4LjFcIjtjYXNlXCJOVCAxMC4wXCI6cmV0dXJuXCIxMFwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRNYWNPU1ZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwxMD09PXRbMF0pc3dpdGNoKHRbMV0pe2Nhc2UgNTpyZXR1cm5cIkxlb3BhcmRcIjtjYXNlIDY6cmV0dXJuXCJTbm93IExlb3BhcmRcIjtjYXNlIDc6cmV0dXJuXCJMaW9uXCI7Y2FzZSA4OnJldHVyblwiTW91bnRhaW4gTGlvblwiO2Nhc2UgOTpyZXR1cm5cIk1hdmVyaWNrc1wiO2Nhc2UgMTA6cmV0dXJuXCJZb3NlbWl0ZVwiO2Nhc2UgMTE6cmV0dXJuXCJFbCBDYXBpdGFuXCI7Y2FzZSAxMjpyZXR1cm5cIlNpZXJyYVwiO2Nhc2UgMTM6cmV0dXJuXCJIaWdoIFNpZXJyYVwiO2Nhc2UgMTQ6cmV0dXJuXCJNb2phdmVcIjtjYXNlIDE1OnJldHVyblwiQ2F0YWxpbmFcIjtkZWZhdWx0OnJldHVybn19LGUuZ2V0QW5kcm9pZFZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwhKDE9PT10WzBdJiZ0WzFdPDUpKXJldHVybiAxPT09dFswXSYmdFsxXTw2P1wiQ3VwY2FrZVwiOjE9PT10WzBdJiZ0WzFdPj02P1wiRG9udXRcIjoyPT09dFswXSYmdFsxXTwyP1wiRWNsYWlyXCI6Mj09PXRbMF0mJjI9PT10WzFdP1wiRnJveW9cIjoyPT09dFswXSYmdFsxXT4yP1wiR2luZ2VyYnJlYWRcIjozPT09dFswXT9cIkhvbmV5Y29tYlwiOjQ9PT10WzBdJiZ0WzFdPDE/XCJJY2UgQ3JlYW0gU2FuZHdpY2hcIjo0PT09dFswXSYmdFsxXTw0P1wiSmVsbHkgQmVhblwiOjQ9PT10WzBdJiZ0WzFdPj00P1wiS2l0S2F0XCI6NT09PXRbMF0/XCJMb2xsaXBvcFwiOjY9PT10WzBdP1wiTWFyc2htYWxsb3dcIjo3PT09dFswXT9cIk5vdWdhdFwiOjg9PT10WzBdP1wiT3Jlb1wiOjk9PT10WzBdP1wiUGllXCI6dm9pZCAwfSxlLmdldFZlcnNpb25QcmVjaXNpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCIuXCIpLmxlbmd0aH0sZS5jb21wYXJlVmVyc2lvbnM9ZnVuY3Rpb24odCxyLGkpe3ZvaWQgMD09PWkmJihpPSExKTt2YXIgbj1lLmdldFZlcnNpb25QcmVjaXNpb24odCkscz1lLmdldFZlcnNpb25QcmVjaXNpb24ociksbz1NYXRoLm1heChuLHMpLGE9MCx1PWUubWFwKFt0LHJdLChmdW5jdGlvbih0KXt2YXIgcj1vLWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxpPXQrbmV3IEFycmF5KHIrMSkuam9pbihcIi4wXCIpO3JldHVybiBlLm1hcChpLnNwbGl0KFwiLlwiKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBBcnJheSgyMC1lLmxlbmd0aCkuam9pbihcIjBcIikrZX0pKS5yZXZlcnNlKCl9KSk7Zm9yKGkmJihhPW8tTWF0aC5taW4obixzKSksby09MTtvPj1hOyl7aWYodVswXVtvXT51WzFdW29dKXJldHVybiAxO2lmKHVbMF1bb109PT11WzFdW29dKXtpZihvPT09YSlyZXR1cm4gMDtvLT0xfWVsc2UgaWYodVswXVtvXTx1WzFdW29dKXJldHVybi0xfX0sZS5tYXA9ZnVuY3Rpb24oZSx0KXt2YXIgcixpPVtdO2lmKEFycmF5LnByb3RvdHlwZS5tYXApcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLHQpO2ZvcihyPTA7cjxlLmxlbmd0aDtyKz0xKWkucHVzaCh0KGVbcl0pKTtyZXR1cm4gaX0sZS5nZXRCcm93c2VyQWxpYXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGkuQlJPV1NFUl9BTElBU0VTX01BUFtlXX0sZS5nZXRCcm93c2VyVHlwZUJ5QWxpYXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGkuQlJPV1NFUl9NQVBbZV18fFwiXCJ9LGV9KCk7dC5kZWZhdWx0PW4sZS5leHBvcnRzPXQuZGVmYXVsdH0sMTg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LkVOR0lORV9NQVA9dC5PU19NQVA9dC5QTEFURk9STVNfTUFQPXQuQlJPV1NFUl9NQVA9dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXZvaWQgMDt0LkJST1dTRVJfQUxJQVNFU19NQVA9e1wiQW1hem9uIFNpbGtcIjpcImFtYXpvbl9zaWxrXCIsXCJBbmRyb2lkIEJyb3dzZXJcIjpcImFuZHJvaWRcIixCYWRhOlwiYmFkYVwiLEJsYWNrQmVycnk6XCJibGFja2JlcnJ5XCIsQ2hyb21lOlwiY2hyb21lXCIsQ2hyb21pdW06XCJjaHJvbWl1bVwiLEVwaXBoYW55OlwiZXBpcGhhbnlcIixGaXJlZm94OlwiZmlyZWZveFwiLEZvY3VzOlwiZm9jdXNcIixHZW5lcmljOlwiZ2VuZXJpY1wiLFwiR29vZ2xlIFNlYXJjaFwiOlwiZ29vZ2xlX3NlYXJjaFwiLEdvb2dsZWJvdDpcImdvb2dsZWJvdFwiLFwiSW50ZXJuZXQgRXhwbG9yZXJcIjpcImllXCIsXCJLLU1lbGVvblwiOlwia19tZWxlb25cIixNYXh0aG9uOlwibWF4dGhvblwiLFwiTWljcm9zb2Z0IEVkZ2VcIjpcImVkZ2VcIixcIk1aIEJyb3dzZXJcIjpcIm16XCIsXCJOQVZFUiBXaGFsZSBCcm93c2VyXCI6XCJuYXZlclwiLE9wZXJhOlwib3BlcmFcIixcIk9wZXJhIENvYXN0XCI6XCJvcGVyYV9jb2FzdFwiLFBoYW50b21KUzpcInBoYW50b21qc1wiLFB1ZmZpbjpcInB1ZmZpblwiLFF1cFppbGxhOlwicXVwemlsbGFcIixRUTpcInFxXCIsUVFMaXRlOlwicXFsaXRlXCIsU2FmYXJpOlwic2FmYXJpXCIsU2FpbGZpc2g6XCJzYWlsZmlzaFwiLFwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwiOlwic2Ftc3VuZ19pbnRlcm5ldFwiLFNlYU1vbmtleTpcInNlYW1vbmtleVwiLFNsZWlwbmlyOlwic2xlaXBuaXJcIixTd2luZzpcInN3aW5nXCIsVGl6ZW46XCJ0aXplblwiLFwiVUMgQnJvd3NlclwiOlwidWNcIixWaXZhbGRpOlwidml2YWxkaVwiLFwiV2ViT1MgQnJvd3NlclwiOlwid2Vib3NcIixXZUNoYXQ6XCJ3ZWNoYXRcIixcIllhbmRleCBCcm93c2VyXCI6XCJ5YW5kZXhcIixSb2t1Olwicm9rdVwifTt0LkJST1dTRVJfTUFQPXthbWF6b25fc2lsazpcIkFtYXpvbiBTaWxrXCIsYW5kcm9pZDpcIkFuZHJvaWQgQnJvd3NlclwiLGJhZGE6XCJCYWRhXCIsYmxhY2tiZXJyeTpcIkJsYWNrQmVycnlcIixjaHJvbWU6XCJDaHJvbWVcIixjaHJvbWl1bTpcIkNocm9taXVtXCIsZXBpcGhhbnk6XCJFcGlwaGFueVwiLGZpcmVmb3g6XCJGaXJlZm94XCIsZm9jdXM6XCJGb2N1c1wiLGdlbmVyaWM6XCJHZW5lcmljXCIsZ29vZ2xlYm90OlwiR29vZ2xlYm90XCIsZ29vZ2xlX3NlYXJjaDpcIkdvb2dsZSBTZWFyY2hcIixpZTpcIkludGVybmV0IEV4cGxvcmVyXCIsa19tZWxlb246XCJLLU1lbGVvblwiLG1heHRob246XCJNYXh0aG9uXCIsZWRnZTpcIk1pY3Jvc29mdCBFZGdlXCIsbXo6XCJNWiBCcm93c2VyXCIsbmF2ZXI6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCIsb3BlcmE6XCJPcGVyYVwiLG9wZXJhX2NvYXN0OlwiT3BlcmEgQ29hc3RcIixwaGFudG9tanM6XCJQaGFudG9tSlNcIixwdWZmaW46XCJQdWZmaW5cIixxdXB6aWxsYTpcIlF1cFppbGxhXCIscXE6XCJRUSBCcm93c2VyXCIscXFsaXRlOlwiUVEgQnJvd3NlciBMaXRlXCIsc2FmYXJpOlwiU2FmYXJpXCIsc2FpbGZpc2g6XCJTYWlsZmlzaFwiLHNhbXN1bmdfaW50ZXJuZXQ6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCIsc2VhbW9ua2V5OlwiU2VhTW9ua2V5XCIsc2xlaXBuaXI6XCJTbGVpcG5pclwiLHN3aW5nOlwiU3dpbmdcIix0aXplbjpcIlRpemVuXCIsdWM6XCJVQyBCcm93c2VyXCIsdml2YWxkaTpcIlZpdmFsZGlcIix3ZWJvczpcIldlYk9TIEJyb3dzZXJcIix3ZWNoYXQ6XCJXZUNoYXRcIix5YW5kZXg6XCJZYW5kZXggQnJvd3NlclwifTt0LlBMQVRGT1JNU19NQVA9e3RhYmxldDpcInRhYmxldFwiLG1vYmlsZTpcIm1vYmlsZVwiLGRlc2t0b3A6XCJkZXNrdG9wXCIsdHY6XCJ0dlwifTt0Lk9TX01BUD17V2luZG93c1Bob25lOlwiV2luZG93cyBQaG9uZVwiLFdpbmRvd3M6XCJXaW5kb3dzXCIsTWFjT1M6XCJtYWNPU1wiLGlPUzpcImlPU1wiLEFuZHJvaWQ6XCJBbmRyb2lkXCIsV2ViT1M6XCJXZWJPU1wiLEJsYWNrQmVycnk6XCJCbGFja0JlcnJ5XCIsQmFkYTpcIkJhZGFcIixUaXplbjpcIlRpemVuXCIsTGludXg6XCJMaW51eFwiLENocm9tZU9TOlwiQ2hyb21lIE9TXCIsUGxheVN0YXRpb240OlwiUGxheVN0YXRpb24gNFwiLFJva3U6XCJSb2t1XCJ9O3QuRU5HSU5FX01BUD17RWRnZUhUTUw6XCJFZGdlSFRNTFwiLEJsaW5rOlwiQmxpbmtcIixUcmlkZW50OlwiVHJpZGVudFwiLFByZXN0bzpcIlByZXN0b1wiLEdlY2tvOlwiR2Vja29cIixXZWJLaXQ6XCJXZWJLaXRcIn19LDkwOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgaSxuPShpPXIoOTEpKSYmaS5fX2VzTW9kdWxlP2k6e2RlZmF1bHQ6aX0scz1yKDE4KTtmdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX12YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHQscixpO3JldHVybiBlLmdldFBhcnNlcj1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQmJih0PSExKSxcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3JldHVybiBuZXcgbi5kZWZhdWx0KGUsdCl9LGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBuLmRlZmF1bHQoZSkuZ2V0UmVzdWx0KCl9LHQ9ZSxpPVt7a2V5OlwiQlJPV1NFUl9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5CUk9XU0VSX01BUH19LHtrZXk6XCJFTkdJTkVfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuRU5HSU5FX01BUH19LHtrZXk6XCJPU19NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5PU19NQVB9fSx7a2V5OlwiUExBVEZPUk1TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLlBMQVRGT1JNU19NQVB9fV0sKHI9bnVsbCkmJm8odC5wcm90b3R5cGUsciksaSYmbyh0LGkpLGV9KCk7dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBpPXUocig5MikpLG49dShyKDkzKSkscz11KHIoOTQpKSxvPXUocig5NSkpLGE9dShyKDE3KSk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLG51bGw9PWV8fFwiXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBwYXJhbWV0ZXIgY2FuJ3QgYmUgZW1wdHlcIik7dGhpcy5fdWE9ZSx0aGlzLnBhcnNlZFJlc3VsdD17fSwhMCE9PXQmJnRoaXMucGFyc2UoKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5nZXRVQT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91YX0sdC50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QodGhpcy5fdWEpfSx0LnBhcnNlQnJvd3Nlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj17fTt2YXIgdD1pLmRlZmF1bHQuZmluZCgoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI9dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyfSx0LmdldEJyb3dzZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj90aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyOnRoaXMucGFyc2VCcm93c2VyKCl9LHQuZ2V0QnJvd3Nlck5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/U3RyaW5nKHRoaXMuZ2V0QnJvd3NlcigpLm5hbWUpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dGhpcy5nZXRCcm93c2VyKCkubmFtZXx8XCJcIn0sdC5nZXRCcm93c2VyVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEJyb3dzZXIoKS52ZXJzaW9ufSx0LmdldE9TPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0Lm9zP3RoaXMucGFyc2VkUmVzdWx0Lm9zOnRoaXMucGFyc2VPUygpfSx0LnBhcnNlT1M9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0Lm9zPXt9O3ZhciB0PW4uZGVmYXVsdC5maW5kKChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQub3M9dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5vc30sdC5nZXRPU05hbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRPUygpLm5hbWU7cmV0dXJuIGU/U3RyaW5nKHQpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dHx8XCJcIn0sdC5nZXRPU1ZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRPUygpLnZlcnNpb259LHQuZ2V0UGxhdGZvcm09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm0/dGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm06dGhpcy5wYXJzZVBsYXRmb3JtKCl9LHQuZ2V0UGxhdGZvcm1UeXBlPWZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgdD10aGlzLmdldFBsYXRmb3JtKCkudHlwZTtyZXR1cm4gZT9TdHJpbmcodCkudG9Mb3dlckNhc2UoKXx8XCJcIjp0fHxcIlwifSx0LnBhcnNlUGxhdGZvcm09ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtPXt9O3ZhciB0PXMuZGVmYXVsdC5maW5kKChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybX0sdC5nZXRFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lP3RoaXMucGFyc2VkUmVzdWx0LmVuZ2luZTp0aGlzLnBhcnNlRW5naW5lKCl9LHQuZ2V0RW5naW5lTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gZT9TdHJpbmcodGhpcy5nZXRFbmdpbmUoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0RW5naW5lKCkubmFtZXx8XCJcIn0sdC5wYXJzZUVuZ2luZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lfSx0LnBhcnNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VCcm93c2VyKCksdGhpcy5wYXJzZU9TKCksdGhpcy5wYXJzZVBsYXRmb3JtKCksdGhpcy5wYXJzZUVuZ2luZSgpLHRoaXN9LHQuZ2V0UmVzdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sdGhpcy5wYXJzZWRSZXN1bHQpfSx0LnNhdGlzZmllcz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9e30saT0wLG49e30scz0wO2lmKE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBvPWVbdF07XCJzdHJpbmdcIj09dHlwZW9mIG8/KG5bdF09byxzKz0xKTpcIm9iamVjdFwiPT10eXBlb2YgbyYmKHJbdF09byxpKz0xKX0pKSxpPjApe3ZhciBvPU9iamVjdC5rZXlzKHIpLGE9by5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc09TKGUpfSkpO2lmKGEpe3ZhciB1PXRoaXMuc2F0aXNmaWVzKHJbYV0pO2lmKHZvaWQgMCE9PXUpcmV0dXJuIHV9dmFyIGQ9by5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc1BsYXRmb3JtKGUpfSkpO2lmKGQpe3ZhciBjPXRoaXMuc2F0aXNmaWVzKHJbZF0pO2lmKHZvaWQgMCE9PWMpcmV0dXJuIGN9fWlmKHM+MCl7dmFyIGY9T2JqZWN0LmtleXMobikuZmluZCgoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXNCcm93c2VyKGUsITApfSkpO2lmKHZvaWQgMCE9PWYpcmV0dXJuIHRoaXMuY29tcGFyZVZlcnNpb24obltmXSl9fSx0LmlzQnJvd3Nlcj1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSExKTt2YXIgcj10aGlzLmdldEJyb3dzZXJOYW1lKCkudG9Mb3dlckNhc2UoKSxpPWUudG9Mb3dlckNhc2UoKSxuPWEuZGVmYXVsdC5nZXRCcm93c2VyVHlwZUJ5QWxpYXMoaSk7cmV0dXJuIHQmJm4mJihpPW4udG9Mb3dlckNhc2UoKSksaT09PXJ9LHQuY29tcGFyZVZlcnNpb249ZnVuY3Rpb24oZSl7dmFyIHQ9WzBdLHI9ZSxpPSExLG49dGhpcy5nZXRCcm93c2VyVmVyc2lvbigpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXJldHVyblwiPlwiPT09ZVswXXx8XCI8XCI9PT1lWzBdPyhyPWUuc3Vic3RyKDEpLFwiPVwiPT09ZVsxXT8oaT0hMCxyPWUuc3Vic3RyKDIpKTp0PVtdLFwiPlwiPT09ZVswXT90LnB1c2goMSk6dC5wdXNoKC0xKSk6XCI9XCI9PT1lWzBdP3I9ZS5zdWJzdHIoMSk6XCJ+XCI9PT1lWzBdJiYoaT0hMCxyPWUuc3Vic3RyKDEpKSx0LmluZGV4T2YoYS5kZWZhdWx0LmNvbXBhcmVWZXJzaW9ucyhuLHIsaSkpPi0xfSx0LmlzT1M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0T1NOYW1lKCEwKT09PVN0cmluZyhlKS50b0xvd2VyQ2FzZSgpfSx0LmlzUGxhdGZvcm09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0UGxhdGZvcm1UeXBlKCEwKT09PVN0cmluZyhlKS50b0xvd2VyQ2FzZSgpfSx0LmlzRW5naW5lPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldEVuZ2luZU5hbWUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaXNCcm93c2VyKGUpfHx0aGlzLmlzT1MoZSl8fHRoaXMuaXNQbGF0Zm9ybShlKX0sdC5zb21lPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHZvaWQgMD09PWUmJihlPVtdKSxlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzKGUpfSkpfSxlfSgpO3QuZGVmYXVsdD1kLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgaSxuPShpPXIoMTcpKSYmaS5fX2VzTW9kdWxlP2k6e2RlZmF1bHQ6aX07dmFyIHM9L3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksbz1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJHb29nbGVib3RcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2ksZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3BlcmEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYVwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcGVyYSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3ByXFwvfG9waW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmFcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHMvXShcXFMrKS9pLGUpfHxuLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1NhbXN1bmdCcm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpTYW1zdW5nQnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvV2hhbGUvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OndoYWxlKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01aQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1aIEJyb3dzZXJcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TVpCcm93c2VyKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxuLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZvY3VzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRm9jdXNcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc3dpbmcvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTd2luZ1wifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpzd2luZylbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jb2FzdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhIENvYXN0XCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNvYXN0KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy95YWJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJZYW5kZXggQnJvd3NlclwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp5YWJyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxuLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3VjYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlVDIEJyb3dzZXJcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxuLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86dWNicm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NYXh0aG9ufG14aW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWF4dGhvblwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpNYXh0aG9ufG14aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lcGlwaGFueS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkVwaXBoYW55XCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmVwaXBoYW55KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9wdWZmaW4vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQdWZmaW5cIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxuLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cHVmZmluKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zbGVpcG5pci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNsZWlwbmlyXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnNsZWlwbmlyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9rLW1lbGVvbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkstTWVsZW9uXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmstbWVsZW9uKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9taWNyb21lc3Nlbmdlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIldlQ2hhdFwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzptaWNyb21lc3NlbmdlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcXFicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOi9xcWJyb3dzZXJsaXRlL2kudGVzdChlKT9cIlFRIEJyb3dzZXIgTGl0ZVwiOlwiUVEgQnJvd3NlclwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpxcWJyb3dzZXJsaXRlfHFxYnJvd3NlcilbL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvbXNpZXx0cmlkZW50L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiSW50ZXJuZXQgRXhwbG9yZXJcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9cXHNlZGdcXC8vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaWNyb3NvZnQgRWRnZVwifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9cXHNlZGdcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZWRnKFtlYV18aW9zKS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pY3Jvc29mdCBFZGdlXCJ9LHI9bi5kZWZhdWx0LmdldFNlY29uZE1hdGNoKC9lZGcoW2VhXXxpb3MpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3ZpdmFsZGkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJWaXZhbGRpXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3ZpdmFsZGlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2VhbW9ua2V5L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2VhTW9ua2V5XCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NlYW1vbmtleVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zYWlsZmlzaC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhaWxmaXNoXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NhaWxmaXNoXFxzP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2lsay9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkFtYXpvbiBTaWxrXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NpbGtcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcGhhbnRvbS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlBoYW50b21KU1wifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2xpbWVyanMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTbGltZXJKU1wifSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zbGltZXJqc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLC9yaW1cXHN0YWJsZXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJCbGFja0JlcnJ5XCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlbXFxkXStcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvKHdlYnxocHcpW28wXXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJXZWJPUyBCcm93c2VyXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3coPzplYik/W28wXXNicm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2JhZGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJCYWRhXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2RvbGZpblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy90aXplbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlRpemVuXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnRpemVuXFxzPyk/YnJvd3NlclxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9xdXB6aWxsYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlF1cFppbGxhXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnF1cHppbGxhKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkZpcmVmb3hcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2Nocm9taXVtL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQ2hyb21pdW1cIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21pdW0pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxuLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2Nocm9tZXxjcmlvc3xjcm1vL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQ2hyb21lXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9HU0EvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJHb29nbGUgU2VhcmNoXCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OkdTQSlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PSFlLnRlc3QoL2xpa2UgYW5kcm9pZC9pKSxyPWUudGVzdCgvYW5kcm9pZC9pKTtyZXR1cm4gdCYmcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJBbmRyb2lkIEJyb3dzZXJcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3BsYXlzdGF0aW9uIDQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQbGF5U3RhdGlvbiA0XCJ9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zYWZhcml8YXBwbGV3ZWJraXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYWZhcmlcIn0scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLy4qL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PS0xIT09ZS5zZWFyY2goXCJcXFxcKFwiKT8vXiguKilcXC8oLiopWyBcXHRdXFwoKC4qKS86L14oLiopXFwvKC4qKSAvO3JldHVybntuYW1lOm4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHQsZSksdmVyc2lvbjpuLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2godCxlKX19fV07dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH0sOTM6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBpLG49KGk9cigxNykpJiZpLl9fZXNNb2R1bGU/aTp7ZGVmYXVsdDppfSxzPXIoMTgpO3ZhciBvPVt7dGVzdDpbL1Jva3VcXC9EVlAvXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvUm9rdVxcL0RWUC0oXFxkK1xcLlxcZCspL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuUm9rdSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy93aW5kb3dzIHBob25lL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93aW5kb3dzIHBob25lICg/Om9zKT9cXHM/KFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLldpbmRvd3NQaG9uZSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy93aW5kb3dzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pLGUpLHI9bi5kZWZhdWx0LmdldFdpbmRvd3NWZXJzaW9uTmFtZSh0KTtyZXR1cm57bmFtZTpzLk9TX01BUC5XaW5kb3dzLHZlcnNpb246dCx2ZXJzaW9uTmFtZTpyfX19LHt0ZXN0OlsvbWFjaW50b3NoL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9tYWMgb3MgeCAoXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSkucmVwbGFjZSgvW19cXHNdL2csXCIuXCIpLHI9bi5kZWZhdWx0LmdldE1hY09TVmVyc2lvbk5hbWUodCksaT17bmFtZTpzLk9TX01BUC5NYWNPUyx2ZXJzaW9uOnR9O3JldHVybiByJiYoaS52ZXJzaW9uTmFtZT1yKSxpfX0se3Rlc3Q6Wy8oaXBvZHxpcGhvbmV8aXBhZCkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL29zIChcXGQrKFtfXFxzXVxcZCspKikgbGlrZSBtYWMgb3MgeC9pLGUpLnJlcGxhY2UoL1tfXFxzXS9nLFwiLlwiKTtyZXR1cm57bmFtZTpzLk9TX01BUC5pT1MsdmVyc2lvbjp0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PSFlLnRlc3QoL2xpa2UgYW5kcm9pZC9pKSxyPWUudGVzdCgvYW5kcm9pZC9pKTtyZXR1cm4gdCYmcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2FuZHJvaWRbXFxzLy1dKFxcZCsoXFwuXFxkKykqKS9pLGUpLHI9bi5kZWZhdWx0LmdldEFuZHJvaWRWZXJzaW9uTmFtZSh0KSxpPXtuYW1lOnMuT1NfTUFQLkFuZHJvaWQsdmVyc2lvbjp0fTtyZXR1cm4gciYmKGkudmVyc2lvbk5hbWU9ciksaX19LHt0ZXN0OlsvKHdlYnxocHcpW28wXXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OndlYnxocHcpW28wXXNcXC8oXFxkKyhcXC5cXGQrKSopL2ksZSkscj17bmFtZTpzLk9TX01BUC5XZWJPU307cmV0dXJuIHQmJnQubGVuZ3RoJiYoci52ZXJzaW9uPXQpLHJ9fSx7dGVzdDpbL2JsYWNrYmVycnl8XFxiYmJcXGQrL2ksL3JpbVxcc3RhYmxldC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcmltXFxzdGFibGV0XFxzb3NcXHMoXFxkKyhcXC5cXGQrKSopL2ksZSl8fG4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5XFxkK1xcLyhcXGQrKFtfXFxzXVxcZCspKikvaSxlKXx8bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1xcYmJiKFxcZCspL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuQmxhY2tCZXJyeSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy9iYWRhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9iYWRhXFwvKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLkJhZGEsdmVyc2lvbjp0fX19LHt0ZXN0OlsvdGl6ZW4vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3RpemVuWy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlRpemVuLHZlcnNpb246dH19fSx7dGVzdDpbL2xpbnV4L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5PU19NQVAuTGludXh9fX0se3Rlc3Q6Wy9Dck9TL10sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLk9TX01BUC5DaHJvbWVPU319fSx7dGVzdDpbL1BsYXlTdGF0aW9uIDQvXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvUGxheVN0YXRpb24gNFsvXFxzXShcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5QbGF5U3RhdGlvbjQsdmVyc2lvbjp0fX19XTt0LmRlZmF1bHQ9byxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5NDpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIGksbj0oaT1yKDE3KSkmJmkuX19lc01vZHVsZT9pOntkZWZhdWx0Oml9LHM9cigxOCk7dmFyIG89W3t0ZXN0OlsvZ29vZ2xlYm90L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJib3RcIix2ZW5kb3I6XCJHb29nbGVcIn19fSx7dGVzdDpbL2h1YXdlaS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKGNhbi1sMDEpL2ksZSkmJlwiTm92YVwiLHI9e3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJIdWF3ZWlcIn07cmV0dXJuIHQmJihyLm1vZGVsPXQpLHJ9fSx7dGVzdDpbL25leHVzXFxzKig/Ojd8OHw5fDEwKS4qL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJOZXh1c1wifX19LHt0ZXN0OlsvaXBhZC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQXBwbGVcIixtb2RlbDpcImlQYWRcIn19fSx7dGVzdDpbL2tmdHQgYnVpbGQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFtYXpvblwiLG1vZGVsOlwiS2luZGxlIEZpcmUgSEQgN1wifX19LHt0ZXN0Olsvc2lsay9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQW1hem9uXCJ9fX0se3Rlc3Q6Wy90YWJsZXQoPyEgcGMpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldH19fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRlc3QoL2lwb2R8aXBob25lL2kpLHI9ZS50ZXN0KC9saWtlIChpcG9kfGlwaG9uZSkvaSk7cmV0dXJuIHQmJiFyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKGlwb2R8aXBob25lKS9pLGUpO3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiQXBwbGVcIixtb2RlbDp0fX19LHt0ZXN0OlsvbmV4dXNcXHMqWzAtNl0uKi9pLC9nYWxheHkgbmV4dXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIk5leHVzXCJ9fX0se3Rlc3Q6Wy9bXi1dbW9iaS9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJibGFja2JlcnJ5XCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkJsYWNrQmVycnlcIn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImJhZGFcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJ3aW5kb3dzIHBob25lXCI9PT1lLmdldEJyb3dzZXJOYW1lKCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJNaWNyb3NvZnRcIn19fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1OdW1iZXIoU3RyaW5nKGUuZ2V0T1NWZXJzaW9uKCkpLnNwbGl0KFwiLlwiKVswXSk7cmV0dXJuXCJhbmRyb2lkXCI9PT1lLmdldE9TTmFtZSghMCkmJnQ+PTN9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImFuZHJvaWRcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwibWFjb3NcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcCx2ZW5kb3I6XCJBcHBsZVwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwid2luZG93c1wiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwibGludXhcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cInBsYXlzdGF0aW9uIDRcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudHZ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJyb2t1XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnR2fX19XTt0LmRlZmF1bHQ9byxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5NTpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIGksbj0oaT1yKDE3KSkmJmkuX19lc01vZHVsZT9pOntkZWZhdWx0Oml9LHM9cigxOCk7dmFyIG89W3t0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwibWljcm9zb2Z0IGVkZ2VcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbihlKXtpZigvXFxzZWRnXFwvL2kudGVzdChlKSlyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuQmxpbmt9O3ZhciB0PW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9lZGdlXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybntuYW1lOnMuRU5HSU5FX01BUC5FZGdlSFRNTCx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy90cmlkZW50L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5UcmlkZW50fSxyPW4uZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC90cmlkZW50XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm4gZS50ZXN0KC9wcmVzdG8vaSl9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5QcmVzdG99LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3ByZXN0b1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50ZXN0KC9nZWNrby9pKSxyPWUudGVzdCgvbGlrZSBnZWNrby9pKTtyZXR1cm4gdCYmIXJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5HZWNrb30scj1uLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZ2Vja29cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvKGFwcGxlKT93ZWJraXRcXC81MzdcXC4zNi9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuRU5HSU5FX01BUC5CbGlua319fSx7dGVzdDpbLyhhcHBsZSk/d2Via2l0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5XZWJLaXR9LHI9bi5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3dlYmtpdFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX1dO3QuZGVmYXVsdD1vLGUuZXhwb3J0cz10LmRlZmF1bHR9fSl9KSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldE1hdHJpeEFycmF5VHlwZSA9IHNldE1hdHJpeEFycmF5VHlwZTtcbmV4cG9ydHMudG9SYWRpYW4gPSB0b1JhZGlhbjtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5SQU5ET00gPSBleHBvcnRzLkFSUkFZX1RZUEUgPSBleHBvcnRzLkVQU0lMT04gPSB2b2lkIDA7XG5cbi8qKlxyXG4gKiBDb21tb24gdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcclxuICovXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xudmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydHMuRVBTSUxPTiA9IEVQU0lMT047XG52YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnRzLkFSUkFZX1RZUEUgPSBBUlJBWV9UWVBFO1xudmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcclxuICovXG5cbmV4cG9ydHMuUkFORE9NID0gUkFORE9NO1xuXG5mdW5jdGlvbiBzZXRNYXRyaXhBcnJheVR5cGUodHlwZSkge1xuICBleHBvcnRzLkFSUkFZX1RZUEUgPSBBUlJBWV9UWVBFID0gdHlwZTtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcclxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcclxuICovXG5cbmZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG4vKipcclxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxyXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXHJcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5cbmlmICghTWF0aC5oeXBvdCkgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHkgPSAwLFxuICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHkgKz0gYXJndW1lbnRzW2ldICogYXJndW1lbnRzW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydCh5KTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlYzQgPSBleHBvcnRzLnZlYzMgPSBleHBvcnRzLnZlYzIgPSBleHBvcnRzLnF1YXQyID0gZXhwb3J0cy5xdWF0ID0gZXhwb3J0cy5tYXQ0ID0gZXhwb3J0cy5tYXQzID0gZXhwb3J0cy5tYXQyZCA9IGV4cG9ydHMubWF0MiA9IGV4cG9ydHMuZ2xNYXRyaXggPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmV4cG9ydHMuZ2xNYXRyaXggPSBnbE1hdHJpeDtcblxudmFyIG1hdDIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQyLmpzXCIpKTtcblxuZXhwb3J0cy5tYXQyID0gbWF0MjtcblxudmFyIG1hdDJkID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0MmQuanNcIikpO1xuXG5leHBvcnRzLm1hdDJkID0gbWF0MmQ7XG5cbnZhciBtYXQzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0My5qc1wiKSk7XG5cbmV4cG9ydHMubWF0MyA9IG1hdDM7XG5cbnZhciBtYXQ0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0NC5qc1wiKSk7XG5cbmV4cG9ydHMubWF0NCA9IG1hdDQ7XG5cbnZhciBxdWF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcXVhdC5qc1wiKSk7XG5cbmV4cG9ydHMucXVhdCA9IHF1YXQ7XG5cbnZhciBxdWF0MiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1YXQyLmpzXCIpKTtcblxuZXhwb3J0cy5xdWF0MiA9IHF1YXQyO1xuXG52YXIgdmVjMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzIuanNcIikpO1xuXG5leHBvcnRzLnZlYzIgPSB2ZWMyO1xuXG52YXIgdmVjMyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzMuanNcIikpO1xuXG5leHBvcnRzLnZlYzMgPSB2ZWMzO1xuXG52YXIgdmVjNCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3ZlYzQuanNcIikpO1xuXG5leHBvcnRzLnZlYzQgPSB2ZWM0O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmZyb21Sb3RhdGlvbiA9IGZyb21Sb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVNjYWxpbmcgPSBmcm9tU2NhbGluZztcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5mcm9iID0gZnJvYjtcbmV4cG9ydHMuTERVID0gTERVO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuc3ViID0gZXhwb3J0cy5tdWwgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKipcclxuICogMngyIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcclxuICpcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0xMDtcbiAgb3V0WzNdID0gbTExO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSBhMCAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICB2YXIgYTAgPSBhWzBdO1xuICBvdXRbMF0gPSBhWzNdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGEwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcclxuICovXG5cblxuZnVuY3Rpb24gTERVKEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0gLyBhWzBdO1xuICBVWzBdID0gYVswXTtcbiAgVVsxXSA9IGFbMV07XG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07XG4gIHJldHVybiBbTCwgRCwgVV07XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmRldGVybWluYW50ID0gZGV0ZXJtaW5hbnQ7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLmZyb21UcmFuc2xhdGlvbiA9IGZyb21UcmFuc2xhdGlvbjtcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5mcm9iID0gZnJvYjtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhciA9IG11bHRpcGx5U2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhckFuZEFkZCA9IG11bHRpcGx5U2NhbGFyQW5kQWRkO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXHJcbiAqIDJ4MyBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQyZFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcclxuICogPHByZT5cclxuICogW2EsIGIsIGMsXHJcbiAqICBkLCB0eCwgdHldXHJcbiAqIDwvcHJlPlxyXG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBiLCAwLFxyXG4gKiAgYywgZCwgMCxcclxuICogIHR4LCB0eSwgMV1cclxuICogPC9wcmU+XHJcbiAqIFRoZSBsYXN0IGNvbHVtbiBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MmQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXSxcbiAgICAgIGFiID0gYVsxXSxcbiAgICAgIGFjID0gYVsyXSxcbiAgICAgIGFkID0gYVszXTtcbiAgdmFyIGF0eCA9IGFbNF0sXG4gICAgICBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDtcbiAgb3V0WzFdID0gYTE7XG4gIG91dFsyXSA9IGEyO1xuICBvdXRbM10gPSBhMztcbiAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0MmQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdlswXTtcbiAgb3V0WzVdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCAxKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDJkJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgc3ViID0gc3VidHJhY3Q7XG5leHBvcnRzLnN1YiA9IHN1YjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5mcm9tTWF0NCA9IGZyb21NYXQ0O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21TY2FsaW5nID0gZnJvbVNjYWxpbmc7XG5leHBvcnRzLmZyb21NYXQyZCA9IGZyb21NYXQyZDtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMubm9ybWFsRnJvbU1hdDQgPSBub3JtYWxGcm9tTWF0NDtcbmV4cG9ydHMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxyXG4gKiAzeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0M1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDQob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbNF07XG4gIG91dFs0XSA9IGFbNV07XG4gIG91dFs1XSA9IGFbNl07XG4gIG91dFs2XSA9IGFbOF07XG4gIG91dFs3XSA9IGFbOV07XG4gIG91dFs4XSA9IGFbMTBdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMiA9IGFbNV07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGEwMTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGEwMjtcbiAgICBvdXRbN10gPSBhMTI7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYVsxXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYVsyXTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IGFbOF07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gIHZhciBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGIwMSAqIGRldDtcbiAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgb3V0WzNdID0gYjExICogZGV0O1xuICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIG91dFswXSA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgb3V0WzFdID0gYTAyICogYTIxIC0gYTAxICogYTIyO1xuICBvdXRbMl0gPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIG91dFszXSA9IGExMiAqIGEyMCAtIGExMCAqIGEyMjtcbiAgb3V0WzRdID0gYTAwICogYTIyIC0gYTAyICogYTIwO1xuICBvdXRbNV0gPSBhMDIgKiBhMTAgLSBhMDAgKiBhMTI7XG4gIG91dFs2XSA9IGExMCAqIGEyMSAtIGExMSAqIGEyMDtcbiAgb3V0WzddID0gYTAxICogYTIwIC0gYTAwICogYTIxO1xuICBvdXRbOF0gPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgICAgYjAxID0gYlsxXSxcbiAgICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgICAgYjExID0gYls0XSxcbiAgICAgIGIxMiA9IGJbNV07XG4gIHZhciBiMjAgPSBiWzZdLFxuICAgICAgYjIxID0gYls3XSxcbiAgICAgIGIyMiA9IGJbOF07XG4gIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG4gIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuO1xuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0geCAqIGFbMF07XG4gIG91dFsxXSA9IHggKiBhWzFdO1xuICBvdXRbMl0gPSB4ICogYVsyXTtcbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gdlsxXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSBhWzRdO1xuICBvdXRbN10gPSBhWzVdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4qXHJcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4qIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4qXHJcbiogQHJldHVybnMge21hdDN9IG91dFxyXG4qL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XHJcbipcclxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cclxuKlxyXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcclxuKi9cblxuXG5mdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gLTE7XG4gIG91dFs3XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cblxuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XSxcbiAgICAgIGE4ID0gYVs4XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XSxcbiAgICAgIGI4ID0gYls4XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgc3ViID0gc3VidHJhY3Q7XG5leHBvcnRzLnN1YiA9IHN1YjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmFkam9pbnQgPSBhZGpvaW50O1xuZXhwb3J0cy5kZXRlcm1pbmFudCA9IGRldGVybWluYW50O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21YUm90YXRpb24gPSBmcm9tWFJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tWVJvdGF0aW9uID0gZnJvbVlSb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVpSb3RhdGlvbiA9IGZyb21aUm90YXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21RdWF0MiA9IGZyb21RdWF0MjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuZ2V0U2NhbGluZyA9IGdldFNjYWxpbmc7XG5leHBvcnRzLmdldFJvdGF0aW9uID0gZ2V0Um90YXRpb247XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbjtcbmV4cG9ydHMuZnJvbVF1YXQgPSBmcm9tUXVhdDtcbmV4cG9ydHMuZnJ1c3R1bSA9IGZydXN0dW07XG5leHBvcnRzLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG5leHBvcnRzLnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3ID0gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc7XG5leHBvcnRzLm9ydGhvID0gb3J0aG87XG5leHBvcnRzLmxvb2tBdCA9IGxvb2tBdDtcbmV4cG9ydHMudGFyZ2V0VG8gPSB0YXJnZXRUbztcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5mcm9iID0gZnJvYjtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhciA9IG11bHRpcGx5U2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhckFuZEFkZCA9IG11bHRpcGx5U2NhbGFyQW5kQWRkO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLnN1YiA9IGV4cG9ydHMubXVsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgb3V0WzBdID0gYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpO1xuICBvdXRbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSA9IGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzNdID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSA9IGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKTtcbiAgb3V0WzZdID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gPSBhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFs4XSA9IGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKTtcbiAgb3V0WzldID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IHZbMV07XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSB2WzJdO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IC1zO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHM7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgb3V0WzFdID0geHkgKyB3ejtcbiAgb3V0WzJdID0geHogLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geHkgLSB3ejtcbiAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgb3V0WzZdID0geXogKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geHogKyB3eTtcbiAgb3V0WzldID0geXogLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgZnJvbSBhIGR1YWwgcXVhdC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgTWF0cml4XHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWF0MihvdXQsIGEpIHtcbiAgdmFyIHRyYW5zbGF0aW9uID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN107XG4gIHZhciBtYWduaXR1ZGUgPSBieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnogKyBidyAqIGJ3OyAvL09ubHkgc2NhbGUgaWYgaXQgbWFrZXMgc2Vuc2VcblxuICBpZiAobWFnbml0dWRlID4gMCkge1xuICAgIHRyYW5zbGF0aW9uWzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyIC8gbWFnbml0dWRlO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zbGF0aW9uWzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMjtcbiAgICB0cmFuc2xhdGlvblsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICB9XG5cbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBhLCB0cmFuc2xhdGlvbik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXHJcbiAqICBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGggZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sXHJcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIHZhciBtMTEgPSBtYXRbMF07XG4gIHZhciBtMTIgPSBtYXRbMV07XG4gIHZhciBtMTMgPSBtYXRbMl07XG4gIHZhciBtMjEgPSBtYXRbNF07XG4gIHZhciBtMjIgPSBtYXRbNV07XG4gIHZhciBtMjMgPSBtYXRbNl07XG4gIHZhciBtMzEgPSBtYXRbOF07XG4gIHZhciBtMzIgPSBtYXRbOV07XG4gIHZhciBtMzMgPSBtYXRbMTBdO1xuICBvdXRbMF0gPSBNYXRoLmh5cG90KG0xMSwgbTEyLCBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLmh5cG90KG0yMSwgbTIyLCBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcclxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXHJcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcclxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Um90YXRpb24ob3V0LCBtYXQpIHtcbiAgdmFyIHNjYWxpbmcgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgZ2V0U2NhbGluZyhzY2FsaW5nLCBtYXQpO1xuICB2YXIgaXMxID0gMSAvIHNjYWxpbmdbMF07XG4gIHZhciBpczIgPSAxIC8gc2NhbGluZ1sxXTtcbiAgdmFyIGlzMyA9IDEgLyBzY2FsaW5nWzJdO1xuICB2YXIgc20xMSA9IG1hdFswXSAqIGlzMTtcbiAgdmFyIHNtMTIgPSBtYXRbMV0gKiBpczI7XG4gIHZhciBzbTEzID0gbWF0WzJdICogaXMzO1xuICB2YXIgc20yMSA9IG1hdFs0XSAqIGlzMTtcbiAgdmFyIHNtMjIgPSBtYXRbNV0gKiBpczI7XG4gIHZhciBzbTIzID0gbWF0WzZdICogaXMzO1xuICB2YXIgc20zMSA9IG1hdFs4XSAqIGlzMTtcbiAgdmFyIHNtMzIgPSBtYXRbOV0gKiBpczI7XG4gIHZhciBzbTMzID0gbWF0WzEwXSAqIGlzMztcbiAgdmFyIHRyYWNlID0gc20xMSArIHNtMjIgKyBzbTMzO1xuICB2YXIgUyA9IDA7XG5cbiAgaWYgKHRyYWNlID4gMCkge1xuICAgIFMgPSBNYXRoLnNxcnQodHJhY2UgKyAxLjApICogMjtcbiAgICBvdXRbM10gPSAwLjI1ICogUztcbiAgICBvdXRbMF0gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMV0gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICBvdXRbMl0gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgfSBlbHNlIGlmIChzbTExID4gc20yMiAmJiBzbTExID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20xMSAtIHNtMjIgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMjMgLSBzbTMyKSAvIFM7XG4gICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgb3V0WzFdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzJdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gIH0gZWxzZSBpZiAoc20yMiA+IHNtMzMpIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIHNtMjIgLSBzbTExIC0gc20zMykgKiAyO1xuICAgIG91dFszXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFswXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChzbTIzICsgc20zMikgLyBTO1xuICB9IGVsc2Uge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20zMyAtIHNtMTEgLSBzbTIyKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gICAgb3V0WzFdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gICAgb3V0WzJdID0gMC4yNSAqIFM7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICB2YXIgb3ggPSBvWzBdO1xuICB2YXIgb3kgPSBvWzFdO1xuICB2YXIgb3ogPSBvWzJdO1xuICB2YXIgb3V0MCA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICB2YXIgb3V0MSA9ICh4eSArIHd6KSAqIHN4O1xuICB2YXIgb3V0MiA9ICh4eiAtIHd5KSAqIHN4O1xuICB2YXIgb3V0NCA9ICh4eSAtIHd6KSAqIHN5O1xuICB2YXIgb3V0NSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICB2YXIgb3V0NiA9ICh5eiArIHd4KSAqIHN5O1xuICB2YXIgb3V0OCA9ICh4eiArIHd5KSAqIHN6O1xuICB2YXIgb3V0OSA9ICh5eiAtIHd4KSAqIHN6O1xuICB2YXIgb3V0MTAgPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgb3V0WzZdID0gb3V0NjtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gb3V0ODtcbiAgb3V0WzldID0gb3V0OTtcbiAgb3V0WzEwXSA9IG91dDEwO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXQwICogb3ggKyBvdXQ0ICogb3kgKyBvdXQ4ICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dDEgKiBveCArIG91dDUgKiBveSArIG91dDkgKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0MiAqIG94ICsgb3V0NiAqIG95ICsgb3V0MTAgKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geXggLSB3ejtcbiAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gIG91dFs2XSA9IHp5ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xuICB2YXIgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IG5lYXIgKiAyICogcmw7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IG5lYXIgKiAyICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyICogMiAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXHJcbiAqIFBhc3NpbmcgbnVsbC91bmRlZmluZWQvbm8gdmFsdWUgZm9yIGZhciB3aWxsIGdlbmVyYXRlIGluZmluaXRlIHByb2plY3Rpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtLCBjYW4gYmUgbnVsbCBvciBJbmZpbml0eVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cclxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxyXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgdmFyIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuICBvdXRbMF0gPSB4U2NhbGU7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIG91dFs0XSA9IDAuMDtcbiAgb3V0WzVdID0geVNjYWxlO1xuICBvdXRbNl0gPSAwLjA7XG4gIG91dFs3XSA9IDAuMDtcbiAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gIG91dFs5XSA9ICh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41O1xuICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTFdID0gLTEuMDtcbiAgb3V0WzEyXSA9IDAuMDtcbiAgb3V0WzEzXSA9IDAuMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpcy5cclxuICogSWYgeW91IHdhbnQgYSBtYXRyaXggdGhhdCBhY3R1YWxseSBtYWtlcyBhbiBvYmplY3QgbG9vayBhdCBhbm90aGVyIG9iamVjdCwgeW91IHNob3VsZCB1c2UgdGFyZ2V0VG8gaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0YXJnZXRUbyhvdXQsIGV5ZSwgdGFyZ2V0LCB1cCkge1xuICB2YXIgZXlleCA9IGV5ZVswXSxcbiAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICB1cHkgPSB1cFsxXSxcbiAgICAgIHVweiA9IHVwWzJdO1xuICB2YXIgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgICAgejIgPSBleWV6IC0gdGFyZ2V0WzJdO1xuICB2YXIgbGVuID0gejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG5cbiAgdmFyIHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MixcbiAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0geDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyO1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHgxO1xuICBvdXRbMl0gPSB4MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gejEgKiB4MiAtIHoyICogeDE7XG4gIG91dFs1XSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICBvdXRbNl0gPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gejA7XG4gIG91dFs5XSA9IHoxO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gZXlleDtcbiAgb3V0WzEzXSA9IGV5ZXk7XG4gIG91dFsxNF0gPSBleWV6O1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuO1xuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdLCBhWzldLCBhWzEwXSwgYVsxMV0sIGFbMTJdLCBhWzEzXSwgYVsxNF0sIGFbMTVdKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQ0J3NcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuZXhwb3J0cy5zdWIgPSBzdWI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuc2V0QXhpc0FuZ2xlID0gc2V0QXhpc0FuZ2xlO1xuZXhwb3J0cy5nZXRBeGlzQW5nbGUgPSBnZXRBeGlzQW5nbGU7XG5leHBvcnRzLmdldEFuZ2xlID0gZ2V0QW5nbGU7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLmNhbGN1bGF0ZVcgPSBjYWxjdWxhdGVXO1xuZXhwb3J0cy5leHAgPSBleHA7XG5leHBvcnRzLmxuID0gbG47XG5leHBvcnRzLnBvdyA9IHBvdztcbmV4cG9ydHMuc2xlcnAgPSBzbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmNvbmp1Z2F0ZSA9IGNvbmp1Z2F0ZTtcbmV4cG9ydHMuZnJvbU1hdDMgPSBmcm9tTWF0MztcbmV4cG9ydHMuZnJvbUV1bGVyID0gZnJvbUV1bGVyO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLnNldEF4ZXMgPSBleHBvcnRzLnNxbGVycCA9IGV4cG9ydHMucm90YXRpb25UbyA9IGV4cG9ydHMuZXF1YWxzID0gZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxdWFyZWRMZW5ndGggPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMubGVuZ3RoID0gZXhwb3J0cy5sZXJwID0gZXhwb3J0cy5kb3QgPSBleHBvcnRzLnNjYWxlID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLmFkZCA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5jb3B5ID0gZXhwb3J0cy5mcm9tVmFsdWVzID0gZXhwb3J0cy5jbG9uZSA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxudmFyIG1hdDMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQzLmpzXCIpKTtcblxudmFyIHZlYzMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWMzLmpzXCIpKTtcblxudmFyIHZlYzQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWM0LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxyXG4gKiBRdWF0ZXJuaW9uXHJcbiAqIEBtb2R1bGUgcXVhdFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxyXG4gKiB0aGVuIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNldEF4aXNBbmdsZShvdXQsIGF4aXMsIHJhZCkge1xuICByYWQgPSByYWQgKiAwLjU7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxyXG4gKiAgcXVhdGVybmlvbi4gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aFxyXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxyXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcclxuICogIE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cclxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxyXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxyXG4gKiAgWzAsIDAsIDFdIGFuZCAyNzAuIFRoaXMgbWV0aG9kIGZhdm9ycyB0aGUgbGF0dGVyLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxyXG4gKiBAcGFyYW0gIHtxdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRBeGlzQW5nbGUob3V0X2F4aXMsIHEpIHtcbiAgdmFyIHJhZCA9IE1hdGguYWNvcyhxWzNdKSAqIDIuMDtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuXG4gIGlmIChzID4gZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIG91dF9heGlzWzBdID0gcVswXSAvIHM7XG4gICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgIG91dF9heGlzWzBdID0gMTtcbiAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgb3V0X2F4aXNbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJhZDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGJldHdlZW4gdHdvIHVuaXQgcXVhdGVybmlvbnNcclxuICpcclxuICogQHBhcmFtICB7cXVhdH0gYSAgICAgT3JpZ2luIHVuaXQgcXVhdGVybmlvbiBcclxuICogQHBhcmFtICB7cXVhdH0gYiAgICAgRGVzdGluYXRpb24gdW5pdCBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBiZXR3ZWVuIHRoZSB0d28gcXVhdGVybmlvbnNcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0QW5nbGUoYSwgYikge1xuICB2YXIgZG90cHJvZHVjdCA9IGRvdChhLCBiKTtcbiAgcmV0dXJuIE1hdGguYWNvcygyICogZG90cHJvZHVjdCAqIGRvdHByb2R1Y3QgLSAxKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieSA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ6ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXHJcbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXHJcbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBleHAob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIGV0ID0gTWF0aC5leHAodyk7XG4gIHZhciBzID0gciA+IDAgPyBldCAqIE1hdGguc2luKHIpIC8gciA6IDA7XG4gIG91dFswXSA9IHggKiBzO1xuICBvdXRbMV0gPSB5ICogcztcbiAgb3V0WzJdID0geiAqIHM7XG4gIG91dFszXSA9IGV0ICogTWF0aC5jb3Mocik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsbihvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgdCA9IHIgPiAwID8gTWF0aC5hdGFuMihyLCB3KSAvIHIgOiAwO1xuICBvdXRbMF0gPSB4ICogdDtcbiAgb3V0WzFdID0geSAqIHQ7XG4gIG91dFsyXSA9IHogKiB0O1xuICBvdXRbM10gPSAwLjUgKiBNYXRoLmxvZyh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBzY2FsYXIgcG93ZXIgb2YgYSB1bml0IHF1YXRlcm5pb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgcXVhdGVybmlvbiBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBvdyhvdXQsIGEsIGIpIHtcbiAgbG4ob3V0LCBhKTtcbiAgc2NhbGUob3V0LCBvdXQsIGIpO1xuICBleHAob3V0LCBvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgLy8gYmVuY2htYXJrczpcbiAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIGJ3ID0gYlszXTtcbiAgdmFyIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxOyAvLyBjYWxjIGNvc2luZVxuXG4gIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidzsgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG5cbiAgaWYgKGNvc29tIDwgMC4wKSB7XG4gICAgY29zb20gPSAtY29zb207XG4gICAgYnggPSAtYng7XG4gICAgYnkgPSAtYnk7XG4gICAgYnogPSAtYno7XG4gICAgYncgPSAtYnc7XG4gIH0gLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuXG5cbiAgaWYgKDEuMCAtIGNvc29tID4gZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICBzaW5vbSA9IE1hdGguc2luKG9tZWdhKTtcbiAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gIH0gZWxzZSB7XG4gICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZVxuICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgIHNjYWxlMSA9IHQ7XG4gIH0gLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuXG5cbiAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdW5pdCBxdWF0ZXJuaW9uXHJcbiAqIFxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0KSB7XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcbiAgLy8gVE9ETzogQ2FsbGluZyByYW5kb20gMyB0aW1lcyBpcyBwcm9iYWJseSBub3QgdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiAgdmFyIHUxID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MiA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTMgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHNxcnQxTWludXNVMSA9IE1hdGguc3FydCgxIC0gdTEpO1xuICB2YXIgc3FydFUxID0gTWF0aC5zcXJ0KHUxKTtcbiAgb3V0WzBdID0gc3FydDFNaW51c1UxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzFdID0gc3FydDFNaW51c1UxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzJdID0gc3FydFUxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgb3V0WzNdID0gc3FydFUxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICB2YXIgaW52RG90ID0gZG90ID8gMS4wIC8gZG90IDogMDsgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gIG91dFsxXSA9IC1hMSAqIGludkRvdDtcbiAgb3V0WzJdID0gLWEyICogaW52RG90O1xuICBvdXRbM10gPSBhMyAqIGludkRvdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XHJcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXHJcbiAqXHJcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXHJcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICB2YXIgZlJvb3Q7XG5cbiAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xuXG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsgLy8gMS8oNHcpXG5cbiAgICBvdXRbMF0gPSAobVs1XSAtIG1bN10pICogZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0gLSBtWzJdKSAqIGZSb290O1xuICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChtWzRdID4gbVswXSkgaSA9IDE7XG4gICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgIHZhciBqID0gKGkgKyAxKSAlIDM7XG4gICAgdmFyIGsgPSAoaSArIDIpICUgMztcbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kgKiAzICsgaV0gLSBtW2ogKiAzICsgal0gLSBtW2sgKiAzICsga10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiAqIDMgKyBrXSAtIG1bayAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEBwYXJhbSB7eX0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBZIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tRXVsZXIob3V0LCB4LCB5LCB6KSB7XG4gIHZhciBoYWxmVG9SYWQgPSAwLjUgKiBNYXRoLlBJIC8gMTgwLjA7XG4gIHggKj0gaGFsZlRvUmFkO1xuICB5ICo9IGhhbGZUb1JhZDtcbiAgeiAqPSBoYWxmVG9SYWQ7XG4gIHZhciBzeCA9IE1hdGguc2luKHgpO1xuICB2YXIgY3ggPSBNYXRoLmNvcyh4KTtcbiAgdmFyIHN5ID0gTWF0aC5zaW4oeSk7XG4gIHZhciBjeSA9IE1hdGguY29zKHkpO1xuICB2YXIgc3ogPSBNYXRoLnNpbih6KTtcbiAgdmFyIGN6ID0gTWF0aC5jb3Moeik7XG4gIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gIG91dFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgY2xvbmUgPSB2ZWM0LmNsb25lO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG52YXIgZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xudmFyIGNvcHkgPSB2ZWM0LmNvcHk7XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5jb3B5ID0gY29weTtcbnZhciBzZXQgPSB2ZWM0LnNldDtcbi8qKlxyXG4gKiBBZGRzIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNldCA9IHNldDtcbnZhciBhZGQgPSB2ZWM0LmFkZDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5hZGQgPSBhZGQ7XG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIHNjYWxlID0gdmVjNC5zY2FsZTtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG52YXIgZG90ID0gdmVjNC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZG90ID0gZG90O1xudmFyIGxlcnAgPSB2ZWM0LmxlcnA7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydHMubGVycCA9IGxlcnA7XG52YXIgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbnZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbiA9IGxlbjtcbnZhciBzcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG52YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xudmFyIG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBhIFRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xudmFyIGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xudmFyIGVxdWFscyA9IHZlYzQuZXF1YWxzO1xuLyoqXHJcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcclxuICogdmVjdG9yIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuXG52YXIgcm90YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApO1xuICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcblxuICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgIGlmICh2ZWMzLmxlbih0bXB2ZWMzKSA8IDAuMDAwMDAxKSB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgIHNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSAwO1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IDA7XG4gICAgICBvdXRbM10gPSAxO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB9XG4gIH07XG59KCk7XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5leHBvcnRzLnJvdGF0aW9uVG8gPSByb3RhdGlvblRvO1xuXG52YXIgc3FsZXJwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBjcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBzbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpO1xuLyoqXHJcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXHJcbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxyXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cclxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZXhwb3J0cy5zcWxlcnAgPSBzcWxlcnA7XG5cbnZhciBzZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgIG1hdHJbNl0gPSByaWdodFsyXTtcbiAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgbWF0cls0XSA9IHVwWzFdO1xuICAgIG1hdHJbN10gPSB1cFsyXTtcbiAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgIG1hdHJbOF0gPSAtdmlld1syXTtcbiAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuc2V0QXhlcyA9IHNldEF4ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uVmFsdWVzID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXM7XG5leHBvcnRzLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5leHBvcnRzLmZyb21UcmFuc2xhdGlvbiA9IGZyb21UcmFuc2xhdGlvbjtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tTWF0NCA9IGZyb21NYXQ0O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5nZXREdWFsID0gZ2V0RHVhbDtcbmV4cG9ydHMuc2V0RHVhbCA9IHNldER1YWw7XG5leHBvcnRzLmdldFRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb247XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMucm90YXRlQnlRdWF0QXBwZW5kID0gcm90YXRlQnlRdWF0QXBwZW5kO1xuZXhwb3J0cy5yb3RhdGVCeVF1YXRQcmVwZW5kID0gcm90YXRlQnlRdWF0UHJlcGVuZDtcbmV4cG9ydHMucm90YXRlQXJvdW5kQXhpcyA9IHJvdGF0ZUFyb3VuZEF4aXM7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbmV4cG9ydHMuY29uanVnYXRlID0gY29uanVnYXRlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLnNxdWFyZWRMZW5ndGggPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMubGVuZ3RoID0gZXhwb3J0cy5kb3QgPSBleHBvcnRzLm11bCA9IGV4cG9ydHMuc2V0UmVhbCA9IGV4cG9ydHMuZ2V0UmVhbCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxudmFyIHF1YXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9xdWF0LmpzXCIpKTtcblxudmFyIG1hdDQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tYXQ0LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxyXG4gKiBEdWFsIFF1YXRlcm5pb248YnI+XHJcbiAqIEZvcm1hdDogW3JlYWwsIGR1YWxdPGJyPlxyXG4gKiBRdWF0ZXJuaW9uIGZvcm1hdDogWFlaVzxicj5cclxuICogTWFrZSBzdXJlIHRvIGhhdmUgbm9ybWFsaXplZCBkdWFsIHF1YXRlcm5pb25zLCBvdGhlcndpc2UgdGhlIGZ1bmN0aW9ucyBtYXkgbm90IHdvcmsgYXMgaW50ZW5kZWQuPGJyPlxyXG4gKiBAbW9kdWxlIHF1YXQyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBkdWFsIHF1YXRcclxuICpcclxuICogQHJldHVybnMge3F1YXQyfSBhIG5ldyBkdWFsIHF1YXRlcm5pb24gW3JlYWwgLT4gcm90YXRpb24sIGR1YWwgLT4gdHJhbnNsYXRpb25dXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBkcVswXSA9IDA7XG4gICAgZHFbMV0gPSAwO1xuICAgIGRxWzJdID0gMDtcbiAgICBkcVs0XSA9IDA7XG4gICAgZHFbNV0gPSAwO1xuICAgIGRxWzZdID0gMDtcbiAgICBkcVs3XSA9IDA7XG4gIH1cblxuICBkcVszXSA9IDE7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSBhWzBdO1xuICBkcVsxXSA9IGFbMV07XG4gIGRxWzJdID0gYVsyXTtcbiAgZHFbM10gPSBhWzNdO1xuICBkcVs0XSA9IGFbNF07XG4gIGRxWzVdID0gYVs1XTtcbiAgZHFbNl0gPSBhWzZdO1xuICBkcVs3XSA9IGFbN107XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejEgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MiBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIsIHcyKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IHgxO1xuICBkcVsxXSA9IHkxO1xuICBkcVsyXSA9IHoxO1xuICBkcVszXSA9IHcxO1xuICBkcVs0XSA9IHgyO1xuICBkcVs1XSA9IHkyO1xuICBkcVs2XSA9IHoyO1xuICBkcVs3XSA9IHcyO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gdmFsdWVzIChxdWF0IGFuZCB0cmFuc2xhdGlvbilcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejEgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MiBaIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIHZhciBheCA9IHgyICogMC41LFxuICAgICAgYXkgPSB5MiAqIDAuNSxcbiAgICAgIGF6ID0gejIgKiAwLjU7XG4gIGRxWzRdID0gYXggKiB3MSArIGF5ICogejEgLSBheiAqIHkxO1xuICBkcVs1XSA9IGF5ICogdzEgKyBheiAqIHgxIC0gYXggKiB6MTtcbiAgZHFbNl0gPSBheiAqIHcxICsgYXggKiB5MSAtIGF5ICogeDE7XG4gIGRxWzddID0gLWF4ICogeDEgLSBheSAqIHkxIC0gYXogKiB6MTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb24gYW5kIGEgdHJhbnNsYXRpb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBhIG5vcm1hbGl6ZWQgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IHQgdHJhbmxhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdCkge1xuICB2YXIgYXggPSB0WzBdICogMC41LFxuICAgICAgYXkgPSB0WzFdICogMC41LFxuICAgICAgYXogPSB0WzJdICogMC41LFxuICAgICAgYnggPSBxWzBdLFxuICAgICAgYnkgPSBxWzFdLFxuICAgICAgYnogPSBxWzJdLFxuICAgICAgYncgPSBxWzNdO1xuICBvdXRbMF0gPSBieDtcbiAgb3V0WzFdID0gYnk7XG4gIG91dFsyXSA9IGJ6O1xuICBvdXRbM10gPSBidztcbiAgb3V0WzRdID0gYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbNV0gPSBheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFs2XSA9IGF6ICogYncgKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSB0cmFuc2xhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHt2ZWMzfSB0IHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB0WzBdICogMC41O1xuICBvdXRbNV0gPSB0WzFdICogMC41O1xuICBvdXRbNl0gPSB0WzJdICogMC41O1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gcSB0aGUgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcSkge1xuICBvdXRbMF0gPSBxWzBdO1xuICBvdXRbMV0gPSBxWzFdO1xuICBvdXRbMl0gPSBxWzJdO1xuICBvdXRbM10gPSBxWzNdO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGZyb20gYSBtYXRyaXggKDR4NClcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICAvL1RPRE8gT3B0aW1pemUgdGhpc1xuICB2YXIgb3V0ZXIgPSBxdWF0LmNyZWF0ZSgpO1xuICBtYXQ0LmdldFJvdGF0aW9uKG91dGVyLCBhKTtcbiAgdmFyIHQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgbWF0NC5nZXRUcmFuc2xhdGlvbih0LCBhKTtcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBvdXRlciwgdCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIGR1YWwgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBzb3VyY2UgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIGR1YWwgcXVhdCB0byB0aGUgaWRlbnRpdHkgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgb3V0WzBdID0geDE7XG4gIG91dFsxXSA9IHkxO1xuICBvdXRbMl0gPSB6MTtcbiAgb3V0WzNdID0gdzE7XG4gIG91dFs0XSA9IHgyO1xuICBvdXRbNV0gPSB5MjtcbiAgb3V0WzZdID0gejI7XG4gIG91dFs3XSA9IHcyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIHJlYWwgcGFydCBvZiBhIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgcmVhbCBwYXJ0XHJcbiAqIEBwYXJhbSAge3F1YXQyfSBhIER1YWwgUXVhdGVybmlvblxyXG4gKiBAcmV0dXJuIHtxdWF0fSByZWFsIHBhcnRcclxuICovXG5cblxudmFyIGdldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogR2V0cyB0aGUgZHVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCBkdWFsIHBhcnRcclxuICogQHBhcmFtICB7cXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IGR1YWwgcGFydFxyXG4gKi9cblxuZXhwb3J0cy5nZXRSZWFsID0gZ2V0UmVhbDtcblxuZnVuY3Rpb24gZ2V0RHVhbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVs0XTtcbiAgb3V0WzFdID0gYVs1XTtcbiAgb3V0WzJdID0gYVs2XTtcbiAgb3V0WzNdID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIHJlYWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBxIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJlYWwgcGFydFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIHNldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogU2V0IHRoZSBkdWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSBkdWFsIHBhcnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNldFJlYWwgPSBzZXRSZWFsO1xuXG5mdW5jdGlvbiBzZXREdWFsKG91dCwgcSkge1xuICBvdXRbNF0gPSBxWzBdO1xuICBvdXRbNV0gPSBxWzFdO1xuICBvdXRbNl0gPSBxWzJdO1xuICBvdXRbN10gPSBxWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIHRyYW5zbGF0aW9uIG9mIGEgbm9ybWFsaXplZCBkdWFsIHF1YXRcclxuICogQHBhcmFtICB7dmVjM30gb3V0IHRyYW5zbGF0aW9uXHJcbiAqIEBwYXJhbSAge3F1YXQyfSBhIER1YWwgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXHJcbiAqIEByZXR1cm4ge3ZlYzN9IHRyYW5zbGF0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgYSkge1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICBvdXRbMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICBvdXRbMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgYSBkdWFsIHF1YXQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBheDEgPSBhWzBdLFxuICAgICAgYXkxID0gYVsxXSxcbiAgICAgIGF6MSA9IGFbMl0sXG4gICAgICBhdzEgPSBhWzNdLFxuICAgICAgYngxID0gdlswXSAqIDAuNSxcbiAgICAgIGJ5MSA9IHZbMV0gKiAwLjUsXG4gICAgICBiejEgPSB2WzJdICogMC41LFxuICAgICAgYXgyID0gYVs0XSxcbiAgICAgIGF5MiA9IGFbNV0sXG4gICAgICBhejIgPSBhWzZdLFxuICAgICAgYXcyID0gYVs3XTtcbiAgb3V0WzBdID0gYXgxO1xuICBvdXRbMV0gPSBheTE7XG4gIG91dFsyXSA9IGF6MTtcbiAgb3V0WzNdID0gYXcxO1xuICBvdXRbNF0gPSBhdzEgKiBieDEgKyBheTEgKiBiejEgLSBhejEgKiBieTEgKyBheDI7XG4gIG91dFs1XSA9IGF3MSAqIGJ5MSArIGF6MSAqIGJ4MSAtIGF4MSAqIGJ6MSArIGF5MjtcbiAgb3V0WzZdID0gYXcxICogYnoxICsgYXgxICogYnkxIC0gYXkxICogYngxICsgYXoyO1xuICBvdXRbN10gPSAtYXgxICogYngxIC0gYXkxICogYnkxIC0gYXoxICogYnoxICsgYXcyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVYKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVZKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVaKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYnkgYSBnaXZlbiBxdWF0ZXJuaW9uIChhICogcSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdEFwcGVuZChvdXQsIGEsIHEpIHtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXSxcbiAgICAgIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKiBxdyArIGF3ICogcXggKyBheSAqIHF6IC0gYXogKiBxeTtcbiAgb3V0WzFdID0gYXkgKiBxdyArIGF3ICogcXkgKyBheiAqIHF4IC0gYXggKiBxejtcbiAgb3V0WzJdID0gYXogKiBxdyArIGF3ICogcXogKyBheCAqIHF5IC0gYXkgKiBxeDtcbiAgb3V0WzNdID0gYXcgKiBxdyAtIGF4ICogcXggLSBheSAqIHF5IC0gYXogKiBxejtcbiAgYXggPSBhWzRdO1xuICBheSA9IGFbNV07XG4gIGF6ID0gYVs2XTtcbiAgYXcgPSBhWzddO1xuICBvdXRbNF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbNV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbNl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbN10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYnkgYSBnaXZlbiBxdWF0ZXJuaW9uIChxICogYSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdFByZXBlbmQob3V0LCBxLCBhKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBieCA9IGFbMF0sXG4gICAgICBieSA9IGFbMV0sXG4gICAgICBieiA9IGFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFszXSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIGJ4ID0gYVs0XTtcbiAgYnkgPSBhWzVdO1xuICBieiA9IGFbNl07XG4gIGJ3ID0gYVs3XTtcbiAgb3V0WzRdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzVdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzZdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzddID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCBhIGdpdmVuIGF4aXMuIERvZXMgdGhlIG5vcm1hbGlzYXRpb24gYXV0b21hdGljYWxseVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIGhvdyBmYXIgdGhlIHJvdGF0aW9uIHNob3VsZCBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVBcm91bmRBeGlzKG91dCwgYSwgYXhpcywgcmFkKSB7XG4gIC8vU3BlY2lhbCBjYXNlIGZvciByYWQgPSAwXG4gIGlmIChNYXRoLmFicyhyYWQpIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBjb3B5KG91dCwgYSk7XG4gIH1cblxuICB2YXIgYXhpc0xlbmd0aCA9IE1hdGguaHlwb3QoYXhpc1swXSwgYXhpc1sxXSwgYXhpc1syXSk7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYnggPSBzICogYXhpc1swXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBieSA9IHMgKiBheGlzWzFdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ6ID0gcyAqIGF4aXNbMl0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYncgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYXgxID0gYVswXSxcbiAgICAgIGF5MSA9IGFbMV0sXG4gICAgICBhejEgPSBhWzJdLFxuICAgICAgYXcxID0gYVszXTtcbiAgb3V0WzBdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFsxXSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbMl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzNdID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHZhciBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFs2XSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFs3XSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIGR1YWwgcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXgwID0gYVswXSxcbiAgICAgIGF5MCA9IGFbMV0sXG4gICAgICBhejAgPSBhWzJdLFxuICAgICAgYXcwID0gYVszXSxcbiAgICAgIGJ4MSA9IGJbNF0sXG4gICAgICBieTEgPSBiWzVdLFxuICAgICAgYnoxID0gYls2XSxcbiAgICAgIGJ3MSA9IGJbN10sXG4gICAgICBheDEgPSBhWzRdLFxuICAgICAgYXkxID0gYVs1XSxcbiAgICAgIGF6MSA9IGFbNl0sXG4gICAgICBhdzEgPSBhWzddLFxuICAgICAgYngwID0gYlswXSxcbiAgICAgIGJ5MCA9IGJbMV0sXG4gICAgICBiejAgPSBiWzJdLFxuICAgICAgYncwID0gYlszXTtcbiAgb3V0WzBdID0gYXgwICogYncwICsgYXcwICogYngwICsgYXkwICogYnowIC0gYXowICogYnkwO1xuICBvdXRbMV0gPSBheTAgKiBidzAgKyBhdzAgKiBieTAgKyBhejAgKiBieDAgLSBheDAgKiBiejA7XG4gIG91dFsyXSA9IGF6MCAqIGJ3MCArIGF3MCAqIGJ6MCArIGF4MCAqIGJ5MCAtIGF5MCAqIGJ4MDtcbiAgb3V0WzNdID0gYXcwICogYncwIC0gYXgwICogYngwIC0gYXkwICogYnkwIC0gYXowICogYnowO1xuICBvdXRbNF0gPSBheDAgKiBidzEgKyBhdzAgKiBieDEgKyBheTAgKiBiejEgLSBhejAgKiBieTEgKyBheDEgKiBidzAgKyBhdzEgKiBieDAgKyBheTEgKiBiejAgLSBhejEgKiBieTA7XG4gIG91dFs1XSA9IGF5MCAqIGJ3MSArIGF3MCAqIGJ5MSArIGF6MCAqIGJ4MSAtIGF4MCAqIGJ6MSArIGF5MSAqIGJ3MCArIGF3MSAqIGJ5MCArIGF6MSAqIGJ4MCAtIGF4MSAqIGJ6MDtcbiAgb3V0WzZdID0gYXowICogYncxICsgYXcwICogYnoxICsgYXgwICogYnkxIC0gYXkwICogYngxICsgYXoxICogYncwICsgYXcxICogYnowICsgYXgxICogYnkwIC0gYXkxICogYngwO1xuICBvdXRbN10gPSBhdzAgKiBidzEgLSBheDAgKiBieDEgLSBheTAgKiBieTEgLSBhejAgKiBiejEgKyBhdzEgKiBidzAgLSBheDEgKiBieDAgLSBheTEgKiBieTAgLSBhejEgKiBiejA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBkdWFsIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBkdWFsIHF1YXQgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBkdWFsIHF1YXQgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gZHVhbCBxdWF0J3MgKFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgcmVhbCBwYXJ0cylcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgZG90ID0gcXVhdC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBkdWFsIHF1YXRzJ3NcclxuICogTk9URTogVGhlIHJlc3VsdGluZyBkdWFsIHF1YXRlcm5pb25zIHdvbid0IGFsd2F5cyBiZSBub3JtYWxpemVkIChUaGUgZXJyb3IgaXMgbW9zdCBub3RpY2VhYmxlIHdoZW4gdCA9IDAuNSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0cy5kb3QgPSBkb3Q7XG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBtdCA9IDEgLSB0O1xuICBpZiAoZG90KGEsIGIpIDwgMCkgdCA9IC10O1xuICBvdXRbMF0gPSBhWzBdICogbXQgKyBiWzBdICogdDtcbiAgb3V0WzFdID0gYVsxXSAqIG10ICsgYlsxXSAqIHQ7XG4gIG91dFsyXSA9IGFbMl0gKiBtdCArIGJbMl0gKiB0O1xuICBvdXRbM10gPSBhWzNdICogbXQgKyBiWzNdICogdDtcbiAgb3V0WzRdID0gYVs0XSAqIG10ICsgYls0XSAqIHQ7XG4gIG91dFs1XSA9IGFbNV0gKiBtdCArIGJbNV0gKiB0O1xuICBvdXRbNl0gPSBhWzZdICogbXQgKyBiWzZdICogdDtcbiAgb3V0WzddID0gYVs3XSAqIG10ICsgYls3XSAqIHQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIGR1YWwgcXVhdC4gSWYgdGhleSBhcmUgbm9ybWFsaXplZCwgY29uanVnYXRlIGlzIGNoZWFwZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIHNxbGVuID0gc3F1YXJlZExlbmd0aChhKTtcbiAgb3V0WzBdID0gLWFbMF0gLyBzcWxlbjtcbiAgb3V0WzFdID0gLWFbMV0gLyBzcWxlbjtcbiAgb3V0WzJdID0gLWFbMl0gLyBzcWxlbjtcbiAgb3V0WzNdID0gYVszXSAvIHNxbGVuO1xuICBvdXRbNF0gPSAtYVs0XSAvIHNxbGVuO1xuICBvdXRbNV0gPSAtYVs1XSAvIHNxbGVuO1xuICBvdXRbNl0gPSAtYVs2XSAvIHNxbGVuO1xuICBvdXRbN10gPSBhWzddIC8gc3FsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgZHVhbCBxdWF0XHJcbiAqIElmIHRoZSBkdWFsIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0Mi5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSAtYVs0XTtcbiAgb3V0WzVdID0gLWFbNV07XG4gIG91dFs2XSA9IC1hWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbGVuZ3RoID0gcXVhdC5sZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG52YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5sZW4gPSBsZW47XG52YXIgc3F1YXJlZExlbmd0aCA9IHF1YXQuc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJMZW4gPSBzcXJMZW47XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIG1hZ25pdHVkZSA9IHNxdWFyZWRMZW5ndGgoYSk7XG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICBtYWduaXR1ZGUgPSBNYXRoLnNxcnQobWFnbml0dWRlKTtcbiAgICB2YXIgYTAgPSBhWzBdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMSA9IGFbMV0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGEyID0gYVsyXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTMgPSBhWzNdIC8gbWFnbml0dWRlO1xuICAgIHZhciBiMCA9IGFbNF07XG4gICAgdmFyIGIxID0gYVs1XTtcbiAgICB2YXIgYjIgPSBhWzZdO1xuICAgIHZhciBiMyA9IGFbN107XG4gICAgdmFyIGFfZG90X2IgPSBhMCAqIGIwICsgYTEgKiBiMSArIGEyICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IChiMCAtIGEwICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzVdID0gKGIxIC0gYTEgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNl0gPSAoYjIgLSBhMiAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs3XSA9IChiMyAtIGEzICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkdWFsIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkdWFsIHF1YXRcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdxdWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJyknO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGR1YWwgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGIgdGhlIHNlY29uZCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBkdWFsIHF1YXRlcm5pb25zIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHVhbCBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGZpcnN0IGR1YWwgcXVhdC5cclxuICogQHBhcmFtIHtxdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQyID0gdHJhbnNmb3JtTWF0MjtcbmV4cG9ydHMudHJhbnNmb3JtTWF0MmQgPSB0cmFuc2Zvcm1NYXQyZDtcbmV4cG9ydHMudHJhbnNmb3JtTWF0MyA9IHRyYW5zZm9ybU1hdDM7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDQgPSB0cmFuc2Zvcm1NYXQ0O1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLmFuZ2xlID0gYW5nbGU7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZm9yRWFjaCA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5zcXJEaXN0ID0gZXhwb3J0cy5kaXN0ID0gZXhwb3J0cy5kaXYgPSBleHBvcnRzLm11bCA9IGV4cG9ydHMuc3ViID0gZXhwb3J0cy5sZW4gPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKipcclxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWMyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeTtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcclxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcclxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgMkQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IFRoZSByZWNlaXZpbmcgdmVjMlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCBjKSB7XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgdmFyIHAwID0gYVswXSAtIGJbMF0sXG4gICAgICBwMSA9IGFbMV0gLSBiWzFdLFxuICAgICAgc2luQyA9IE1hdGguc2luKGMpLFxuICAgICAgY29zQyA9IE1hdGguY29zKGMpOyAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcclxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cblxuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgICAgeTEgPSBhWzFdLFxuICAgICAgeDIgPSBiWzBdLFxuICAgICAgeTIgPSBiWzFdO1xuICB2YXIgbGVuMSA9IHgxICogeDEgKyB5MSAqIHkxO1xuXG4gIGlmIChsZW4xID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuMSA9IDEgLyBNYXRoLnNxcnQobGVuMSk7XG4gIH1cblxuICB2YXIgbGVuMiA9IHgyICogeDIgKyB5MiAqIHkyO1xuXG4gIGlmIChsZW4yID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuMiA9IDEgLyBNYXRoLnNxcnQobGVuMik7XG4gIH1cblxuICB2YXIgY29zaW5lID0gKHgxICogeDIgKyB5MSAqIHkyKSAqIGxlbjEgKiBsZW4yO1xuXG4gIGlmIChjb3NpbmUgPiAxLjApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbiA9IGxlbjtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zdWIgPSBzdWI7XG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGl2ID0gZGl2O1xudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG52YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckRpc3QgPSBzcXJEaXN0O1xudmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmhlcm1pdGUgPSBoZXJtaXRlO1xuZXhwb3J0cy5iZXppZXIgPSBiZXppZXI7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDMgPSB0cmFuc2Zvcm1NYXQzO1xuZXhwb3J0cy50cmFuc2Zvcm1RdWF0ID0gdHJhbnNmb3JtUXVhdDtcbmV4cG9ydHMucm90YXRlWCA9IHJvdGF0ZVg7XG5leHBvcnRzLnJvdGF0ZVkgPSByb3RhdGVZO1xuZXhwb3J0cy5yb3RhdGVaID0gcm90YXRlWjtcbmV4cG9ydHMuYW5nbGUgPSBhbmdsZTtcbmV4cG9ydHMuemVybyA9IHplcm87XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mb3JFYWNoID0gZXhwb3J0cy5zcXJMZW4gPSBleHBvcnRzLmxlbiA9IGV4cG9ydHMuc3FyRGlzdCA9IGV4cG9ydHMuZGlzdCA9IGV4cG9ydHMuZGl2ID0gZXhwb3J0cy5tdWwgPSBleHBvcnRzLnN1YiA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxyXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaGVybWl0ZShvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMTtcbiAgdmFyIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdDtcbiAgdmFyIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgdmFyIGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgdmFyIGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge21hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcclxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gYmVuY2htYXJrczogaHR0cHM6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zLWZpeGVkXG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07IC8vIHZhciBxdmVjID0gW3F4LCBxeSwgcXpdO1xuICAvLyB2YXIgdXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCBhKTtcblxuICB2YXIgdXZ4ID0gcXkgKiB6IC0gcXogKiB5LFxuICAgICAgdXZ5ID0gcXogKiB4IC0gcXggKiB6LFxuICAgICAgdXZ6ID0gcXggKiB5IC0gcXkgKiB4OyAvLyB2YXIgdXV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgdXYpO1xuXG4gIHZhciB1dXZ4ID0gcXkgKiB1dnogLSBxeiAqIHV2eSxcbiAgICAgIHV1dnkgPSBxeiAqIHV2eCAtIHF4ICogdXZ6LFxuICAgICAgdXV2eiA9IHF4ICogdXZ5IC0gcXkgKiB1dng7IC8vIHZlYzMuc2NhbGUodXYsIHV2LCAyICogdyk7XG5cbiAgdmFyIHcyID0gcXcgKiAyO1xuICB1dnggKj0gdzI7XG4gIHV2eSAqPSB3MjtcbiAgdXZ6ICo9IHcyOyAvLyB2ZWMzLnNjYWxlKHV1diwgdXV2LCAyKTtcblxuICB1dXZ4ICo9IDI7XG4gIHV1dnkgKj0gMjtcbiAgdXV2eiAqPSAyOyAvLyByZXR1cm4gdmVjMy5hZGQob3V0LCBhLCB2ZWMzLmFkZChvdXQsIHV2LCB1dXYpKTtcblxuICBvdXRbMF0gPSB4ICsgdXZ4ICsgdXV2eDtcbiAgb3V0WzFdID0geSArIHV2eSArIHV1dnk7XG4gIG91dFsyXSA9IHogKyB1dnogKyB1dXZ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKGMpIC0gcFsyXSAqIE1hdGguc2luKGMpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKGMpICsgcFsyXSAqIE1hdGguY29zKGMpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCBjKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKGMpICsgcFswXSAqIE1hdGguY29zKGMpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhjKSAtIHBbMF0gKiBNYXRoLnNpbihjKTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYykge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhjKSAtIHBbMV0gKiBNYXRoLnNpbihjKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihjKSArIHBbMV0gKiBNYXRoLmNvcyhjKTtcbiAgclsyXSA9IHBbMl07IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKi9cblxuXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciB0ZW1wQSA9IGZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSk7XG4gIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICBub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gIGlmIChjb3NpbmUgPiAxLjApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAndmVjMygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3ViID0gc3ViO1xudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpdiA9IGRpdjtcbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpc3QgPSBkaXN0O1xudmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckRpc3QgPSBzcXJEaXN0O1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbiA9IGxlbjtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQ0ID0gdHJhbnNmb3JtTWF0NDtcbmV4cG9ydHMudHJhbnNmb3JtUXVhdCA9IHRyYW5zZm9ybVF1YXQ7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZm9yRWFjaCA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKipcclxuICogNCBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWM0XHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6LCB3KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHosIHcpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IC1hWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IHggKiBsZW47XG4gIG91dFsxXSA9IHkgKiBsZW47XG4gIG91dFsyXSA9IHogKiBsZW47XG4gIG91dFszXSA9IHcgKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjcm9zcy1wcm9kdWN0IG9mIHRocmVlIHZlY3RvcnMgaW4gYSA0LWRpbWVuc2lvbmFsIHNwYWNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gVSB0aGUgZmlyc3QgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gViB0aGUgc2Vjb25kIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgdSwgdiwgdykge1xuICB2YXIgQSA9IHZbMF0gKiB3WzFdIC0gdlsxXSAqIHdbMF0sXG4gICAgICBCID0gdlswXSAqIHdbMl0gLSB2WzJdICogd1swXSxcbiAgICAgIEMgPSB2WzBdICogd1szXSAtIHZbM10gKiB3WzBdLFxuICAgICAgRCA9IHZbMV0gKiB3WzJdIC0gdlsyXSAqIHdbMV0sXG4gICAgICBFID0gdlsxXSAqIHdbM10gLSB2WzNdICogd1sxXSxcbiAgICAgIEYgPSB2WzJdICogd1szXSAtIHZbM10gKiB3WzJdO1xuICB2YXIgRyA9IHVbMF07XG4gIHZhciBIID0gdVsxXTtcbiAgdmFyIEkgPSB1WzJdO1xuICB2YXIgSiA9IHVbM107XG4gIG91dFswXSA9IEggKiBGIC0gSSAqIEUgKyBKICogRDtcbiAgb3V0WzFdID0gLShHICogRikgKyBJICogQyAtIEogKiBCO1xuICBvdXRbMl0gPSBHICogRSAtIEggKiBDICsgSiAqIEE7XG4gIG91dFszXSA9IC0oRyAqIEQpICsgSCAqIEIgLSBJICogQTtcbiAgcmV0dXJuIG91dDtcbn1cblxuO1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgdmFyIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDsgLy8gTWFyc2FnbGlhLCBHZW9yZ2UuIENob29zaW5nIGEgUG9pbnQgZnJvbSB0aGUgU3VyZmFjZSBvZiBhXG4gIC8vIFNwaGVyZS4gQW5uLiBNYXRoLiBTdGF0aXN0LiA0MyAoMTk3MiksIG5vLiAyLCA2NDUtLTY0Ni5cbiAgLy8gaHR0cDovL3Byb2plY3RldWNsaWQub3JnL2V1Y2xpZC5hb21zLzExNzc2OTI2NDQ7XG5cbiAgdmFyIHYxLCB2MiwgdjMsIHY0O1xuICB2YXIgczEsIHMyO1xuXG4gIGRvIHtcbiAgICB2MSA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgdjIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHMxID0gdjEgKiB2MSArIHYyICogdjI7XG4gIH0gd2hpbGUgKHMxID49IDEpO1xuXG4gIGRvIHtcbiAgICB2MyA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgdjQgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHMyID0gdjMgKiB2MyArIHY0ICogdjQ7XG4gIH0gd2hpbGUgKHMyID49IDEpO1xuXG4gIHZhciBkID0gTWF0aC5zcXJ0KCgxIC0gczEpIC8gczIpO1xuICBvdXRbMF0gPSBzY2FsZSAqIHYxO1xuICBvdXRbMV0gPSBzY2FsZSAqIHYyO1xuICBvdXRbMl0gPSBzY2FsZSAqIHYzICogZDtcbiAgb3V0WzNdID0gc2NhbGUgKiB2NCAqIGQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdLFxuICAgICAgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTsgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcblxuICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3ViID0gc3ViO1xudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpdiA9IGRpdjtcbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpc3QgPSBkaXN0O1xudmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckRpc3QgPSBzcXJEaXN0O1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbiA9IGxlbjtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDsiLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC40IC0gMjAxNC0wOS0yOFxyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9yaWsgVGFuZ2VsZGVyO1xyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cclxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01TJywgJ21zJywgJ28nXTtcclxudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xyXG5cclxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxudmFyIGFicyA9IE1hdGguYWJzO1xyXG52YXIgbm93ID0gRGF0ZS5ub3c7XHJcblxyXG4vKipcclxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XHJcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxyXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcclxuICogQHBhcmFtIHtTdHJpbmd9IGZuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XHJcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICovXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XHJcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcclxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGV4dGVuZCBvYmplY3QuXHJcbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlXVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxyXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xyXG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xyXG59XHJcblxyXG4vKipcclxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxyXG4gKi9cclxuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xyXG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXHJcbiAgICAgICAgY2hpbGRQO1xyXG5cclxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xyXG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XHJcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XHJcblxyXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICBleHRlbmQoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cclxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xyXG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxyXG4gKiBAcGFyYW0geyp9IHZhbDFcclxuICogQHBhcmFtIHsqfSB2YWwyXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xyXG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXHJcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xyXG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcclxuICogQG1ldGhvZCBoYXNQYXJlbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcclxuICovXHJcbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXHJcbiAqL1xyXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcclxuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xyXG59XHJcblxyXG4vKipcclxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcclxuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XHJcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xyXG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xyXG59XHJcblxyXG4vKipcclxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxyXG4gKi9cclxuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcclxuICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xyXG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvcnQpIHtcclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcclxuICovXHJcbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcclxuICAgIHZhciBwcmVmaXgsIHByb3A7XHJcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xyXG5cclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xyXG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcclxuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgdW5pcXVlIGlkXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXHJcbiAqL1xyXG52YXIgX3VuaXF1ZUlkID0gMTtcclxuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xyXG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyk7XHJcbn1cclxuXHJcbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XHJcblxyXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xyXG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XHJcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xyXG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcclxudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xyXG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcclxuXHJcbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XHJcblxyXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xyXG52YXIgSU5QVVRfTU9WRSA9IDI7XHJcbnZhciBJTlBVVF9FTkQgPSA0O1xyXG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcclxuXHJcbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XHJcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XHJcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xyXG52YXIgRElSRUNUSU9OX1VQID0gODtcclxudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XHJcblxyXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcclxudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xyXG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xyXG5cclxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcclxudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XHJcblxyXG4vKipcclxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqIEByZXR1cm5zIHtJbnB1dH1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xyXG5cclxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxyXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxyXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xyXG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcblxyXG59XHJcblxyXG5JbnB1dC5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYmluZCB0aGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXHJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxyXG4gKiBAcmV0dXJucyB7SW5wdXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcclxuICAgIHZhciBUeXBlO1xyXG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcclxuXHJcbiAgICBpZiAoaW5wdXRDbGFzcykge1xyXG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xyXG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XHJcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xyXG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcclxuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcclxuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcclxuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcclxuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcclxuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XHJcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcclxuXHJcbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xyXG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcclxuXHJcbiAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXHJcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcclxuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcclxuXHJcbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcclxuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xyXG5cclxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XHJcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcclxuXHJcbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XHJcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xyXG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XHJcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcclxuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXHJcbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xyXG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXHJcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcclxuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XHJcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XHJcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcclxuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcclxuXHJcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcclxuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xyXG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XHJcblxyXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XHJcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcclxuXHJcbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XHJcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xyXG5cclxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XHJcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xyXG5cclxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XHJcblxyXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcclxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XHJcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xyXG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcclxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XHJcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcclxuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcclxuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcclxuXHJcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcclxuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcclxuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxyXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xyXG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgICAgICAgeTogY2VudGVyLnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xyXG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcclxuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcclxuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXHJcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXHJcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XHJcblxyXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHZhciBkZWx0YVggPSBsYXN0LmRlbHRhWCAtIGlucHV0LmRlbHRhWDtcclxuICAgICAgICB2YXIgZGVsdGFZID0gbGFzdC5kZWx0YVkgLSBpbnB1dC5kZWx0YVk7XHJcblxyXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xyXG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcclxuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcclxuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xyXG5cclxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXHJcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xyXG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xyXG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XHJcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XHJcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XHJcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcclxuICovXHJcbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XHJcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcclxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xyXG4gICAgdmFyIHBvaW50ZXJzID0gW107XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xyXG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcclxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXHJcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxyXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcclxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcclxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcclxuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XHJcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XHJcblxyXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcclxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxyXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XHJcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xyXG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxyXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcclxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XHJcbiAgICBpZiAoeCA9PT0geSkge1xyXG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xyXG4gICAgICAgIHJldHVybiB4ID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cclxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcclxuICAgIH1cclxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxyXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcclxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcclxuICAgIH1cclxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxyXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcclxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSAtIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXHJcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xyXG59XHJcblxyXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xyXG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcclxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcclxuICAgIG1vdXNldXA6IElOUFVUX0VORFxyXG59O1xyXG5cclxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XHJcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcclxuXHJcbi8qKlxyXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xyXG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcclxuXHJcbiAgICB0aGlzLmFsbG93ID0gdHJ1ZTsgLy8gdXNlZCBieSBJbnB1dC5Ub3VjaE1vdXNlIHRvIGRpc2FibGUgbW91c2UgZXZlbnRzXHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXHJcblxyXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcclxuXHJcbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcclxuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXHJcbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQgfHwgIXRoaXMuYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXHJcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcclxuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcclxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxyXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXHJcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXHJcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcclxufTtcclxuXHJcbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXHJcbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xyXG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcclxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxyXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcclxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxyXG59O1xyXG5cclxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xyXG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcclxuXHJcbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxyXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XHJcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xyXG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xyXG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcclxufVxyXG5cclxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcclxuICAgIC8qKlxyXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xyXG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XHJcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xyXG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xyXG5cclxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcclxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xyXG5cclxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcclxuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcclxuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xyXG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxyXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxyXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxyXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xyXG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXHJcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXHJcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxyXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xyXG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG5cclxuLyoqXHJcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XHJcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XHJcblxyXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cclxuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxyXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHRoaXMge1RvdWNoSW5wdXR9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XHJcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcclxuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XHJcblxyXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xyXG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xyXG59XHJcblxyXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xyXG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXHJcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXHJcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxyXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG5cclxuLyoqXHJcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xyXG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XHJcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xyXG4gICAgICAgIGlmICghdG91Y2hlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcclxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xyXG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xyXG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xyXG5cclxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXHJcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcclxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxyXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xyXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcclxuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcclxuICAgIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcclxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xyXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcclxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xyXG4gICAgXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxyXG4gKlxyXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cclxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcclxuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xyXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XHJcbn1cclxuXHJcbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XHJcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxyXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIG1vc3QgbW9iaWxlIGJyb3dzZXIgYWxzbyBlbWl0IG1vdXNlZXZlbnRzLCByaWdodCBhZnRlciB0b3VjaHN0YXJ0XHJcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiAhdGhpcy5tb3VzZS5hbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNldCB0aGUgYWxsb3dNb3VzZSB3aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2UuYWxsb3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XHJcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XHJcblxyXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXHJcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcclxudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xyXG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcclxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcclxudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XHJcblxyXG4vKipcclxuICogVG91Y2ggQWN0aW9uXHJcbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuc2V0KHZhbHVlKTtcclxufVxyXG5cclxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcclxuICAgICAqL1xyXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcclxuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAgICAgKi9cclxuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICAvLyBub3QgbmVlZGVkIHdpdGggbmF0aXZlIHN1cHBvcnQgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eVxyXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxyXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XHJcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSk7XHJcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc05vbmUgfHxcclxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XHJcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XHJcbiAgICAgKi9cclxuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcclxuICAgIC8vIG5vbmVcclxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG5cclxuICAgIC8vIHBhbi14IGFuZCBwYW4teSBjYW4gYmUgY29tYmluZWRcclxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX1BBTl9YICsgJyAnICsgVE9VQ0hfQUNUSU9OX1BBTl9ZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBhbi14IE9SIHBhbi15XHJcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFuaXB1bGF0aW9uXHJcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXHJcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXHJcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxyXG4gKlxyXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXHJcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXHJcbiAqXHJcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cclxuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cclxuICpcclxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxyXG4gKiAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xyXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcclxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxyXG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxyXG4gKi9cclxudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcclxudmFyIFNUQVRFX0JFR0FOID0gMjtcclxudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xyXG52YXIgU1RBVEVfRU5ERUQgPSA4O1xyXG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xyXG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XHJcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcclxuXHJcbi8qKlxyXG4gKiBSZWNvZ25pemVyXHJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcclxuXHJcbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXHJcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xyXG5cclxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XHJcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XHJcbn1cclxuXHJcblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcclxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XHJcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xyXG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcclxuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XHJcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcclxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcclxuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZW1pdCh3aXRoU3RhdGUpIHtcclxuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgKHdpdGhTdGF0ZSA/IHN0YXRlU3RyKHN0YXRlKSA6ICcnKSwgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXHJcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcclxuICAgICAgICAgICAgZW1pdCh0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVtaXQoKTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xyXG5cclxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxyXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgICAgICBlbWl0KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXHJcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXHJcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcclxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbiB3ZSBlbWl0P1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XHJcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcclxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xyXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGV4dGVuZCh7fSwgaW5wdXREYXRhKTtcclxuXHJcbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XHJcbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XHJcblxyXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxyXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxyXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXHJcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcclxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcclxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcclxuICovXHJcbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XHJcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcclxuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcclxuICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xyXG4gICAgICAgIHJldHVybiAnbW92ZSc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcclxuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xyXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcclxuICAgICAgICByZXR1cm4gJ2Rvd24nO1xyXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XHJcbiAgICAgICAgcmV0dXJuICd1cCc7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xyXG4gICAgICAgIHJldHVybiAnbGVmdCc7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcclxuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXHJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XHJcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcclxuICAgIGlmIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XHJcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG9pbnRlcnM6IDFcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcclxuICAgICAqL1xyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcclxuXHJcbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XHJcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcclxuXHJcbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxyXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFBhblxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMucFggPSBudWxsO1xyXG4gICAgdGhpcy5wWSA9IG51bGw7XHJcbn1cclxuXHJcbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3BhbicsXHJcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWN0aW9ucztcclxuICAgIH0sXHJcblxyXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XHJcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XHJcblxyXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cclxuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcclxuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XHJcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQaW5jaFxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xyXG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3BpbmNoJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgICAgcG9pbnRlcnM6IDJcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcclxuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcclxuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dCwgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUHJlc3NcclxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XHJcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG59XHJcblxyXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXHJcbiAgICAgICAgcG9pbnRlcnM6IDEsXHJcbiAgICAgICAgdGltZTogNTAwLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxyXG4gICAgICAgIHRocmVzaG9sZDogNSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xyXG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblxyXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XHJcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxyXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcclxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVcclxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xyXG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgICAgcG9pbnRlcnM6IDJcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogU3dpcGVcclxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMTAsXHJcbiAgICAgICAgdmVsb2NpdHk6IDAuNjUsXHJcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcclxuICAgICAgICBwb2ludGVyczogMVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciB2ZWxvY2l0eTtcclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlYO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0LmRpcmVjdGlvbiAmJlxyXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcclxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcclxuICogYSBzaW5nbGUgdGFwLlxyXG4gKlxyXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcclxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXHJcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcclxuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcclxuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG59XHJcblxyXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAndGFwJyxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICB0YXBzOiAxLFxyXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXHJcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxyXG4gICAgICAgIHRocmVzaG9sZDogMiwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcclxuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xyXG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcclxuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHJcbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxyXG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcclxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcclxuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcclxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cclxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcclxuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xyXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhbiBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xyXG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtzdHJpbmd9XHJcbiAqL1xyXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNCc7XHJcblxyXG4vKipcclxuICogZGVmYXVsdCBzZXR0aW5nc1xyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5IYW1tZXIuZGVmYXVsdHMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBkb21FdmVudHM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXHJcbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXHJcbiAgICAgKi9cclxuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBlbmFibGU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXHJcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cclxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXHJcbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xyXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIGlucHV0Q2xhc3M6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcclxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHByZXNldDogW1xyXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxyXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfV0sXHJcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH0sIFsncm90YXRlJ11dLFxyXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIseyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH1dLFxyXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfSwgWydzd2lwZSddXSxcclxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXHJcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dLFxyXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cclxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqL1xyXG4gICAgY3NzUHJvcHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cclxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcclxuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcclxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgU1RPUCA9IDE7XHJcbnZhciBGT1JDRURfU1RPUCA9IDI7XHJcblxyXG4vKipcclxuICogTWFuYWdlclxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIEhhbW1lci5kZWZhdWx0cyk7XHJcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHJcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XHJcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcclxuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XHJcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XHJcblxyXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgZWFjaChvcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcclxuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcclxuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxuTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXHJcbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxyXG4gICAgICovXHJcbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcclxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcclxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxyXG4gICAgICovXHJcbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xyXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xyXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcjtcclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG5cclxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cclxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXHJcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxyXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xyXG5cclxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxyXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxyXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcclxuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxyXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcclxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXHJcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxyXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cclxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXHJcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxyXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXHJcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxyXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxyXG4gICAgICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcclxuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcclxuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplciksIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGJpbmQgZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XHJcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XHJcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xyXG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xyXG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcclxuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXHJcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxyXG4gICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XHJcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcclxuICovXHJcbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XHJcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBlbGVtZW50LnN0eWxlW3ByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpXSA9IGFkZCA/IHZhbHVlIDogJyc7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XHJcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcclxuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcclxuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcclxufVxyXG5cclxuZXh0ZW5kKEhhbW1lciwge1xyXG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxyXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcclxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxyXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXHJcblxyXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxyXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxyXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcclxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcclxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXHJcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcclxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxyXG5cclxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcclxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcclxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxyXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXHJcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXHJcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXHJcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcclxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXHJcblxyXG4gICAgTWFuYWdlcjogTWFuYWdlcixcclxuICAgIElucHV0OiBJbnB1dCxcclxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcclxuXHJcbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxyXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcclxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcclxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxyXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcclxuXHJcbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxyXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxyXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxyXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxyXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcclxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXHJcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXHJcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxyXG5cclxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcclxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXHJcbiAgICBlYWNoOiBlYWNoLFxyXG4gICAgbWVyZ2U6IG1lcmdlLFxyXG4gICAgZXh0ZW5kOiBleHRlbmQsXHJcbiAgICBpbmhlcml0OiBpbmhlcml0LFxyXG4gICAgYmluZEZuOiBiaW5kRm4sXHJcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcclxufSk7XHJcblxyXG5pZiAodHlwZW9mIGRlZmluZSA9PSBUWVBFX0ZVTkNUSU9OICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gSGFtbWVyO1xyXG4gICAgfSk7XHJcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XHJcbn0gZWxzZSB7XHJcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XHJcbn1cclxuXHJcbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBNaW5pbWFsaXN0aWMgZXZlbnQgZW1pdHRlciBtaXhpbi5cbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuIElmIHRoZSBsaXN0ZW5lciBoYXNcbiAqIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnQsIHRoaXMgaXMgYSBuby1vcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgdmFyIGV2ZW50TWFwID0gdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG4gIHZhciBoYW5kbGVyTGlzdCA9IGV2ZW50TWFwW25hbWVdID0gZXZlbnRNYXBbbmFtZV0gfHwgW107XG4gIGlmIChoYW5kbGVyTGlzdC5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBoYW5kbGVyTGlzdC5wdXNoKGZuKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQuIElmIHRoZSBsaXN0ZW5lclxuICogaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGV2ZW50LCB0aGlzIGlzIGEgbm8tb3AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gIHZhciBldmVudE1hcCA9IHRoaXMuX19ldmVudHMgPSB0aGlzLl9fZXZlbnRzIHx8IHt9O1xuICB2YXIgaGFuZGxlckxpc3QgPSBldmVudE1hcFtuYW1lXTtcbiAgaWYgKGhhbmRsZXJMaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gaGFuZGxlckxpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGhhbmRsZXJMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEVtaXRzIGFuIGV2ZW50LCBjYXVzaW5nIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhhdCBldmVudCB0byBiZVxuICogY2FsbGVkIGluIHJlZ2lzdHJhdGlvbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQXJndW1lbnRzIHRvIGNhbGwgbGlzdGVuZXJzIHdpdGguXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKG5hbWUsIHZhcl9hcmdzKSB7XG4gIHZhciBldmVudE1hcCA9IHRoaXMuX19ldmVudHMgPSB0aGlzLl9fZXZlbnRzIHx8IHt9O1xuICB2YXIgaGFuZGxlckxpc3QgPSBldmVudE1hcFtuYW1lXTtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSBoYW5kbGVyTGlzdFtpXTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNaXhlcyBpbiB7QGxpbmsgRXZlbnRFbWl0dGVyfSBpbnRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RW1pdHRlcihjdG9yKSB7XG4gIGZvciAodmFyIHByb3AgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIGlmIChFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBjdG9yLnByb3RvdHlwZVtwcm9wXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbcHJvcF07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlbnRFbWl0dGVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgY3NzU3VwcG9ydGVkID0gcmVxdWlyZSgnLi9zdXBwb3J0L0NzcycpO1xudmFyIHBvc2l0aW9uQWJzb2x1dGVseSA9IHJlcXVpcmUoJy4vdXRpbC9wb3NpdGlvbkFic29sdXRlbHknKTtcbnZhciBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0VHJhbnNmb3JtO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgSG90c3BvdFxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgSG90c3BvdCBhbGxvd3MgYSBET00gZWxlbWVudCB0byBiZSBwbGFjZWQgYXQgYSBmaXhlZCBwb3NpdGlvbiBpbiB0aGVcbiAqIGltYWdlLiBUaGUgcG9zaXRpb24gaXMgdXBkYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHtAbGluayBWaWV3IHZpZXd9XG4gKiBjaGFuZ2VzLlxuICpcbiAqIFBvc2l0aW9uaW5nIGlzIHBlcmZvcm1lZCB3aXRoIHRoZSBgdHJhbnNmb3JtYCBDU1MgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGBwb3NpdGlvbmAsIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcyB3aGVuIG5vdC5cbiAqIEluIGJvdGggY2FzZXMsIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQgaXMgcGxhY2VkIGluIHRoZSByZXF1ZXN0ZWRcbiAqIHBvc2l0aW9uOyBjbGllbnRzIGFyZSBleHBlY3RlZCB0byB1c2UgYWRkaXRpb25hbCBjaGlsZHJlbiBlbGVtZW50cyBvciBvdGhlclxuICogQ1NTIHByb3BlcnRpZXMgdG8gYWNoaWV2ZSBtb3JlIHNvcGhpc3RpY2F0ZWQgbGF5b3V0cy5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGtpbmRzIG9mIGhvdHNwb3RzOiByZWd1bGFyIGFuZCBlbWJlZGRlZC4gQSByZWd1bGFyIGhvdHNwb3RcbiAqIGRvZXMgbm90IGNoYW5nZSBzaXplIGRlcGVuZGluZyBvbiB0aGUgem9vbSBsZXZlbC4gQW4gZW1iZWRkZWQgaG90c3BvdCBpc1xuICogZGlzcGxheWVkIGF0IGEgZml4ZWQgc2l6ZSByZWxhdGl2ZSB0byB0aGUgcGFub3JhbWEsIGFsd2F5cyBjb3ZlcmluZyB0aGVcbiAqIHNhbWUgcG9ydGlvbiBvZiB0aGUgaW1hZ2UuIEVtYmVkZGVkIGhvdHNwb3RzIHJlcXVpcmUgQ1NTIDNEIHRyYW5zZm9ybVxuICogc3VwcG9ydC5cbiAqXG4gKiBDbGllbnRzIHNob3VsZCBjYWxsIHtAbGluayBIb3RzcG90Q29udGFpbmVyI2NyZWF0ZUhvdHNwb3R9IGluc3RlYWQgb2ZcbiAqIGludm9raW5nIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnQgVGhlIERPTSBlbGVtZW50LlxuICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSB2aWV3LlxuICogQHBhcmFtIHtPYmplY3R9IGNvb3JkcyBUaGUgaG90c3BvdCBjb29yZGluYXRlcy5cbiAqICAgICBVc2Uge0BsaW5rIFJlY3RpbGluZWFyVmlld0Nvb3Jkc30gZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30gb3JcbiAqICAgICB7QGxpbmsgRmxhdFZpZXdDb29yZHN9IGZvciBhIHtAbGluayBGbGF0Vmlld30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wZXJzcGVjdGl2ZSBQZXJzcGVjdGl2ZSBvcHRpb25zIGZvciBlbWJlZGRlZCBob3RzcG90cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5wZXJzcGVjdGl2ZS5yYWRpdXM9bnVsbF0gSWYgc2V0LCBlbWJlZCB0aGUgaG90c3BvdFxuICogICAgIGludG8gdGhlIGltYWdlIGJ5IHRyYW5zZm9ybWluZyBpdCBpbnRvIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlIHdpdGggdGhpc1xuICogICAgIHJhZGl1cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXM9bnVsbF0gSWYgc2V0LCBhcHBlbmQgdGhpc1xuICogICAgIHZhbHVlIHRvIHRoZSBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkgdXNlZCB0byBwb3NpdGlvbiB0aGUgaG90c3BvdC4gVGhpc1xuICogICAgIG1heSBiZSB1c2VkIHRvIHJvdGF0ZSBhbiBlbWJlZGRlZCBob3RzcG90LlxuICovXG5mdW5jdGlvbiBIb3RzcG90KGRvbUVsZW1lbnQsIHBhcmVudERvbUVsZW1lbnQsIHZpZXcsIGNvb3Jkcywgb3B0cykge1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnBlcnNwZWN0aXZlID0gb3B0cy5wZXJzcGVjdGl2ZSB8fCB7fTtcbiAgb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMgPVxuICAgICAgb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMgIT0gbnVsbCA/IG9wdHMucGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zIDogXCJcIjtcblxuICBpZiAoKG9wdHMucGVyc3BlY3RpdmUucmFkaXVzIHx8IG9wdHMucGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zKSAmJiAhY3NzU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NTUyB0cmFuc2Zvcm1zIG9uIGhvdHNwb3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xuICB9XG5cbiAgdGhpcy5fZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQgPSBwYXJlbnREb21FbGVtZW50O1xuICB0aGlzLl92aWV3ID0gdmlldztcbiAgdGhpcy5fY29vcmRzID0ge307XG4gIHRoaXMuX3BlcnNwZWN0aXZlID0ge307XG5cbiAgdGhpcy5zZXRQb3NpdGlvbihjb29yZHMpO1xuXG4gIC8vIEFkZCBob3RzcG90IGludG8gdGhlIERPTS5cbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9kb21FbGVtZW50KTtcblxuICB0aGlzLnNldFBlcnNwZWN0aXZlKG9wdHMucGVyc3BlY3RpdmUpO1xuXG4gIC8vIFdoZXRoZXIgdGhlIGhvdHNwb3QgaXMgdmlzaWJsZS5cbiAgLy8gVGhlIGhvdHNwb3QgbWF5IHN0aWxsIGJlIGhpZGRlbiBpZiBpdCdzIGluc2lkZSBhIGhpZGRlbiBIb3RzcG90Q29udGFpbmVyLlxuICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcblxuICAvLyBUaGUgY3VycmVudCBjYWxjdWxhdGVkIHNjcmVlbiBwb3NpdGlvbi5cbiAgdGhpcy5fcG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbn1cblxuZXZlbnRFbWl0dGVyKEhvdHNwb3QpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqIENsaWVudHMgc2hvdWxkIGNhbGwge0BsaW5rIEhvdHNwb3RDb250YWluZXIjZGVzdHJveUhvdHNwb3R9IGluc3RlYWQuXG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9kb21FbGVtZW50KTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRzO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHNcbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgZm9yICh2YXIga2V5IGluIGNvb3Jkcykge1xuICAgIHRoaXMuX2Nvb3Jkc1trZXldID0gY29vcmRzW2tleV07XG4gIH1cbiAgdGhpcy5fdXBkYXRlKCk7XG4gIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBlbWl0IGEgaG90c3BvdHNDaGFuZ2UgZXZlbnQgb24gdGhlIHBhcmVudFxuICAvLyBIb3RzcG90Q29udGFpbmVyLiBXaGF0J3MgdGhlIGJlc3Qgd2F5IHRvIGRvIHNvP1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSG90c3BvdC5wcm90b3R5cGUucGVyc3BlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BlcnNwZWN0aXZlO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5zZXRQZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKHBlcnNwZWN0aXZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBwZXJzcGVjdGl2ZSkge1xuICAgIHRoaXMuX3BlcnNwZWN0aXZlW2tleV0gPSBwZXJzcGVjdGl2ZVtrZXldO1xuICB9XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG4vKipcbiAqIFNob3cgdGhlIGhvdHNwb3RcbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEhpZGUgdGhlIGhvdHNwb3RcbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxufTtcblxuXG5Ib3RzcG90LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbGVtZW50ID0gdGhpcy5fZG9tRWxlbWVudDtcblxuICB2YXIgcGFyYW1zID0gdGhpcy5fY29vcmRzO1xuICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcbiAgdmFyIHgsIHk7XG5cbiAgdmFyIGlzVmlzaWJsZSA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuXG4gICAgaWYgKHRoaXMuX3BlcnNwZWN0aXZlLnJhZGl1cykge1xuICAgICAgLy8gSG90c3BvdHMgdGhhdCBhcmUgZW1iZWRkZWQgaW4gdGhlIHBhbm9yYW1hIG1heSBiZSB2aXNpYmxlIGV2ZW4gd2hlblxuICAgICAgLy8gcG9zaXRpb25lZCBiZWhpbmQgdGhlIGNhbWVyYS5cbiAgICAgIGlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLl9zZXRFbWJlZGRlZFBvc2l0aW9uKHZpZXcsIHBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXIgaG90c3BvdHMgYXJlIG9ubHkgdmlzaWJsZSB3aGVuIHBvc2l0aW9uZWQgaW4gZnJvbnQgb2YgdGhlXG4gICAgICAvLyBjYW1lcmEuIE5vdGUgdGhhdCB0aGV5IG1heSBiZSBwYXJ0aWFsbHkgdmlzaWJsZSB3aGVuIHBvc2l0aW9uZWQgb3V0c2lkZVxuICAgICAgLy8gdGhlIHZpZXdwb3J0LlxuICAgICAgdmlldy5jb29yZGluYXRlc1RvU2NyZWVuKHBhcmFtcywgcG9zaXRpb24pO1xuICAgICAgeCA9IHBvc2l0aW9uLng7XG4gICAgICB5ID0gcG9zaXRpb24ueTtcblxuICAgICAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2hvdyBpZiB2aXNpYmxlLCBoaWRlIGlmIG5vdC5cbiAgaWYgKGlzVmlzaWJsZSkge1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIH1cbiAgZWxzZSB7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgfVxuXG59O1xuXG5cbkhvdHNwb3QucHJvdG90eXBlLl9zZXRFbWJlZGRlZFBvc2l0aW9uID0gZnVuY3Rpb24odmlldywgcGFyYW1zKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSB2aWV3LmNvb3JkaW5hdGVzVG9QZXJzcGVjdGl2ZVRyYW5zZm9ybShcbiAgICAgIHBhcmFtcywgdGhpcy5fcGVyc3BlY3RpdmUucmFkaXVzLCB0aGlzLl9wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMpO1xuICBzZXRUcmFuc2Zvcm0odGhpcy5fZG9tRWxlbWVudCwgdHJhbnNmb3JtKTtcbn07XG5cblxuSG90c3BvdC5wcm90b3R5cGUuX3NldFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICBwb3NpdGlvbkFic29sdXRlbHkodGhpcy5fZG9tRWxlbWVudCwgeCwgeSwgdGhpcy5fcGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIb3RzcG90O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgSG90c3BvdCA9IHJlcXVpcmUoJy4vSG90c3BvdCcpO1xudmFyIGNhbGNSZWN0ID0gcmVxdWlyZSgnLi91dGlsL2NhbGNSZWN0Jyk7XG52YXIgY3NzUG9pbnRlckV2ZW50c1N1cHBvcnRlZCA9IHJlcXVpcmUoJy4vc3VwcG9ydC9jc3NQb2ludGVyRXZlbnRzJyk7XG52YXIgcG9zaXRpb25BYnNvbHV0ZWx5ID0gcmVxdWlyZSgnLi91dGlsL3Bvc2l0aW9uQWJzb2x1dGVseScpO1xudmFyIHNldEFic29sdXRlID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEFic29sdXRlO1xudmFyIHNldE92ZXJmbG93SGlkZGVuID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldE92ZXJmbG93SGlkZGVuO1xudmFyIHNldE92ZXJmbG93VmlzaWJsZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRPdmVyZmxvd1Zpc2libGU7XG52YXIgc2V0TnVsbFNpemUgPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0TnVsbFNpemU7XG52YXIgc2V0UGl4ZWxTaXplID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldFBpeGVsU2l6ZTtcbnZhciBzZXRQb2ludGVyRXZlbnRzID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldFdpdGhWZW5kb3JQcmVmaXgoJ3BvaW50ZXItZXZlbnRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIGhvdHNwb3QgaGFzIGJlZW4gY3JlYXRlZCBvciBkZXN0cm95ZWQgb24gdGhlIGNvbnRhaW5lci5cbiAqIEBldmVudCBIb3RzcG90Q29udGFpbmVyI2hvdHNwb3RzQ2hhbmdlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgSG90c3BvdENvbnRhaW5lclxuICogQGNsYXNzZGVzY1xuICpcbiAqIENyZWF0ZXMgYSBET00gZWxlbWVudCB0byBob2xkIHtAbGluayBIb3RzcG90IGhvdHNwb3RzfSBhbmQgdXBkYXRlcyB0aGVpclxuICogcG9zaXRpb24gd2hlbiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnREb21FbGVtZW50IFRoZSBET00gZWxlbWVudCBpbnNpZGUgd2hpY2ggdGhlIGNvbnRhaW5lclxuICogICAgIHNob3VsZCBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXcgVGhlIHZpZXcgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBob3RzcG90cyBhcmUgcG9zaXRpb25lZC5cbiAqIEBwYXJhbSB7UmVuZGVyTG9vcH0gcmVuZGVyTG9vcCBUaGUgcmVuZGVyIGxvb3AgaW5kaWNhdGluZyB3aGVuIHRoZSBob3RzcG90c1xuICogICAgIG11c3QgYmUgcmVuZGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtSZWN0U3BlY30gb3B0cy5yZWN0IFJlY3Rhbmd1bGFyIHJlZ2lvbiBjb3ZlcmVkIGJ5IHRoZSBjb250YWluZXIuIFNlZVxuICogICAge0BsaW5rIEVmZmVjdHMjcmVjdH0uXG4gKi9cbmZ1bmN0aW9uIEhvdHNwb3RDb250YWluZXIocGFyZW50RG9tRWxlbWVudCwgc3RhZ2UsIHZpZXcsIHJlbmRlckxvb3AsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudCA9IHBhcmVudERvbUVsZW1lbnQ7XG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG4gIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICB0aGlzLl9yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcblxuICAvLyBIb3RzcG90IGxpc3QuXG4gIHRoaXMuX2hvdHNwb3RzID0gW107XG5cbiAgLy8gV2hldGhlciB0aGUgaG90c3BvdCBjb250YWluZXIgc2hvdWxkIGJlIHZpc2libGUuXG4gIC8vIEl0IG1heSBzdGlsbCBiZSBoaWRkZW4gaWYgYSByZWN0IGVmZmVjdCBpcyBzZXQgb24gYSBicm93c2VyIHdpdGhvdXRcbiAgLy8gcG9pbnRlci1ldmVudHMgc3VwcG9ydC5cbiAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cbiAgLy8gVGhlIGN1cnJlbnQgcmVjdC5cbiAgdGhpcy5fcmVjdCA9IG9wdHMucmVjdDtcblxuICAvLyBXaGV0aGVyIHRoZSB2aXNpYmlsaXR5IG9yIHRoZSByZWN0IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBET00gdXBkYXRlLlxuICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG5cbiAgLy8gVGhlIGxhc3Qgc2VlbiBzdGFnZSBkaW1lbnNpb25zLlxuICB0aGlzLl9zdGFnZVdpZHRoID0gbnVsbDtcbiAgdGhpcy5fc3RhZ2VIZWlnaHQgPSBudWxsO1xuXG4gIC8vIFRlbXBvcmFyeSB2YXJpYWJsZSB0byBob2xkIHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uIGFuZCBzaXplLlxuICB0aGlzLl90bXBSZWN0ID0ge307XG5cbiAgLy8gV3JhcHBlciBlbGVtZW50LiBXaGVuIHRoZSByZWN0IGVmZmVjdCBpcyBzZXQsIHRoZSB3cmFwcGVyIHdpbGwgaGF2ZSBub256ZXJvXG4gIC8vIGRpbWVuc2lvbnMgYW5kIGBwb2ludGVyLWV2ZW50czogbm9uZWAgc28gdGhhdCBob3RzcG90cyBvdXRzaWRlIHRoZSByZWN0IGFyZVxuICAvLyBoaWRkZW4sIGJ1dCBubyBtb3VzZSBldmVudHMgYXJlIGhpamFja2VkLiBUaGUgZXhjZXB0aW9uIGlzIGJyb3dzZXJzIHdpdGhvdXRcbiAgLy8gcG9pbnRlci1ldmVudHMgc3VwcG9ydCwgd2hlcmUgd2UgcmVmdXNlIHRvIHNob3cgdGhlIGhvdHNwb3RzIHdoZW4gYSByZWN0IGlzXG4gIC8vIHNldCBhcyBpdCB3b3VsZCBwcmV2ZW50IHRoZSBjb250cm9scyBmcm9tIHJlY2VpdmluZyBtb3VzZSBldmVudHMuXG4gIHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyKTtcbiAgc2V0UG9pbnRlckV2ZW50cyh0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlciwgJ25vbmUnKTtcbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlcik7XG5cbiAgLy8gSG90c3BvdCBjb250YWluZXIgZWxlbWVudC4gSXQgaGFzIHplcm8gZGltZW5zaW9ucyBhbmQgYHBvaW50ZXItZXZlbnRzOiBhbGxgXG4gIC8vIHRvIG92ZXJyaWRlIHRoZSBgcG9pbnRlci1ldmVudHM6IG5vbmVgIG9uIHRoZSB3cmFwcGVyIGFuZCBhbGxvdyBob3RzcG90cyB0b1xuICAvLyBiZSBpbnRlcmFjdGVkIHdpdGguXG4gIHRoaXMuX2hvdHNwb3RDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2V0QWJzb2x1dGUodGhpcy5faG90c3BvdENvbnRhaW5lcik7XG4gIHNldFBvaW50ZXJFdmVudHModGhpcy5faG90c3BvdENvbnRhaW5lciwgJ2FsbCcpO1xuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLl9ob3RzcG90Q29udGFpbmVyKTtcblxuICAvLyBVcGRhdGUgd2hlbiB0aGUgaG90c3BvdHMgY2hhbmdlIG9yIHNjZW5lIGlzIHJlLXJlbmRlcmVkLlxuICB0aGlzLl91cGRhdGVIYW5kbGVyID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gIHRoaXMuX3JlbmRlckxvb3AuYWRkRXZlbnRMaXN0ZW5lcignYWZ0ZXJSZW5kZXInLCB0aGlzLl91cGRhdGVIYW5kbGVyKTtcbn1cblxuZXZlbnRFbWl0dGVyKEhvdHNwb3RDb250YWluZXIpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5faG90c3BvdHMubGVuZ3RoKSB7XG4gICAgdGhpcy5kZXN0cm95SG90c3BvdCh0aGlzLl9ob3RzcG90c1swXSk7XG4gIH1cblxuICB0aGlzLl9wYXJlbnREb21FbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyKTtcblxuICB0aGlzLl9yZW5kZXJMb29wLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FmdGVyUmVuZGVyJywgdGhpcy5fdXBkYXRlSGFuZGxlcik7XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hvdHNwb3RDb250YWluZXI7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtSZWN0fSByZWN0XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLnNldFJlY3QgPSBmdW5jdGlvbihyZWN0KSB7XG4gIGlmIChyZWN0ICYmICFjc3NQb2ludGVyRXZlbnRzU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlVzaW5nIGEgcmVjdCBlZmZlY3QgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuIFwiICtcbiAgICAgICAgXCJIb3RzcG90cyBtYXkgbm90IGJlIHNob3duLlwiKVxuICB9XG4gIHRoaXMuX3JlY3QgPSByZWN0O1xuICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7UmVjdH1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVjdDtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGhvdHNwb3QgaW4gdGhpcyBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50IERPTSBlbGVtZW50IHRvIHVzZSBmb3IgdGhlIGhvdHNwb3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgVGhlIGhvdHNwb3QgY29vcmRpbmF0ZXMuXG4gKiAgICAgVXNlIHtAbGluayBSZWN0aWxpbmVhclZpZXdDb29yZHN9YCBmb3IgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fSBvclxuICogICAgIHtAbGluayBGbGF0Vmlld0Nvb3Jkc30gZm9yIGEge0BsaW5rIEZsYXRWaWV3fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnMgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBgb3B0c2AgYXJndW1lbnQgdG9cbiAqICAgICB0aGUge0BsaW5rIEhvdHNwb3R9IGNvbnN0cnVjdG9yLlxuICogQHJldHVybiB7SG90c3BvdH1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuY3JlYXRlSG90c3BvdCA9IGZ1bmN0aW9uKGRvbUVsZW1lbnQsIGNvb3Jkcywgb3B0cykge1xuICBjb29yZHMgPSBjb29yZHMgfHwge307XG5cbiAgdmFyIGhvdHNwb3QgPSBuZXcgSG90c3BvdChcbiAgICAgIGRvbUVsZW1lbnQsIHRoaXMuX2hvdHNwb3RDb250YWluZXIsIHRoaXMuX3ZpZXcsIGNvb3Jkcywgb3B0cyk7XG4gIHRoaXMuX2hvdHNwb3RzLnB1c2goaG90c3BvdCk7XG4gIGhvdHNwb3QuX3VwZGF0ZSgpO1xuXG4gIHRoaXMuZW1pdCgnaG90c3BvdHNDaGFuZ2UnKTtcblxuICByZXR1cm4gaG90c3BvdDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge0hvdHNwb3R9IGhvdHNwb3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmhhc0hvdHNwb3QgPSBmdW5jdGlvbihob3RzcG90KSB7XG4gIHJldHVybiB0aGlzLl9ob3RzcG90cy5pbmRleE9mKGhvdHNwb3QpID49IDA7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7SG90c3BvdFtdfVxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5saXN0SG90c3BvdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9ob3RzcG90cyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIGhvdHNwb3QgZnJvbSB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7SG90c3BvdH0gaG90c3BvdFxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95SG90c3BvdCA9IGZ1bmN0aW9uKGhvdHNwb3QpIHtcbiAgdmFyIGkgPSB0aGlzLl9ob3RzcG90cy5pbmRleE9mKGhvdHNwb3QpO1xuICBpZiAoaSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggaG90c3BvdCcpO1xuICB9XG4gIHRoaXMuX2hvdHNwb3RzLnNwbGljZShpLCAxKTtcblxuICBob3RzcG90LmRlc3Ryb3koKTtcbiAgdGhpcy5lbWl0KCdob3RzcG90c0NoYW5nZScpO1xufTtcblxuXG4vKipcbiAqIEhpZGUgdGhlIGNvbnRhaW5lcidzIERPTSBlbGVtZW50LCBjYXVzaW5nIGV2ZXJ5IGNvbnRhaW5lZCB7QGxpbmsgSG90c3BvdH0gdG9cbiAqIGJlIGhpZGRlbi5cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTaG93IHRoZSBjb250YWluZXIncyBET00gZWxlbWVudCwgY2F1c2luZyBldmVyeSBjb250YWluZWQge0BsaW5rIEhvdHNwb3R9IHRvXG4gKiBiZSBzaG93bi5cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbn07XG5cblxuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd3JhcHBlciA9IHRoaXMuX2hvdHNwb3RDb250YWluZXJXcmFwcGVyO1xuICB2YXIgd2lkdGggPSB0aGlzLl9zdGFnZS53aWR0aCgpO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5fc3RhZ2UuaGVpZ2h0KCk7XG4gIHZhciB0bXBSZWN0ID0gdGhpcy5fdG1wUmVjdDtcblxuICAvLyBBdm9pZCB1cGRhdGluZyB0aGUgd3JhcHBlciBET00gdW5sZXNzIG5lY2Vzc2FyeS5cbiAgaWYgKHRoaXMuX3Zpc2liaWxpdHlPclJlY3RDaGFuZ2VkIHx8XG4gICAgICAodGhpcy5fcmVjdCAmJiAod2lkdGggIT09IHRoaXMuX3N0YWdlV2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9zdGFnZUhlaWdodCkpKSB7XG4gICAgdmFyIHZpc2libGUgPSB0aGlzLl92aXNpYmxlICYmICEodGhpcy5fcmVjdCAmJiAhY3NzUG9pbnRlckV2ZW50c1N1cHBvcnRlZCgpKTtcbiAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJztcblxuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICBpZiAodGhpcy5fcmVjdCkge1xuICAgICAgICBjYWxjUmVjdCh3aWR0aCwgaGVpZ2h0LCB0aGlzLl9yZWN0LCB0bXBSZWN0KTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZWx5KHdyYXBwZXIsIHdpZHRoICogdG1wUmVjdC54LCBoZWlnaHQgKiB0bXBSZWN0LnkpO1xuICAgICAgICBzZXRQaXhlbFNpemUod3JhcHBlciwgd2lkdGggKiB0bXBSZWN0LndpZHRoLCBoZWlnaHQgKiB0bXBSZWN0LmhlaWdodCk7XG4gICAgICAgIHNldE92ZXJmbG93SGlkZGVuKHdyYXBwZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZWx5KHdyYXBwZXIsIDAsIDApO1xuICAgICAgICBzZXROdWxsU2l6ZSh3cmFwcGVyKTtcbiAgICAgICAgc2V0T3ZlcmZsb3dWaXNpYmxlKHdyYXBwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YWdlV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9zdGFnZUhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVXBkYXRlIGhvdHNwb3RzIHVuY29uZGl0aW9uYWxseSwgYXMgdGhlIHZpZXcgcGFyYW1ldGVycyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvdHNwb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5faG90c3BvdHNbaV0uX3VwZGF0ZSgpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSG90c3BvdENvbnRhaW5lcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlsL2V4dGVuZCcpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIGxheWVyIGhhcyBiZWVuIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhYmxlIFdoZXRoZXIgYWxsIHRpbGVzIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHdpdGhvdXRcbiAqICAgICBtaXNzaW5nIHRleHR1cmVzIG9yIHJlc29ydGluZyB0byBmYWxsYmFja3MuXG4gKiBAZXZlbnQgTGF5ZXIjcmVuZGVyQ29tcGxldGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBMYXllclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgTGF5ZXIgaXMgYSBjb21iaW5hdGlvbiBvZiB7QGxpbmsgU291cmNlfSwge0BsaW5rIEdlb21ldHJ5fSwge0BsaW5rIFZpZXd9XG4gKiBhbmQge0BsaW5rIFRleHR1cmVTdG9yZX0gdGhhdCBtYXkgYmUgYWRkZWQgaW50byBhIHtAbGluayBTdGFnZX0gYW5kIHJlbmRlcmVkXG4gKiB3aXRoIHtAbGluayBFZmZlY3RzfS5cbiAqXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtWaWV3fSB2aWV3XG4gKiBAcGFyYW0ge1RleHR1cmVTdG9yZX0gdGV4dHVyZVN0b3JlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtFZmZlY3RzfSBvcHRzLmVmZmVjdHNcbiovXG5mdW5jdGlvbiBMYXllcihzb3VyY2UsIGdlb21ldHJ5LCB2aWV3LCB0ZXh0dXJlU3RvcmUsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fdmlldyA9IHZpZXc7XG4gIHRoaXMuX3RleHR1cmVTdG9yZSA9IHRleHR1cmVTdG9yZTtcblxuICB0aGlzLl9lZmZlY3RzID0gb3B0cy5lZmZlY3RzIHx8IHt9O1xuXG4gIHRoaXMuX2ZpeGVkTGV2ZWxJbmRleCA9IG51bGw7XG5cbiAgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ3ZpZXdDaGFuZ2UnLCBzZWxmLnZpZXcoKSk7XG4gIH07XG5cbiAgdGhpcy5fdmlldy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG5cbiAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgndGV4dHVyZVN0b3JlQ2hhbmdlJywgc2VsZi50ZXh0dXJlU3RvcmUoKSk7XG4gIH07XG5cbiAgdGhpcy5fdGV4dHVyZVN0b3JlLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHR1cmVMb2FkJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHR1cmVFcnJvcicsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3RleHR1cmVTdG9yZS5hZGRFdmVudExpc3RlbmVyKCd0ZXh0dXJlSW52YWxpZCcsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG59XG5cbmV2ZW50RW1pdHRlcihMYXllcik7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5MYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl92aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RleHR1cmVMb2FkJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RleHR1cmVFcnJvcicsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3RleHR1cmVTdG9yZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXh0dXJlSW52YWxpZCcsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2Ugc291cmNlfS5cbiAqIEByZXR1cm4ge1NvdXJjZX1cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIEdlb21ldHJ5IGdlb21ldHJ5fS5cbiAqIEByZXR1cm4ge0dlb21ldHJ5fVxuICovXG5MYXllci5wcm90b3R5cGUuZ2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFZpZXcgdmlld30uXG4gKiBAcmV0dXJuIHtWaWV3fVxuICovXG5MYXllci5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdmlldztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBUZXh0dXJlU3RvcmUgdGV4dHVyZSBzdG9yZX0uXG4gKiBAcmV0dXJuIHtUZXh0dXJlU3RvcmV9XG4gKi9cbkxheWVyLnByb3RvdHlwZS50ZXh0dXJlU3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RleHR1cmVTdG9yZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2V0IHtAbGluayBFZmZlY3RzIGVmZmVjdHN9LlxuICogQHJldHVybiB7RWZmZWN0c31cbiAqL1xuTGF5ZXIucHJvdG90eXBlLmVmZmVjdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VmZmVjdHM7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUge0BsaW5rIEVmZmVjdHMgZWZmZWN0c30uXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqL1xuTGF5ZXIucHJvdG90eXBlLnNldEVmZmVjdHMgPSBmdW5jdGlvbihlZmZlY3RzKSB7XG4gIHRoaXMuX2VmZmVjdHMgPSBlZmZlY3RzO1xuICB0aGlzLmVtaXQoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lZmZlY3RzKTtcbn07XG5cblxuLyoqXG4gKiBNZXJnZXMgZWZmZWN0cyBpbnRvIHRoZSBjdXJyZW50bHkgc2V0IG9uZXMuIFRoZSBtZXJnZSBpcyBub24tcmVjdXJzaXZlOyBmb3JcbiAqIGluc3RhbmNlLCBpZiBjdXJyZW50IGVmZmVjdHMgYXJlIGB7IHJlY3Q6IHsgcmVsYXRpdmVXaWR0aDogMC41IH0gfWAsXG4gKiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggYHsgcmVjdDogeyByZWxhdGl2ZVg6IDAuNSB9fWAgd2lsbCByZXNldFxuICogYHJlY3QucmVsYXRpdmVXaWR0aGAuXG4gKlxuICogQHBhcmFtIHtFZmZlY3RzfSBlZmZlY3RzXG4gKi9cbkxheWVyLnByb3RvdHlwZS5tZXJnZUVmZmVjdHMgPSBmdW5jdGlvbihlZmZlY3RzKSB7XG4gIGV4dGVuZCh0aGlzLl9lZmZlY3RzLCBlZmZlY3RzKTtcbiAgdGhpcy5lbWl0KCdlZmZlY3RzQ2hhbmdlJywgdGhpcy5fZWZmZWN0cyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZml4ZWQgbGV2ZWwgaW5kZXguXG4gKiBAcmV0dXJuIHsobnVtYmVyfG51bGwpfVxuICovXG5MYXllci5wcm90b3R5cGUuZml4ZWRMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZml4ZWRMZXZlbEluZGV4O1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGZpeGVkIGxldmVsIGluZGV4LiBXaGVuIHNldCwgdGhlIGNvcnJlc3BvbmRpbmcgbGV2ZWwgd2lsbCBiZVxuICogdXNlZCByZWdhcmRsZXNzIG9mIHRoZSB2aWV3IHBhcmFtZXRlcnMuIFVuc2V0IHdpdGggYSBudWxsIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7KG51bWJlcnxudWxsKX0gbGV2ZWxJbmRleFxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGV2ZWwgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICovXG5MYXllci5wcm90b3R5cGUuc2V0Rml4ZWRMZXZlbCA9IGZ1bmN0aW9uKGxldmVsSW5kZXgpIHtcbiAgaWYgKGxldmVsSW5kZXggIT09IHRoaXMuX2ZpeGVkTGV2ZWxJbmRleCkge1xuICAgIGlmIChsZXZlbEluZGV4ICE9IG51bGwgJiYgKGxldmVsSW5kZXggPj0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0Lmxlbmd0aCB8fFxuICAgICAgICBsZXZlbEluZGV4IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxldmVsIGluZGV4IG91dCBvZiByYW5nZTogXCIgKyBsZXZlbEluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5fZml4ZWRMZXZlbEluZGV4ID0gbGV2ZWxJbmRleDtcbiAgICB0aGlzLmVtaXQoJ2ZpeGVkTGV2ZWxDaGFuZ2UnLCB0aGlzLl9maXhlZExldmVsSW5kZXgpO1xuICB9XG59O1xuXG5cbkxheWVyLnByb3RvdHlwZS5fc2VsZWN0TGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsO1xuICBpZiAodGhpcy5fZml4ZWRMZXZlbEluZGV4ICE9IG51bGwpIHtcbiAgICBsZXZlbCA9IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdFt0aGlzLl9maXhlZExldmVsSW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIGxldmVsID0gdGhpcy5fdmlldy5zZWxlY3RMZXZlbCh0aGlzLl9nZW9tZXRyeS5zZWxlY3RhYmxlTGV2ZWxMaXN0KTtcbiAgfVxuICByZXR1cm4gbGV2ZWw7XG59O1xuXG5cbkxheWVyLnByb3RvdHlwZS52aXNpYmxlVGlsZXMgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgdmFyIGxldmVsID0gdGhpcy5fc2VsZWN0TGV2ZWwoKTtcbiAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5LnZpc2libGVUaWxlcyh0aGlzLl92aWV3LCBsZXZlbCwgcmVzdWx0KTtcbn07XG5cblxuLyoqXG4gKiBQaW4gYSB3aG9sZSBsZXZlbCBpbnRvIHRoZSB0ZXh0dXJlIHN0b3JlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXhcbiAqL1xuTGF5ZXIucHJvdG90eXBlLnBpbkxldmVsID0gZnVuY3Rpb24obGV2ZWxJbmRleCkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3RbbGV2ZWxJbmRleF07XG4gIHZhciB0aWxlcyA9IHRoaXMuX2dlb21ldHJ5LmxldmVsVGlsZXMobGV2ZWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlLnBpbih0aWxlc1tpXSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVbnBpbiBhIHdob2xlIGxldmVsIGZyb20gdGhlIHRleHR1cmUgc3RvcmUuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxJbmRleFxuICovXG5MYXllci5wcm90b3R5cGUudW5waW5MZXZlbCA9IGZ1bmN0aW9uKGxldmVsSW5kZXgpIHtcbiAgdmFyIGxldmVsID0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0W2xldmVsSW5kZXhdO1xuICB2YXIgdGlsZXMgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbFRpbGVzKGxldmVsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX3RleHR1cmVTdG9yZS51bnBpbih0aWxlc1tpXSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQaW4gdGhlIGZpcnN0IGxldmVsLiBFcXVpdmFsZW50IHRvIGBwaW5MZXZlbCgwKWAuXG4gKi9cbkxheWVyLnByb3RvdHlwZS5waW5GaXJzdExldmVsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBpbkxldmVsKDApO1xufTtcblxuXG4vKipcbiAqIFVucGluIHRoZSBmaXJzdCBsZXZlbC4gRXF1aXZhbGVudCB0byBgdW5waW5MZXZlbCgwKWAuXG4gKi9cbkxheWVyLnByb3RvdHlwZS51bnBpbkZpcnN0TGV2ZWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudW5waW5MZXZlbCgwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyk7XG5cbi8qKlxuICogQGNsYXNzIE5ldHdvcmtFcnJvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNsYXNzZGVzY1xuICpcbiAqIFNpZ25hbHMgYW4gZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyBhIFVSTC4gVGhpcyBpcyB1c2VkIGJ5XG4gKiB7QGxpbmsgTG9hZGVyIGxvYWRlcnN9IHRvIGRpc3Rpbmd1aXNoIG5ldHdvcmsgZmFpbHVyZXMgZnJvbSBvdGhlciBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIE5ldHdvcmtFcnJvcihtZXNzYWdlKSB7XG4gIC8vIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MjEwNy93aGF0cy1hLWdvb2Qtd2F5LXRvLWV4dGVuZC1lcnJvci1pbi1qYXZhc2NyaXB0XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbmluaGVyaXRzKE5ldHdvcmtFcnJvciwgRXJyb3IpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtFcnJvcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQge0BsaW5rIFN0YWdlI3JlbmRlcn0gaXMgYWJvdXQgdG8gYmUgY2FsbGVkLlxuICogQGV2ZW50IFJlbmRlckxvb3AjYmVmb3JlUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQge0BsaW5rIFN0YWdlI3JlbmRlcn0gaGFzIGp1c3QgYmVlbiBjYWxsZWQuXG4gKiBAZXZlbnQgUmVuZGVyTG9vcCNhZnRlclJlbmRlclxuICovXG5cbi8qKlxuICogQGNsYXNzIFJlbmRlckxvb3BcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFJlbmRlckxvb3Agd3JhcHMgYSB7QGxpbmsgU3RhZ2V9IGFuZCBjYWxscyB7QGxpbmsgU3RhZ2UjcmVuZGVyfSBvbiB0aGUgbmV4dFxuICogZnJhbWUgd2hlbmV2ZXIgaXQgZmlyZXMge0BsaW5rIFN0YWdlI3JlbmRlckludmFsaWR9LiBJdCBtYXkgYmUgc3RhcnRlZCBhbmRcbiAqIHN0b3BwZWQsIGFuZCBpcyBpbml0aWFsbHkgaW4gdGhlIHN0b3BwZWQgc3RhdGUsIGluIHdoaWNoIG5vIGNhbGwgdG9cbiAqIHtAbGluayBTdGFnZSNyZW5kZXJ9IG9jY3Vycy5cbiAqXG4gKiBAbGlzdGVucyBTdGFnZSNyZW5kZXJJbnZhbGlkXG4gKlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2VcbiAqL1xuZnVuY3Rpb24gUmVuZGVyTG9vcChzdGFnZSkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBUaGUgc3RhZ2Ugd3JhcHBlZCBieSB0aGUgbG9vcC5cbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcblxuICAvLyBXaGV0aGVyIHRoZSBsb29wIGlzIHJ1bm5pbmcuXG4gIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuICAvLyBXaGV0aGVyIHRoZSBsb29wIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gIHRoaXMuX3JlbmRlcmluZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBjdXJyZW50IHJlcXVlc3RBbmltYXRpb25GcmFtZSBoYW5kbGUuXG4gIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSBudWxsO1xuXG4gIC8vIFRoZSBjYWxsYmFjayBwYXNzZWQgaW50byByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gIHRoaXMuX2JvdW5kTG9vcCA9IHRoaXMuX2xvb3AuYmluZCh0aGlzKTtcblxuICAvLyBIYW5kbGVyIGZvciByZW5kZXJJbnZhbGlkIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBzdGFnZS5cbiAgdGhpcy5fcmVuZGVySW52YWxpZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSByZW5kZXJpbmcsIHRoZXJlJ3Mgbm8gbmVlZCB0byBzY2hlZHVsZSBhIG5ldyByZW5kZXJcbiAgICAvLyBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICBpZiAoIXNlbGYuX3JlbmRlcmluZykge1xuICAgICAgc2VsZi5yZW5kZXJPbk5leHRGcmFtZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIYW5kbGUgcmVuZGVySW52YWxpZCBldmVudHMgZW1pdHRlZCBieSB0aGUgc3RhZ2UuXG4gIHRoaXMuX3N0YWdlLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbmRlckludmFsaWQnLCB0aGlzLl9yZW5kZXJJbnZhbGlkSGFuZGxlcik7XG5cbn1cblxuZXZlbnRFbWl0dGVyKFJlbmRlckxvb3ApO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0b3AoKTtcbiAgdGhpcy5fc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVuZGVySW52YWxpZCcsIHRoaXMuX3JlbmRlckludmFsaWRIYW5kbGVyKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcmV0dXJuIHtTdGFnZX1cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUuc3RhZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWdlO1xufTtcblxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICB0aGlzLnJlbmRlck9uTmV4dEZyYW1lKCk7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICovXG5SZW5kZXJMb29wLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9yZXF1ZXN0SGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RIYW5kbGUpO1xuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSBudWxsO1xuICB9XG4gIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBGb3JjZXMgdGhlIHN0YWdlIHRvIHJlbmRlciBvbiB0aGUgbmV4dCBmcmFtZSwgZXZlbiBpZiBpdHMgY29udGVudHMgcmVtYWluXG4gKiB2YWxpZC4gRG9lcyBub3RoaW5nIGlmIHRoZSBsb29wIGlzIHN0b3BwZWQuXG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLnJlbmRlck9uTmV4dEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9ydW5uaW5nICYmICF0aGlzLl9yZXF1ZXN0SGFuZGxlKSB7XG4gICAgdGhpcy5fcmVxdWVzdEhhbmRsZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYm91bmRMb29wKTtcbiAgfVxufTtcblxuXG5SZW5kZXJMb29wLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlciBsb29wIHJ1bm5pbmcgd2hpbGUgaW4gc3RvcHBlZCBzdGF0ZScpO1xuICB9XG4gIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2JlZm9yZVJlbmRlcicpO1xuICB0aGlzLl9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgdGhpcy5fc3RhZ2UucmVuZGVyKCk7XG4gIHRoaXMuZW1pdCgnYWZ0ZXJSZW5kZXInKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJMb29wO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyk7XG52YXIgVGV4dHVyZVN0b3JlID0gcmVxdWlyZSgnLi9UZXh0dXJlU3RvcmUnKTtcbnZhciBIb3RzcG90Q29udGFpbmVyID0gcmVxdWlyZSgnLi9Ib3RzcG90Q29udGFpbmVyJyk7XG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgbm93ID0gcmVxdWlyZSgnLi91dGlsL25vdycpO1xudmFyIG5vb3AgPSByZXF1aXJlKCcuL3V0aWwvbm9vcCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL3V0aWwvdHlwZScpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgc2NlbmUncyB2aWV3IGhhcyBjaGFuZ2VkLiBTZWUge0BsaW5rIFZpZXcjZXZlbnQ6Y2hhbmdlfS5cbiAqIEBldmVudCBTY2VuZSN2aWV3Q2hhbmdlXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIHNjZW5lJ3MgbGF5ZXJzIGhhdmUgY2hhbmdlZC5cbiAqIEBldmVudCBTY2VuZSNsYXllckNoYW5nZVxuICovXG5cbi8qKlxuICogQGNsYXNzIFNjZW5lXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBTY2VuZSBpcyBhIHN0YWNrIG9mIHtAbGluayBMYXllciBsYXllcnN9IHNoYXJpbmcgdGhlIHNhbWUge0BsaW5rIFZpZXcgdmlld31cbiAqIGFuZCB7QGxpbmsgSG90c3BvdENvbnRhaW5lciBob3RzcG90IGNvbnRhaW5lcn0uIEl0IGJlbG9uZ3MgdG8gdGhlXG4gKiB7QGxpbmsgVmlld2VyIHZpZXdlcn0gaW5zaWRlIHdoaWNoIGl0IGlzIGRpc3BsYXllZC5cbiAqXG4gKiBDbGllbnRzIHNob3VsZCBjYWxsIHtAbGluayBWaWV3ZXIjY3JlYXRlU2NlbmV9IGluc3RlYWQgb2YgaW52b2tpbmcgdGhlXG4gKiBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1ZpZXdlcn0gdmlld2VyIFRoZSB2aWV3ZXIgdGhpcyBzY2VuZSBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSBzY2VuZSdzIHVuZGVybHlpbmcgdmlldy5cbiAqL1xuZnVuY3Rpb24gU2NlbmUodmlld2VyLCB2aWV3KSB7XG4gIHRoaXMuX3ZpZXdlciA9IHZpZXdlcjtcbiAgdGhpcy5fdmlldyA9IHZpZXc7XG4gIHRoaXMuX2xheWVycyA9IFtdO1xuXG4gIC8vIEhvdHNwb3QgY29udGFpbmVyLiBBc3N1bWUgaXQgb2NjdXBpZXMgYSBmdWxsIHJlY3QuXG4gIHRoaXMuX2hvdHNwb3RDb250YWluZXIgPSBuZXcgSG90c3BvdENvbnRhaW5lcihcbiAgICB2aWV3ZXIuX2NvbnRyb2xDb250YWluZXIsXG4gICAgdmlld2VyLnN0YWdlKCksXG4gICAgdGhpcy5fdmlldyxcbiAgICB2aWV3ZXIucmVuZGVyTG9vcCgpKTtcblxuICAvLyBUaGUgY3VycmVudCBtb3ZlbWVudC5cbiAgdGhpcy5fbW92ZW1lbnQgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudFN0YXJ0VGltZSA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RlcCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50UGFyYW1zID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRDYWxsYmFjayA9IG51bGw7XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXIgZm9yIHVwZGF0aW5nIHRoZSB2aWV3IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAgLy8gVGhlIGxpc3RlbmVyIGlzIHNldC91bnNldCBvbiB0aGUgcmVuZGVyIGxvb3Agd2hlbiBhIG1vdmVtZW50IHN0YXJ0cy9zdG9wcy5cbiAgdGhpcy5fdXBkYXRlTW92ZW1lbnRIYW5kbGVyID0gdGhpcy5fdXBkYXRlTW92ZW1lbnQuYmluZCh0aGlzKTtcblxuICAvLyBTaG93IG9yIGhpZGUgaG90c3BvdHMgd2hlbiBzY2VuZSBjaGFuZ2VzLlxuICB0aGlzLl91cGRhdGVIb3RzcG90Q29udGFpbmVySGFuZGxlciA9IHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXIuYmluZCh0aGlzKTtcbiAgdGhpcy5fdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3NjZW5lQ2hhbmdlJywgdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lckhhbmRsZXIpO1xuXG4gIC8vIEVtaXQgZXZlbnQgd2hlbiB2aWV3IGNoYW5nZXMuXG4gIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ3ZpZXdDaGFuZ2UnKTtcbiAgdGhpcy5fdmlldy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG5cbiAgLy8gVXBkYXRlIHRoZSBob3RzcG90IGNvbnRhaW5lci5cbiAgdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lcigpO1xufVxuXG5ldmVudEVtaXR0ZXIoU2NlbmUpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci4gQ2xpZW50cyBzaG91bGQgY2FsbCB7QGxpbmsgVmlld2VyI2Rlc3Ryb3lTY2VuZX0gaW5zdGVhZC5cbiAqL1xuU2NlbmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3ZpZXdlci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY2VuZUNoYW5nZScsIHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXJIYW5kbGVyKTtcblxuICBpZiAodGhpcy5fbW92ZW1lbnQpIHtcbiAgICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB9XG5cbiAgdGhpcy5faG90c3BvdENvbnRhaW5lci5kZXN0cm95KCk7XG5cbiAgdGhpcy5kZXN0cm95QWxsTGF5ZXJzKCk7XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUge0BsaW5rIEhvdHNwb3RDb250YWluZXIgaG90c3BvdCBjb250YWluZXJ9IGZvciB0aGUgc2NlbmUuXG4gKiBAcmV0dXJuIHtMYXllcn1cbiAqL1xuU2NlbmUucHJvdG90eXBlLmhvdHNwb3RDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hvdHNwb3RDb250YWluZXI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG9mIHRoZSB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBiZWxvbmdpbmcgdG8gdGhlIHNjZW5lLCBvclxuICogbnVsbCBpZiB0aGUgc2NlbmUgaGFzIG5vIGxheWVycy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBTY2VuZSNsaXN0TGF5ZXJzWzBdYC4gSXQgbWF5IGJlIHJlbW92ZWQgaW4gdGhlXG4gKiBmdXR1cmUuXG4gKlxuICogQHJldHVybiB7TGF5ZXJ9XG4gKi9cblNjZW5lLnByb3RvdHlwZS5sYXllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdO1xufTtcblxuLyoqXG4qIFJldHVybnMgYSBsaXN0IG9mIGFsbCB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBiZWxvbmdpbmcgdG8gdGhlIHNjZW5lLiBUaGVcbiogcmV0dXJuZWQgbGlzdCBpcyBpbiBkaXNwbGF5IG9yZGVyLCBiYWNrZ3JvdW5kIHRvIGZvcmVncm91bmQuXG4qIEByZXR1cm4ge0xheWVyW119XG4gKi9cblNjZW5lLnByb3RvdHlwZS5saXN0TGF5ZXJzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXS5jb25jYXQodGhpcy5fbGF5ZXJzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2VuZSdzIHVuZGVybHlpbmcge0BsaW5rIFZpZXcgdmlld30uXG4gKiBAcmV0dXJuIHtWaWV3fVxuICovXG5TY2VuZS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdmlldztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB7QGxpbmsgVmlld2VyIHZpZXdlcn0gdGhlIHNjZW5lIGJlbG9uZ3MgdG8uXG4gKiBAcmV0dXJuIHtWaWV3ZXJ9XG4gKi9cblNjZW5lLnByb3RvdHlwZS52aWV3ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3ZpZXdlcjtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNjZW5lIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU2NlbmUucHJvdG90eXBlLnZpc2libGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3ZpZXdlci5zY2VuZSgpID09PSB0aGlzO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIExheWVyIGxheWVyfSBhbmQgYWRkcyBpdCBpbnRvIHRoZSBzY2VuZSBpbiB0aGVcbiAqIGZvcmVncm91bmQgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgTGF5ZXIgY3JlYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7U291cmNlfSBvcHRzLnNvdXJjZSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2V9LlxuICogQHBhcmFtIHtTb3VyY2V9IG9wdHMuZ2VvbWV0cnkgVGhlIGxheWVyJ3MgdW5kZXJseWluZyB7QGxpbmsgR2VvbWV0cnl9LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5waW5GaXJzdExldmVsPWZhbHNlXSBXaGV0aGVyIHRvIHBpbiB0aGUgZmlyc3QgbGV2ZWwgdG9cbiAqICAgICBwcm92aWRlIGEgZmFsbGJhY2sgb2YgbGFzdCByZXNvcnQsIGF0IHRoZSBjb3N0IG9mIG1lbW9yeSBjb25zdW1wdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy50ZXh0dXJlU3RvcmVPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlXG4gKiAgICAge0BsaW5rIFRleHR1cmVTdG9yZX0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubGF5ZXJPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIHtAbGluayBMYXllcn1cbiAqICAgICBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm4ge0xheWVyfVxuICovXG5TY2VuZS5wcm90b3R5cGUuY3JlYXRlTGF5ZXIgPSBmdW5jdGlvbihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciB0ZXh0dXJlU3RvcmVPcHRzID0gb3B0cy50ZXh0dXJlU3RvcmVPcHRzIHx8IHt9O1xuICB2YXIgbGF5ZXJPcHRzID0gb3B0cy5sYXllck9wdHMgfHwge307XG5cbiAgdmFyIHNvdXJjZSA9IG9wdHMuc291cmNlO1xuICB2YXIgZ2VvbWV0cnkgPSBvcHRzLmdlb21ldHJ5O1xuICB2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG4gIHZhciBzdGFnZSA9IHRoaXMuX3ZpZXdlci5zdGFnZSgpO1xuICB2YXIgdGV4dHVyZVN0b3JlID0gbmV3IFRleHR1cmVTdG9yZShzb3VyY2UsIHN0YWdlLCB0ZXh0dXJlU3RvcmVPcHRzKTtcbiAgdmFyIGxheWVyID0gbmV3IExheWVyKHNvdXJjZSwgZ2VvbWV0cnksIHZpZXcsIHRleHR1cmVTdG9yZSwgbGF5ZXJPcHRzKTtcblxuICB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XG5cbiAgaWYgKG9wdHMucGluRmlyc3RMZXZlbCkge1xuICAgIGxheWVyLnBpbkZpcnN0TGV2ZWwoKTtcbiAgfVxuXG4gIC8vIFNpZ25hbCB0aGF0IHRoZSBsYXllcnMgaGF2ZSBjaGFuZ2VkLlxuICB0aGlzLmVtaXQoJ2xheWVyQ2hhbmdlJyk7XG5cbiAgcmV0dXJuIGxheWVyO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIGEge0BsaW5rIExheWVyIGxheWVyfSBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBzY2VuZS5cbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBsYXllciBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIHNjZW5lLlxuICovXG5TY2VuZS5wcm90b3R5cGUuZGVzdHJveUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIGkgPSB0aGlzLl9sYXllcnMuaW5kZXhPZihsYXllcik7XG4gIGlmIChpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYXllciBpbiBzY2VuZScpO1xuICB9XG5cbiAgdGhpcy5fbGF5ZXJzLnNwbGljZShpLCAxKTtcblxuICAvLyBTaWduYWwgdGhhdCB0aGUgbGF5ZXJzIGhhdmUgY2hhbmdlZC5cbiAgdGhpcy5lbWl0KCdsYXllckNoYW5nZScpO1xuXG4gIGxheWVyLnRleHR1cmVTdG9yZSgpLmRlc3Ryb3koKTtcbiAgbGF5ZXIuZGVzdHJveSgpO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIGFsbCB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIHNjZW5lLlxuICovXG5TY2VuZS5wcm90b3R5cGUuZGVzdHJveUFsbExheWVycyA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5fbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmRlc3Ryb3lMYXllcih0aGlzLl9sYXllcnNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogU3dpdGNoZXMgdG8gdGhlIHNjZW5lLlxuICpcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9IG9uIHRoaXMgc2NlbmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucyB0byBwYXNzIGludG8ge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc3dpdGNoIGlzIGNvbXBsZXRlLlxuICovXG5TY2VuZS5wcm90b3R5cGUuc3dpdGNoVG8gPSBmdW5jdGlvbihvcHRzLCBkb25lKSB7XG4gIHJldHVybiB0aGlzLl92aWV3ZXIuc3dpdGNoU2NlbmUodGhpcywgb3B0cywgZG9uZSk7XG59O1xuXG5cbi8qKlxuICogVHdlZW5zIHRoZSBzY2VuZSdzIHVuZGVybHlpbmcge0BsaW5rIFZpZXcgdmlld30uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUYXJnZXQgdmlldyBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVHJhbnNpdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdHMuZWFzZT1lYXNlSW5PdXRRdWFkXSBUd2VlbiBlYXNpbmcgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5jb250cm9sc0ludGVycnVwdD1mYWxzZV0gYWxsb3cgY29udHJvbHMgdG8gaW50ZXJydXB0XG4gKiAgICAgYW4gb25nb2luZyB0d2Vlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50cmFuc2l0aW9uRHVyYXRpb249MTAwMF0gVHdlZW4gZHVyYXRpb24sIGluXG4gKiAgICAgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNsb3Nlc3Q9dHJ1ZV0gV2hldGhlciB0byB0d2VlbiB0aHJvdWdoIHRoZSBzaG9ydGVzdFxuICogICAgcGF0aCBiZXR3ZWVuIHRoZSBpbml0aWFsIGFuZCBmaW5hbCB2aWV3IHBhcmFtZXRlcnMuIFRoaXMgcmVxdWlyZXNcbiAqICAgIHtAbGluayBWaWV3I25vcm1hbGl6ZVRvQ2xvc2VzdH0gdG8gYmUgaW1wbGVtZW50ZWQsIGFuZCBkb2VzIG5vdGhpbmdcbiAqICAgIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB0d2VlbiBmaW5pc2hlcyBvciBpc1xuICogICAgaW50ZXJydXB0ZWQuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5sb29rVG8gPSBmdW5jdGlvbihwYXJhbXMsIG9wdHMsIGRvbmUpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGRvbmUgPSBkb25lIHx8IG5vb3A7XG5cbiAgaWYgKHR5cGUocGFyYW1zKSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgdmlldyBwYXJhbWV0ZXJzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG5cbiAgLy8gUXVhZHJhdGljIGluL291dCBlYXNpbmcuXG4gIHZhciBlYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfTtcblxuICB2YXIgZWFzZSA9IG9wdHMuZWFzZSAhPSBudWxsID8gb3B0cy5lYXNlIDogZWFzZUluT3V0UXVhZDtcbiAgdmFyIGNvbnRyb2xzSW50ZXJydXB0ID0gb3B0cy5jb250cm9sc0ludGVycnVwdCAhPSBudWxsID8gb3B0cy5jb250cm9sc0ludGVycnVwdCA6IGZhbHNlO1xuICB2YXIgZHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiAhPSBudWxsID8gb3B0cy50cmFuc2l0aW9uRHVyYXRpb24gOiAxMDAwO1xuICB2YXIgc2hvcnRlc3QgPSBvcHRzLnNob3J0ZXN0ICE9IG51bGwgPyBvcHRzLnNob3J0ZXN0IDogdHJ1ZTtcblxuICB2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG5cbiAgdmFyIGluaXRpYWxQYXJhbXMgPSB2aWV3LnBhcmFtZXRlcnMoKTtcblxuICB2YXIgZmluYWxQYXJhbXMgPSB7fTtcbiAgZGVmYXVsdHMoZmluYWxQYXJhbXMsIHBhcmFtcyk7XG4gIGRlZmF1bHRzKGZpbmFsUGFyYW1zLCBpbml0aWFsUGFyYW1zKTtcblxuICAvLyBUd2VlbiB0aHJvdWdoIHRoZSBzaG9ydGVzdCBwYXRoIGlmIHJlcXVlc3RlZC5cbiAgLy8gVGhlIHZpZXcgbXVzdCBpbXBsZW1lbnQgdGhlIG5vcm1hbGl6ZVRvQ2xvc2VzdCgpIG1ldGhvZC5cbiAgaWYgKHNob3J0ZXN0ICYmIHZpZXcubm9ybWFsaXplVG9DbG9zZXN0KSB7XG4gICAgdmlldy5ub3JtYWxpemVUb0Nsb3Nlc3QoZmluYWxQYXJhbXMsIGZpbmFsUGFyYW1zKTtcbiAgfVxuXG4gIHZhciBtb3ZlbWVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGZpbmFsVXBkYXRlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ocGFyYW1zLCBlbGFwc2VkKSB7XG5cbiAgICAgIGlmIChlbGFwc2VkID49IGR1cmF0aW9uICYmIGZpbmFsVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBNYXRoLm1pbihlbGFwc2VkIC8gZHVyYXRpb24sIDEpO1xuXG4gICAgICBmb3IgKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5pdGlhbFBhcmFtc1twYXJhbV07XG4gICAgICAgIHZhciBlbmQgPSBmaW5hbFBhcmFtc1twYXJhbV07XG4gICAgICAgIHBhcmFtc1twYXJhbV0gPSBzdGFydCArIGVhc2UoZGVsdGEpICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgZmluYWxVcGRhdGUgPSBlbGFwc2VkID49IGR1cmF0aW9uO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuXG4gICAgfTtcbiAgfTtcblxuICB2YXIgcmVlbmFibGVDb250cm9scyA9IHRoaXMuX3ZpZXdlci5jb250cm9scygpLmVuYWJsZWQoKTtcblxuICBpZiAoIWNvbnRyb2xzSW50ZXJydXB0KSB7XG4gICAgdGhpcy5fdmlld2VyLmNvbnRyb2xzKCkuZGlzYWJsZSgpO1xuICB9XG5cbiAgdGhpcy5zdGFydE1vdmVtZW50KG1vdmVtZW50LCBmdW5jdGlvbigpIHtcbiAgICBpZiAocmVlbmFibGVDb250cm9scykge1xuICAgICAgdGhpcy5fdmlld2VyLmNvbnRyb2xzKCkuZW5hYmxlKCk7XG4gICAgfVxuICAgIGRvbmUoKTtcbiAgfSk7XG5cbn07XG5cblxuLyoqXG4gKiBTdGFydHMgYSBtb3ZlbWVudCwgcG9zc2libHkgcmVwbGFjaW5nIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBtb3ZlbWVudCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdmVtZW50IGZpbmlzaGVzIG9yIGlzXG4gKiAgICAgaW50ZXJydXB0ZWQuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5zdGFydE1vdmVtZW50ID0gZnVuY3Rpb24oZm4sIGRvbmUpIHtcblxuICB2YXIgcmVuZGVyTG9vcCA9IHRoaXMuX3ZpZXdlci5yZW5kZXJMb29wKCk7XG5cbiAgaWYgKHRoaXMuX21vdmVtZW50KSB7XG4gICAgdGhpcy5zdG9wTW92ZW1lbnQoKTtcbiAgfVxuXG4gIHZhciBzdGVwID0gZm4oKTtcbiAgaWYgKHR5cGVvZiBzdGVwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbW92ZW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX21vdmVtZW50ID0gZm47XG4gIHRoaXMuX21vdmVtZW50U3RlcCA9IHN0ZXA7XG4gIHRoaXMuX21vdmVtZW50U3RhcnRUaW1lID0gbm93KCk7XG4gIHRoaXMuX21vdmVtZW50UGFyYW1zID0ge307XG4gIHRoaXMuX21vdmVtZW50Q2FsbGJhY2sgPSBkb25lO1xuXG4gIHJlbmRlckxvb3AuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlUmVuZGVyJywgdGhpcy5fdXBkYXRlTW92ZW1lbnRIYW5kbGVyKTtcbiAgcmVuZGVyTG9vcC5yZW5kZXJPbk5leHRGcmFtZSgpO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICovXG5TY2VuZS5wcm90b3R5cGUuc3RvcE1vdmVtZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHJlbmRlckxvb3AgPSB0aGlzLl92aWV3ZXIucmVuZGVyTG9vcCgpO1xuXG4gIGlmICghdGhpcy5fbW92ZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fbW92ZW1lbnRDYWxsYmFjaykge1xuICAgIHRoaXMuX21vdmVtZW50Q2FsbGJhY2soKTtcbiAgfVxuXG4gIHJlbmRlckxvb3AucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlUmVuZGVyJywgdGhpcy5fdXBkYXRlTW92ZW1lbnRIYW5kbGVyKTtcblxuICB0aGlzLl9tb3ZlbWVudCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RlcCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RhcnRUaW1lID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRQYXJhbXMgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudENhbGxiYWNrID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cblNjZW5lLnByb3RvdHlwZS5tb3ZlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbW92ZW1lbnQ7XG59O1xuXG5cblNjZW5lLnByb3RvdHlwZS5fdXBkYXRlTW92ZW1lbnQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAoIXRoaXMuX21vdmVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGNhbGwgdXBkYXRlJyk7XG4gIH1cblxuICB2YXIgcmVuZGVyTG9vcCA9IHRoaXMuX3ZpZXdlci5yZW5kZXJMb29wKCk7XG4gIHZhciB2aWV3ID0gdGhpcy5fdmlldztcblxuICB2YXIgZWxhcHNlZCA9IG5vdygpIC0gdGhpcy5fbW92ZW1lbnRTdGFydFRpbWU7XG4gIHZhciBzdGVwID0gdGhpcy5fbW92ZW1lbnRTdGVwO1xuICB2YXIgcGFyYW1zID0gdGhpcy5fbW92ZW1lbnRQYXJhbXM7XG5cbiAgcGFyYW1zID0gdmlldy5wYXJhbWV0ZXJzKHBhcmFtcyk7XG4gIHBhcmFtcyA9IHN0ZXAocGFyYW1zLCBlbGFwc2VkKTtcbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgdGhpcy5zdG9wTW92ZW1lbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB2aWV3LnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICByZW5kZXJMb29wLnJlbmRlck9uTmV4dEZyYW1lKCk7XG4gIH1cblxufTtcblxuXG5TY2VuZS5wcm90b3R5cGUuX3VwZGF0ZUhvdHNwb3RDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudmlzaWJsZSgpKSB7XG4gICAgdGhpcy5faG90c3BvdENvbnRhaW5lci5zaG93KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5faG90c3BvdENvbnRhaW5lci5oaWRlKCk7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2VuZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1hcCA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbnMvTWFwJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9TZXQnKTtcbnZhciBMcnVTZXQgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25zL0xydVNldCcpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgcmV0cnkgPSByZXF1aXJlKCcuL3V0aWwvcmV0cnknKTtcbnZhciBjaGFpbiA9IHJlcXVpcmUoJy4vdXRpbC9jaGFpbicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVidWcgPSB0eXBlb2YgTUFSWklQQU5PREVCVUcgIT09ICd1bmRlZmluZWQnICYmIE1BUlpJUEFOT0RFQlVHLnRleHR1cmVTdG9yZTtcblxuXG4vLyBBIFN0YWdlIGluZm9ybXMgdGhlIFRleHR1cmVTdG9yZSBhYm91dCB0aGUgc2V0IG9mIHZpc2libGUgdGlsZXMgZHVyaW5nIGFcbi8vIGZyYW1lIGJ5IGNhbGxpbmcgc3RhcnRGcmFtZSwgbWFya1RpbGUgYW5kIGVuZEZyYW1lLiBJbiBhIHBhcnRpY3VsYXIgZnJhbWUsXG4vLyBUZXh0dXJlU3RvcmUgZXhwZWN0cyBvbmUgb3IgbW9yZSBjYWxscyB0byBzdGFydEZyYW1lLCBmb2xsb3dlZCBieSB6ZXJvIG9yXG4vLyBtb3JlIGNhbGxzIHRvIG1hcmtUaWxlLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBjYWxscyB0byBlbmRGcmFtZS4gVGhlXG4vLyBudW1iZXIgb2YgY2FsbHMgdG8gc3RhcnRGcmFtZSBhbmQgZW5kRnJhbWUgbXVzdCBtYXRjaC4gQ2FsbHMgdG8gb3RoZXJcbi8vIFRleHR1cmVTdG9yZSBtZXRob2RzIG1heSBiZSBmcmVlbHkgaW50ZXJsZWF2ZWQgd2l0aCB0aGlzIHNlcXVlbmNlLlxuLy9cbi8vIEF0IGFueSBnaXZlbiB0aW1lLCBUZXh0dXJlU3RvcmUgaXMgaW4gb25lIG9mIGZvdXIgc3RhdGVzLiBUaGUgU1RBUlQgc3RhdGVcbi8vIGNvcnJlc3BvbmRzIHRvIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBmaXJzdCBzdGFydEZyYW1lIGFuZCB0aGUgZmlyc3Rcbi8vIG1hcmtUaWxlIG9mIGEgZnJhbWUuIFRoZSBNQVJLIHN0YXRlIGNvcnJlc3BvbmRzIHRvIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZVxuLy8gZmlyc3QgbWFya1RpbGUgYW5kIHRoZSBmaXJzdCBlbmRGcmFtZS4gVGhlIEVORCBzdGF0ZSBjb3JyZXNwb25kcyB0byB0aGVcbi8vIGludGVydmFsIGJldHdlZW4gdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBlbmRGcmFtZS4gQXQgYW55IG90aGVyIHRpbWUsIHRoZVxuLy8gVGV4dHVyZVN0b3JlIGlzIGluIHRoZSBJRExFIHN0YXRlLlxudmFyIFN0YXRlID0ge1xuICBJRExFOiAwLFxuICBTVEFSVDogMSxcbiAgTUFSSzogMixcbiAgRU5EOiAzXG59O1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgY2FjaGVkIHRleHR1cmVzIGZvciBwcmV2aW91c2x5IHZpc2libGUgdGlsZXMuXG4gIHByZXZpb3VzbHlWaXNpYmxlQ2FjaGVTaXplOiA1MTJcbn07XG5cblxuLy8gQXNzaWduIGFuIGlkIHRvIGVhY2ggb3BlcmF0aW9uIHNvIHdlIGNhbiB0cmFjayBpdHMgc3RhdGUuXG4vLyBXZSBhY3R1YWxseSBvbmx5IG5lZWQgdGhpcyBpbiBkZWJ1ZyBtb2RlLCBidXQgdGhlIGNvZGUgaXMgbGVzcyBjb252b2x1dGVkXG4vLyBpZiB3ZSB0cmFjayB1bmNvbmRpdGlvbmFsbHksIGFuZCB0aGUgcGVyZm9ybWFuY2UgaGl0IGlzIG1pbmltYWwgYW55d2F5LlxudmFyIG5leHRJZCA9IDA7XG5cblxuLy8gRGlzdGluZ3Vpc2hlcyBhIGNhbmNlbGxhdGlvbiBmcm9tIG90aGVyIGtpbmRzIG9mIGVycm9ycy5cbmZ1bmN0aW9uIENhbmNlbEVycm9yKCkge31cbmluaGVyaXRzKENhbmNlbEVycm9yLCBFcnJvcik7XG5cblxuLyoqXG4gKiBAY2xhc3MgVGV4dHVyZVN0b3JlSXRlbVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEFuIGl0ZW0gc2F2ZWQgaW4gYSB7QGxpbmsgVGV4dHVyZVN0b3JlfS5cbiAqXG4gKiBDbGllbnRzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuIEl0IGlzIGF1dG9tYXRpY2FsbHkgaW5zdGFudGlhdGVkIGJ5XG4gKiBhIHtAbGluayBUZXh0dXJlU3RvcmV9IHRvIG1hbmFnZSB0aGUgbGlmZXRpbWUgb2YgYSBzdG9yZWQgaXRlbTogbG9hZGluZyxcbiAqIHJlZnJlc2hpbmcsIHVubG9hZGluZyBhbmQgZW1pdHRpbmcgYXNzb2NpYXRlZCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtUZXh0dXJlU3RvcmV9IHN0b3JlIFRoZSB1bmRlcmx5aW5nIHtAbGluayBUZXh0dXJlU3RvcmV9LlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB1bmRlcmx5aW5nIHRpbGUuXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVTdG9yZUl0ZW0oc3RvcmUsIHRpbGUpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGlkID0gbmV4dElkKys7XG5cbiAgc2VsZi5faWQgPSBpZDtcbiAgc2VsZi5fc3RvcmUgPSBzdG9yZTtcbiAgc2VsZi5fdGlsZSA9IHRpbGU7XG5cbiAgc2VsZi5fYXNzZXQgPSBudWxsO1xuICBzZWxmLl90ZXh0dXJlID0gbnVsbDtcblxuICBzZWxmLl9jaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgc3RvcmUuZW1pdCgndGV4dHVyZUludmFsaWQnLCB0aWxlKTtcbiAgfTtcblxuICB2YXIgc291cmNlID0gc3RvcmUuc291cmNlKCk7XG4gIHZhciBzdGFnZSA9IHN0b3JlLnN0YWdlKCk7XG5cbiAgdmFyIGxvYWRBc3NldCA9IHNvdXJjZS5sb2FkQXNzZXQuYmluZChzb3VyY2UpO1xuICB2YXIgY3JlYXRlVGV4dHVyZSA9IHN0YWdlLmNyZWF0ZVRleHR1cmUuYmluZChzdGFnZSk7XG5cbiAgLy8gUmV0cnkgbG9hZGluZyB0aGUgYXNzZXQgdW50aWwgaXQgc3VjY2VlZHMsIHRoZW4gY3JlYXRlIHRoZSB0ZXh0dXJlIGZyb20gaXQuXG4gIC8vIFRoaXMgcHJvY2VzcyBtYXkgYmUgY2FuY2VsZWQgYXQgYW55IHBvaW50IGJ5IGNhbGxpbmcgdGhlIGRlc3Ryb3koKSBtZXRob2QuXG4gIHZhciBmbiA9IGNoYWluKHJldHJ5KGxvYWRBc3NldCksIGNyZWF0ZVRleHR1cmUpO1xuXG4gIHN0b3JlLmVtaXQoJ3RleHR1cmVTdGFydExvYWQnLCB0aWxlKTtcbiAgaWYgKGRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ2xvYWRpbmcnLCBpZCwgdGlsZSk7XG4gIH1cblxuICBzZWxmLl9jYW5jZWwgPSBmbihzdGFnZSwgdGlsZSwgZnVuY3Rpb24oZXJyLCBfdGlsZSwgYXNzZXQsIHRleHR1cmUpIHtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3QgY2FsbCBjYW5jZWwgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICBzZWxmLl9jYW5jZWwgPSBudWxsO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgLy8gVGhlIGxvYWRpbmcgcHJvY2VzcyB3YXMgaW50ZXJydXB0ZWQgYnkgYW4gZXJyb3IuXG4gICAgICAvLyBUaGlzIGNvdWxkIGVpdGhlciBiZSBiZWNhdXNlIHRoZSB0ZXh0dXJlIGNyZWF0aW9uIGZhaWxlZCwgb3IgYmVjYXVzZVxuICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgY2FuY2VsZWQgYmVmb3JlIHRoZSBsb2FkaW5nIHdhcyBjb21wbGV0ZS5cblxuICAgICAgLy8gRGVzdHJveSB0aGUgYXNzZXQgYW5kIHRleHR1cmUsIGlmIHRoZXkgZXhpc3QuXG4gICAgICBpZiAoYXNzZXQpIHtcbiAgICAgICAgYXNzZXQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVtaXQgZXZlbnRzLlxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENhbmNlbEVycm9yKSB7XG4gICAgICAgIHN0b3JlLmVtaXQoJ3RleHR1cmVDYW5jZWwnLCB0aWxlKTtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2NhbmNlbCcsIGlkLCB0aWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuZW1pdCgndGV4dHVyZUVycm9yJywgdGlsZSwgZXJyKTtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yJywgaWQsIHRpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTYXZlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSB0ZXh0dXJlLlxuICAgIHNlbGYuX3RleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgLy8gSWYgdGhlIGFzc2V0IGlzIGR5bmFtaWMsIHNhdmUgYSBsb2NhbCByZWZlcmVuY2UgdG8gaXQgYW5kIHNldCB1cCBhXG4gICAgLy8gaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgaXQgY2hhbmdlcy4gT3RoZXJ3aXNlLCBkZXN0cm95IHRoZSBhc3NldFxuICAgIC8vIGFzIHdlIHdvbid0IGJlIG5lZWRpbmcgaXQgYW55IGxvbmdlci5cbiAgICBpZiAoYXNzZXQuaXNEeW5hbWljKCkpIHtcbiAgICAgIHNlbGYuX2Fzc2V0ID0gYXNzZXQ7XG4gICAgICBhc3NldC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzZWxmLl9jaGFuZ2VIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8vIEVtaXQgZXZlbnQuXG4gICAgc3RvcmUuZW1pdCgndGV4dHVyZUxvYWQnLCB0aWxlKTtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsb2FkJywgaWQsIHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbn1cblxuXG5UZXh0dXJlU3RvcmVJdGVtLnByb3RvdHlwZS5hc3NldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXNzZXQ7XG59O1xuXG5cblRleHR1cmVTdG9yZUl0ZW0ucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG59O1xuXG5cblRleHR1cmVTdG9yZUl0ZW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG4gIHZhciBzdG9yZSA9IHRoaXMuX3N0b3JlO1xuICB2YXIgdGlsZSA9IHRoaXMuX3RpbGU7XG4gIHZhciBhc3NldCA9IHRoaXMuX2Fzc2V0O1xuICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gIHZhciBjYW5jZWwgPSB0aGlzLl9jYW5jZWw7XG5cbiAgaWYgKGNhbmNlbCkge1xuICAgIC8vIFRoZSB0ZXh0dXJlIGlzIHN0aWxsIGxvYWRpbmcsIHNvIGNhbmNlbCBpdC5cbiAgICBjYW5jZWwobmV3IENhbmNlbEVycm9yKCdUZXh0dXJlIGxvYWQgY2FuY2VsbGVkJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlc3Ryb3kgYXNzZXQuXG4gIGlmIChhc3NldCkge1xuICAgIGFzc2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2NoYW5nZUhhbmRsZXIpO1xuICAgIGFzc2V0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIERlc3Ryb3kgdGV4dHVyZS5cbiAgaWYgKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIEVtaXQgZXZlbnQuXG4gIHN0b3JlLmVtaXQoJ3RleHR1cmVVbmxvYWQnLCB0aWxlKTtcbiAgaWYgKGRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ3VubG9hZCcsIGlkLCB0aWxlKTtcbiAgfVxuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbmV2ZW50RW1pdHRlcihUZXh0dXJlU3RvcmVJdGVtKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSB0ZXh0dXJlIGhhcyBzdGFydGVkIHRvIGxvYWQuXG4gKlxuICogVGhpcyBldmVudCBpcyBmb2xsb3dlZCBieSBlaXRoZXIge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlTG9hZH0sXG4gKiB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVFcnJvcn0gb3Ige0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlQ2FuY2VsfS5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVTdGFydExvYWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgaGFzIHN0YXJ0ZWQgdG8gbG9hZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZUxvYWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgd2FzIGxvYWRlZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdW5sb2FkZWQuXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlVW5sb2FkXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIHdhcyB1bmxvYWRlZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gaW52YWxpZGF0ZWQuXG4gKlxuICogVGhpcyBldmVudCBtYXkgYmUgcmFpc2VkIGZvciBhIHRleHR1cmUgd2l0aCBhbiB1bmRlcmx5aW5nIGR5bmFtaWMgYXNzZXQuIEl0XG4gKiBtYXkgb25seSBvY2N1ciB3aGlsZSB0aGUgdGV4dHVyZSBpcyBsb2FkZWQsIGkuZS4sIGluIGJldHdlZW5cbiAqIHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZUxvYWR9IGFuZCB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVVbmxvYWR9LlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZUludmFsaWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgd2FzIGludmFsaWRhdGVkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGxvYWRpbmcgYSB0ZXh0dXJlIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAqXG4gKiBUaGlzIGV2ZW50IG1heSBmb2xsb3cge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlU3RhcnRMb2FkfSBpZiB0aGUgdGV4dHVyZVxuICogYmVjb21lcyB1bm5lY2Vzc2FyeSBiZWZvcmUgaXQgZmluaXNoZXMgbG9hZGluZy5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVDYW5jZWxcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgbG9hZGluZyB3YXMgY2FuY2VsbGVkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGxvYWRpbmcgYSB0ZXh0dXJlIGhhcyBmYWlsZWQuXG4gKlxuICogVGhpcyBldmVudCBtYXkgZm9sbG93IHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZVN0YXJ0TG9hZH0gaWYgdGhlIHRleHR1cmVcbiAqIGZhaWxzIHRvIGxvYWQuXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlRXJyb3JcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgbG9hZGluZyBoYXMgZmFpbGVkLlxuICovXG5cbi8qKlxuICogQGNsYXNzIFRleHR1cmVTdG9yZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgVGV4dHVyZVN0b3JlIG1haW50YWlucyBhIGNhY2hlIG9mIHRleHR1cmVzIHVzZWQgdG8gcmVuZGVyIGEge0BsaW5rIExheWVyfS5cbiAqXG4gKiBBIHtAbGluayBTdGFnZX0gY29tbXVuaWNhdGVzIHdpdGggdGhlIFRleHR1cmVTdG9yZSB0aHJvdWdoIHRoZSBzdGFydEZyYW1lKCksXG4gKiBtYXJrVGlsZSgpIGFuZCBlbmRGcmFtZSgpIG1ldGhvZHMsIHdoaWNoIGluZGljYXRlIHRoZSB0aWxlcyB0aGF0IGFyZSB2aXNpYmxlXG4gKiBpbiB0aGUgY3VycmVudCBmcmFtZS4gVGV4dHVyZXMgZm9yIHZpc2libGUgdGlsZXMgYXJlIGxvYWRlZCBhbmQgcmV0YWluZWRcbiAqIGFzIGxvbmcgYXMgdGhlIHRpbGVzIHJlbWFpbiB2aXNpYmxlLiBBIGxpbWl0ZWQgYW1vdW50IG9mIHRleHR1cmVzIHdob3NlXG4gKiB0aWxlcyB3ZXJlIHByZXZpb3VzbHkgdmlzaWJsZSBhcmUgY2FjaGVkIGFjY29yZGluZyB0byBhbiBMUlUgcG9saWN5LiBUaWxlc1xuICogbWF5IGJlIHBpbm5lZCB0byBrZWVwIHRoZWlyIHJlc3BlY3RpdmUgdGV4dHVyZXMgY2FjaGVkIGV2ZW4gd2hlbiB0aGV5IGFyZVxuICogaW52aXNpYmxlOyB0aGVzZSB0ZXh0dXJlcyBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgcHJldmlvdXNseSB2aXNpYmxlIGxpbWl0LlxuICpcbiAqIE11bHRpcGxlIGxheWVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgdW5kZXJseWluZyB7QGxpbmsgV2ViR2xTdGFnZX0gbWF5XG4gKiBzaGFyZSB0aGUgc2FtZSBUZXh0dXJlU3RvcmUuIExheWVycyBiZWxvbmdpbmcgdG8gZGlzdGluY3Qge0BsaW5rIFdlYkdsU3RhZ2V9XG4gKiBpbnN0YW5jZXMsIG9yIGJlbG9uZ2luZyB0byBhIHtAbGluayBDc3NTdGFnZX0gb3IgYSB7QGxpbmsgRmxhc2hTdGFnZX0sXG4gKiBtYXkgbm90IGRvIHNvIGR1ZSB0byByZXN0cmljdGlvbnMgb24gdGhlIHVzZSBvZiB0ZXh0dXJlcyBhY3Jvc3Mgc3RhZ2VzLlxuICpcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2UgVGhlIHVuZGVybHlpbmcgc291cmNlLlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnByZXZpb3VzbHlWaXNpYmxlQ2FjaGVTaXplPTMyXSBUaGUgbWF4aW11bSBudW1iZXIgb2ZcbiAqICAgICBwcmV2aW91c2x5IHZpc2libGUgdGV4dHVyZXMgdG8gY2FjaGUgYWNjb3JkaW5nIHRvIGFuIExSVSBwb2xpY3kuXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVTdG9yZShzb3VyY2UsIHN0YWdlLCBvcHRzKSB7XG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuXG4gIC8vIFRoZSBjdXJyZW50IHN0YXRlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLklETEU7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBzdGFydEZyYW1lIGNhbGxzIHlldCB0byBiZSBtYXRjaGVkIGJ5IGVuZEZyYW1lIGNhbGxzIGR1cmluZ1xuICAvLyB0aGUgY3VycmVudCBmcmFtZS5cbiAgdGhpcy5fZGVsaW1Db3VudCA9IDA7XG5cbiAgLy8gVGhlIGNhY2hlIHByb3BlcjogbWFwIGNhY2hlZCB0aWxlcyB0byB0aGVpciByZXNwZWN0aXZlIHRleHR1cmVzL2Fzc2V0cy5cbiAgdGhpcy5faXRlbU1hcCA9IG5ldyBNYXAoKTtcblxuICAvLyBUaGUgc3Vic2V0IG9mIGNhY2hlZCB0aWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgdmlzaWJsZS5cbiAgdGhpcy5fdmlzaWJsZSA9IG5ldyBTZXQoKTtcblxuICAvLyBUaGUgc3Vic2V0IG9mIGNhY2hlZCB0aWxlcyB0aGF0IHdlcmUgdmlzaWJsZSByZWNlbnRseSwgYnV0IGFyZSBub3RcbiAgLy8gdmlzaWJsZSByaWdodCBub3cuIE5ld2x5IGluc2VydGVkIHRpbGVzIHJlcGxhY2Ugb2xkZXIgb25lcy5cbiAgdGhpcy5fcHJldmlvdXNseVZpc2libGUgPSBuZXcgTHJ1U2V0KG9wdHMucHJldmlvdXNseVZpc2libGVDYWNoZVNpemUpO1xuXG4gIC8vIFRoZSBzdWJzZXQgb2YgY2FjaGVkIHRpbGVzIHRoYXQgc2hvdWxkIG5ldmVyIGJlIGV2aWN0ZWQgZnJvbSB0aGUgY2FjaGUuXG4gIC8vIEEgdGlsZSBtYXkgYmUgcGlubmVkIG1vcmUgdGhhbiBvbmNlOyBtYXAgZWFjaCB0aWxlIGludG8gYSByZWZlcmVuY2UgY291bnQuXG4gIHRoaXMuX3Bpbk1hcCA9IG5ldyBNYXAoKTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGVzLlxuICB0aGlzLl9uZXdWaXNpYmxlID0gbmV3IFNldCgpO1xuICB0aGlzLl9ub0xvbmdlclZpc2libGUgPSBbXTtcbiAgdGhpcy5fdmlzaWJsZUFnYWluID0gW107XG4gIHRoaXMuX2V2aWN0ZWQgPSBbXTtcbn1cblxuZXZlbnRFbWl0dGVyKFRleHR1cmVTdG9yZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTdGFnZX0uXG4gKiBAcmV0dXJuIHtTdGFnZX1cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5zdGFnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3RhZ2U7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2V9LlxuICogQHJldHVybiB7U291cmNlfVxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdGV4dHVyZXMgZnJvbSB0aGUgVGV4dHVyZVN0b3JlLCBpbmNsdWRpbmcgcGlubmVkIHRleHR1cmVzLlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBDb2xsZWN0IGxpc3Qgb2YgdGlsZXMgdG8gYmUgZXZpY3RlZC5cbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xuICBzZWxmLl9pdGVtTWFwLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHNlbGYuX2V2aWN0ZWQucHVzaCh0aWxlKTtcbiAgfSk7XG5cbiAgLy8gRXZpY3QgdGlsZXMuXG4gIHNlbGYuX2V2aWN0ZWQuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgc2VsZi5fdW5sb2FkVGlsZSh0aWxlKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgYWxsIGludGVybmFsIHN0YXRlLlxuICBzZWxmLl9pdGVtTWFwLmNsZWFyKCk7XG4gIHNlbGYuX3Zpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fcHJldmlvdXNseVZpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fcGluTWFwLmNsZWFyKCk7XG4gIHNlbGYuX25ld1Zpc2libGUuY2xlYXIoKTtcbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmxlbmd0aCA9IDA7XG4gIHNlbGYuX3Zpc2libGVBZ2Fpbi5sZW5ndGggPSAwO1xuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0ZXh0dXJlcyBpbiB0aGUgVGV4dHVyZVN0b3JlLCBleGNsdWRpbmcgdW5waW5uZWQgdGV4dHVyZXMuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuY2xlYXJOb3RQaW5uZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIENvbGxlY3QgbGlzdCBvZiB0aWxlcyB0byBiZSBldmljdGVkLlxuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG4gIHNlbGYuX2l0ZW1NYXAuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKCFzZWxmLl9waW5NYXAuaGFzKHRpbGUpKSB7XG4gICAgICBzZWxmLl9ldmljdGVkLnB1c2godGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBFdmljdCB0aWxlcy5cbiAgc2VsZi5fZXZpY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBzZWxmLl91bmxvYWRUaWxlKHRpbGUpO1xuICB9KTtcblxuICAvLyBDbGVhciBhbGwgY2FjaGVzIGV4Y2VwdCB0aGUgcGlubmVkIHNldC5cbiAgc2VsZi5fdmlzaWJsZS5jbGVhcigpO1xuICBzZWxmLl9wcmV2aW91c2x5VmlzaWJsZS5jbGVhcigpO1xuXG4gIC8vIENsZWFyIHRlbXBvcmFyeSB2YXJpYWJsZXMuXG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbn07XG5cblxuLyoqXG4gKiBTaWduYWwgdGhlIGJlZ2lubmluZyBvZiBhIGZyYW1lLiBDYWxsZWQgZnJvbSB7QGxpbmsgU3RhZ2V9LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnN0YXJ0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgaW4gYW4gYXBwcm9wcmlhdGUgc3RhdGUuXG4gIGlmICh0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuSURMRSAmJiB0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuU1RBUlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogc3RhcnRGcmFtZSBjYWxsZWQgb3V0IG9mIHNlcXVlbmNlJyk7XG4gIH1cblxuICAvLyBFbnRlciB0aGUgU1RBUlQgc3RhdGUsIGlmIG5vdCBhbHJlYWR5IHRoZXJlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUQVJUO1xuXG4gIC8vIEV4cGVjdCBvbmUgbW9yZSBlbmRGcmFtZSBjYWxsLlxuICB0aGlzLl9kZWxpbUNvdW50Kys7XG59O1xuXG5cbi8qKlxuICogTWFyayBhIHRpbGUgYXMgdmlzaWJsZSB3aXRoaW4gdGhlIGN1cnJlbnQgZnJhbWUuIENhbGxlZCBmcm9tIHtAbGluayBTdGFnZX0uXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgdG8gbWFyay5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5tYXJrVGlsZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgaW4gYW4gYXBwcm9wcmlhdGUgc3RhdGUuXG4gIGlmICh0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuU1RBUlQgJiYgdGhpcy5fc3RhdGUgIT09IFN0YXRlLk1BUkspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogbWFya1RpbGUgY2FsbGVkIG91dCBvZiBzZXF1ZW5jZScpO1xuICB9XG5cbiAgLy8gRW50ZXIgdGhlIE1BUksgc3RhdGUsIGlmIG5vdCBhbHJlYWR5IHRoZXJlLlxuICB0aGlzLl9zdGF0ZSA9IFN0YXRlLk1BUks7XG5cbiAgLy8gUmVmcmVzaCB0ZXh0dXJlIGZvciBkeW5hbWljIGFzc2V0cy5cbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgdmFyIHRleHR1cmUgPSBpdGVtICYmIGl0ZW0udGV4dHVyZSgpO1xuICB2YXIgYXNzZXQgPSBpdGVtICYmIGl0ZW0uYXNzZXQoKTtcbiAgaWYgKHRleHR1cmUgJiYgYXNzZXQpIHtcbiAgICB0ZXh0dXJlLnJlZnJlc2godGlsZSwgYXNzZXQpO1xuICB9XG5cbiAgLy8gQWRkIHRpbGUgdG8gdGhlIHZpc2libGUgc2V0LlxuICB0aGlzLl9uZXdWaXNpYmxlLmFkZCh0aWxlKTtcbn07XG5cblxuLyoqXG4gKiBTaWduYWwgdGhlIGVuZCBvZiBhIGZyYW1lLiBDYWxsZWQgZnJvbSB7QGxpbmsgU3RhZ2V9LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgYXJlIGluIGFuIGFwcHJvcHJpYXRlIHN0YXRlLlxuICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlLlNUQVJUICYmIHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5NQVJLICYmIHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5FTkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogZW5kRnJhbWUgY2FsbGVkIG91dCBvZiBzZXF1ZW5jZScpO1xuICB9XG5cbiAgLy8gRW50ZXIgdGhlIEVORCBzdGF0ZSwgaWYgbm90IGFscmVhZHkgdGhlcmUuXG4gIHRoaXMuX3N0YXRlID0gU3RhdGUuRU5EO1xuXG4gIC8vIEV4cGVjdCBvbmUgbGVzcyBjYWxsIHRvIGVuZEZyYW1lLlxuICB0aGlzLl9kZWxpbUNvdW50LS07XG5cbiAgLy8gSWYgbm8gZnVydGhlciBjYWxscyBhcmUgZXhwZWN0ZWQsIHByb2Nlc3MgZnJhbWUgYW5kIGVudGVyIHRoZSBJRExFIHN0YXRlLlxuICBpZiAoIXRoaXMuX2RlbGltQ291bnQpIHtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBDYWxjdWxhdGUgdGhlIHNldCBvZiB0aWxlcyB0aGF0IHVzZWQgdG8gYmUgdmlzaWJsZSBidXQgbm8gbG9uZ2VyIGFyZS5cbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmxlbmd0aCA9IDA7XG4gIHNlbGYuX3Zpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKCFzZWxmLl9uZXdWaXNpYmxlLmhhcyh0aWxlKSkge1xuICAgICAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLnB1c2godGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIHNldCBvZiB0aWxlcyB0aGF0IHdlcmUgdmlzaWJsZSByZWNlbnRseSBhbmQgaGF2ZSBiZWNvbWVcbiAgLy8gdmlzaWJsZSBhZ2Fpbi5cbiAgc2VsZi5fdmlzaWJsZUFnYWluLmxlbmd0aCA9IDA7XG4gIHNlbGYuX25ld1Zpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgaWYgKHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLmhhcyh0aWxlKSkge1xuICAgICAgc2VsZi5fdmlzaWJsZUFnYWluLnB1c2godGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBSZW1vdmUgdGlsZXMgdGhhdCBoYXZlIGJlY29tZSB2aXNpYmxlIGFnYWluIGZyb20gdGhlIGxpc3Qgb2YgcHJldmlvdXNseVxuICAvLyB2aXNpYmxlIHRpbGVzLlxuICBzZWxmLl92aXNpYmxlQWdhaW4uZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgc2VsZi5fcHJldmlvdXNseVZpc2libGUucmVtb3ZlKHRpbGUpO1xuICB9KTtcblxuICAvLyBDYW5jZWwgbG9hZGluZyBvZiB0aWxlcyB0aGF0IGFyZSBubyBsb25nZXIgdmlzaWJsZS5cbiAgLy8gTW92ZSBubyBsb25nZXIgdmlzaWJsZSB0aWxlcyB3aXRoIGEgbG9hZGVkIHRleHR1cmUgaW50byB0aGUgcHJldmlvdXNseVxuICAvLyB2aXNpYmxlIHNldCwgYW5kIGNvbGxlY3QgdGhlIHRpbGVzIGV2aWN0ZWQgZnJvbSB0aGUgbGF0dGVyLlxuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG4gIHNlbGYuX25vTG9uZ2VyVmlzaWJsZS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICB2YXIgaXRlbSA9IHNlbGYuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICAgIHZhciB0ZXh0dXJlID0gaXRlbSAmJiBpdGVtLnRleHR1cmUoKTtcbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdmFyIG90aGVyVGlsZSA9IHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLmFkZCh0aWxlKTtcbiAgICAgIGlmIChvdGhlclRpbGUgIT0gbnVsbCkge1xuICAgICAgICBzZWxmLl9ldmljdGVkLnB1c2gob3RoZXJUaWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW0pIHtcbiAgICAgIHNlbGYuX3VubG9hZFRpbGUodGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBVbmxvYWQgZXZpY3RlZCB0aWxlcywgdW5sZXNzIHRoZXkgYXJlIHBpbm5lZC5cbiAgc2VsZi5fZXZpY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBpZiAoIXNlbGYuX3Bpbk1hcC5oYXModGlsZSkpIHtcbiAgICAgIHNlbGYuX3VubG9hZFRpbGUodGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBMb2FkIHZpc2libGUgdGlsZXMgdGhhdCBhcmUgbm90IGFscmVhZHkgaW4gdGhlIHN0b3JlLlxuICAvLyBSZWZyZXNoIHRleHR1cmUgb24gdmlzaWJsZSB0aWxlcyBmb3IgZHluYW1pYyBhc3NldHMuXG4gIHNlbGYuX25ld1Zpc2libGUuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgdmFyIGl0ZW0gPSBzZWxmLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHNlbGYuX2xvYWRUaWxlKHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3dhcCB0aGUgb2xkIHZpc2libGUgc2V0IHdpdGggdGhlIG5ldyBvbmUuXG4gIHZhciB0bXAgPSBzZWxmLl92aXNpYmxlO1xuICBzZWxmLl92aXNpYmxlID0gc2VsZi5fbmV3VmlzaWJsZTtcbiAgc2VsZi5fbmV3VmlzaWJsZSA9IHRtcDtcblxuICAvLyBDbGVhciB0aGUgbmV3IHZpc2libGUgc2V0LlxuICBzZWxmLl9uZXdWaXNpYmxlLmNsZWFyKCk7XG5cbiAgLy8gQ2xlYXIgdGVtcG9yYXJ5IHZhcmlhYmxlcy5cbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmxlbmd0aCA9IDA7XG4gIHNlbGYuX3Zpc2libGVBZ2Fpbi5sZW5ndGggPSAwO1xuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuX2xvYWRUaWxlID0gZnVuY3Rpb24odGlsZSkge1xuICBpZiAodGhpcy5faXRlbU1hcC5oYXModGlsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogbG9hZGluZyB0ZXh0dXJlIGFscmVhZHkgaW4gY2FjaGUnKTtcbiAgfVxuICB2YXIgaXRlbSA9IG5ldyBUZXh0dXJlU3RvcmVJdGVtKHRoaXMsIHRpbGUpO1xuICB0aGlzLl9pdGVtTWFwLnNldCh0aWxlLCBpdGVtKTtcbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5fdW5sb2FkVGlsZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmRlbCh0aWxlKTtcbiAgaWYgKCFpdGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlU3RvcmU6IHVubG9hZGluZyB0ZXh0dXJlIG5vdCBpbiBjYWNoZScpO1xuICB9XG4gIGl0ZW0uZGVzdHJveSgpO1xufTtcblxuXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICBpZiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmFzc2V0KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtTWFwLmdldCh0aWxlKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS50ZXh0dXJlKCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogUGluIGEgdGlsZS4gVGV4dHVyZXMgZm9yIHBpbm5lZCB0aWxlcyBhcmUgbmV2ZXIgZXZpY3RlZCBmcm9tIHRoZSBzdG9yZS5cbiAqIFVwb24gcGlubmluZywgdGhlIHRleHR1cmUgaXMgY3JlYXRlZCBpZiBub3QgYWxyZWFkeSBwcmVzZW50LiBQaW5zIGFyZVxuICogcmVmZXJlbmNlLWNvdW50ZWQ7IGEgdGlsZSBtYXkgYmUgcGlubmVkIG11bHRpcGxlIHRpbWVzIGFuZCBtdXN0IGJlIHVucGlubmVkXG4gKiB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIgb2YgdGltZXMuIFBpbm5pbmcgaXMgdXNlZnVsIGUuZy4gdG8gZW5zdXJlIHRoYXRcbiAqIHRoZSBsb3dlc3QtcmVzb2x1dGlvbiBsZXZlbCBvZiBhbiBpbWFnZSBpcyBhbHdheXMgYXZhaWxhYmxlIHRvIGZhbGwgYmFja1xuICogb250by5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSB0aGUgdGlsZSB0byBwaW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwaW4gcmVmZXJlbmNlIGNvdW50LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnBpbiA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgLy8gSW5jcmVtZW50IHJlZmVyZW5jZSBjb3VudC5cbiAgdmFyIGNvdW50ID0gKHRoaXMuX3Bpbk1hcC5nZXQodGlsZSkgfHwgMCkgKyAxO1xuICB0aGlzLl9waW5NYXAuc2V0KHRpbGUsIGNvdW50KTtcbiAgLy8gSWYgdGhlIHRleHR1cmUgZm9yIHRoZSB0aWxlIGlzIG5vdCBwcmVzZW50LCBsb2FkIGl0IG5vdy5cbiAgaWYgKCF0aGlzLl9pdGVtTWFwLmhhcyh0aWxlKSkge1xuICAgIHRoaXMuX2xvYWRUaWxlKHRpbGUpO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cblxuLyoqXG4gKiBVbnBpbiBhIHRpbGUuIFBpbnMgYXJlIHJlZmVyZW5jZS1jb3VudGVkOyBhIHRpbGUgbWF5IGJlIHBpbm5lZCBtdWx0aXBsZVxuICogdGltZXMgYW5kIG11c3QgYmUgdW5waW5uZWQgdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyIG9mIHRpbWVzLlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIHRoZSB0aWxlIHRvIHVucGluXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcGluIHJlZmVyZW5jZSBjb3VudC5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS51bnBpbiA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgdmFyIGNvdW50ID0gdGhpcy5fcGluTWFwLmdldCh0aWxlKTtcbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmICghY291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogdW5waW4gd2hlbiBub3QgcGlubmVkJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudC5cbiAgICBjb3VudC0tO1xuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgIHRoaXMuX3Bpbk1hcC5zZXQodGlsZSwgY291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9waW5NYXAuZGVsKHRpbGUpO1xuICAgICAgLy8gSWYgdGhlIHRpbGUgZG9lcyBub3QgYmVsb25nIHRvIGVpdGhlciB0aGUgdmlzaWJsZSBvciBwcmV2aW91c2x5XG4gICAgICAvLyB2aXNpYmxlIHNldHMsIGV2aWN0IGl0IGZyb20gdGhlIGNhY2hlLlxuICAgICAgaWYgKCF0aGlzLl92aXNpYmxlLmhhcyh0aWxlKSAmJiAhdGhpcy5fcHJldmlvdXNseVZpc2libGUuaGFzKHRpbGUpKSB7XG4gICAgICAgIHRoaXMuX3VubG9hZFRpbGUodGlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdHlwZSBmb3Ige0BsaW5rIFRleHR1cmVTdG9yZSNxdWVyeX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaWxlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlzaWJsZSBXaGV0aGVyIHRoZSB0aWxlIGlzIGluIHRoZSB2aXNpYmxlIHNldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJldmlvdXNseVZpc2libGUgV2hldGhlciB0aGUgdGlsZSBpcyBpbiB0aGUgcHJldmlvdXNseVxuICogICAgIHZpc2libGUgc2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNBc3NldCBXaGV0aGVyIHRoZSBhc3NldCBmb3IgdGhlIHRpbGUgaXMgcHJlc2VudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzVGV4dHVyZSBXaGV0aGVyIHRoZSB0ZXh0dXJlIGZvciB0aGUgdGlsZSBpcyBwcmVzZW50LlxuICogQHByb3BlcnR5IHtib29sZWFufSBwaW5uZWQgV2hldGhlciB0aGUgdGlsZSBpcyBpbiB0aGUgcGlubmVkIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaW5Db3VudCBUaGUgcGluIHJlZmVyZW5jZSBjb3VudCBmb3IgdGhlIHRpbGUuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgc3RhdGUgb2YgYSB0aWxlLlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlIHRvIHF1ZXJ5LlxuICogQHJldHVybiB7VGlsZVN0YXRlfVxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICB2YXIgcGluQ291bnQgPSB0aGlzLl9waW5NYXAuZ2V0KHRpbGUpIHx8IDA7XG4gIHJldHVybiB7XG4gICAgdmlzaWJsZTogdGhpcy5fdmlzaWJsZS5oYXModGlsZSksXG4gICAgcHJldmlvdXNseVZpc2libGU6IHRoaXMuX3ByZXZpb3VzbHlWaXNpYmxlLmhhcyh0aWxlKSxcbiAgICBoYXNBc3NldDogaXRlbSAhPSBudWxsICYmIGl0ZW0uYXNzZXQoKSAhPSBudWxsLFxuICAgIGhhc1RleHR1cmU6IGl0ZW0gIT0gbnVsbCAmJiBpdGVtLnRleHR1cmUoKSAhPSBudWxsLFxuICAgIHBpbm5lZDogcGluQ291bnQgIT09IDAsXG4gICAgcGluQ291bnQ6IHBpbkNvdW50XG4gIH07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZVN0b3JlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2V0ID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9TZXQnKTtcblxuLyoqXG4gKiBAY2xhc3MgVGlsZVNlYXJjaGVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBUaWxlU2VhcmNoZXIgcGVyZm9ybXMgc2VhcmNoZXMgZm9yIHZpc2libGUgdGlsZXMuXG4gKi9cbmZ1bmN0aW9uIFRpbGVTZWFyY2hlcigpIHtcbiAgLy8gU3RhY2sgb2YgdGlsZXMgdG8gYmUgZXhwbG9yZWQuXG4gIHRoaXMuX3N0YWNrID0gW107XG5cbiAgLy8gU2V0IG9mIGFscmVhZHkgZXhwbG9yZWQgdGlsZXMuXG4gIHRoaXMuX3Zpc2l0ZWQgPSBuZXcgU2V0KCk7XG5cbiAgLy8gVGlsZSB2ZXJ0aWNlcy4gQWxsb2NhdGVkIGJ5IFRpbGUjdmVydGljZXMgb24gZmlyc3QgdXNlLlxuICB0aGlzLl92ZXJ0aWNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzZWFyY2ggZm9yIHZpc2libGUgdGlsZXMgYnkgc3RhcnRpbmcgYXQgYSBnaXZlbiB0aWxlIGFuZFxuICogcmVjdXJzaXZlbHkgZXhwbG9yaW5nIG5laWdoYm9ycyB1bnRpbCBubyBtb3JlIHZpc2libGUgdGlsZXMgYXJlIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB7Vmlld30gdmlldyBUaGUgdmlldyB1c2VkIHRvIGRlZW0gd2hldGhlciBhIHRpbGUgaXMgdmlzaWJsZS5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgc3RhcnRpbmcgdGlsZS5cbiAqIEBwYXJhbSB7VGlsZVtdfSByZXN1bHQgQW4gYXJyYXkgdG8gYXBwZW5kIHRoZSB2aXNpYmxlIHRpbGVzIHRvLCBpbmNsdWRpbmcgdGhlXG4gKiAgICAgc3RhcnRpbmcgdGlsZSB3aGVuIHZpc2libGUuIEV4aXN0aW5nIGFycmF5IG1lbWJlcnMgYXJlIHByZXNlcnZlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiB2aXNpYmxlIHRpbGVzIGZvdW5kLlxuICovXG5UaWxlU2VhcmNoZXIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHZpZXcsIHN0YXJ0aW5nVGlsZSwgcmVzdWx0KSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICB2YXIgdmlzaXRlZCA9IHRoaXMuX3Zpc2l0ZWQ7XG4gIHZhciB2ZXJ0aWNlcyA9IHRoaXMuX3ZlcnRpY2VzO1xuXG4gIHZhciBjb3VudCA9IDA7XG5cbiAgLy8gQ2xlYXIgaW50ZXJuYWwgc3RhdGUuXG4gIHRoaXMuX2NsZWFyKCk7XG5cbiAgc3RhY2sucHVzaChzdGFydGluZ1RpbGUpO1xuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHRpbGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmICh2aXNpdGVkLmhhcyh0aWxlKSkge1xuICAgICAgLy8gU2tpcCBhbHJlYWR5IHZpc2l0ZWQgdGlsZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghdmlldy5pbnRlcnNlY3RzKHRpbGUudmVydGljZXModmVydGljZXMpKSkge1xuICAgICAgLy8gU2tpcCBub24tdmlzaWJsZSB0aWxlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0aWxlIGFzIHZpc2l0ZWQuXG4gICAgdmlzaXRlZC5hZGQodGlsZSk7XG5cbiAgICAvLyBBZGQgbmVpZ2hib3JzIHRvIHRoZSBzdGFjayBvZiB0aWxlcyB0byBleHBsb3JlLlxuICAgIHZhciBuZWlnaGJvcnMgPSB0aWxlLm5laWdoYm9ycygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFjay5wdXNoKG5laWdoYm9yc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIHJlc3VsdC5cbiAgICByZXN1bHQucHVzaCh0aWxlKTtcblxuICAgIGNvdW50Kys7XG4gIH1cblxuICAvLyBSZXVzZSB0aGUgdmVydGljZXMgYXJyYXkgaW4gZnV0dXJlIHNlYXJjaGVzLlxuICB0aGlzLl92ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXG4gIC8vIENsZWFyIGludGVybmFsIHN0YXRlLlxuICB0aGlzLl9jbGVhcigpO1xuXG4gIHJldHVybiBjb3VudDtcbn07XG5cblRpbGVTZWFyY2hlci5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YWNrLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3Zpc2l0ZWQuY2xlYXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZVNlYXJjaGVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBub3cgPSByZXF1aXJlKCcuL3V0aWwvbm93Jyk7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZHVyYXRpb246IEluZmluaXR5XG59O1xuXG5cbi8qKlxuICogU2lnbmFscyBhIHRpbWVvdXQuXG4gKiBAZXZlbnQgVGltZXIjdGltZW91dFxuICovXG5cblxuLyoqXG4gKiBAY2xhc3MgVGltZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFRpbWVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHJlY2VpdmUgYW4gZXZlbnQgYWZ0ZXIgYSB0aW1lb3V0LlxuICpcbiAqIEEgdGltZXIgaGFzIGEgc2V0IGR1cmF0aW9uLCBhbmQgaXMgZWl0aGVyIHN0YXJ0ZWQgb3Igc3RvcHBlZCBhdCBhIGdpdmVuIHRpbWUuXG4gKiBUaGUgdGltZXIgaXMgaW5pdGlhbGx5IHN0b3BwZWQuIFdoZW4gdGhlIHRpbWVyIGlzIHN0YXJ0ZWQsIGEgdGltZW91dCBldmVudCBpc1xuICogc2NoZWR1bGVkIHRvIGZpcmUgb25jZSB0aGUgc2V0IGR1cmF0aW9uIGVsYXBzZXMuIFdoZW4gdGhlIHRpbWVyIGlzIHN0b3BwZWQsXG4gKiB0aGUgc2NoZWR1bGVkIHRpbWVvdXQgZXZlbnQgaXMgY2FuY2VsbGVkLiBXaGVuIGEgdGltZW91dCBldmVudCBmaXJlcywgdGhlXG4gKiB0aW1lciByZXR1cm5zIHRvIHRoZSBzdG9wcGVkIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kdXJhdGlvbj1JbmZpbml0eV0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIFRpbWVyKG9wdHMpIHtcblxuICBvcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuX2R1cmF0aW9uID0gb3B0cy5kdXJhdGlvbjtcblxuICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG4gIHRoaXMuX2hhbmRsZSA9IG51bGw7XG5cbiAgdGhpcy5fY2hlY2sgPSB0aGlzLl9jaGVjay5iaW5kKHRoaXMpO1xuXG59XG5cbmV2ZW50RW1pdHRlcihUaW1lcik7XG5cblxuLyoqXG4gKiBTdGFydHMgdGhlIHRpbWVyLiBJZiB0aGUgdGltZXIgaXMgYWxyZWFkeSBzdGFydGVkLCB0aGlzIGhhcyB0aGUgZWZmZWN0IG9mXG4gKiBzdG9wcGluZyBhbmQgc3RhcnRpbmcgYWdhaW4gKGkuZS4gcmVzZXR0aW5nIHRoZSB0aW1lcikuXG4gKi9cblRpbWVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFydFRpbWUgPSBub3coKTtcbiAgaWYgKHRoaXMuX2hhbmRsZSA9PSBudWxsICYmIHRoaXMuX2R1cmF0aW9uIDwgSW5maW5pdHkpIHtcbiAgICB0aGlzLl9zZXR1cCh0aGlzLl9kdXJhdGlvbik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGluIHRoZSBzdGFydGVkIHN0YXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVGltZXIucHJvdG90eXBlLnN0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YXJ0VGltZSAhPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSB0aW1lci5cbiAqL1xuVGltZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgaWYgKHRoaXMuX2hhbmRsZSAhPSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRsZSk7XG4gICAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgfVxufTtcblxuXG5UaW1lci5wcm90b3R5cGUuX3NldHVwID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgdGhpcy5faGFuZGxlID0gc2V0VGltZW91dCh0aGlzLl9jaGVjaywgaW50ZXJ2YWwpO1xufTtcblxuXG5UaW1lci5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9oYW5kbGUpO1xuICB0aGlzLl9oYW5kbGUgPSBudWxsO1xufTtcblxuXG5UaW1lci5wcm90b3R5cGUuX2NoZWNrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICB2YXIgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuXG4gIHRoaXMuX3RlYXJkb3duKCk7XG5cbiAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgdGhpcy5lbWl0KCd0aW1lb3V0Jyk7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPCBJbmZpbml0eSkge1xuICAgIHRoaXMuX3NldHVwKHJlbWFpbmluZyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2V0IGR1cmF0aW9uLlxuICovXG5UaW1lci5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGR1cmF0aW9uLiBJZiB0aGUgdGltZXIgaXMgYWxyZWFkeSBzdGFydGVkLCB0aGUgdGltZW91dCBldmVudCBpc1xuICogcmVzY2hlZHVsZWQgdG8gb2NjdXIgb25jZSB0aGUgbmV3IGR1cmF0aW9uIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAqIHRvIHN0YXJ0LiBJbiBwYXJ0aWN1bGFyLCBpZiBhbiBhbW91bnQgb2YgdGltZSBsYXJnZXIgdGhhbiB0aGUgbmV3IGR1cmF0aW9uXG4gKiBoYXMgYWxyZWFkeSBlbGFwc2VkLCB0aGUgdGltZW91dCBldmVudCBmaXJlcyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICovXG5UaW1lci5wcm90b3R5cGUuc2V0RHVyYXRpb24gPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICBpZiAodGhpcy5fc3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICB0aGlzLl9jaGVjaygpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnYm93c2VyJyk7XG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG5cbnZhciBSZW5kZXJMb29wID0gcmVxdWlyZSgnLi9SZW5kZXJMb29wJyk7XG52YXIgQ29udHJvbHMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL0NvbnRyb2xzJyk7XG52YXIgU2NlbmUgPSByZXF1aXJlKCcuL1NjZW5lJyk7XG52YXIgVGltZXIgPSByZXF1aXJlKCcuL1RpbWVyJyk7XG5cbnZhciBXZWJHbFN0YWdlID0gcmVxdWlyZSgnLi9zdGFnZXMvV2ViR2wnKTtcbnZhciBDc3NTdGFnZSA9IHJlcXVpcmUoJy4vc3RhZ2VzL0NzcycpO1xudmFyIEZsYXNoU3RhZ2UgPSByZXF1aXJlKCcuL3N0YWdlcy9GbGFzaCcpO1xuXG52YXIgQ29udHJvbEN1cnNvciA9IHJlcXVpcmUoJy4vY29udHJvbHMvQ29udHJvbEN1cnNvcicpO1xudmFyIEhhbW1lckdlc3R1cmVzID0gcmVxdWlyZSgnLi9jb250cm9scy9IYW1tZXJHZXN0dXJlcycpO1xuXG52YXIgcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL3JlZ2lzdGVyRGVmYXVsdENvbnRyb2xzJyk7XG52YXIgcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzJyk7XG5cbnZhciBzZXRPdmVyZmxvd0hpZGRlbiA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRPdmVyZmxvd0hpZGRlbjtcbnZhciBzZXRBYnNvbHV0ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRBYnNvbHV0ZTtcbnZhciBzZXRGdWxsU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRGdWxsU2l6ZTtcbnZhciBzZXRCbG9ja2luZyA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRCbG9ja2luZztcblxudmFyIHR3ZWVuID0gcmVxdWlyZSgnLi91dGlsL3R3ZWVuJyk7XG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vdXRpbC9ub29wJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgc3RhZ2VNYXAgPSB7XG4gIHdlYmdsOiBXZWJHbFN0YWdlLFxuICBjc3M6IENzc1N0YWdlLFxuICBmbGFzaDogRmxhc2hTdGFnZVxufTtcblxudmFyIHN0YWdlUHJlZkxpc3QgPSBbXG4gIFdlYkdsU3RhZ2UsXG4gIENzc1N0YWdlLFxuICBGbGFzaFN0YWdlXG5dO1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgY3VycmVudCBzY2VuZSBoYXMgY2hhbmdlZC5cbiAqIEBldmVudCBWaWV3ZXIjc2NlbmVDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgdmlldyBvZiB0aGUgY3VycmVudCBzY2VuZSBoYXMgY2hhbmdlZC4gU2VlXG4gKiB7QGxpbmsgVmlldyNldmVudDpjaGFuZ2V9LlxuICogQGV2ZW50IFZpZXdlciN2aWV3Q2hhbmdlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgVmlld2VyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBWaWV3ZXIgaXMgYSBjb250YWluZXIgZm9yIG11bHRpcGxlIHtAbGluayBTY2VuZSBzY2VuZXN9IHRvIGJlIGRpc3BsYXllZFxuICogaW5zaWRlIGEge0BsaW5rIFN0YWdlIHN0YWdlfSBjb250YWluZWQgaW4gdGhlIERPTS5cbiAqXG4gKiBTY2VuZXMgbWF5IGJlIGNyZWF0ZWQgYnkgY2FsbGluZyB7QGxpbmsgVmlld2VyI2NyZWF0ZVNjZW5lfS4gRXhjZXB0IGR1cmluZyBhXG4gKiBzY2VuZSBzd2l0Y2gsIGEgc2luZ2xlIG9uZSBvZiB0aGVtLCBjYWxsZWQgdGhlIGN1cnJlbnQgc2NlbmUsIGlzIHZpc2libGUuXG4gKiBDYWxsaW5nIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9IHNldHMgdGhlIGN1cnJlbnQgc2NlbmUgYW5kIHN3aXRjaGVzIHRvIGl0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tRWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gY29udGFpbiB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBWaWV3ZXIgY3JlYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7KG51bGx8J3dlYmdsJ3wnY3NzJ3wnZmxhc2gnKX0gW29wdHMuc3RhZ2VUeXBlPW51bGxdIFRoZSB0eXBlIG9mIHN0YWdlXG4gKiAgICAgdG8gY3JlYXRlLiBUaGUgZGVmYXVsdCBpcyB0byBjaG9vc2UgdGhlIG1vc3QgYXBwcm9wcmlhdGUgdHlwZSBkZXBlbmRpbmdcbiAqICAgICBvbiB0aGUgYnJvd3NlciBjYXBhYmlsaXRpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250cm9scyBPcHRpb25zIHRvIGJlIHBhc3NlZCB0b1xuICogICAgIHtAbGluayByZWdpc3RlckRlZmF1bHRDb250cm9sc30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5zdGFnZSBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUge0BsaW5rIFN0YWdlfVxuICogICAgIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY3Vyc29ycyBDdXJzb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmN1cnNvcnMuZHJhZyBEcmFnIGN1cnNvciBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGVcbiAqICAgICB7QGxpbmsgQ29udHJvbEN1cnNvcn0gY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIFZpZXdlcihkb21FbGVtZW50LCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHRoaXMuX2RvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG4gIC8vIEFkZCBgb3ZlcmZsb3c6IGhpZGRlbmAgdG8gdGhlIGRvbUVsZW1lbnQuXG4gIHNldE92ZXJmbG93SGlkZGVuKGRvbUVsZW1lbnQpO1xuXG4gIC8vIFNlbGVjdCB0aGUgc3RhZ2UgdHlwZSB0byB1c2UuXG4gIHZhciBTdGFnZTtcbiAgaWYgKG9wdHMuc3RhZ2VUeXBlKSB7XG4gICAgLy8gSWYgYSBzcGVjaWZpYyBzdGFnZSB0eXBlIHdhcyBzcGVjaWZpZWQsIHVzZSB0aGF0IG9uZS5cbiAgICBTdGFnZSA9IHN0YWdlTWFwW29wdHMuc3RhZ2VUeXBlXTtcbiAgICBpZiAoIVN0YWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3RhZ2UgdHlwZTogJyArIG9wdHMuc3RhZ2VUeXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBiZXN0IHN1cHBvcnRlZCBzdGFnZSBhY2NvcmRpbmcgdG8gdGhlIGRlZmF1bHQgcHJlZmVyZW5jZVxuICAgIC8vIG9yZGVyLiBOb3RlIHRoYXQgdGhpcyBtYXkgeWllbGQgYW4gdW5zdXBwb3J0ZWQgc3RhZ2UgZm9yIHNvbWVcbiAgICAvLyBnZW9tZXRyeS92aWV3IGNvbWJpbmF0aW9ucy4gQ2xpZW50IGNvZGUgaXMgZXhwZWN0ZWQgdG8gcGFzcyBpbiBhXG4gICAgLy8gc3BlY2lmaWMgc3RhZ2UgdHlwZSBpbiB0aG9zZSBjYXNlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWdlUHJlZkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFnZVByZWZMaXN0W2ldLnN1cHBvcnRlZCgpKSB7XG4gICAgICAgIFN0YWdlID0gc3RhZ2VQcmVmTGlzdFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghU3RhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgc3RhZ2UgdHlwZXMgYXJlIHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBzdGFnZS5cbiAgdGhpcy5fc3RhZ2UgPSBuZXcgU3RhZ2Uob3B0cy5zdGFnZSk7XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGRlZmF1bHQgcmVuZGVyZXJzIGZvciB0aGUgc2VsZWN0ZWQgc3RhZ2UuXG4gIHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycyh0aGlzLl9zdGFnZSk7XG5cbiAgLy8gQWRkIHRoZSBzdGFnZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAgdGhpcy5fZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9zdGFnZS5kb21FbGVtZW50KCkpO1xuXG4gIC8vIENyZWF0ZSBjb250cm9sIGNvbnRhaW5lci5cbiAgLy8gQ29udHJvbHMgY2Fubm90IGJlIHBsYWNlZCBkaXJlY3RseSBvbiB0aGUgcm9vdCBET00gZWxlbWVudCBiZWNhdXNlXG4gIC8vIEhhbW1lci5qcyB3aWxsIHByZXZlbnQgY2xpY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGVsZW1lbnRzIGJlbmVhdGguXG5cbiAgLy8gVGhlIGhvdHNwb3QgY29udGFpbmVycyB3aWxsIGJlIGFkZGVkIGluc2lkZSB0aGUgY29udHJvbHMgY29udGFpbmVyLlxuICB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xuICBzZXRGdWxsU2l6ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcblxuICAvLyBQcmV2ZW50IGJvdW5jZSBzY3JvbGwgZWZmZWN0IG9uIGlPUy5cbiAgLy8gQXBwbGllZCBvbmx5IGZvciBpT1MsIGFzIEFuZHJvaWQncyBldmVudHMgbXVzdCBoYXZlIHRoZSBkZWZhdWx0IGFjdGlvbiB0byBhbGxvdyBpbnRlcmFjdGlvbiB3aXRoIGhvdHNwb3RzLlxuICBpZiAoYnJvd3Nlci5pb3MpIHtcbiAgICB0aGlzLl9jb250cm9sQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuICB9XG5cblxuICAvLyBPbGQgSUUgZG9lcyBub3QgZGV0ZWN0IG1vdXNlIGV2ZW50cyBvbiBlbGVtZW50cyB3aXRob3V0IGJhY2tncm91bmRcbiAgLy8gQWRkIGEgY2hpbGQgZWxlbWVudCB0byB0aGUgY29udHJvbHMgd2l0aCBmdWxsIHdpZHRoLCBhIGJhY2tncm91bmQgY29sb3JcbiAgLy8gYW5kIG9wYWNpdHkgMFxuICB2YXIgY29udHJvbENhcHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2V0QWJzb2x1dGUoY29udHJvbENhcHR1cmUpO1xuICBzZXRGdWxsU2l6ZShjb250cm9sQ2FwdHVyZSk7XG4gIHNldEJsb2NraW5nKGNvbnRyb2xDYXB0dXJlKTtcblxuICB0aGlzLl9jb250cm9sQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xDYXB0dXJlKTtcbiAgZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcblxuICAvLyBSZXNwb25kIHRvIHdpbmRvdyBzaXplIGNoYW5nZXMuXG4gIHRoaXMuX3NpemUgPSB7fTtcbiAgdGhpcy51cGRhdGVTaXplKCk7XG4gIHRoaXMuX3VwZGF0ZVNpemVMaXN0ZW5lciA9IHRoaXMudXBkYXRlU2l6ZS5iaW5kKHRoaXMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlU2l6ZUxpc3RlbmVyKTtcblxuICAvLyBDcmVhdGUgcmVuZGVyIGxvb3AuXG4gIHRoaXMuX3JlbmRlckxvb3AgPSBuZXcgUmVuZGVyTG9vcCh0aGlzLl9zdGFnZSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjb250cm9scyBhbmQgcmVnaXN0ZXIgdGhlbSB3aXRoIHRoZSByZW5kZXIgbG9vcC5cbiAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHMoKTtcbiAgdGhpcy5fY29udHJvbE1ldGhvZHMgPSByZWdpc3RlckRlZmF1bHRDb250cm9scyh0aGlzLl9jb250cm9scywgdGhpcy5fY29udHJvbENvbnRhaW5lciwgb3B0cy5jb250cm9scyk7XG4gIHRoaXMuX2NvbnRyb2xzLmF0dGFjaCh0aGlzLl9yZW5kZXJMb29wKTtcblxuICAvLyBFeHBvc2UgSGFtbWVySlMuXG4gIHRoaXMuX2hhbW1lck1hbmFnZXJUb3VjaCA9IEhhbW1lckdlc3R1cmVzLmdldCh0aGlzLl9jb250cm9sQ29udGFpbmVyLCAndG91Y2gnKTtcbiAgdGhpcy5faGFtbWVyTWFuYWdlck1vdXNlID0gSGFtbWVyR2VzdHVyZXMuZ2V0KHRoaXMuX2NvbnRyb2xDb250YWluZXIsICdtb3VzZScpO1xuXG4gIC8vIEluaXRpYWxpemUgZHJhZyBjdXJzb3IuXG4gIHRoaXMuX2RyYWdDdXJzb3IgPSBuZXcgQ29udHJvbEN1cnNvcih0aGlzLl9jb250cm9scywgJ21vdXNlVmlld0RyYWcnLCBkb21FbGVtZW50LCBvcHRzLmN1cnNvcnMgJiYgb3B0cy5jdXJzb3JzLmRyYWcgfHwge30pO1xuXG4gIC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcC5cbiAgdGhpcy5fcmVuZGVyTG9vcC5zdGFydCgpO1xuXG4gIC8vIFNjZW5lIGxpc3QuXG4gIHRoaXMuX3NjZW5lcyA9IFtdO1xuXG4gIC8vIFRoZSBjdXJyZW50bHkgdmlzaWJsZSBzY2VuZS5cbiAgLy8gRHVyaW5nIGEgc2NlbmUgdHJhbnNpdGlvbiwgdGhpcyBpcyB0aGUgc2NlbmUgYmVpbmcgc3dpdGNoZWQgdG8uXG4gIHRoaXMuX2N1cnJlbnRTY2VuZSA9IG51bGw7XG5cbiAgLy8gVGhlIHNjZW5lIGJlaW5nIHN3aXRjaGVkIGZyb20gZHVyaW5nIGEgc2NlbmUgdHJhbnNpdGlvbi5cbiAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gdXBkYXRlIHRoZSBsYXllcnMgY29ycmVjdGx5IHdoZW4gdGhleSBhcmUgYWRkZWQgb3JcbiAgLy8gcmVtb3ZlZCBkdXJpbmcgYSB0cmFuc2l0aW9uLlxuICB0aGlzLl9yZXBsYWNlZFNjZW5lID0gbnVsbDtcblxuICAvLyBUaGUgY3VycmVudCB0cmFuc2l0aW9uLlxuICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuXG4gIC8vIFRoZSBldmVudCBsaXN0ZW5lciBmaXJlZCB3aGVuIHRoZSBjdXJyZW50IHNjZW5lIGxheWVycyBjaGFuZ2UuXG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIGNvcnJlY3Qgc2NlbmUgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyID0gdGhpcy5fdXBkYXRlU2NlbmVMYXllcnMuYmluZCh0aGlzKTtcblxuICAvLyBUaGUgZXZlbnQgbGlzdGVuZXIgZmlyZWQgd2hlbiB0aGUgY3VycmVudCBzY2VuZSB2aWV3IGNoYW5nZXMuXG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIGNvcnJlY3Qgc2NlbmUgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndmlld0NoYW5nZScpO1xuXG4gIC8vIFNldHVwIHRoZSBpZGxlIHRpbWVyLlxuICAvLyBCeSBkZWZhdWx0LCB0aGUgdGltZXIgaGFzIGFuIGluZmluaXRlIGR1cmF0aW9uIHNvIGl0IGRvZXMgbm90aGluZy5cbiAgdGhpcy5faWRsZVRpbWVyID0gbmV3IFRpbWVyKCk7XG4gIHRoaXMuX2lkbGVUaW1lci5zdGFydCgpO1xuXG4gIC8vIFJlc2V0IHRoZSB0aW1lciB3aGVuZXZlciB0aGUgdmlldyBjaGFuZ2VzLlxuICB0aGlzLl9yZXNldElkbGVUaW1lckhhbmRsZXIgPSB0aGlzLl9yZXNldElkbGVUaW1lci5iaW5kKHRoaXMpO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZpZXdDaGFuZ2UnLCB0aGlzLl9yZXNldElkbGVUaW1lckhhbmRsZXIpO1xuXG4gIC8vIFN0YXJ0IHRoZSBpZGxlIG1vdmVtZW50IHdoZW4gdGhlIGlkbGUgdGltZXIgZmlyZXMuXG4gIHRoaXMuX3RyaWdnZXJJZGxlVGltZXJIYW5kbGVyID0gdGhpcy5fdHJpZ2dlcklkbGVUaW1lci5iaW5kKHRoaXMpO1xuICB0aGlzLl9pZGxlVGltZXIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHRoaXMuX3RyaWdnZXJJZGxlVGltZXJIYW5kbGVyKTtcblxuICAvLyBTdG9wIGFuIG9uZ29pbmcgbW92ZW1lbnQgd2hlbiB0aGUgY29udHJvbHMgYXJlIGFjdGl2YXRlZCBvciB3aGVuIHRoZVxuICAvLyBzY2VuZSBjaGFuZ2VzLlxuICB0aGlzLl9zdG9wTW92ZW1lbnRIYW5kbGVyID0gdGhpcy5zdG9wTW92ZW1lbnQuYmluZCh0aGlzKTtcbiAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgdGhpcy5fc3RvcE1vdmVtZW50SGFuZGxlcik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignc2NlbmVDaGFuZ2UnLCB0aGlzLl9zdG9wTW92ZW1lbnRIYW5kbGVyKTtcblxuICAvLyBUaGUgY3VycmVudGx5IHByb2dyYW1tZWQgaWRsZSBtb3ZlbWVudC5cbiAgdGhpcy5faWRsZU1vdmVtZW50ID0gbnVsbDtcbn1cblxuZXZlbnRFbWl0dGVyKFZpZXdlcik7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlU2l6ZUxpc3RlbmVyKTtcblxuICBpZiAodGhpcy5fY3VycmVudFNjZW5lKSB7XG4gICAgdGhpcy5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyh0aGlzLl9jdXJyZW50U2NlbmUpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3JlcGxhY2VkU2NlbmUpIHtcbiAgICB0aGlzLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzKHRoaXMuX3JlcGxhY2VkU2NlbmUpO1xuICB9XG5cbiAgdGhpcy5fZHJhZ0N1cnNvci5kZXN0cm95KCk7XG5cbiAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiB0aGlzLl9jb250cm9sTWV0aG9kcykge1xuICAgIHRoaXMuX2NvbnRyb2xNZXRob2RzW21ldGhvZE5hbWVdLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLl9zY2VuZXMubGVuZ3RoKSB7XG4gICAgdGhpcy5kZXN0cm95U2NlbmUodGhpcy5fc2NlbmVzWzBdKTtcbiAgfVxuXG4gIC8vIFRoZSBGbGFzaCByZW5kZXJlciBtdXN0IGJlIHRvcm4gZG93biBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tXG4gIC8vIHRoZSBET00sIHNvIGFsbCBzY2VuZXMgbXVzdCBoYXZlIGJlZW4gZGVzdHJveWVkIGJlZm9yZSB0aGlzIHBvaW50LlxuICB0aGlzLl9kb21FbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3N0YWdlLmRvbUVsZW1lbnQoKSk7XG5cbiAgdGhpcy5fc3RhZ2UuZGVzdHJveSgpO1xuICB0aGlzLl9yZW5kZXJMb29wLmRlc3Ryb3koKTtcbiAgdGhpcy5fY29udHJvbHMuZGVzdHJveSgpO1xuICB0aGlzLl9jb250cm9scyA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX2NhbmNlbEN1cnJlbnRUd2Vlbikge1xuICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbigpO1xuICB9XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YWdlIHNpemUgdG8gZmlsbCB0aGUgY29udGFpbmluZyBlbGVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHJlc2l6ZWQuXG4gKiBNb3N0IGNsaWVudHMgd29uJ3QgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgaXQgdG8ga2VlcCB0aGUgc2l6ZSB1cCB0byBkYXRlLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICBzaXplLndpZHRoID0gdGhpcy5fZG9tRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgc2l6ZS5oZWlnaHQgPSB0aGlzLl9kb21FbGVtZW50LmNsaWVudEhlaWdodDtcbiAgdGhpcy5fc3RhZ2Uuc2V0U2l6ZShzaXplKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTdGFnZSBzdGFnZX0uXG4gKiBAcmV0dXJuIHtTdGFnZX1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zdGFnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3RhZ2U7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgUmVuZGVyTG9vcCByZW5kZXIgbG9vcH0uXG4gKiBAcmV0dXJuIHtSZW5kZXJMb29wfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnJlbmRlckxvb3AgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JlbmRlckxvb3A7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgQ29udHJvbHMgY29udHJvbHN9LlxuICogQHJldHVybiB7Q29udHJvbHN9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuY29udHJvbHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgU2NlbmUgc2NlbmV9IHdpdGggYSBzaW5nbGUgbGF5ZXIgYW5kIGFkZHMgaXQgdG8gdGhlXG4gKiB2aWV3ZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgc2NlbmUgZG9lcyBub3QgY2hhbmdlLiBUbyBzd2l0Y2ggdG8gdGhlIHNjZW5lLCBjYWxsXG4gKiB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBTY2VuZSBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtWaWV3fSBvcHRzLnZpZXcgVGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlld30uXG4gKiBAcGFyYW0ge1NvdXJjZX0gb3B0cy5zb3VyY2UgVGhlIGxheWVyJ3MgdW5kZXJseWluZyB7QGxpbmsgU291cmNlfS5cbiAqIEBwYXJhbSB7R2VvbWV0cnl9IG9wdHMuZ2VvbWV0cnkgVGhlIGxheWVyJ3MgdW5kZXJseWluZyB7QGxpbmsgR2VvbWV0cnl9LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5waW5GaXJzdExldmVsPWZhbHNlXSBXaGV0aGVyIHRvIHBpbiB0aGUgZmlyc3QgbGV2ZWwgdG9cbiAqICAgICBwcm92aWRlIGEgZmFsbGJhY2sgb2YgbGFzdCByZXNvcnQsIGF0IHRoZSBjb3N0IG9mIG1lbW9yeSBjb25zdW1wdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy50ZXh0dXJlU3RvcmVPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlXG4gKiAgICAge0BsaW5rIFRleHR1cmVTdG9yZX0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubGF5ZXJPcHRzPXt9XSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIHtAbGluayBMYXllcn1cbiAqICAgICBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm4ge1NjZW5lfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmNyZWF0ZVNjZW5lID0gZnVuY3Rpb24ob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgc2NlbmUgPSB0aGlzLmNyZWF0ZUVtcHR5U2NlbmUoeyB2aWV3OiBvcHRzLnZpZXcgfSk7XG5cbiAgc2NlbmUuY3JlYXRlTGF5ZXIoe1xuICAgIHNvdXJjZTogb3B0cy5zb3VyY2UsXG4gICAgZ2VvbWV0cnk6IG9wdHMuZ2VvbWV0cnksXG4gICAgcGluRmlyc3RMZXZlbDogb3B0cy5waW5GaXJzdExldmVsLFxuICAgIHRleHR1cmVTdG9yZU9wdHM6IG9wdHMudGV4dHVyZVN0b3JlT3B0cyxcbiAgICBsYXllck9wdHM6IG9wdHMubGF5ZXJPcHRzXG4gIH0pO1xuXG4gIHJldHVybiBzY2VuZTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBTY2VuZSBzY2VuZX0gd2l0aCBubyBsYXllcnMgYW5kIGFkZHMgaXQgdG8gdGhlIHZpZXdlci5cbiAqXG4gKiBMYXllcnMgbWF5IGJlIGFkZGVkIHRvIHRoZSBzY2VuZSBieSBjYWxsaW5nIHtAbGluayBTY2VuZSNjcmVhdGVMYXllcn0uXG4gKiBIb3dldmVyLCBpZiB0aGUgc2NlbmUgaGFzIGEgc2luZ2xlIGxheWVyLCBpdCBpcyBzaW1wbGVyIHRvIGNhbGxcbiAqIHtAbGluayBWaWV3ZXIjY3JlYXRlU2NlbmV9IGluc3RlYWQgb2YgdGhpcyBtZXRob2QuXG4gKlxuICogVGhlIGN1cnJlbnQgc2NlbmUgZG9lcyBub3QgY2hhbmdlLiBUbyBzd2l0Y2ggdG8gdGhlIHNjZW5lLCBjYWxsXG4gKiB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBTY2VuZSBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtWaWV3fSBvcHRzLnZpZXcgVGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlld30uXG4gKiBAcmV0dXJuIHtTY2VuZX1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5jcmVhdGVFbXB0eVNjZW5lID0gZnVuY3Rpb24ob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgc2NlbmUgPSBuZXcgU2NlbmUodGhpcywgb3B0cy52aWV3KTtcbiAgdGhpcy5fc2NlbmVzLnB1c2goc2NlbmUpO1xuXG4gIHJldHVybiBzY2VuZTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fdXBkYXRlU2NlbmVMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGk7XG4gIHZhciBsYXllcjtcblxuICB2YXIgc3RhZ2UgPSB0aGlzLl9zdGFnZTtcbiAgdmFyIGN1cnJlbnRTY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgdmFyIHJlcGxhY2VkU2NlbmUgPSB0aGlzLl9yZXBsYWNlZFNjZW5lO1xuXG4gIHZhciBvbGRMYXllcnMgPSBzdGFnZS5saXN0TGF5ZXJzKCk7XG5cbiAgLy8gVGhlIHN0YWdlIGNvbnRhaW5zIGxheWVycyBmcm9tIGF0IG1vc3QgdHdvIHNjZW5lczogdGhlIGN1cnJlbnQgb25lLCBvbiB0b3AsXG4gIC8vIGFuZCB0aGUgb25lIGN1cnJlbnRseSBiZWluZyBzd2l0Y2hlZCBhd2F5IGZyb20sIG9uIHRoZSBib3R0b20uXG4gIHZhciBuZXdMYXllcnMgPSBbXTtcbiAgaWYgKHJlcGxhY2VkU2NlbmUpIHtcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuY29uY2F0KHJlcGxhY2VkU2NlbmUubGlzdExheWVycygpKTtcbiAgfVxuICBpZiAoY3VycmVudFNjZW5lKSB7XG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmNvbmNhdChjdXJyZW50U2NlbmUubGlzdExheWVycygpKTtcbiAgfVxuXG4gIC8vIEEgc2luZ2xlIGxheWVyIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIHNjZW5lIGF0IGEgdGltZS5cbiAgaWYgKE1hdGguYWJzKG9sZExheWVycy5sZW5ndGggLSBuZXdMYXllcnMubGVuZ3RoKSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhZ2UgYW5kIHNjZW5lIG91dCBvZiBzeW5jJyk7XG4gIH1cblxuICBpZiAobmV3TGF5ZXJzLmxlbmd0aCA8IG9sZExheWVycy5sZW5ndGgpIHtcbiAgICAvLyBBIGxheWVyIHdhcyByZW1vdmVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBvbGRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxheWVyID0gb2xkTGF5ZXJzW2ldO1xuICAgICAgaWYgKG5ld0xheWVycy5pbmRleE9mKGxheWVyKSA8IDApIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJGcm9tU3RhZ2UobGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld0xheWVycy5sZW5ndGggPiBvbGRMYXllcnMubGVuZ3RoKSB7XG4gICAgLy8gQSBsYXllciB3YXMgYWRkZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGF5ZXIgPSBuZXdMYXllcnNbaV07XG4gICAgICBpZiAob2xkTGF5ZXJzLmluZGV4T2YobGF5ZXIpIDwgMCkge1xuICAgICAgICB0aGlzLl9hZGRMYXllclRvU3RhZ2UobGF5ZXIsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IFdoZW4gaW4gdGhlIG1pZGRsZSBvZiBhIHNjZW5lIHRyYW5zaXRpb24sIGNhbGwgdGhlIHRyYW5zaXRpb24gdXBkYXRlXG4gIC8vIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgYW4gYWRkZWQgbGF5ZXIgZnJvbSBmbGFzaGluZyB3aXRoIHRoZSB3cm9uZ1xuICAvLyBvcGFjaXR5LlxufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9hZGRMYXllclRvU3RhZ2UgPSBmdW5jdGlvbihsYXllciwgaSkge1xuICAvLyBQaW4gdGhlIGZpcnN0IGxldmVsIHRvIGVuc3VyZSBhIGZhbGxiYWNrIHdoaWxlIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBgcGluRmlyc3RMZXZlbGAgb3B0aW9uIHBhc3NlZCB0b1xuICAvLyBjcmVhdGVTY2VuZSgpLCB3aGljaCBwaW5zIHRoZSBsYXllciBldmVuIHdoZW4gaXQncyBub3QgdmlzaWJsZS5cbiAgbGF5ZXIucGluRmlyc3RMZXZlbCgpO1xuICB0aGlzLl9zdGFnZS5hZGRMYXllcihsYXllciwgaSk7XG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX3JlbW92ZUxheWVyRnJvbVN0YWdlID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdGhpcy5fc3RhZ2UucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICBsYXllci51bnBpbkZpcnN0TGV2ZWwoKTtcbiAgbGF5ZXIudGV4dHVyZVN0b3JlKCkuY2xlYXJOb3RQaW5uZWQoKTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fYWRkU2NlbmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHNjZW5lLmFkZEV2ZW50TGlzdGVuZXIoJ2xheWVyQ2hhbmdlJywgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyKTtcbiAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHNjZW5lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xheWVyQ2hhbmdlJywgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyKTtcbiAgc2NlbmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyBhIHtAbGluayBTY2VuZSBzY2VuZX0gYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgdmlld2VyLlxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAqL1xuVmlld2VyLnByb3RvdHlwZS5kZXN0cm95U2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgaSA9IHRoaXMuX3NjZW5lcy5pbmRleE9mKHNjZW5lKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIHNjZW5lIGluIHZpZXdlcicpO1xuICB9XG5cbiAgdmFyIGo7XG4gIHZhciBsYXllcnM7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRTY2VuZSA9PT0gc2NlbmUpIHtcbiAgICAvLyBUaGUgZGVzdHJveWVkIHNjZW5lIGlzIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMsIHJlbW92ZSBsYXllcnMgZnJvbSBzdGFnZSBhbmQgY2FuY2VsIHRyYW5zaXRpb24uXG4gICAgdGhpcy5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyhzY2VuZSk7XG4gICAgbGF5ZXJzID0gc2NlbmUubGlzdExheWVycygpO1xuICAgIGZvciAoaiA9IDA7IGogPCBsYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxheWVyRnJvbVN0YWdlKGxheWVyc1tqXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4pIHtcbiAgICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbigpO1xuICAgICAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFNjZW5lID0gbnVsbDtcbiAgICB0aGlzLmVtaXQoJ3NjZW5lQ2hhbmdlJyk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVwbGFjZWRTY2VuZSA9PT0gc2NlbmUpIHtcbiAgICAvLyBUaGUgZGVzdHJveWVkIHNjZW5lIGlzIGJlaW5nIHN3aXRjaGVkIGF3YXkgZnJvbS5cbiAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCByZW1vdmUgbGF5ZXJzIGZyb20gc3RhZ2UuXG4gICAgdGhpcy5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyhzY2VuZSk7XG4gICAgbGF5ZXJzID0gc2NlbmUubGlzdExheWVycygpO1xuICAgIGZvciAoaiA9IDA7IGogPCBsYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxheWVyRnJvbVN0YWdlKGxheWVyc1tqXSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcGxhY2VkU2NlbmUgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5fc2NlbmVzLnNwbGljZShpLCAxKTtcblxuICBzY2VuZS5kZXN0cm95KCk7XG59O1xuXG5cbi8qKlxuICogRGVzdHJveXMgYWxsIHtAbGluayBTY2VuZSBzY2VuZXN9IGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgdmlld2VyLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3lBbGxTY2VuZXMgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuX3NjZW5lcy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5kZXN0cm95U2NlbmUodGhpcy5fc2NlbmVzWzBdKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdmlld2VyIGNvbnRhaW5zIGEge0BsaW5rIFNjZW5lIHNjZW5lfS5cbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5WaWV3ZXIucHJvdG90eXBlLmhhc1NjZW5lID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgcmV0dXJuIHRoaXMuX3NjZW5lcy5pbmRleE9mKHNjZW5lKSA+PSAwO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB7QGxpbmsgU2NlbmUgc2NlbmVzfS5cbiAqIEByZXR1cm4ge1NjZW5lW119XG4gKi9cblZpZXdlci5wcm90b3R5cGUubGlzdFNjZW5lcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW10uY29uY2F0KHRoaXMuX3NjZW5lcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB7QGxpbmsgU2NlbmUgc2NlbmV9LCBvciBudWxsIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAqXG4gKiBUbyBjaGFuZ2UgdGhlIGN1cnJlbnQgc2NlbmUsIGNhbGwge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0uXG4gKlxuICogQHJldHVybiB7U2NlbmV9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuc2NlbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTY2VuZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB7QGxpbmsgVmlldyB2aWV3fSBmb3IgdGhlIGN1cnJlbnQge0BsaW5rIFNjZW5lIHNjZW5lfSwgb3IgbnVsbFxuICogaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICogQHJldHVybiB7Vmlld31cbiAqL1xuVmlld2VyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKHNjZW5lKSB7XG4gICAgcmV0dXJuIHNjZW5lLnZpZXcoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBUd2VlbnMgdGhlIHtAbGluayBWaWV3IHZpZXd9IGZvciB0aGUgY3VycmVudCB7QGxpbmsgU2NlbmUgc2NlbmV9LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjbG9va1RvfSBvbiB0aGUgY3VycmVudFxuICogc2NlbmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucyB0byBwYXNzIGludG8ge0BsaW5rIFNjZW5lI2xvb2tUb30uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdHdlZW4gaXMgY29tcGxldGUuXG4gKi9cblZpZXdlci5wcm90b3R5cGUubG9va1RvID0gZnVuY3Rpb24ocGFyYW1zLCBvcHRzLCBkb25lKSB7XG4gIC8vIFRPRE86IGlzIGl0IGFuIGVycm9yIHRvIGNhbGwgbG9va1RvIHdoZW4gbm8gc2NlbmUgaXMgZGlzcGxheWVkP1xuICB2YXIgc2NlbmUgPSB0aGlzLl9jdXJyZW50U2NlbmU7XG4gIGlmIChzY2VuZSkge1xuICAgIHNjZW5lLmxvb2tUbyhwYXJhbXMsIG9wdHMsIGRvbmUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU3RhcnRzIGEgbW92ZW1lbnQsIHBvc3NpYmx5IHJlcGxhY2luZyB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFNjZW5lI3N0YXJ0TW92ZW1lbnR9IG9uIHRoZVxuICogY3VycmVudCBzY2VuZS4gSWYgdGhlcmUgaXMgbm8gY3VycmVudCBzY2VuZSwgdGhpcyBpcyBhIG5vLW9wLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBtb3ZlbWVudCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdmVtZW50IGZpbmlzaGVzIG9yIGlzXG4gKiAgICAgaW50ZXJydXB0ZWQuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuc3RhcnRNb3ZlbWVudCA9IGZ1bmN0aW9uKGZuLCBkb25lKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKCFzY2VuZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzY2VuZS5zdGFydE1vdmVtZW50KGZuLCBkb25lKTtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgY3VycmVudCBtb3ZlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFNjZW5lI3N0b3BNb3ZlbWVudH0gb24gdGhlXG4gKiBjdXJyZW50IHNjZW5lLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHNjZW5lLCB0aGlzIGlzIGEgbm8tb3AuXG4gKi9cblZpZXdlci5wcm90b3R5cGUuc3RvcE1vdmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKCFzY2VuZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzY2VuZS5zdG9wTW92ZW1lbnQoKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjbW92ZW1lbnR9IG9uIHRoZVxuICogY3VycmVudCBzY2VuZS4gSWYgdGhlcmUgaXMgbm8gY3VycmVudCBzY2VuZSwgdGhpcyBpcyBhIG5vLW9wLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5WaWV3ZXIucHJvdG90eXBlLm1vdmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKCFzY2VuZSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gc2NlbmUubW92ZW1lbnQoKTtcbn07XG5cblxuLyoqXG4gKiBTY2hlZHVsZXMgYW4gaWRsZSBtb3ZlbWVudCB0byBiZSBhdXRvbWF0aWNhbGx5IHN0YXJ0ZWQgd2hlbiB0aGUgdmlldyByZW1haW5zXG4gKiB1bmNoYW5nZWQgZm9yIHRoZSBnaXZlbiB0aW1lb3V0IHBlcmlvZC5cbiAqXG4gKiBDaGFuZ2luZyB0aGUgdmlldyB3aGlsZSB0aGUgaWRsZSBtb3ZlbWVudCBpcyBhY3RpdmUgc3RvcHMgdGhlIG1vdmVtZW50IGFuZFxuICogc2NoZWR1bGVzIGl0IHRvIHN0YXJ0IGFnYWluIGFmdGVyIHRoZSBzYW1lIHRpbWVvdXQgcGVyaW9kLiBUbyBkaXNhYmxlIGl0XG4gKiBwZXJtYW5lbnRseSwgY2FsbCB3aXRoIGEgbnVsbCBtb3ZlbWVudCBvciBhbiBpbmZpbml0ZSB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgcGVyaW9kIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vdmVtZW50IEF1dG9tYXRpYyBtb3ZlbWVudCBmdW5jdGlvbiwgb3IgbnVsbCB0byBkaXNhYmxlLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLnNldElkbGVNb3ZlbWVudCA9IGZ1bmN0aW9uKHRpbWVvdXQsIG1vdmVtZW50KSB7XG4gIHRoaXMuX2lkbGVUaW1lci5zZXREdXJhdGlvbih0aW1lb3V0KTtcbiAgdGhpcy5faWRsZU1vdmVtZW50ID0gbW92ZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIGlkbGUgbW92ZW1lbnQuIEl0IHdpbGwgYmUgc3RhcnRlZCBhZ2FpbiBhZnRlciB0aGUgdGltZW91dCBzZXQgYnlcbiAqIHtAbGluayBWaWV3ZXIjc2V0SWRsZU1vdmVtZW50fS5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5icmVha0lkbGVNb3ZlbWVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB0aGlzLl9yZXNldElkbGVUaW1lcigpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9yZXNldElkbGVUaW1lciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9pZGxlVGltZXIuc3RhcnQoKTtcbn07XG5cblxuVmlld2VyLnByb3RvdHlwZS5fdHJpZ2dlcklkbGVUaW1lciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWRsZU1vdmVtZW50ID0gdGhpcy5faWRsZU1vdmVtZW50O1xuICBpZiAoIWlkbGVNb3ZlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnN0YXJ0TW92ZW1lbnQoaWRsZU1vdmVtZW50KTtcbn07XG5cblxudmFyIGRlZmF1bHRTd2l0Y2hEdXJhdGlvbiA9IDEwMDA7XG5cbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2l0aW9uVXBkYXRlKHZhbCwgbmV3U2NlbmUsIG9sZFNjZW5lKSB7XG4gIHZhciBsYXllcnMgPSBuZXdTY2VuZS5saXN0TGF5ZXJzKCk7XG4gIGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgbGF5ZXIubWVyZ2VFZmZlY3RzKHsgb3BhY2l0eTogdmFsIH0pO1xuICB9KTtcblxuICBuZXdTY2VuZS5faG90c3BvdENvbnRhaW5lci5kb21FbGVtZW50KCkuc3R5bGUub3BhY2l0eSA9IHZhbDtcbn1cblxuXG4vKipcbiAqIFN3aXRjaGVzIHRvIGFub3RoZXIge0BsaW5rIFNjZW5lIHNjZW5lfSB3aXRoIGEgZmFkZSB0cmFuc2l0aW9uLiBUaGlzIHNjZW5lXG4gKiBiZWNvbWVzIHRoZSBjdXJyZW50IG9uZS5cbiAqXG4gKiBJZiBhIHRyYW5zaXRpb24gaXMgYWxyZWFkeSB0YWtpbmcgcGxhY2UsIGl0IGlzIGludGVycnVwdGVkIGJlZm9yZSB0aGUgbmV3IG9uZVxuICogc3RhcnRzLlxuICpcbiAqIEBwYXJhbSB7U2NlbmV9IG5ld1NjZW5lIFRoZSBzY2VuZSB0byBzd2l0Y2ggdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUcmFuc2l0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudHJhbnNpdGlvbkR1cmF0aW9uPTEwMDBdIFRyYW5zaXRpb24gZHVyYXRpb24sIGluXG4gKiAgICAgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRyYW5zaXRpb25VcGRhdGU9ZGVmYXVsdFRyYW5zaXRpb25VcGRhdGVdXG4gKiAgICAgVHJhbnNpdGlvbiB1cGRhdGUgZnVuY3Rpb24sIHdpdGggc2lnbmF0dXJlIGBmKHQsIG5ld1NjZW5lLCBvbGRTY2VuZSlgLlxuICogICAgIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggZnJhbWUgd2l0aCBgdGAgaW5jcmVhc2luZyBmcm9tIDAgdG8gMS5cbiAqICAgICBBbiBpbml0aWFsIGNhbGwgd2l0aCBgdD0wYCBhbmQgYSBmaW5hbCBjYWxsIHdpdGggYHQ9MWAgYXJlIGd1YXJhbnRlZWQuXG4gKiAgICAgVGhlIGRlZmF1bHQgZnVuY3Rpb24gc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbmV3IHNjZW5lIHRvIGB0YC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzIG9yIGlzXG4gKiAgICAgaW50ZXJydXB0ZWQuIElmIHRoZSBuZXcgc2NlbmUgaXMgZXF1YWwgdG8gdGhlIG9sZCBvbmUsIG5vIHRyYW5zaXRpb25cbiAqICAgICB0YWtlcyBwbGFjZSwgYnV0IHRoaXMgZnVuY3Rpb24gaXMgc3RpbGwgY2FsbGVkLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLnN3aXRjaFNjZW5lID0gZnVuY3Rpb24obmV3U2NlbmUsIG9wdHMsIGRvbmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBkb25lID0gZG9uZSB8fCBub29wO1xuXG4gIHZhciBzdGFnZSA9IHRoaXMuX3N0YWdlO1xuXG4gIHZhciBvbGRTY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcblxuICAvLyBEbyBub3RoaW5nIGlmIHRoZSB0YXJnZXQgc2NlbmUgaXMgdGhlIGN1cnJlbnQgb25lLlxuICBpZiAob2xkU2NlbmUgPT09IG5ld1NjZW5lKSB7XG4gICAgZG9uZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9zY2VuZXMuaW5kZXhPZihuZXdTY2VuZSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIHNjZW5lIGluIHZpZXdlcicpO1xuICB9XG5cbiAgLy8gQ2FuY2VsIGFuIGFscmVhZHkgb25nb2luZyB0cmFuc2l0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc3RhZ2UgY29udGFpbnNcbiAgLy8gbGF5ZXJzIGZyb20gZXhhY3RseSBvbmUgc2NlbmUgYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGJlZ2lucy5cbiAgaWYgKHRoaXMuX2NhbmNlbEN1cnJlbnRUd2Vlbikge1xuICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbigpO1xuICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgb2xkU2NlbmVMYXllcnMgPSBvbGRTY2VuZSA/IG9sZFNjZW5lLmxpc3RMYXllcnMoKSA6IFtdO1xuICB2YXIgbmV3U2NlbmVMYXllcnMgPSBuZXdTY2VuZS5saXN0TGF5ZXJzKCk7XG4gIHZhciBzdGFnZUxheWVycyA9IHN0YWdlLmxpc3RMYXllcnMoKTtcblxuICAvLyBDaGVjayB0aGF0IHRoZSBzdGFnZSBjb250YWlucyBleGFjdGx5IGFzIG1hbnkgbGF5ZXJzIGFzIHRoZSBjdXJyZW50IHNjZW5lLFxuICAvLyBhbmQgdGhhdCB0aGUgdG9wIGxheWVyIGlzIHRoZSByaWdodCBvbmUuIElmIHRoaXMgdGVzdCBmYWlscywgZWl0aGVyIHRoZXJlXG4gIC8vIGlzIGEgYnVnIG9yIHRoZSB1c2VyIHRyaWVkIHRvIG1vZGlmeSB0aGUgc3RhZ2UgY29uY3VycmVudGx5LlxuICBpZiAob2xkU2NlbmUgJiYgKChzdGFnZUxheWVycy5sZW5ndGggIT09IG9sZFNjZW5lTGF5ZXJzLmxlbmd0aCkgfHxcbiAgICAgIChzdGFnZUxheWVycy5sZW5ndGggPiAxICYmIHN0YWdlTGF5ZXJzWzBdICE9IG9sZFNjZW5lTGF5ZXJzWzBdKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIG5vdCBpbiBzeW5jIHdpdGggdmlld2VyJyk7XG4gIH1cblxuICAvLyBHZXQgdGhlIHRyYW5zaXRpb24gcGFyYW1ldGVycy5cbiAgdmFyIGR1cmF0aW9uID0gb3B0cy50cmFuc2l0aW9uRHVyYXRpb24gIT0gbnVsbCA/XG4gICAgICBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiA6IGRlZmF1bHRTd2l0Y2hEdXJhdGlvbjtcbiAgdmFyIHVwZGF0ZSA9IG9wdHMudHJhbnNpdGlvblVwZGF0ZSAhPSBudWxsID9cbiAgICAgIG9wdHMudHJhbnNpdGlvblVwZGF0ZSA6IGRlZmF1bHRUcmFuc2l0aW9uVXBkYXRlO1xuXG4gIC8vIEFkZCBuZXcgc2NlbmUgbGF5ZXJzIGludG8gdGhlIHN0YWdlIGJlZm9yZSBzdGFydGluZyB0aGUgdHJhbnNpdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTY2VuZUxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2FkZExheWVyVG9TdGFnZShuZXdTY2VuZUxheWVyc1tpXSk7XG4gIH1cblxuICAvLyBVcGRhdGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGZyYW1lLlxuICBmdW5jdGlvbiB0d2VlblVwZGF0ZSh2YWwpIHtcbiAgICB1cGRhdGUodmFsLCBuZXdTY2VuZSwgb2xkU2NlbmUpO1xuICB9XG5cbiAgLy8gT25jZSB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIG9sZCBzY2VuZSBsYXllcnMgZnJvbSB0aGUgc3RhZ2UgYW5kXG4gIC8vIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzLiBJZiB0aGUgb2xkIHNjZW5lIHdhcyBkZXN0cm95ZWQgZHVyaW5nIHRoZVxuICAvLyB0cmFuc2l0aW9uLCB0aGlzIGhhcyBhbHJlYWR5IGJlZW4gdGFrZW4gY2FyZSBvZi4gT3RoZXJ3aXNlLCB3ZSBzdGlsbCBuZWVkXG4gIC8vIHRvIGdldCBhIGZyZXNoIGNvcHkgb2YgdGhlIHNjZW5lJ3MgbGF5ZXJzLCBzaW5jZSB0aGV5IG1pZ2h0IGhhdmUgY2hhbmdlZFxuICAvLyBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gIGZ1bmN0aW9uIHR3ZWVuRG9uZSgpIHtcbiAgICBpZiAoc2VsZi5fcmVwbGFjZWRTY2VuZSkge1xuICAgICAgc2VsZi5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyhzZWxmLl9yZXBsYWNlZFNjZW5lKTtcbiAgICAgIG9sZFNjZW5lTGF5ZXJzID0gc2VsZi5fcmVwbGFjZWRTY2VuZS5saXN0TGF5ZXJzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZFNjZW5lTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuX3JlbW92ZUxheWVyRnJvbVN0YWdlKG9sZFNjZW5lTGF5ZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuX3JlcGxhY2VkU2NlbmUgPSBudWxsO1xuICAgIH1cbiAgICBzZWxmLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSBjYW5jZWxhYmxlIGZvciB0aGUgdHJhbnNpdGlvbi5cbiAgdGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuID0gdHdlZW4oZHVyYXRpb24sIHR3ZWVuVXBkYXRlLCB0d2VlbkRvbmUpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBhbmQgcmVwbGFjZWQgc2NlbmUuXG4gIHRoaXMuX2N1cnJlbnRTY2VuZSA9IG5ld1NjZW5lO1xuICB0aGlzLl9yZXBsYWNlZFNjZW5lID0gb2xkU2NlbmU7XG5cbiAgLy8gRW1pdCBzY2VuZSBhbmQgdmlldyBjaGFuZ2UgZXZlbnRzLlxuICB0aGlzLmVtaXQoJ3NjZW5lQ2hhbmdlJyk7XG4gIHRoaXMuZW1pdCgndmlld0NoYW5nZScpO1xuXG4gIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIG5ldyBzY2VuZS5cbiAgLy8gTm90ZSB0aGF0IGV2ZW50IGxpc3RlbmVycyBjYW4gb25seSBiZSByZW1vdmVkIGZyb20gdGhlIG9sZCBzY2VuZSBvbmNlIHRoZVxuICAvLyB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLCBzaW5jZSBsYXllcnMgbWlnaHQgZ2V0IGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlXG4gIC8vIGludGVyaW0uXG4gIHRoaXMuX2FkZFNjZW5lRXZlbnRMaXN0ZW5lcnMobmV3U2NlbmUpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0YXRpY0Fzc2V0ID0gcmVxdWlyZSgnLi9TdGF0aWMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBEeW5hbWljQXNzZXRcbiAqIEBpbXBsZW1lbnRzIEFzc2V0XG4gKiBAZXh0ZW5kcyBTdGF0aWNBc3NldFxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgbXV0YWJsZSB7QGxpbmsgQXNzZXR9IGNvbXBhdGlibGUgd2l0aCB7QGxpbmsgV2ViR2xTdGFnZX0gYW5kXG4gKiB7QGxpbmsgQ3NzU3RhZ2V9LlxuICpcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gZWxlbWVudCBUaGVcbiAqICAgICB1bmRlcmx5aW5nIHBpeGVsIHNvdXJjZS5cbiAqIEB0aHJvd3MgSWYgdGhlIHBpeGVsIHNvdXJjZSBpcyB1bnN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gRHluYW1pY0Fzc2V0KGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgdGhpcy5fdGltZXN0YW1wID0gMDtcbn1cblxuaW5oZXJpdHMoRHluYW1pY0Fzc2V0LCBTdGF0aWNBc3NldCk7XG5ldmVudEVtaXR0ZXIoRHluYW1pY0Fzc2V0KTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5EeW5hbWljQXNzZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbWVzdGFtcDtcbn07XG5cbkR5bmFtaWNBc3NldC5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgYXNzZXQgZGlydHksIHNpZ25hbGluZyB0aGF0IHRoZSBjb250ZW50cyBvZiB0aGUgdW5kZXJseWluZyBwaXhlbFxuICogc291cmNlIGhhdmUgY2hhbmdlZC5cbiAqXG4gKiBAdGhyb3dzIElmIHRoZSBhc3NldCBpcyBub3QgZHluYW1pYy5cbiAqL1xuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdGltZXN0YW1wKys7XG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNBc3NldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIEZsYXNoQXNzZXRcbiAqIEBpbXBsZW1lbnRzIEFzc2V0XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQW4gaW1tdXRhYmxlIHtAbGluayBBc3NldH0gY29tcGF0aWJsZSB3aXRoIHtAbGluayBGbGFzaFN0YWdlfS5cbiAqIFxuICogVGhlIGFzc2V0J3MgdW5kZXJseWluZyBwaXhlbCBzb3VyY2UgaXMgYSB1bmlxdWUgaW1hZ2UgSUQgYXNzb2NpYXRlZCB3aXRoXG4gKiBhIEZsYXNoIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZmxhc2hFbGVtZW50IFRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBGbGFzaCBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbWFnZUlkIFRoZSB1bmlxdWUgaW1hZ2UgSUQgaW5zaWRlIHRoZSBGbGFzaCBhcHBsaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gRmxhc2hBc3NldChmbGFzaEVsZW1lbnQsIGltYWdlSWQpIHtcbiAgdGhpcy5fZmxhc2hFbGVtZW50ID0gZmxhc2hFbGVtZW50O1xuICB0aGlzLl9pbWFnZUlkID0gaW1hZ2VJZDtcbn1cblxuZXZlbnRFbWl0dGVyKEZsYXNoQXNzZXQpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkZsYXNoQXNzZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZmxhc2hFbGVtZW50LnVubG9hZEltYWdlKHRoaXMuX2ltYWdlSWQpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5GbGFzaEFzc2V0LnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbWFnZUlkO1xufTtcblxuRmxhc2hBc3NldC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgLy8gTm90IGFjdHVhbGx5IHVzZWQgYW55d2hlcmUuXG4gIHJldHVybiAwO1xufTtcblxuRmxhc2hBc3NldC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIE5vdCBhY3R1YWxseSB1c2VkIGFueXdoZXJlLlxuICByZXR1cm4gMDtcbn07XG5cbkZsYXNoQXNzZXQucHJvdG90eXBlLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cbkZsYXNoQXNzZXQucHJvdG90eXBlLmlzRHluYW1pYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsYXNoQXNzZXQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi91dGlsL2dsb2JhbCcpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBwcm9wZXJ0eU1hcCA9IHtcbiAgSFRNTEltYWdlRWxlbWVudDogWyduYXR1cmFsV2lkdGgnLCAnbmF0dXJhbEhlaWdodCddLFxuICBIVE1MQ2FudmFzRWxlbWVudDogWyd3aWR0aCcsICdoZWlnaHQnXSxcbiAgSW1hZ2VCaXRtYXA6IFsnd2lkdGgnLCAnaGVpZ2h0J11cbn07XG5cbi8qKlxuICogQGNsYXNzIFN0YXRpY0Fzc2V0XG4gKiBAaW1wbGVtZW50cyBBc3NldFxuICogQGNsYXNzZGVzY1xuICpcbiAqIEFuIGltbXV0YWJsZSB7QGxpbmsgQXNzZXR9IGNvbXBhdGlibGUgd2l0aCB7QGxpbmsgV2ViR2xTdGFnZX0gYW5kXG4gKiB7QGxpbmsgQ3NzU3RhZ2V9LlxuICpcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxJbWFnZUJpdG1hcH0gZWxlbWVudCBUaGVcbiAqICAgICB1bmRlcmx5aW5nIHBpeGVsIHNvdXJjZS5cbiAqIEB0aHJvd3MgSWYgdGhlIHBpeGVsIHNvdXJjZSBpcyB1bnN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gU3RhdGljQXNzZXQoZWxlbWVudCkge1xuICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG4gIGZvciAodmFyIHR5cGUgaW4gcHJvcGVydHlNYXApIHtcbiAgICBpZiAoZ2xvYmFsW3R5cGVdICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBnbG9iYWxbdHlwZV0pIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl93aWR0aFByb3AgPSBwcm9wZXJ0eU1hcFt0eXBlXVswXTtcbiAgICAgIHRoaXMuX2hlaWdodFByb3AgPSBwcm9wZXJ0eU1hcFt0eXBlXVsxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIXN1cHBvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGl4ZWwgc291cmNlJyk7XG4gIH1cblxuICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbn1cblxuZXZlbnRFbWl0dGVyKFN0YXRpY0Fzc2V0KTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5TdGF0aWNBc3NldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5TdGF0aWNBc3NldC5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudFt0aGlzLl93aWR0aFByb3BdO1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWxlbWVudFt0aGlzLl9oZWlnaHRQcm9wXTtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5TdGF0aWNBc3NldC5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGljQXNzZXQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vdXRpbC9kZWZhdWx0cycpO1xuXG52YXIgZGVmYXVsdFNwZWVkID0gMC4xO1xudmFyIGRlZmF1bHRBY2NlbCA9IDAuMDE7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgeWF3U3BlZWQ6IGRlZmF1bHRTcGVlZCxcbiAgcGl0Y2hTcGVlZDogZGVmYXVsdFNwZWVkLFxuICBmb3ZTcGVlZDogZGVmYXVsdFNwZWVkLFxuICB5YXdBY2NlbDogZGVmYXVsdEFjY2VsLFxuICBwaXRjaEFjY2VsOiBkZWZhdWx0QWNjZWwsXG4gIGZvdkFjY2VsOiBkZWZhdWx0QWNjZWwsXG4gIHRhcmdldFBpdGNoOiAwLFxuICB0YXJnZXRGb3Y6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy55YXdTcGVlZD0wLjFdIFlhdyBtYXhpbXVtIHNwZWVkXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMucGl0Y2hTcGVlZD0wLjFdIFBpdGNoIG1heGltdW0gc3BlZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5mb3ZTcGVlZD0wLjFdIEZvdiBtYXhpbXVtIHNwZWVkXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMueWF3QWNjZWw9MC4wMV0gWWF3IGFjY2VsZXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnBpdGNoQWNjZWw9MC4wMV0gUGl0Y2ggYWNjZWxlcmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMuZm92QWNjZWw9MC4wMV0gRm92IGFjY2VsZXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnRhcmdldFBpdGNoPTBdIFZhbHVlIHRoYXQgcGl0Y2ggY29udmVyZ2VzIHRvLiBgbnVsbGAgbWVhbnMgdGhhdCB0aGUgcGl0Y2ggd2lsbCBub3QgY2hhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnRhcmdldEZvdj1udWxsXSBWYWx1ZSB0aGF0IGZvdiBjb252ZXJnZXMgdG8uIGBudWxsYCBtZWFucyB0aGF0IHRoZSBmb3Ygd2lsbCBub3QgY2hhbmdlLlxuICogQHJldHVybnMgTW92ZW1lbnQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBWaWV3ZXIjc2V0SWRsZU1vdmVtZW50fSBvciB7QGxpbmsgU2NlbmUjc3RhcnRNb3ZlbWVudH1cbiovXG5mdW5jdGlvbiBhdXRvcm90YXRlKG9wdHMpIHtcblxuICBvcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHZhciB5YXdTcGVlZCA9IG9wdHMueWF3U3BlZWQ7XG4gIHZhciBwaXRjaFNwZWVkID0gb3B0cy5waXRjaFNwZWVkO1xuICB2YXIgZm92U3BlZWQgPSBvcHRzLmZvdlNwZWVkO1xuICB2YXIgeWF3QWNjZWwgPSBvcHRzLnlhd0FjY2VsO1xuICB2YXIgcGl0Y2hBY2NlbCA9IG9wdHMucGl0Y2hBY2NlbDtcbiAgdmFyIGZvdkFjY2VsID0gb3B0cy5mb3ZBY2NlbDtcbiAgdmFyIHRhcmdldFBpdGNoID0gb3B0cy50YXJnZXRQaXRjaDtcbiAgdmFyIHRhcmdldEZvdiA9IG9wdHMudGFyZ2V0Rm92O1xuXG4gIHJldHVybiBmdW5jdGlvbiBzdGFydCgpIHtcblxuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIGxhc3RZYXdTcGVlZCA9IDA7XG4gICAgdmFyIGxhc3RQaXRjaFNwZWVkID0gMDtcbiAgICB2YXIgbGFzdEZvdlNwZWVkID0gMDtcblxuICAgIHZhciBjdXJyZW50WWF3U3BlZWQgPSAwO1xuICAgIHZhciBjdXJyZW50UGl0Y2hTcGVlZCA9IDA7XG4gICAgdmFyIGN1cnJlbnRGb3ZTcGVlZCA9IDA7XG5cbiAgICB2YXIgdGltZURlbHRhO1xuICAgIHZhciB5YXdEZWx0YTtcbiAgICB2YXIgcGl0Y2hEZWx0YTtcbiAgICB2YXIgZm92RGVsdGE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc3RlcChwYXJhbXMsIGN1cnJlbnRUaW1lKSB7XG5cbiAgICAgIHRpbWVEZWx0YSA9IChjdXJyZW50VGltZSAtIGxhc3RUaW1lKSAvIDEwMDA7XG4gICAgICBjdXJyZW50WWF3U3BlZWQgPSBNYXRoLm1pbihsYXN0WWF3U3BlZWQgKyB0aW1lRGVsdGEgKiB5YXdBY2NlbCwgeWF3U3BlZWQpO1xuICAgICAgeWF3RGVsdGEgPSBjdXJyZW50WWF3U3BlZWQgKiB0aW1lRGVsdGE7XG4gICAgICBwYXJhbXMueWF3ID0gcGFyYW1zLnlhdyArIHlhd0RlbHRhO1xuXG4gICAgICBpZiAodGFyZ2V0UGl0Y2ggIT0gbnVsbCAmJiBwYXJhbXMucGl0Y2ggIT09IHRhcmdldFBpdGNoKSB7XG4gICAgICAgIHZhciBwaXRjaFRocmVzaCA9IDAuNSAqIGxhc3RQaXRjaFNwZWVkICogbGFzdFBpdGNoU3BlZWQgLyBwaXRjaEFjY2VsO1xuICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0UGl0Y2ggLSBwYXJhbXMucGl0Y2gpID4gcGl0Y2hUaHJlc2gpIHtcbiAgICAgICAgICAvLyBBY2NlbGVyYXRpb24gcGhhc2VcbiAgICAgICAgICBjdXJyZW50UGl0Y2hTcGVlZCA9IE1hdGgubWluKGxhc3RQaXRjaFNwZWVkICsgdGltZURlbHRhICogcGl0Y2hBY2NlbCwgcGl0Y2hTcGVlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVjZWxlcmF0aW9uIHBoYXNlXG4gICAgICAgICAgY3VycmVudFBpdGNoU3BlZWQgPSBNYXRoLm1heChsYXN0UGl0Y2hTcGVlZCAtIHRpbWVEZWx0YSAqIHBpdGNoQWNjZWwsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN1cnJlbnRQaXRjaFNwZWVkIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSAoPj0gMClcbiAgICAgICAgcGl0Y2hEZWx0YSA9IGN1cnJlbnRQaXRjaFNwZWVkICogdGltZURlbHRhO1xuICAgICAgICBpZiAodGFyZ2V0UGl0Y2ggPCBwYXJhbXMucGl0Y2gpIHtcbiAgICAgICAgICBwYXJhbXMucGl0Y2ggPSBNYXRoLm1heCh0YXJnZXRQaXRjaCwgcGFyYW1zLnBpdGNoIC0gcGl0Y2hEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFBpdGNoID4gcGFyYW1zLnBpdGNoKSB7XG4gICAgICAgICAgcGFyYW1zLnBpdGNoID0gTWF0aC5taW4odGFyZ2V0UGl0Y2gsIHBhcmFtcy5waXRjaCArIHBpdGNoRGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRGb3YgIT0gbnVsbCAmJiBwYXJhbXMuZm92ICE9PSB0YXJnZXRQaXRjaCkge1xuICAgICAgICB2YXIgZm92VGhyZXNoID0gMC41ICogbGFzdEZvdlNwZWVkICogbGFzdEZvdlNwZWVkIC8gZm92QWNjZWw7XG4gICAgICAgIGlmIChNYXRoLmFicyh0YXJnZXRGb3YgLSBwYXJhbXMuZm92KSA+IGZvdlRocmVzaCkge1xuICAgICAgICAgIC8vIEFjY2VsZXJhdGlvbiBwaGFzZVxuICAgICAgICAgIGN1cnJlbnRGb3ZTcGVlZCA9IE1hdGgubWluKGxhc3RGb3ZTcGVlZCArIHRpbWVEZWx0YSAqIGZvdkFjY2VsLCBmb3ZTcGVlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVjZWxlcmF0aW9uIHBoYXNlXG4gICAgICAgICAgY3VycmVudEZvdlNwZWVkID0gTWF0aC5tYXgobGFzdEZvdlNwZWVkIC0gdGltZURlbHRhICogZm92QWNjZWwsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN1cnJlbnRGb3ZTcGVlZCBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgKD49IDApXG4gICAgICAgIGZvdkRlbHRhID0gY3VycmVudEZvdlNwZWVkICogdGltZURlbHRhO1xuICAgICAgICBpZiAodGFyZ2V0Rm92IDwgcGFyYW1zLmZvdikge1xuICAgICAgICAgIHBhcmFtcy5mb3YgPSBNYXRoLm1heCh0YXJnZXRGb3YsIHBhcmFtcy5mb3YgLSBmb3ZEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldEZvdiA+IHBhcmFtcy5mb3YpIHtcbiAgICAgICAgICBwYXJhbXMuZm92ID0gTWF0aC5taW4odGFyZ2V0Rm92LCBwYXJhbXMuZm92ICsgZm92RGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICBsYXN0WWF3U3BlZWQgPSBjdXJyZW50WWF3U3BlZWQ7XG4gICAgICBsYXN0UGl0Y2hTcGVlZCA9IGN1cnJlbnRQaXRjaFNwZWVkO1xuICAgICAgbGFzdEZvdlNwZWVkID0gY3VycmVudEZvdlNwZWVkO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuXG4gICAgfTtcblxuICB9O1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXV0b3JvdGF0ZTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb2QgPSByZXF1aXJlKCcuLi91dGlsL21vZCcpO1xuXG4vLyBBbiBMcnVNYXAgaG9sZHMgdXAgdG8gYSBtYXhpbXVtIG51bWJlciBvZiBrZXktdmFsdWUgcGFpcnMsIG9yZGVyZWQgYnkgdGhlaXJcbi8vIHRpbWUgb2YgaW5zZXJ0aW9uLiBXaGVuIHRoZSBhZGRpdGlvbiBvZiBhIGtleS12YWx1ZSBwYWlyIHdvdWxkIGNhdXNlIHRoZVxuLy8gY2FwYWNpdHkgdG8gYmUgZXhjZWVkZWQsIHRoZSBvbGRlc3Qga2V5LXZhbHVlIHBhaXIgaW4gdGhlIHNldCBpcyBldmljdGVkLlxuLy8gQXMgYSBzcGVjaWFsIGNhc2UsIGFuIExydU1hcCB3aXRoIHplcm8gY2FwYWNpdHkgYWx3YXlzIHJlamVjdHMgdGhlIGluc2VydGlvblxuLy8gb2YgYSBrZXktdmFsdWUgcGFpci5cbi8vXG4vLyBLZXlzIG11c3QgaW1wbGVtZW50IGhhc2goKSBhbmQgZXF1YWxzKCkuIE5vdGUgdGhhdCB0aGUgaW1wbGVtZW50YXRpb24gZG9lc24ndFxuLy8gY3VycmVudGx5IHVzZSBoYXNoKCksIGJ1dCBhIGZ1dHVyZSB2ZXJzaW9uIG1pZ2h0LlxuZnVuY3Rpb24gTHJ1TWFwKGNhcGFjaXR5KSB7XG4gIGlmICghaXNGaW5pdGUoY2FwYWNpdHkpIHx8IE1hdGguZmxvb3IoY2FwYWNpdHkpICE9PSBjYXBhY2l0eSB8fCBjYXBhY2l0eSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xydU1hcDogaW52YWxpZCBjYXBhY2l0eScpO1xuICB9XG4gIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG5cbiAgLy8gS2V5cyBhbmQgdmFsdWVzIGFyZSBzdG9yZWQgaW4gY2lyY3VsYXIgYXJyYXlzIG9yZGVyZWQgYnkgZGVjcmVhc2luZyBhZ2UuXG4gIC8vIFN0YXJ0IGlzIHRoZSBpbmRleCBvZiB0aGUgb2xkZXN0IGtleS92YWx1ZSBhbmQgc2l6ZSBpcyB0aGUgbnVtYmVyIG9mIHZhbGlkXG4gIC8vIGtleS92YWx1ZXM7IHRoZSByZWdpb24gY29udGFpbmluZyB2YWxpZCBrZXlzL3ZhbHVlcyBtYXkgd3JhcCBhcm91bmQuXG4gIHRoaXMuX2tleXMgPSBuZXcgQXJyYXkodGhpcy5fY2FwYWNpdHkpO1xuICB0aGlzLl92YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5fY2FwYWNpdHkpO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX3NpemUgPSAwO1xufVxuXG5McnVNYXAucHJvdG90eXBlLl9pbmRleCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIG1vZCh0aGlzLl9zdGFydCArIGksIHRoaXMuX2NhcGFjaXR5KTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgdG8gdGhlIHNwZWNpZmllZCBrZXksIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuTHJ1TWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdLZXkgPSB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGkpXTtcbiAgICBpZiAoa2V5LmVxdWFscyhleGlzdGluZ0tleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgoaSldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIEFzc29jaWF0ZXMgdGhlIHNwZWNpZmllZCB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBwb3NzaWJseSByZXBsYWNpbmcgdGhlXG4vLyBjdXJyZW50bHkgYXNzb2NpYXRlZCB2YWx1ZS4gVGhlIGtleS12YWx1ZSBwYWlyIGJlY29tZXMgdGhlIG5ld2VzdC4gSWYgdGhlIG1hcFxuLy8gaXMgYXQgY2FwYWNpdHksIHRoZSBvbGRlc3Qga2V5LXZhbHVlIHBhaXIgaXMgcmVtb3ZlZC4gUmV0dXJucyB0aGUgcmVtb3ZlZFxuLy8ga2V5LCBvciBudWxsIG90aGVyd2lzZS4gSWYgdGhlIGNhcGFjaXR5IGlzIHplcm8sIGRvZXMgbm90aGluZyBhbmQgcmV0dXJuc1xuLy8gdGhlIGtleS5cbkxydU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5fY2FwYWNpdHkgPT09IDApIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHRoaXMuZGVsKGtleSk7XG4gIHZhciBldmljdGVkS2V5ID1cbiAgICAgIHRoaXMuX3NpemUgPT09IHRoaXMuX2NhcGFjaXR5ID8gdGhpcy5fa2V5c1t0aGlzLl9pbmRleCgwKV0gOiBudWxsO1xuICB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KHRoaXMuX3NpemUpXSA9IGtleTtcbiAgdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KHRoaXMuX3NpemUpXSA9IHZhbHVlO1xuICBpZiAodGhpcy5fc2l6ZSA8IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgdGhpcy5fc2l6ZSsrO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5faW5kZXgoMSk7XG4gIH1cbiAgcmV0dXJuIGV2aWN0ZWRLZXk7XG59O1xuXG4vLyBSZW1vdmVzIHRoZSBrZXktdmFsdWUgcGFpciBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuXG4vLyBSZXR1cm5zIHRoZSByZW1vdmVkIHZhbHVlLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbkxydU1hcC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oa2V5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgaWYgKGtleS5lcXVhbHModGhpcy5fa2V5c1t0aGlzLl9pbmRleChpKV0pKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChpKV07XG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IHRoaXMuX3NpemUgLSAxOyBqKyspIHtcbiAgICAgICAgdGhpcy5fa2V5c1t0aGlzLl9pbmRleChqKV0gPSB0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGogKyAxKV07XG4gICAgICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleChqKV0gPSB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgoaiArIDEpXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJldHVybnMgd2hldGhlciB0aGVyZSBpcyBhIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cbkxydU1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgaWYgKGtleS5lcXVhbHModGhpcy5fa2V5c1t0aGlzLl9pbmRleChpKV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgbWFwLlxuTHJ1TWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuLy8gUmVtb3ZlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gdGhlIG1hcC5cbkxydU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fa2V5cy5sZW5ndGggPSAwO1xuICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgdGhpcy5fc3RhcnQgPSAwO1xuICB0aGlzLl9zaXplID0gMDtcbn07XG5cbi8vIENhbGxzIGZuKGtleSwgdmFsdWUpIGZvciBlYWNoIGl0ZW0gaW4gdGhlIG1hcCwgaW4gYW4gdW5zcGVjaWZpZWQgb3JkZXIuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgZm4gd2FzIGNhbGxlZC5cbi8vIFRoZSByZXN1bHQgaXMgdW5zcGVjaWZpZWQgaWYgdGhlIG1hcCBpcyBtdXRhdGVkIGR1cmluZyBpdGVyYXRpb24uXG5McnVNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbikge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIGZuKHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaSldLCB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgoaSldKTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTHJ1TWFwO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxuLy8gQW4gTHJ1U2V0IGhvbGRzIHVwIHRvIGEgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMsIG9yZGVyZWQgYnkgdGhlaXIgdGltZSBvZlxuLy8gaW5zZXJ0aW9uLiBXaGVuIHRoZSBhZGRpdGlvbiBvZiBhbiBlbGVtZW50IHdvdWxkIGNhdXNlIHRoZSBjYXBhY2l0eSB0byBiZVxuLy8gZXhjZWVkZWQsIHRoZSBvbGRlc3QgZWxlbWVudCBpbiB0aGUgc2V0IGlzIGV2aWN0ZWQuIEFzIGEgc3BlY2lhbCBjYXNlLCBhblxuLy8gTHJ1U2V0IHdpdGggemVybyBjYXBhY2l0eSBhbHdheXMgcmVqZWN0cyB0aGUgaW5zZXJ0aW9uIG9mIGFuIGVsZW1lbnQuXG4vL1xuLy8gRWxlbWVudHMgbXVzdCBpbXBsZW1lbnQgaGFzaCgpIGFuZCBlcXVhbHMoKS4gTm90ZSB0aGF0IHRoZSBpbXBsZW1lbnRhdGlvblxuLy8gZG9lc24ndCBjdXJyZW50bHkgdXNlIGhhc2goKSwgYnV0IGEgZnV0dXJlIHZlcnNpb24gbWlnaHQuXG5mdW5jdGlvbiBMcnVTZXQoY2FwYWNpdHkpIHtcbiAgaWYgKCFpc0Zpbml0ZShjYXBhY2l0eSkgfHwgTWF0aC5mbG9vcihjYXBhY2l0eSkgIT09IGNhcGFjaXR5IHx8IGNhcGFjaXR5IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTHJ1U2V0OiBpbnZhbGlkIGNhcGFjaXR5Jyk7XG4gIH1cbiAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcblxuICAvLyBFbGVtZW50cyBhcmUgc3RvcmVkIGluIGEgY2lyY3VsYXIgYXJyYXkgb3JkZXJlZCBieSBkZWNyZWFzaW5nIGFnZS5cbiAgLy8gU3RhcnQgaXMgdGhlIGluZGV4IG9mIHRoZSBvbGRlc3QgZWxlbWVudCBhbmQgc2l6ZSBpcyB0aGUgbnVtYmVyIG9mIHZhbGlkXG4gIC8vIGVsZW1lbnRzOyB0aGUgcmVnaW9uIGNvbnRhaW5pbmcgdmFsaWQgZWxlbWVudHMgbWF5IHdyYXAgYXJvdW5kLlxuICB0aGlzLl9lbGVtZW50cyA9IG5ldyBBcnJheSh0aGlzLl9jYXBhY2l0eSk7XG4gIHRoaXMuX3N0YXJ0ID0gMDtcbiAgdGhpcy5fc2l6ZSA9IDA7XG59XG5cbkxydVNldC5wcm90b3R5cGUuX2luZGV4ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gbW9kKHRoaXMuX3N0YXJ0ICsgaSwgdGhpcy5fY2FwYWNpdHkpO1xufTtcblxuLy8gQWRkcyBhbiBlbGVtZW50IGludG8gdGhlIHNldCwgcG9zc2libHkgcmVwbGFjaW5nIGFuIGVxdWFsIGVsZW1lbnQgYWxyZWFkeSBpblxuLy8gdGhlIHNldC4gVGhlIGVsZW1lbnQgYmVjb21lcyB0aGUgbmV3ZXN0LiBJZiB0aGUgc2V0IGlzIGF0IGNhcGFjaXR5LCB0aGVcbi8vIG9sZGVzdCBlbGVtZW50IGlzIHJlbW92ZWQuIFJldHVybnMgdGhlIHJlbW92ZWQgZWxlbWVudCBpZiBpdCBkb2VzIG5vdCBlcXVhbFxuLy8gdGhlIGluc2VydGVkIGVsZW1lbnQsIG9yIG51bGwgb3RoZXJ3aXNlLiBJZiB0aGUgY2FwYWNpdHkgaXMgemVybywgZG9lc1xuLy8gbm90aGluZyBhbmQgcmV0dXJucyB0aGUgZWxlbWVudC5cbkxydVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAodGhpcy5fY2FwYWNpdHkgPT09IDApIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgdmFyIGV2aWN0ZWRFbGVtZW50ID1cbiAgICAgIHRoaXMuX3NpemUgPT09IHRoaXMuX2NhcGFjaXR5ID8gdGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoMCldIDogbnVsbDtcbiAgdGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgodGhpcy5fc2l6ZSldID0gZWxlbWVudDtcbiAgaWYgKHRoaXMuX3NpemUgPCB0aGlzLl9jYXBhY2l0eSkge1xuICAgIHRoaXMuX3NpemUrKztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2luZGV4KDEpO1xuICB9XG4gIHJldHVybiBldmljdGVkRWxlbWVudDtcbn07XG5cbi8vIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBzZXQuXG4vLyBSZXR1cm5zIHRoZSByZW1vdmVkIGVsZW1lbnQsIG9yIG51bGwgaWYgdGhlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZC5cbkxydVNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0VsZW1lbnQgPSB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleChpKV07XG4gICAgaWYgKGVsZW1lbnQuZXF1YWxzKGV4aXN0aW5nRWxlbWVudCkpIHtcbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgdGhpcy5fc2l6ZSAtIDE7IGorKykge1xuICAgICAgICB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleChqKV0gPSB0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleChqICsgMSldO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGUgc2V0LlxuTHJ1U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgaWYgKGVsZW1lbnQuZXF1YWxzKHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGkpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNldC5cbkxydVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbi8vIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldC5cbkxydVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgdGhpcy5fc3RhcnQgPSAwO1xuICB0aGlzLl9zaXplID0gMDtcbn07XG5cbi8vIENhbGxzIGZuKGVsZW1lbnQpIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgaW4gYW4gdW5zcGVjaWZpZWQgb3JkZXIuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgZm4gd2FzIGNhbGxlZC5cbi8vIFRoZSByZXN1bHQgaXMgdW5zcGVjaWZpZWQgaWYgdGhlIHNldCBpcyBtdXRhdGVkIGR1cmluZyBpdGVyYXRpb24uXG5McnVTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbikge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIGZuKHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KGkpXSk7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExydVNldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cbnZhciBkZWZhdWx0Q2FwYWNpdHkgPSA2NDtcblxuLy8gQSBtYXAgZGF0YSBzdHJ1Y3R1cmUgZm9yIGtleXMgaW1wbGVtZW50aW5nIGhhc2goKSBhbmQgZXF1YWxzKCkgYW5kIGFyYml0cmFyeVxuLy8gdmFsdWVzLiBUaGUgY2FwYWNpdHksIGlmIGdpdmVuLCBpcyBqdXN0IGEgaGludDsgdGhlIG1hcCBpcyBhbGxvd2VkIHRvIGV4Y2VlZFxuLy8gaXQsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgc3VmZmVyLlxuZnVuY3Rpb24gTWFwKGNhcGFjaXR5KSB7XG4gIGlmIChjYXBhY2l0eSAhPSBudWxsICYmXG4gICAgICAoIWlzRmluaXRlKGNhcGFjaXR5KSB8fCBNYXRoLmZsb29yKGNhcGFjaXR5KSAhPT0gY2FwYWNpdHkgfHwgY2FwYWNpdHkgPCAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFwOiBpbnZhbGlkIGNhcGFjaXR5Jyk7XG4gIH1cbiAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eSB8fCBkZWZhdWx0Q2FwYWNpdHk7XG5cbiAgdGhpcy5fa2V5QnVja2V0cyA9IFtdO1xuICB0aGlzLl92YWxCdWNrZXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHRoaXMuX2tleUJ1Y2tldHMucHVzaChbXSk7XG4gICAgdGhpcy5fdmFsQnVja2V0cy5wdXNoKFtdKTtcbiAgfVxuICB0aGlzLl9zaXplID0gMDtcbn1cblxuLy8gUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbk1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBoID0gbW9kKGtleS5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGtleUJ1Y2tldCA9IHRoaXMuX2tleUJ1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nS2V5ID0ga2V5QnVja2V0W2ldO1xuICAgIGlmIChrZXkuZXF1YWxzKGV4aXN0aW5nS2V5KSkge1xuICAgICAgdmFyIHZhbEJ1Y2tldCA9IHRoaXMuX3ZhbEJ1Y2tldHNbaF07XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHZhbEJ1Y2tldFtpXTtcbiAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIEFzc29jaWF0ZXMgdGhlIHNwZWNpZmllZCB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBwb3NzaWJseSByZXBsYWNpbmcgdGhlXG4vLyBjdXJyZW50bHkgYXNzb2NpYXRlZCB2YWx1ZS5cbi8vIFJldHVybnMgdGhlIHJlcGxhY2VkIHZhbHVlLCBvciBudWxsIGlmIG5vIHZhbHVlIHdhcyByZXBsYWNlZC5cbk1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgdmFyIGggPSBtb2Qoa2V5Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1toXTtcbiAgdmFyIHZhbEJ1Y2tldCA9IHRoaXMuX3ZhbEJ1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nS2V5ID0ga2V5QnVja2V0W2ldO1xuICAgIGlmIChrZXkuZXF1YWxzKGV4aXN0aW5nS2V5KSkge1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB2YWxCdWNrZXRbaV07XG4gICAgICBrZXlCdWNrZXRbaV0gPSBrZXk7XG4gICAgICB2YWxCdWNrZXRbaV0gPSB2YWw7XG4gICAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgICB9XG4gIH1cbiAga2V5QnVja2V0LnB1c2goa2V5KTtcbiAgdmFsQnVja2V0LnB1c2godmFsKTtcbiAgdGhpcy5fc2l6ZSsrO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJlbW92ZXMgdGhlIGtleS12YWx1ZSBwYWlyIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cbi8vIFJldHVybnMgdGhlIHJlbW92ZWQgdmFsdWUsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuTWFwLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGggPSBtb2Qoa2V5Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1toXTtcbiAgdmFyIHZhbEJ1Y2tldCA9IHRoaXMuX3ZhbEJ1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nS2V5ID0ga2V5QnVja2V0W2ldO1xuICAgIGlmIChrZXkuZXF1YWxzKGV4aXN0aW5nS2V5KSkge1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB2YWxCdWNrZXRbaV07XG4gICAgICAvLyBTcGxpY2UgbWFudWFsbHkgdG8gYXZvaWQgQXJyYXkjc3BsaWNlIHJldHVybiB2YWx1ZSBhbGxvY2F0aW9uLlxuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBrZXlCdWNrZXQubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgIGtleUJ1Y2tldFtqXSA9IGtleUJ1Y2tldFtqKzFdO1xuICAgICAgICB2YWxCdWNrZXRbal0gPSB2YWxCdWNrZXRbaisxXTtcbiAgICAgIH1cbiAgICAgIGtleUJ1Y2tldC5sZW5ndGggPSBrZXlCdWNrZXQubGVuZ3RoIC0gMTtcbiAgICAgIHZhbEJ1Y2tldC5sZW5ndGggPSB2YWxCdWNrZXQubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJldHVybnMgd2hldGhlciB0aGVyZSBpcyBhIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cbk1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBoID0gbW9kKGtleS5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGtleUJ1Y2tldCA9IHRoaXMuX2tleUJ1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nS2V5ID0ga2V5QnVja2V0W2ldO1xuICAgIGlmIChrZXkuZXF1YWxzKGV4aXN0aW5nS2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBrZXktdmFsdWUgcGFpcnMgaW4gdGhlIG1hcC5cbk1hcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbi8vIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBwYWlycyBmcm9tIHRoZSBtYXAuXG5NYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHRoaXMuX2tleUJ1Y2tldHNbaV0ubGVuZ3RoID0gMDtcbiAgICB0aGlzLl92YWxCdWNrZXRzW2ldLmxlbmd0aCA9IDA7XG4gIH1cbiAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuXG4vLyBDYWxscyBmbihrZXksIHZhbHVlKSBmb3IgZWFjaCBrZXktdmFsdWUgcGFpciBpbiB0aGUgbWFwLCBpbiBhbiB1bnNwZWNpZmllZFxuLy8gb3JkZXIuIFJldHVybnMgdGhlIG51bWJlciBvZiB0aW1lcyBmbiB3YXMgY2FsbGVkLlxuLy8gVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiB0aGUgbWFwIGlzIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbk1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2ldO1xuICAgIHZhciB2YWxCdWNrZXQgPSB0aGlzLl92YWxCdWNrZXRzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5QnVja2V0Lmxlbmd0aDsgaisrKSB7XG4gICAgICBmbihrZXlCdWNrZXRbal0sIHZhbEJ1Y2tldFtqXSk7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cbnZhciBkZWZhdWx0Q2FwYWNpdHkgPSA2NDtcblxuLy8gQSBzZXQgZGF0YSBzdHJ1Y3R1cmUgZm9yIGVsZW1lbnRzIGltcGxlbWVudGluZyBoYXNoKCkgYW5kIGVxdWFscygpLlxuLy8gVGhlIGNhcGFjaXR5LCBpZiBnaXZlbiwgaXMganVzdCBhIGhpbnQ7IHRoZSBzZXQgaXMgYWxsb3dlZCB0byBleGNlZWQgaXQsIGJ1dFxuLy8gcGVyZm9ybWFuY2UgbWF5IHN1ZmZlci5cbmZ1bmN0aW9uIFNldChjYXBhY2l0eSkge1xuICBpZiAoY2FwYWNpdHkgIT0gbnVsbCAmJlxuICAgICAgKCFpc0Zpbml0ZShjYXBhY2l0eSkgfHwgTWF0aC5mbG9vcihjYXBhY2l0eSkgIT09IGNhcGFjaXR5IHx8IGNhcGFjaXR5IDwgMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldDogaW52YWxpZCBjYXBhY2l0eScpO1xuICB9XG4gIHRoaXMuX2NhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHkgfHwgZGVmYXVsdENhcGFjaXR5O1xuXG4gIHRoaXMuX2J1Y2tldHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdGhpcy5fYnVja2V0cy5wdXNoKFtdKTtcbiAgfVxuICB0aGlzLl9zaXplID0gMDtcbn1cblxuLy8gQWRkcyBhbiBlbGVtZW50LCByZXBsYWNpbmcgYW4gZXhpc3RpbmcgZWxlbWVudC5cbi8vIFJldHVybnMgdGhlIHJlcGxhY2VkIGVsZW1lbnQsIG9yIG51bGwgaWYgbm8gZWxlbWVudCB3YXMgcmVwbGFjZWQuXG5TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGggPSBtb2QoZWxlbWVudC5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGJ1Y2tldCA9IHRoaXMuX2J1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nRWxlbWVudCA9IGJ1Y2tldFtpXTtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHMoZXhpc3RpbmdFbGVtZW50KSkge1xuICAgICAgYnVja2V0W2ldID0gZWxlbWVudDtcbiAgICAgIHJldHVybiBleGlzdGluZ0VsZW1lbnQ7XG4gICAgfVxuICB9XG4gIGJ1Y2tldC5wdXNoKGVsZW1lbnQpO1xuICB0aGlzLl9zaXplKys7XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmVtb3ZlcyBhbiBlbGVtZW50LlxuLy8gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbGVtZW50LCBvciBudWxsIGlmIHRoZSBlbGVtZW50IHdhcyBub3QgZm91bmQuXG5TZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGggPSBtb2QoZWxlbWVudC5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGJ1Y2tldCA9IHRoaXMuX2J1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nRWxlbWVudCA9IGJ1Y2tldFtpXTtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHMoZXhpc3RpbmdFbGVtZW50KSkge1xuICAgICAgLy8gU3BsaWNlIG1hbnVhbGx5IHRvIGF2b2lkIEFycmF5I3NwbGljZSByZXR1cm4gdmFsdWUgYWxsb2NhdGlvbi5cbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgYnVja2V0Lmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICBidWNrZXRbal0gPSBidWNrZXRbaisxXTtcbiAgICAgIH1cbiAgICAgIGJ1Y2tldC5sZW5ndGggPSBidWNrZXQubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgIHJldHVybiBleGlzdGluZ0VsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhlIHNldC5cblNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgaCA9IG1vZChlbGVtZW50Lmhhc2goKSwgdGhpcy5fY2FwYWNpdHkpO1xuICB2YXIgYnVja2V0ID0gdGhpcy5fYnVja2V0c1toXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdFbGVtZW50ID0gYnVja2V0W2ldO1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhleGlzdGluZ0VsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzZXQuXG5TZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG4vLyBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzZXQuXG5TZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHRoaXMuX2J1Y2tldHNbaV0ubGVuZ3RoID0gMDtcbiAgfVxuICB0aGlzLl9zaXplID0gMDtcbn07XG5cbi8vIENhbGxzIGZuKGVsZW1lbnQpIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgaW4gYW4gdW5zcGVjaWZpZWQgb3JkZXIuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgZm4gd2FzIGNhbGxlZC5cbi8vIFRoZSByZXN1bHQgaXMgdW5zcGVjaWZpZWQgaWYgdGhlIHNldCBpcyBtdXRhdGVkIGR1cmluZyBpdGVyYXRpb24uXG5TZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbikge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB2YXIgYnVja2V0ID0gdGhpcy5fYnVja2V0c1tpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ1Y2tldC5sZW5ndGg7IGorKykge1xuICAgICAgZm4oYnVja2V0W2pdKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgV29ya1F1ZXVlID0gcmVxdWlyZSgnLi9Xb3JrUXVldWUnKTtcbnZhciBtb2QgPSByZXF1aXJlKCcuLi91dGlsL21vZCcpO1xuXG5cbmZ1bmN0aW9uIFdvcmtQb29sKG9wdHMpIHtcbiAgdGhpcy5fY29uY3VycmVuY3kgPSBvcHRzICYmIG9wdHMuY29uY3VycmVuY3kgfHwgMTtcbiAgdGhpcy5fcGF1c2VkID0gb3B0cyAmJiAhIW9wdHMucGF1c2VkIHx8IGZhbHNlO1xuXG4gIHRoaXMuX3Bvb2wgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgdGhpcy5fcG9vbC5wdXNoKG5ldyBXb3JrUXVldWUob3B0cykpO1xuICB9XG5cbiAgdGhpcy5fbmV4dCA9IDA7XG59XG5cblxuV29ya1Bvb2wucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb29sLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVuICs9IHRoaXMuX3Bvb2xbaV0ubGVuZ3RoKCk7XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn07XG5cblxuV29ya1Bvb2wucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihmbiwgY2IpIHtcbiAgdmFyIGkgPSB0aGlzLl9uZXh0O1xuICB2YXIgY2FuY2VsID0gdGhpcy5fcG9vbFtpXS5wdXNoKGZuLCBjYik7XG4gIHRoaXMuX25leHQgPSBtb2QodGhpcy5fbmV4dCArIDEsIHRoaXMuX2NvbmN1cnJlbmN5KTtcbiAgcmV0dXJuIGNhbmNlbDtcbn07XG5cblxuV29ya1Bvb2wucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgIHRoaXMuX3Bvb2xbaV0ucGF1c2UoKTtcbiAgICB9XG4gIH1cbn07XG5cblxuV29ya1Bvb2wucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICB0aGlzLl9wb29sW2ldLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtQb29sO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm93ID0gcmVxdWlyZSgnLi4vdXRpbC9ub3cnKTtcblxuXG5mdW5jdGlvbiBXb3JrVGFzayhmbiwgY2IpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuY2ZuID0gbnVsbDtcbn1cblxuXG5mdW5jdGlvbiBXb3JrUXVldWUob3B0cykge1xuICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB0aGlzLl9kZWxheSA9IG9wdHMgJiYgb3B0cy5kZWxheSB8fCAwO1xuICB0aGlzLl9wYXVzZWQgPSBvcHRzICYmICEhb3B0cy5wYXVzZWQgfHwgZmFsc2U7XG4gIHRoaXMuX2N1cnJlbnRUYXNrID0gbnVsbDtcbiAgdGhpcy5fbGFzdEZpbmlzaGVkID0gbnVsbDtcbn1cblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoO1xufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihmbiwgY2IpIHtcblxuICB2YXIgdGFzayA9IG5ldyBXb3JrVGFzayhmbiwgY2IpO1xuXG4gIHZhciBjYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzLCB0YXNrKTtcblxuICAvLyBQdXNoIHRoZSB0YXNrIGludG8gdGhlIHF1ZXVlLlxuICB0aGlzLl9xdWV1ZS5wdXNoKHRhc2spO1xuXG4gIC8vIFJ1biB0aGUgdGFzayBpZiBpZGxlLlxuICB0aGlzLl9uZXh0KCk7XG5cbiAgcmV0dXJuIGNhbmNlbDtcblxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbmV4dCgpO1xuICB9XG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24odGFzaykge1xuXG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAodGhpcy5fY3VycmVudFRhc2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtRdWV1ZTogY2FsbGVkIHN0YXJ0IHdoaWxlIHJ1bm5pbmcgdGFzaycpO1xuICB9XG5cbiAgLy8gTWFyayBxdWV1ZSBhcyBidXN5LCBzbyB0aGF0IGNvbmN1cnJlbnQgdGFza3Mgd2FpdC5cbiAgdGhpcy5fY3VycmVudFRhc2sgPSB0YXNrO1xuXG4gIC8vIEV4ZWN1dGUgdGhlIHRhc2suXG4gIHZhciBmaW5pc2ggPSB0aGlzLl9maW5pc2guYmluZCh0aGlzLCB0YXNrKTtcbiAgdGFzay5jZm4gPSB0YXNrLmZuKGZpbmlzaCk7XG5cbiAgLy8gRGV0ZWN0IHdoZW4gYSBub24tY2FuY2VsbGFibGUgZnVuY3Rpb24gaGFzIGJlZW4gcXVldWVkLlxuICBpZiAodHlwZW9mIHRhc2suY2ZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrUXVldWU6IGZ1bmN0aW9uIGlzIG5vdCBjYW5jZWxsYWJsZScpO1xuICB9XG5cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24odGFzaykge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKHRoaXMuX2N1cnJlbnRUYXNrICE9PSB0YXNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrUXVldWU6IGNhbGxlZCBmaW5pc2ggb24gd3JvbmcgdGFzaycpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdGFzayBjYWxsYmFjayBvbiB0aGUgcmV0dXJuIHZhbHVlcy5cbiAgdGFzay5jYi5hcHBseShudWxsLCBhcmdzKTtcblxuICAvLyBNYXJrIGFzIG5vdCBidXN5IGFuZCByZWNvcmQgdGFzayBmaW5pc2ggdGltZSwgdGhlbiBhZHZhbmNlIHRvIG5leHQgdGFzay5cbiAgdGhpcy5fY3VycmVudFRhc2sgPSBudWxsO1xuICB0aGlzLl9sYXN0RmluaXNoZWQgPSBub3coKTtcbiAgdGhpcy5fbmV4dCgpO1xuXG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uKHRhc2spIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRUYXNrID09PSB0YXNrKSB7XG5cbiAgICAvLyBDYW5jZWwgcnVubmluZyB0YXNrLiBCZWNhdXNlIGNhbmNlbCBwYXNzZXMgY29udHJvbCB0byB0aGUgX2ZpbmlzaFxuICAgIC8vIGNhbGxiYWNrIHdlIHBhc3NlZCBpbnRvIGZuLCB0aGUgY2xlYW51cCBsb2dpYyB3aWxsIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgdGFzay5jZm4uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIFJlbW92ZSB0YXNrIGZyb20gcXVldWUuXG4gICAgdmFyIHBvcyA9IHRoaXMuX3F1ZXVlLmluZGV4T2YodGFzayk7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UocG9zLCAxKTtcbiAgICAgIHRhc2suY2IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuXG4gIH1cblxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgIC8vIERvIG5vdCBzdGFydCB0YXNrcyB3aGlsZSBwYXVzZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAvLyBObyB0YXNrcyB0byBydW4uXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRUYXNrKSB7XG4gICAgLy8gV2lsbCBiZSBjYWxsZWQgYWdhaW4gd2hlbiB0aGUgY3VycmVudCB0YXNrIGZpbmlzaGVzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9sYXN0RmluaXNoZWQgIT0gbnVsbCkge1xuICAgIHZhciBlbGFwc2VkID0gbm93KCkgLSB0aGlzLl9sYXN0RmluaXNoZWQ7XG4gICAgdmFyIHJlbWFpbmluZyA9IHRoaXMuX2RlbGF5IC0gZWxhcHNlZDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgLy8gVG9vIHNvb24uIFJ1biBhZ2FpbiBhZnRlciB0aGUgaW50ZXItdGFzayBkZWxheS5cbiAgICAgIHNldFRpbWVvdXQodGhpcy5fbmV4dC5iaW5kKHRoaXMpLCByZW1haW5pbmcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biB0aGUgbmV4dCB0YXNrLlxuICB2YXIgdGFzayA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gIHRoaXMuX3N0YXJ0KHRhc2spO1xuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV29ya1F1ZXVlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgY29sb3IgdHJhbnNmb3JtYXRpb24ge0BsaW5rIEVmZmVjdHN9LlxuICpcbiAqIFJlZmVyZW5jZXM6XG4gKlxuICogICAtIFtDb2xvck1hdHJpeCBHdWlkZV0oaHR0cDovL2RvY3MucmFpbm1ldGVyLm5ldC90aXBzL2NvbG9ybWF0cml4LWd1aWRlKVxuICogICAtIFtNYXRyaXggT3BlcmF0aW9ucyBmb3IgSW1hZ2UgUHJvY2Vzc2luZ10oaHR0cDovL3d3dy5ncmFmaWNhb2JzY3VyYS5jb20vbWF0cml4L2luZGV4Lmh0bWwpXG4gKiAgIC0gW1dlYkdMSW1hZ2VGaWx0ZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9waG9ib3NsYWIvV2ViR0xJbWFnZUZpbHRlcilcbiAqICAgLSBbZ2xmeC5qc10oaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMpXG4gKlxuICogQG5hbWVzcGFjZSBjb2xvckVmZmVjdHNcbiAqL1xuXG4vKipcbiAqIEEgdmVjdG9yIGFuZCBtYXRyaXggY29ycmVzcG9uZGluZyB0byBhbiBpZGVudGl0eSB0cmFuc2Zvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IE9iamVjdCB0byBzdG9yZSByZXN1bHRcbiAqIEBwYXJhbSB7dmVjNH0gcmVzdWx0LmNvbG9yT2Zmc2V0IEFycmF5IHdpdGggemVyb2VzLlxuICogQHBhcmFtIHttYXQ0fSByZXN1bHQuY29sb3JNYXRyaXggSWRlbnRpdHkgbWF0cml4LlxuICpcbiAqIEBtZW1iZXJvZiBjb2xvckVmZmVjdHNcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkocmVzdWx0QXJnKSB7XG4gIHZhciByZXN1bHQgPSByZXN1bHRBcmcgfHwge307XG4gIHJlc3VsdC5jb2xvck9mZnNldCA9IHJlc3VsdC5jb2xvck9mZnNldCB8fCB2ZWM0LmNyZWF0ZSgpO1xuICByZXN1bHQuY29sb3JNYXRyaXggPSByZXN1bHQuY29sb3JNYXRyaXggfHwgbWF0NC5jcmVhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBseSBjb2xvciBlZmZlY3RzIHRvIGEgc2luZ2xlIHBpeGVsXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBwaXhlbCBWYWx1ZXMgaW4gcmFuZ2UgWzAsMV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7dmVjNH0gZWZmZWN0LmNvbG9yT2Zmc2V0XG4gKiBAcGFyYW0ge21hdDR9IGVmZmVjdC5jb2xvck1hdHJpeFxuICogQHBhcmFtIHt2ZWM0fSByZXN1bHQgT2JqZWN0IHRvIHN0b3JlIHJlc3VsdFxuICpcbiAqIEBtZW1iZXJvZiBjb2xvckVmZmVjdHNcbiAqL1xuZnVuY3Rpb24gYXBwbHlUb1BpeGVsKHBpeGVsLCBlZmZlY3QsIHJlc3VsdCkge1xuICB2ZWM0VHJhbnNmb3JtTWF0NFRyYW5zcG9zZWQocmVzdWx0LCBwaXhlbCwgZWZmZWN0LmNvbG9yTWF0cml4KTtcbiAgdmVjNC5hZGQocmVzdWx0LCByZXN1bHQsIGVmZmVjdC5jb2xvck9mZnNldCk7XG59XG5cbi8vIE9kZGx5LCB0aGUgY29sb3JUcmFuc2Zvcm0gbWF0cml4IG5lZWRzIHRvIGJlIHRyYW5zcG9zZWQgdG8gYmUgdXNlZCB3aXRoXG4vLyB2ZWM0LnRyYW5zZm9ybU1hdDQuIEl0IGlzIHN0cmFuZ2UgdGhhdCB0cmFuc2Zvcm1NYXQ0IGRvc24ndCB3b3JrIHRoZSBzYW1lXG4vLyB3YXkgYXMgbXVsdGlwbHlpbmcgb24gdGhlIHNoYWRlci5cbi8vIFRPRE86IGludmVzdGlnYXRlIHRoaXMgZnVydGhlclxuZnVuY3Rpb24gdmVjNFRyYW5zZm9ybU1hdDRUcmFuc3Bvc2VkKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsxXSAqIHkgKyBtWzJdICogeiArIG1bM10gKiB3O1xuICBvdXRbMV0gPSBtWzRdICogeCArIG1bNV0gKiB5ICsgbVs2XSAqIHogKyBtWzddICogdztcbiAgb3V0WzJdID0gbVs4XSAqIHggKyBtWzldICogeSArIG1bMTBdICogeiArIG1bMTFdICogdztcbiAgb3V0WzNdID0gbVsxMl0gKiB4ICsgbVsxM10gKiB5ICsgbVsxNF0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFwcGx5IGNvbG9yIGVmZmVjdHMgdG8gYW4gSW1hZ2VEYXRhXG4gKlxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YSBUaGlzIG9iamVjdCB3aWxsIGJlIG11dGF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7dmVjNH0gZWZmZWN0LmNvbG9yT2Zmc2V0XG4gKiBAcGFyYW0ge21hdDR9IGVmZmVjdC5jb2xvck1hdHJpeFxuICpcbiAqIEBtZW1iZXJvZiBjb2xvckVmZmVjdHNcbiAqL1xudmFyIHRtcFBpeGVsID0gdmVjNC5jcmVhdGUoKTtcbmZ1bmN0aW9uIGFwcGx5VG9JbWFnZURhdGEoaW1hZ2VEYXRhLCBlZmZlY3QpIHtcbiAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcbiAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgd2lkdGggKiBoZWlnaHQ7IGkrKykge1xuICAgIHZlYzQuc2V0KHRtcFBpeGVsLCBkYXRhW2kqNCswXS8yNTUsIGRhdGFbaSo0KzFdLzI1NSwgZGF0YVtpKjQrMl0vMjU1LCBkYXRhW2kqNCszXS8yNTUpO1xuICAgIGFwcGx5VG9QaXhlbCh0bXBQaXhlbCwgZWZmZWN0LCB0bXBQaXhlbCk7XG4gICAgZGF0YVtpKjQrMF0gPSB0bXBQaXhlbFswXSoyNTU7XG4gICAgZGF0YVtpKjQrMV0gPSB0bXBQaXhlbFsxXSoyNTU7XG4gICAgZGF0YVtpKjQrMl0gPSB0bXBQaXhlbFsyXSoyNTU7XG4gICAgZGF0YVtpKjQrM10gPSB0bXBQaXhlbFszXSoyNTU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlkZW50aXR5OiBpZGVudGl0eSxcbiAgYXBwbHlUb1BpeGVsOiBhcHBseVRvUGl4ZWwsXG4gIGFwcGx5VG9JbWFnZURhdGE6IGFwcGx5VG9JbWFnZURhdGFcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBub3cgPSByZXF1aXJlKCcuLi91dGlsL25vdycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIENvbnRyb2xDb21wb3NlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbWJpbmVzIGNoYW5nZXMgaW4gcGFyYW1ldGVycyB0cmlnZ2VyZWQgYnkgbXVsdGlwbGUge0BsaW5rIENvbnRyb2xNZXRob2R9XG4gKiBpbnN0YW5jZXMuXG4gKlxuICogQGxpc3RlbnMgQ29udHJvbE1ldGhvZCNwYXJhbWV0ZXJEeW5hbWljc1xuICovXG5mdW5jdGlvbiBDb250cm9sQ29tcG9zZXIob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB0aGlzLl9tZXRob2RzID0gW107XG5cbiAgdGhpcy5fcGFyYW1ldGVycyA9IFsgJ3gnICwneScsICdheGlzU2NhbGVkWCcsICdheGlzU2NhbGVkWScsICd6b29tJywgJ3lhdycsICdwaXRjaCcsICdyb2xsJyBdO1xuXG4gIHRoaXMuX25vdyA9IG9wdHMubm93Rm9yVGVzdGluZyB8fCBub3c7XG5cbiAgdGhpcy5fY29tcG9zZWRPZmZzZXRzID0geyB9O1xuXG4gIHRoaXMuX2NvbXBvc2VSZXR1cm4gPSB7IG9mZnNldHM6IHRoaXMuX2NvbXBvc2VkT2Zmc2V0cywgY2hhbmdpbmc6IG51bGwgfTtcbn1cblxuZXZlbnRFbWl0dGVyKENvbnRyb2xDb21wb3Nlcik7XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpZiAodGhpcy5oYXMoaW5zdGFuY2UpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGR5bmFtaWNzID0ge307XG4gIHRoaXMuX3BhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICBkeW5hbWljc1twYXJhbWV0ZXJdID0ge1xuICAgICAgZHluYW1pY3M6IG5ldyBEeW5hbWljcygpLFxuICAgICAgdGltZTogbnVsbFxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBwYXJhbWV0ZXJEeW5hbWljc0hhbmRsZXIgPSB0aGlzLl91cGRhdGVEeW5hbWljcy5iaW5kKHRoaXMsIGR5bmFtaWNzKTtcblxuICB2YXIgbWV0aG9kID0ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBkeW5hbWljczogZHluYW1pY3MsXG4gICAgcGFyYW1ldGVyRHluYW1pY3NIYW5kbGVyOiBwYXJhbWV0ZXJEeW5hbWljc0hhbmRsZXJcbiAgfTtcblxuICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCdwYXJhbWV0ZXJEeW5hbWljcycsIHBhcmFtZXRlckR5bmFtaWNzSGFuZGxlcik7XG5cbiAgdGhpcy5fbWV0aG9kcy5wdXNoKG1ldGhvZCk7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXhPZkluc3RhbmNlKGluc3RhbmNlKTtcbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgIG1ldGhvZC5pbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXJhbWV0ZXJEeW5hbWljcycsIG1ldGhvZC5wYXJhbWV0ZXJEeW5hbWljc0hhbmRsZXIpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHRoaXMuX2luZGV4T2ZJbnN0YW5jZShpbnN0YW5jZSkgPj0gMDtcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5faW5kZXhPZkluc3RhbmNlID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX21ldGhvZHNbaV0uaW5zdGFuY2UgPT09IGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0YW5jZXMucHVzaCh0aGlzLl9tZXRob2RzW2ldLmluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2VzO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLl91cGRhdGVEeW5hbWljcyA9IGZ1bmN0aW9uKHN0b3JlZER5bmFtaWNzLCBwYXJhbWV0ZXIsIGR5bmFtaWNzKSB7XG4gIHZhciBwYXJhbWV0ZXJEeW5hbWljcyA9IHN0b3JlZER5bmFtaWNzW3BhcmFtZXRlcl07XG5cbiAgaWYgKCFwYXJhbWV0ZXJEeW5hbWljcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29udHJvbCBwYXJhbWV0ZXIgXCIgKyBwYXJhbWV0ZXIpO1xuICB9XG5cbiAgdmFyIG5ld1RpbWUgPSB0aGlzLl9ub3coKTtcbiAgcGFyYW1ldGVyRHluYW1pY3MuZHluYW1pY3MudXBkYXRlKGR5bmFtaWNzLCAobmV3VGltZSAtIHBhcmFtZXRlckR5bmFtaWNzLnRpbWUpLzEwMDApO1xuICBwYXJhbWV0ZXJEeW5hbWljcy50aW1lID0gbmV3VGltZTtcblxuICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLl9yZXNldENvbXBvc2VkT2Zmc2V0cyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9jb21wb3NlZE9mZnNldHNbdGhpcy5fcGFyYW1ldGVyc1tpXV0gPSAwO1xuICB9XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUub2Zmc2V0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1ldGVyO1xuICB2YXIgY2hhbmdpbmcgPSBmYWxzZTtcblxuICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLl9ub3coKTtcblxuICB0aGlzLl9yZXNldENvbXBvc2VkT2Zmc2V0cygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZXRob2REeW5hbWljcyA9IHRoaXMuX21ldGhvZHNbaV0uZHluYW1pY3M7XG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRoaXMuX3BhcmFtZXRlcnMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHBhcmFtZXRlciA9IHRoaXMuX3BhcmFtZXRlcnNbcF07XG4gICAgICB2YXIgcGFyYW1ldGVyRHluYW1pY3MgPSBtZXRob2REeW5hbWljc1twYXJhbWV0ZXJdO1xuICAgICAgdmFyIGR5bmFtaWNzID0gcGFyYW1ldGVyRHluYW1pY3MuZHluYW1pY3M7XG5cblxuICAgICAgLy8gQWRkIG9mZnNldCB0byBjb21wb3NlZCBvZmZzZXRcbiAgICAgIGlmIChkeW5hbWljcy5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jb21wb3NlZE9mZnNldHNbcGFyYW1ldGVyXSArPSBkeW5hbWljcy5vZmZzZXQ7XG4gICAgICAgIC8vIFJlc2V0IG9mZnNldFxuICAgICAgICBkeW5hbWljcy5vZmZzZXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgb2Zmc2V0IGZyb20gdmVsb2NpdHkgYW5kIGFkZCBpdFxuICAgICAgdmFyIGVsYXBzZWQgPSAoY3VycmVudFRpbWUgLSBwYXJhbWV0ZXJEeW5hbWljcy50aW1lKS8xMDAwO1xuICAgICAgdmFyIG9mZnNldEZyb21WZWxvY2l0eSA9IGR5bmFtaWNzLm9mZnNldEZyb21WZWxvY2l0eShlbGFwc2VkKTtcblxuICAgICAgaWYob2Zmc2V0RnJvbVZlbG9jaXR5KSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2VkT2Zmc2V0c1twYXJhbWV0ZXJdICs9IG9mZnNldEZyb21WZWxvY2l0eTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHZlbG9jaXR5IG9uIGR5bmFtaWNzXG4gICAgICB2YXIgY3VycmVudFZlbG9jaXR5ID0gZHluYW1pY3MudmVsb2NpdHlBZnRlcihlbGFwc2VkKTtcbiAgICAgIGR5bmFtaWNzLnZlbG9jaXR5ID0gY3VycmVudFZlbG9jaXR5O1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBzdGlsbCBhIHZlbG9jaXR5LCBzZXQgY2hhbmdpbmdcbiAgICAgIGlmKGN1cnJlbnRWZWxvY2l0eSkge1xuICAgICAgICBjaGFuZ2luZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBhcmFtZXRlckR5bmFtaWNzLnRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jb21wb3NlUmV0dXJuLmNoYW5naW5nID0gY2hhbmdpbmc7XG4gIHJldHVybiB0aGlzLl9jb21wb3NlUmV0dXJuO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGluc3RhbmNlcyA9IHRoaXMubGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucmVtb3ZlKGluc3RhbmNlc1tpXSk7XG4gIH1cblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbENvbXBvc2VyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIGRlZmF1bHRPcHRzID0ge1xuICBhY3RpdmU6ICdtb3ZlJyxcbiAgaW5hY3RpdmU6ICdkZWZhdWx0JyxcbiAgZGlzYWJsZWQ6ICdkZWZhdWx0J1xufTtcblxuLyoqXG4gKiBAY2xhc3MgQ29udHJvbEN1cnNvclxuICogQGNsYXNzZGVzY1xuICpcbiAqIFNldHMgdGhlIENTUyBjdXJzb3Igb24gYSBET00gZWxlbWVudCBhY2NvcmRpbmcgdG8gdGhlIHN0YXRlIG9mIGFcbiAqIHtAbGluayBDb250cm9sTWV0aG9kfS5cbiAqXG4gKiBAcGFyYW0ge0NvbnRyb2xzfSBjb250cm9scyBDb250cm9scyBpbnN0YW5jZSBjb250YWluaW5nIHRoZSBjb250cm9sIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgY29udHJvbCBtZXRob2QuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIGN1cnNvciBzaG91bGQgYmUgc2V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIGNvbnRyb2wgY3Vyc29ycy4gRWFjaCBmaWVsZCBtdXN0IGJlIGEgdmFsaWQgdmFsdWVcbiAqICAgICBmb3IgdGhlIGBjdXJzb3JgIENTUyBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5hY3RpdmU9J21vdmUnXSBDdXJzb3IgdG8gc2V0IHdoZW4gdGhlIGNvbnRyb2wgbWV0aG9kXG4gKiAgICAgaXMgZW5hYmxlZCBhbmQgYWN0aXZlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmluYWN0aXZlPSdkZWZhdWx0J10gQ3Vyc29yIHRvIHNldCB3aGVuIHRoZSBjb250cm9sXG4gKiAgICAgbWV0aG9kIGlzIGVuYWJsZWQgYW5kIGluYWN0aXZlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmRpc2FibGVkPSdkZWZhdWx0J10gQ3Vyc29yIHRvIHNldCB3aGVuIHRoZSBjb250cm9sXG4gKiAgICAgbWV0aG9kIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBDb250cm9sQ3Vyc29yKGNvbnRyb2xzLCBpZCwgZWxlbWVudCwgb3B0cykge1xuICBvcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdHMpO1xuXG4gIC8vIFRPRE86IFRoaXMgY2xhc3MgbWF5IG1pc2JlaGF2ZSBpZiB0aGUgY29udHJvbCBtZXRob2QgaXMgdW5yZWdpc3RlcmVkIGFuZCBhXG4gIC8vIGRpZmZlcmVudCBjb250cm9sIG1ldGhvZCBpcyByZWdpc3RlcmVkIHVuZGVyIHRoZSBzYW1lIGlkLlxuXG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xuICB0aGlzLl9pZCA9IGlkO1xuXG4gIHRoaXMuX2F0dGFjaGVkID0gZmFsc2U7XG5cbiAgdGhpcy5fc2V0QWN0aXZlQ3Vyc29yID0gdGhpcy5fc2V0Q3Vyc29yLmJpbmQodGhpcywgb3B0cy5hY3RpdmUpO1xuICB0aGlzLl9zZXRJbmFjdGl2ZUN1cnNvciA9IHRoaXMuX3NldEN1cnNvci5iaW5kKHRoaXMsIG9wdHMuaW5hY3RpdmUpO1xuICB0aGlzLl9zZXREaXNhYmxlZEN1cnNvciA9IHRoaXMuX3NldEN1cnNvci5iaW5kKHRoaXMsIG9wdHMuZGlzYWJsZWQpO1xuICB0aGlzLl9zZXRPcmlnaW5hbEN1cnNvciA9IHRoaXMuX3NldEN1cnNvci5iaW5kKHRoaXMsIHRoaXMuX2VsZW1lbnQuc3R5bGUuY3Vyc29yKTtcblxuICB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlciA9IHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnQuYmluZCh0aGlzKTtcblxuICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdtZXRob2RFbmFibGVkJywgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdtZXRob2REaXNhYmxlZCcsIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZCcsIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZGlzYWJsZWQnLCB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG5cbiAgdGhpcy5fdXBkYXRlQXR0YWNobWVudCgpO1xufVxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZGV0YWNoRnJvbUNvbnRyb2xNZXRob2QodGhpcy5fY29udHJvbHMubWV0aG9kKHRoaXMuX2lkKSk7XG4gIHRoaXMuX3NldE9yaWdpbmFsQ3Vyc29yKCk7XG5cbiAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWV0aG9kRW5hYmxlZCcsXG4gICAgICB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21ldGhvZERpc2FibGVkJyxcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgdGhpcy5fY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5hYmxlZCcsXG4gICAgICB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc2FibGVkJyxcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5Db250cm9sQ3Vyc29yLnByb3RvdHlwZS5fdXBkYXRlQXR0YWNobWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udHJvbHMgPSB0aGlzLl9jb250cm9scztcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG4gIGlmIChjb250cm9scy5lbmFibGVkKCkgJiYgY29udHJvbHMubWV0aG9kKGlkKS5lbmFibGVkKSB7XG4gICAgdGhpcy5fYXR0YWNoVG9Db250cm9sTWV0aG9kKGNvbnRyb2xzLm1ldGhvZChpZCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RldGFjaEZyb21Db250cm9sTWV0aG9kKGNvbnRyb2xzLm1ldGhvZChpZCkpO1xuICB9XG59O1xuXG5Db250cm9sQ3Vyc29yLnByb3RvdHlwZS5fYXR0YWNoVG9Db250cm9sTWV0aG9kID0gZnVuY3Rpb24oY29udHJvbE1ldGhvZCkge1xuICBpZiAoIXRoaXMuX2F0dGFjaGVkKSB7XG4gICAgY29udHJvbE1ldGhvZC5pbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCdhY3RpdmUnLCB0aGlzLl9zZXRBY3RpdmVDdXJzb3IpO1xuICAgIGNvbnRyb2xNZXRob2QuaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCB0aGlzLl9zZXRJbmFjdGl2ZUN1cnNvcik7XG5cbiAgICBpZiAoY29udHJvbE1ldGhvZC5hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUN1cnNvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRJbmFjdGl2ZUN1cnNvcigpO1xuICAgIH1cblxuICAgIHRoaXMuX2F0dGFjaGVkID0gdHJ1ZTtcbiAgfVxufTtcblxuQ29udHJvbEN1cnNvci5wcm90b3R5cGUuX2RldGFjaEZyb21Db250cm9sTWV0aG9kID0gZnVuY3Rpb24oY29udHJvbE1ldGhvZCkge1xuICBpZiAodGhpcy5fYXR0YWNoZWQpIHtcbiAgICBjb250cm9sTWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FjdGl2ZScsIHRoaXMuX3NldEFjdGl2ZUN1cnNvcik7XG4gICAgY29udHJvbE1ldGhvZC5pbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdpbmFjdGl2ZScsIHRoaXMuX3NldEluYWN0aXZlQ3Vyc29yKTtcblxuICAgIHRoaXMuX3NldERpc2FibGVkQ3Vyc29yKCk7XG5cbiAgICB0aGlzLl9hdHRhY2hlZCA9IGZhbHNlO1xuICB9XG59O1xuXG5Db250cm9sQ3Vyc29yLnByb3RvdHlwZS5fc2V0Q3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gIHRoaXMuX2VsZW1lbnQuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2xDdXJzb3I7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBDb21wb3NlciA9IHJlcXVpcmUoJy4vQ29tcG9zZXInKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVidWcgPSB0eXBlb2YgTUFSWklQQU5PREVCVUcgIT09ICd1bmRlZmluZWQnICYmIE1BUlpJUEFOT0RFQlVHLmNvbnRyb2xzO1xuXG4vKipcbiAqIEBjbGFzcyBDb250cm9sc1xuICogQGNsYXNzZGVzY1xuICpcbiAqIFNldCBvZiBjb250cm9scyB3aGljaCBhZmZlY3QgYSB2aWV3IChlLmcuIGtleWJvYXJkLCB0b3VjaClcbiAqXG4gKiB7QGxpbmsgQ29udHJvbE1ldGhvZH0gaW5zdGFuY2VzIGNhbiBiZSByZWdpc3RlcmVkIG9uIHRoaXMgY2xhc3MuIFRoZSBtZXRob2RzXG4gKiBhcmUgdGhlbiBjb21iaW5lZCB0byBjYWxjdWxhdGUgdGhlIGZpbmFsIHBhcmFtZXRlcnMgdG8gY2hhbmdlIHRoZSB7QGxpbmsgVmlld30uXG4gKlxuICogQ29udHJvbHMgaXMgYXR0YWNoZWQgdG8gYSB7QGxpbmsgUmVuZGVyTG9vcH0uIEN1cnJlbnRseSBpdCBhZmZlY3RzIHRoZVxuICoge0BsaW5rIHZpZXd9IG9mIGFsbCB7QGxpbmsgTGF5ZXJ9IG9uIHRoZSB7QGxpbmsgU3RhZ2V9IG9mIHRoZVxuICoge0BsaW5rIFJlbmRlckxvb3B9IGl0IGlzIGF0dGFjaGVkIHRvLiBBIG1vcmUgZmxleGlibGUgQVBJIG1heSBiZSBwcm92aWRlZFxuICogaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBUaGUgQ29udHJvbE1ldGhvZCBpbnN0YW5jZXMgYXJlIHJlZ2lzdGVyZWQgd2l0aCBhbiBpZCBhbmQgbWF5IGJlIGVuYWJsZWQsXG4gKiBkaXNhYmxlZCBhbmQgdW5yZWdpc3RlcmVkIHVzaW5nIHRoYXQgaWQuIFRoZSB3aG9sZSBDb250cm9sIGNhbiBhbHNvIGJlXG4gKiBlbmFibGVkIG9yIGRpc2FibGVkLlxuICpcbiAqL1xuZnVuY3Rpb24gQ29udHJvbHMob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB0aGlzLl9tZXRob2RzID0ge307XG4gIHRoaXMuX21ldGhvZEdyb3VwcyA9IHt9O1xuICB0aGlzLl9jb21wb3NlciA9IG5ldyBDb21wb3NlcigpO1xuXG4gIC8vIFdoZXRoZXIgdGhlIGNvbnRyb2xzIGFyZSBlbmFibGVkLlxuICB0aGlzLl9lbmFibGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVkKSA/ICEhb3B0cy5lbmFibGVkIDogdHJ1ZTtcblxuICAvLyBIb3cgbWFueSBjb250cm9sIG1ldGhvZHMgYXJlIGVuYWJsZWQgYW5kIGluIHRoZSBhY3RpdmUgc3RhdGUuXG4gIHRoaXMuX2FjdGl2ZUNvdW50ID0gMDtcblxuICB0aGlzLnVwZGF0ZWRWaWV3c18gPSBbXTtcblxuICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AgPSBudWxsO1xufVxuXG5ldmVudEVtaXR0ZXIoQ29udHJvbHMpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGV0YWNoKCk7XG4gIHRoaXMuX2NvbXBvc2VyLmRlc3Ryb3koKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0NvbnRyb2xNZXRob2RbXX0gTGlzdCBvZiByZWdpc3RlcmVkIEB7bGluayBDb250cm9sTWV0aG9kIGluc3RhbmNlc31cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLm1ldGhvZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tZXRob2RzKSB7XG4gICAgb2JqW2lkXSA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHJldHVybiB7Q29udHJvbE1ldGhvZH1cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiB0aGlzLl9tZXRob2RzW2lkXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0NvbnRyb2xNZXRob2R9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmFibGU9ZmFsc2VdXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5yZWdpc3Rlck1ldGhvZCA9IGZ1bmN0aW9uKGlkLCBpbnN0YW5jZSwgZW5hYmxlKSB7XG4gIGlmICh0aGlzLl9tZXRob2RzW2lkXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udHJvbCBtZXRob2QgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggaWQgJyArIGlkKTtcbiAgfVxuXG4gIHRoaXMuX21ldGhvZHNbaWRdID0ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGFjdGl2ZUhhbmRsZXI6IHRoaXMuX2hhbmRsZUFjdGl2ZS5iaW5kKHRoaXMsIGlkKSxcbiAgICBpbmFjdGl2ZUhhbmRsZXI6IHRoaXMuX2hhbmRsZUluYWN0aXZlLmJpbmQodGhpcywgaWQpXG4gIH07XG5cbiAgaWYoZW5hYmxlKSB7XG4gICAgdGhpcy5lbmFibGVNZXRob2QoaWQsIGluc3RhbmNlKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5Db250cm9scy5wcm90b3R5cGUudW5yZWdpc3Rlck1ldGhvZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRyb2wgbWV0aG9kIHJlZ2lzdGVyZWQgd2l0aCBpZCAnICsgaWQpO1xuICB9XG4gIGlmIChtZXRob2QuZW5hYmxlZCkge1xuICAgIHRoaXMuZGlzYWJsZU1ldGhvZChpZCk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX21ldGhvZHNbaWRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmVuYWJsZU1ldGhvZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRyb2wgbWV0aG9kIHJlZ2lzdGVyZWQgd2l0aCBpZCAnICsgaWQpO1xuICB9XG4gIGlmIChtZXRob2QuZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZXRob2QuZW5hYmxlZCA9IHRydWU7XG4gIGlmIChtZXRob2QuYWN0aXZlKSB7XG4gICAgdGhpcy5faW5jcmVtZW50QWN0aXZlQ291bnQoKTtcbiAgfVxuICB0aGlzLl9saXN0ZW4oaWQpO1xuICB0aGlzLl91cGRhdGVDb21wb3NlcigpO1xuICB0aGlzLmVtaXQoJ21ldGhvZEVuYWJsZWQnLCBpZCk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5kaXNhYmxlTWV0aG9kID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udHJvbCBtZXRob2QgcmVnaXN0ZXJlZCB3aXRoIGlkICcgKyBpZCk7XG4gIH1cbiAgaWYgKCFtZXRob2QuZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZXRob2QuZW5hYmxlZCA9IGZhbHNlO1xuICBpZiAobWV0aG9kLmFjdGl2ZSkge1xuICAgIHRoaXMuX2RlY3JlbWVudEFjdGl2ZUNvdW50KCk7XG4gIH1cbiAgdGhpcy5fdW5saXN0ZW4oaWQpO1xuICB0aGlzLl91cGRhdGVDb21wb3NlcigpO1xuICB0aGlzLmVtaXQoJ21ldGhvZERpc2FibGVkJywgaWQpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG1ldGhvZCBncm91cCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbW9yZSBjb252ZW5pZW50bHkgZW5hYmxlIG9yXG4gKiBkaXNhYmxlIHNldmVyYWwgY29udHJvbCBtZXRob2RzIGF0IG9uY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBtZXRob2RJZHNcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmFkZE1ldGhvZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXBJZCwgbWV0aG9kSWRzKSB7XG4gIHRoaXMuX21ldGhvZEdyb3Vwc1tncm91cElkXSA9IG1ldGhvZElkcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBJZFxuICovXG5Db250cm9scy5wcm90b3R5cGUucmVtb3ZlTWV0aG9kR3JvdXAgPSBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgdGhpcy5fbWV0aG9kR3JvdXBzW2lkXTtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtDb250cm9sTWV0aG9kR3JvdXBbXX0gTGlzdCBvZiBjb250cm9sIG1ldGhvZCBncm91cHNcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLm1ldGhvZEdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGlkIGluIHRoaXMuX21ldGhvZEdyb3Vwcykge1xuICAgIG9ialtpZF0gPSB0aGlzLl9tZXRob2RHcm91cHNbaWRdO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhbGwgdGhlIGNvbnRyb2wgbWV0aG9kcyBpbiB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5lbmFibGVNZXRob2RHcm91cCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fbWV0aG9kR3JvdXBzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZElkKSB7XG4gICAgc2VsZi5lbmFibGVNZXRob2QobWV0aG9kSWQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBhbGwgdGhlIGNvbnRyb2wgbWV0aG9kcyBpbiB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5kaXNhYmxlTWV0aG9kR3JvdXAgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX21ldGhvZEdyb3Vwc1tpZF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2RJZCkge1xuICAgIHNlbGYuZGlzYWJsZU1ldGhvZChtZXRob2RJZCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5Db250cm9scy5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbn07XG5cbi8qKlxuICogRW5hYmxlcyB0aGUgY29udHJvbHNcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMuX2FjdGl2ZUNvdW50ID4gMCkge1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIH1cbiAgdGhpcy5lbWl0KCdlbmFibGVkJyk7XG4gIHRoaXMuX3VwZGF0ZUNvbXBvc2VyKCk7XG59O1xuXG5cbi8qKlxuICogRGlzYWJsZXMgdGhlIGNvbnRyb2xzXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gIGlmICh0aGlzLl9hY3RpdmVDb3VudCA+IDApIHtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbiAgdGhpcy5lbWl0KCdkaXNhYmxlZCcpO1xuICB0aGlzLl91cGRhdGVDb21wb3NlcigpO1xufTtcblxuXG5cbi8qKlxuICogQXR0YWNoZXMgdGhlIGNvbnRyb2xzIHRvIGEge0BsaW5rIFJlbmRlckxvb3B9LiBUaGUgUmVuZGVyTG9vcCB3aWxsIGJlIHdva2VuXG4gKiB1cCB3aGVuIHRoZSBjb250cm9scyBhcmUgYWN0aXZhdGVkXG4gKlxuICogQHBhcmFtIHtSZW5kZXJMb29wfVxuICovXG5Db250cm9scy5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24ocmVuZGVyTG9vcCkge1xuICBpZiAodGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgfVxuXG4gIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XG4gIHRoaXMuX2JlZm9yZVJlbmRlckhhbmRsZXIgPSB0aGlzLl91cGRhdGVWaWV3c1dpdGhDb250cm9scy5iaW5kKHRoaXMpO1xuICB0aGlzLl9jaGFuZ2VIYW5kbGVyID0gcmVuZGVyTG9vcC5yZW5kZXJPbk5leHRGcmFtZS5iaW5kKHJlbmRlckxvb3ApO1xuXG4gIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVSZW5kZXInLCB0aGlzLl9iZWZvcmVSZW5kZXJIYW5kbGVyKTtcbiAgdGhpcy5fY29tcG9zZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fY2hhbmdlSGFuZGxlcik7XG59O1xuXG4vKipcbiAqIERldGFjaGVzIHRoZSBjb250cm9sc1xuICovXG5Db250cm9scy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZVJlbmRlcicsIHRoaXMuX2JlZm9yZVJlbmRlckhhbmRsZXIpO1xuICB0aGlzLl9jb21wb3Nlci5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9jaGFuZ2VIYW5kbGVyKTtcblxuICB0aGlzLl9iZWZvcmVSZW5kZXJIYW5kbGVyID0gbnVsbDtcbiAgdGhpcy5fY2hhbmdlSGFuZGxlciA9IG51bGw7XG4gIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmF0dGFjaGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AgIT0gbnVsbDtcbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9saXN0ZW4gPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbWV0aG9kIGlkJyk7XG4gIH1cbiAgbWV0aG9kLmluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2ZScsIG1ldGhvZC5hY3RpdmVIYW5kbGVyKTtcbiAgbWV0aG9kLmluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2luYWN0aXZlJywgbWV0aG9kLmluYWN0aXZlSGFuZGxlcik7XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fdW5saXN0ZW4gPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbWV0aG9kIGlkJyk7XG4gIH1cbiAgbWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FjdGl2ZScsIG1ldGhvZC5hY3RpdmVIYW5kbGVyKTtcbiAgbWV0aG9kLmluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2luYWN0aXZlJywgbWV0aG9kLmluYWN0aXZlSGFuZGxlcik7XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5faGFuZGxlQWN0aXZlID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIG1ldGhvZCBpZCcpO1xuICB9XG4gIGlmICghbWV0aG9kLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgcmVjZWl2ZSBldmVudCBmcm9tIGRpc2FibGVkIGNvbnRyb2wgbWV0aG9kJyk7XG4gIH1cbiAgaWYgKCFtZXRob2QuYWN0aXZlKSB7XG4gICAgbWV0aG9kLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5faW5jcmVtZW50QWN0aXZlQ291bnQoKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2hhbmRsZUluYWN0aXZlID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIG1ldGhvZCBpZCcpO1xuICB9XG4gIGlmICghbWV0aG9kLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgcmVjZWl2ZSBldmVudCBmcm9tIGRpc2FibGVkIGNvbnRyb2wgbWV0aG9kJyk7XG4gIH1cbiAgaWYgKG1ldGhvZC5hY3RpdmUpIHtcbiAgICBtZXRob2QuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fZGVjcmVtZW50QWN0aXZlQ291bnQoKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2luY3JlbWVudEFjdGl2ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2FjdGl2ZUNvdW50Kys7XG4gIGlmIChkZWJ1Zykge1xuICAgIHRoaXMuX2NoZWNrQWN0aXZlQ291bnQoKTtcbiAgfVxuICBpZiAodGhpcy5fZW5hYmxlZCAmJiB0aGlzLl9hY3RpdmVDb3VudCA9PT0gMSkge1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIH1cbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9kZWNyZW1lbnRBY3RpdmVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9hY3RpdmVDb3VudC0tO1xuICBpZiAoZGVidWcpIHtcbiAgICB0aGlzLl9jaGVja0FjdGl2ZUNvdW50KCk7XG4gIH1cbiAgaWYgKHRoaXMuX2VuYWJsZWQgJiYgdGhpcy5fYWN0aXZlQ291bnQgPT09IDApIHtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9jaGVja0FjdGl2ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGlkIGluIHRoaXMuX21ldGhvZHMpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gICAgaWYgKG1ldGhvZC5lbmFibGVkICYmIG1ldGhvZC5hY3RpdmUpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIGlmIChjb3VudCAhPSB0aGlzLl9hY3RpdmVDb3VudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIGNvbnRyb2wgc3RhdGUnKTtcbiAgfVxufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX3VwZGF0ZUNvbXBvc2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb21wb3NlciA9IHRoaXMuX2NvbXBvc2VyO1xuXG4gIGZvciAodmFyIGlkIGluIHRoaXMuX21ldGhvZHMpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gICAgdmFyIGVuYWJsZWQgPSB0aGlzLl9lbmFibGVkICYmIG1ldGhvZC5lbmFibGVkO1xuXG4gICAgaWYgKGVuYWJsZWQgJiYgIWNvbXBvc2VyLmhhcyhtZXRob2QuaW5zdGFuY2UpKSB7XG4gICAgICBjb21wb3Nlci5hZGQobWV0aG9kLmluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkICYmIGNvbXBvc2VyLmhhcyhtZXRob2QuaW5zdGFuY2UpKSB7XG4gICAgICBjb21wb3Nlci5yZW1vdmUobWV0aG9kLmluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl91cGRhdGVWaWV3c1dpdGhDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udHJvbERhdGEgPSB0aGlzLl9jb21wb3Nlci5vZmZzZXRzKCk7XG4gIGlmIChjb250cm9sRGF0YS5jaGFuZ2luZykge1xuICAgIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcC5yZW5kZXJPbk5leHRGcmFtZSgpO1xuICB9XG5cbiAgLy8gVXBkYXRlIGVhY2ggdmlldyBhdCBtb3N0IG9uY2UsIGV2ZW4gd2hlbiBzaGFyZWQgYnkgbXVsdGlwbGUgbGF5ZXJzLlxuICAvLyBUaGUgbnVtYmVyIG9mIHZpZXdzIGlzIGV4cGVjdGVkIHRvIGJlIHNtYWxsLCBzbyB1c2UgYW4gYXJyYXkgdG8ga2VlcCB0cmFjay5cbiAgdGhpcy51cGRhdGVkVmlld3NfLmxlbmd0aCA9IDA7XG5cbiAgdmFyIGxheWVycyA9IHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcC5zdGFnZSgpLmxpc3RMYXllcnMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmlldyA9IGxheWVyc1tpXS52aWV3KCk7XG4gICAgaWYgKHRoaXMudXBkYXRlZFZpZXdzXy5pbmRleE9mKHZpZXcpIDwgMCkge1xuICAgICAgbGF5ZXJzW2ldLnZpZXcoKS51cGRhdGVXaXRoQ29udHJvbFBhcmFtZXRlcnMoY29udHJvbERhdGEub2Zmc2V0cyk7XG4gICAgICB0aGlzLnVwZGF0ZWRWaWV3c18ucHVzaCh2aWV3KTtcbiAgICB9XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb250cm9scztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIEhhbW1lckdlc3R1cmVzID0gcmVxdWlyZSgnLi9IYW1tZXJHZXN0dXJlcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vdXRpbC9kZWZhdWx0cycpO1xudmFyIG1heEZyaWN0aW9uID0gcmVxdWlyZSgnLi91dGlsJykubWF4RnJpY3Rpb247XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmcmljdGlvbjogNixcbiAgbWF4RnJpY3Rpb25UaW1lOiAwLjNcbn07XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBNQVJaSVBBTk9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgTUFSWklQQU5PREVCVUcuY29udHJvbHM7XG5cbi8qKlxuICogQGNsYXNzIERyYWdDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29udHJvbHMgdGhlIHZpZXcgYnkgY2xpY2tpbmcvdGFwcGluZyBhbmQgZHJhZ2dpbmcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbGlzdGVuIGZvciBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlclR5cGUgV2hpY2ggSGFtbWVyLmpzIHBvaW50ZXIgdHlwZSB0byB1c2UgKGUuZy5cbiAqIGBtb3VzZWAgb3IgYHRvdWNoYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZnJpY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLm1heEZyaWN0aW9uVGltZVxuICovXG5mdW5jdGlvbiBEcmFnQ29udHJvbE1ldGhvZChlbGVtZW50LCBwb2ludGVyVHlwZSwgb3B0cykge1xuICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICB0aGlzLl9vcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuX3N0YXJ0RXZlbnQgPSBudWxsO1xuICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gIHRoaXMuX2R5bmFtaWNzID0ge1xuICAgIHg6IG5ldyBEeW5hbWljcygpLFxuICAgIHk6IG5ldyBEeW5hbWljcygpXG4gIH07XG5cbiAgdGhpcy5faGFtbWVyID0gSGFtbWVyR2VzdHVyZXMuZ2V0KGVsZW1lbnQsIHBvaW50ZXJUeXBlKTtcblxuICB0aGlzLl9oYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgdGhpcy5faGFuZGxlSGFtbWVyRXZlbnQuYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX2hhbmRsZVN0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5jYW5jZWwnLCB0aGlzLl9oYW5kbGVFbmQuYmluZCh0aGlzKSk7XG5cbn1cblxuZXZlbnRFbWl0dGVyKERyYWdDb250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUhhbW1lckV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICBpZiAoZS5pc0ZpcnN0KSB7XG4gICAgaWYgKGRlYnVnICYmIHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnQ29udHJvbE1ldGhvZCBhY3RpdmUgZGV0ZWN0ZWQgd2hlbiBhbHJlYWR5IGFjdGl2ZScpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIH1cbiAgaWYgKGUuaXNGaW5hbCkge1xuICAgIGlmIChkZWJ1ZyAmJiAhdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdDb250cm9sTWV0aG9kIGluYWN0aXZlIGRldGVjdGVkIHdoZW4gYWxyZWFkeSBpbmFjdGl2ZScpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgdGhpcyBldmVudCBmcm9tIGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cywgY2F1c2luZ1xuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yIG9uIENocm9tZS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuX3N0YXJ0RXZlbnQgPSBlO1xufTtcblxuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgdGhpcyBldmVudCBmcm9tIGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cywgY2F1c2luZ1xuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yIG9uIENocm9tZS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGlmICh0aGlzLl9zdGFydEV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlRHluYW1pY3NNb3ZlKGUpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFgnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ2F4aXNTY2FsZWRZJywgdGhpcy5fZHluYW1pY3MueSk7XG4gIH1cbn07XG5cblxuRHJhZ0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVFbmQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgdGhpcyBldmVudCBmcm9tIGRyYWdnaW5nIG90aGVyIERPTSBlbGVtZW50cywgY2F1c2luZ1xuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yIG9uIENocm9tZS5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGlmICh0aGlzLl9zdGFydEV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlRHluYW1pY3NSZWxlYXNlKGUpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFgnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ2F4aXNTY2FsZWRZJywgdGhpcy5fZHluYW1pY3MueSk7XG4gIH1cblxuICB0aGlzLl9zdGFydEV2ZW50ID0gZmFsc2U7XG4gIHRoaXMuX2xhc3RFdmVudCA9IGZhbHNlO1xufTtcblxuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZUR5bmFtaWNzTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHggPSBlLmRlbHRhWDtcbiAgdmFyIHkgPSBlLmRlbHRhWTtcblxuICAvLyBXaGVuIGEgc2Vjb25kIGZpbmdlciB0b3VjaGVzIHRoZSBzY3JlZW4sIHBhbnN0YXJ0IHNvbWV0aW1lcyBoYXMgYSBsYXJnZVxuICAvLyBvZmZzZXQgYXQgc3RhcnQ7IHN1YnRyYWN0IHRoYXQgb2Zmc2V0IHRvIHByZXZlbnQgYSBzdWRkZW4ganVtcC5cbiAgdmFyIGV2ZW50VG9TdWJ0cmFjdCA9IHRoaXMuX2xhc3RFdmVudCB8fCB0aGlzLl9zdGFydEV2ZW50O1xuXG4gIGlmIChldmVudFRvU3VidHJhY3QpIHtcbiAgICB4IC09IGV2ZW50VG9TdWJ0cmFjdC5kZWx0YVg7XG4gICAgeSAtPSBldmVudFRvU3VidHJhY3QuZGVsdGFZO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRSZWN0ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHdpZHRoID0gZWxlbWVudFJlY3QucmlnaHQgLSBlbGVtZW50UmVjdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudFJlY3QudG9wO1xuXG4gIHggLz0gd2lkdGg7XG4gIHkgLz0gaGVpZ2h0O1xuXG4gIHRoaXMuX2R5bmFtaWNzLngucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueS5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy54Lm9mZnNldCA9IC14O1xuICB0aGlzLl9keW5hbWljcy55Lm9mZnNldCA9IC15O1xuXG4gIHRoaXMuX2xhc3RFdmVudCA9IGU7XG59O1xuXG5cbnZhciB0bXBSZWxlYXNlRnJpY3Rpb24gPSBbIG51bGwsIG51bGwgXTtcbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRHluYW1pY3NSZWxlYXNlID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZWxlbWVudFJlY3QgPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgd2lkdGggPSBlbGVtZW50UmVjdC5yaWdodCAtIGVsZW1lbnRSZWN0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50UmVjdC5ib3R0b20gLSBlbGVtZW50UmVjdC50b3A7XG5cbiAgdmFyIHggPSAxMDAwICogZS52ZWxvY2l0eVggLyB3aWR0aDtcbiAgdmFyIHkgPSAxMDAwICogZS52ZWxvY2l0eVkgLyBoZWlnaHQ7XG5cbiAgdGhpcy5fZHluYW1pY3MueC5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy55LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLngudmVsb2NpdHkgPSB4O1xuICB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5ID0geTtcblxuICBtYXhGcmljdGlvbih0aGlzLl9vcHRzLmZyaWN0aW9uLCB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5LCB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5LCB0aGlzLl9vcHRzLm1heEZyaWN0aW9uVGltZSwgdG1wUmVsZWFzZUZyaWN0aW9uKTtcbiAgdGhpcy5fZHluYW1pY3MueC5mcmljdGlvbiA9IHRtcFJlbGVhc2VGcmljdGlvblswXTtcbiAgdGhpcy5fZHluYW1pY3MueS5mcmljdGlvbiA9IHRtcFJlbGVhc2VGcmljdGlvblsxXTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnQ29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgRHluYW1pY3NcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBSZXByZXNlbnRzIGhvdyBhIGNvbnRyb2wgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZWQgaW4gdGhlIGV2ZW50cyBlbWl0dGVkIGJ5XG4gKiB7QGxpbmsgQ29udHJvbE1ldGhvZH0uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCBQYXJhbWV0ZXIgY2hhbmdlZCBieSBhIGZpeGVkIHZhbHVlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVsb2NpdHkgUGFyYW1ldGVyIGlzIGNoYW5naW5nIGF0IHRoaXMgdmVsb2NpdHlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmljdGlvbiBUaGUgdmVsb2NpdHkgd2lsbCBkZWNyZWFzZSBhdCB0aGlzIHJhdGVcbiAqL1xuZnVuY3Rpb24gRHluYW1pY3MoKSB7XG4gIHRoaXMudmVsb2NpdHkgPSBudWxsO1xuICB0aGlzLmZyaWN0aW9uID0gbnVsbDtcbiAgdGhpcy5vZmZzZXQgPSBudWxsO1xufVxuXG5EeW5hbWljcy5lcXVhbHMgPSBmdW5jdGlvbihkMSwgZDIpIHtcbiAgcmV0dXJuIGQxLnZlbG9jaXR5ID09PSBkMi52ZWxvY2l0eSAmJiBkMS5mcmljdGlvbiA9PT0gZDIuZnJpY3Rpb24gJiYgZDEub2Zmc2V0ID09PSBkMi5vZmZzZXQ7XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuIER5bmFtaWNzLmVxdWFscyh0aGlzLCBvdGhlcik7XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3RoZXIsIGVsYXBzZWQpIHtcbiAgaWYgKG90aGVyLm9mZnNldCkge1xuICAgIC8vIElmIG90aGVyIGhhcyBhbiBvZmZzZXQsIG1ha2UgdGhpcy5vZmZzZXQgYSBudW1iZXIgaW5zdGVhZCBvZiBudWxsXG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldCB8fCAwO1xuICAgIHRoaXMub2Zmc2V0ICs9IG90aGVyLm9mZnNldDtcbiAgfVxuXG4gIHZhciBvZmZzZXRGcm9tVmVsb2NpdHkgPSB0aGlzLm9mZnNldEZyb21WZWxvY2l0eShlbGFwc2VkKTtcbiAgaWYgKG9mZnNldEZyb21WZWxvY2l0eSkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIG9mZnNldCB0byBhZGQgZnJvbSB0aGUgdmVsb2NpdHksIG1ha2UgdGhpcyBvZmZzZXQgYSBudW1iZXIgaW5zdGVhZCBvZiBudWxsXG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldCB8fCAwO1xuICAgIHRoaXMub2Zmc2V0ICs9IG9mZnNldEZyb21WZWxvY2l0eTtcbiAgfVxuXG4gIHRoaXMudmVsb2NpdHkgPSBvdGhlci52ZWxvY2l0eTtcbiAgdGhpcy5mcmljdGlvbiA9IG90aGVyLmZyaWN0aW9uO1xufTtcblxuRHluYW1pY3MucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVsb2NpdHkgPSBudWxsO1xuICB0aGlzLmZyaWN0aW9uID0gbnVsbDtcbiAgdGhpcy5vZmZzZXQgPSBudWxsO1xufTtcblxuXG5EeW5hbWljcy5wcm90b3R5cGUudmVsb2NpdHlBZnRlciA9IGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgaWYgKCF0aGlzLnZlbG9jaXR5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuZnJpY3Rpb24pIHtcbiAgICByZXR1cm4gZGVjcmVhc2VBYnModGhpcy52ZWxvY2l0eSwgdGhpcy5mcmljdGlvbiAqZWxhcHNlZCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUub2Zmc2V0RnJvbVZlbG9jaXR5ID0gZnVuY3Rpb24oZWxhcHNlZCkge1xuICBlbGFwc2VkID0gTWF0aC5taW4oZWxhcHNlZCwgdGhpcy5udWxsVmVsb2NpdHlUaW1lKCkpO1xuXG4gIHZhciB2ZWxvY2l0eUVuZCA9IHRoaXMudmVsb2NpdHlBZnRlcihlbGFwc2VkKTtcbiAgdmFyIGF2ZXJhZ2VWZWxvY2l0eSA9ICh0aGlzLnZlbG9jaXR5ICsgdmVsb2NpdHlFbmQpIC8gMjtcblxuICByZXR1cm4gYXZlcmFnZVZlbG9jaXR5ICogZWxhcHNlZDtcbn07XG5cblxuRHluYW1pY3MucHJvdG90eXBlLm51bGxWZWxvY2l0eVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudmVsb2NpdHkgPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0aGlzLnZlbG9jaXR5ICYmICF0aGlzLmZyaWN0aW9uKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIHJldHVybiBNYXRoLmFicyh0aGlzLnZlbG9jaXR5IC8gdGhpcy5mcmljdGlvbik7XG59O1xuXG5mdW5jdGlvbiBkZWNyZWFzZUFicyhudW0sIGRlYykge1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiBNYXRoLm1pbigwLCBudW0gKyBkZWMpO1xuICB9XG4gIGlmIChudW0gPiAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG51bSAtIGRlYyk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY3M7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0cyB0aGUgdmVsb2NpdHkgYW5kIGZyaWN0aW9uIG9mIGEgc2luZ2xlIHBhcmFtZXRlciBieSBwcmVzc2luZyBhbmRcbiAqIHVucHJlc3NpbmcgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBhY3RpdmF0ZXMgdGhlIG1ldGhvZCB3aGVuIHByZXNzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0byBiZSBjb250cm9sbGVkIChlLmcuIGB4YCwgYHlgIG9yIGB6b29tYClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eSBWZWxvY2l0eSBhdCB3aGljaCB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZSBhXG4gKiBuZWdhdGl2ZSBudW1iZXIgZm9yIG9wcG9zaXRlIGRpcmVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZyaWN0aW9uIEZyaWN0aW9uIGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgc3RvcHNcbiovXG5mdW5jdGlvbiBFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kKGVsZW1lbnQsIHBhcmFtZXRlciwgdmVsb2NpdHksIGZyaWN0aW9uKSB7XG4gIGlmKCFlbGVtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogZWxlbWVudCBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q6IHBhcmFtZXRlciBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXZlbG9jaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogdmVsb2NpdHkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCFmcmljdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q6IGZyaWN0aW9uIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX3ByZXNzSGFuZGxlciA9IHRoaXMuX2hhbmRsZVByZXNzLmJpbmQodGhpcyk7XG4gIHRoaXMuX3JlbGVhc2VIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpO1xuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fcHJlc3NIYW5kbGVyKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3ByZXNzSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuXG4gIHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgdGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgdGhpcy5fZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufVxuZXZlbnRFbWl0dGVyKEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wcmVzc0hhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcHJlc3NIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVQcmVzcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wcmVzc2luZyA9IHRydWU7XG5cbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB0aGlzLl92ZWxvY2l0eTtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSAwO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG59O1xuXG5FbGVtZW50UHJlc3NDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLl9wcmVzc2luZykge1xuICAgIHRoaXMuX2R5bmFtaWNzLmZyaWN0aW9uID0gdGhpcy5fZnJpY3Rpb247XG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxuXG4gIHRoaXMuX3ByZXNzaW5nID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBIYW1tZXIgPSByZXF1aXJlKCdoYW1tZXJqcycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCdib3dzZXInKTtcblxudmFyIG5leHRJZCA9IDE7XG52YXIgaWRQcm9wZXJ0eSA9ICdNYXJ6aXBhbm9IYW1tZXJFbGVtZW50SWQnO1xuZnVuY3Rpb24gZ2V0S2V5Rm9yRWxlbWVudEFuZFR5cGUoZWxlbWVudCwgdHlwZSkge1xuICBpZiAoIWVsZW1lbnRbaWRQcm9wZXJ0eV0pIHtcbiAgICBlbGVtZW50W2lkUHJvcGVydHldID0gbmV4dElkKys7XG4gIH1cbiAgcmV0dXJuIHR5cGUgKyBlbGVtZW50W2lkUHJvcGVydHldO1xufVxuXG5cbi8qKlxuICogQGNsYXNzIEhhbW1lckdlc3R1cmVzXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogTWFuYWdlcyBIYW1tZXIuanMgaW5zdGFuY2VzLiBPbmUgaW5zdGFuY2UgaXMgY3JlYXRlZCBmb3IgZWFjaCBjb21iaW5hdGlvbiBvZlxuICogRE9NIGVsZW1lbnQgYW5kIHBvaW50ZXIgdHlwZS5cbiAqL1xuZnVuY3Rpb24gSGFtbWVyR2VzdHVyZXMoKSB7XG4gIHRoaXMuX21hbmFnZXJzID0ge307XG4gIHRoaXMuX3JlZkNvdW50ID0ge307XG59XG5cblxuSGFtbWVyR2VzdHVyZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIGtleSA9IGdldEtleUZvckVsZW1lbnRBbmRUeXBlKGVsZW1lbnQsIHR5cGUpO1xuICBpZiAoIXRoaXMuX21hbmFnZXJzW2tleV0pIHtcbiAgICB0aGlzLl9tYW5hZ2Vyc1trZXldID0gdGhpcy5fY3JlYXRlTWFuYWdlcihlbGVtZW50LCB0eXBlKTtcbiAgICB0aGlzLl9yZWZDb3VudFtrZXldID0gMDtcbiAgfVxuICB0aGlzLl9yZWZDb3VudFtrZXldKys7XG4gIHJldHVybiBuZXcgSGFtbWVyR2VzdHVyZXNIYW5kbGUodGhpcywgdGhpcy5fbWFuYWdlcnNba2V5XSwgZWxlbWVudCwgdHlwZSk7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzLnByb3RvdHlwZS5fY3JlYXRlTWFuYWdlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcbiAgdmFyIG1hbmFnZXIgPSBuZXcgSGFtbWVyLk1hbmFnZXIoZWxlbWVudCk7XG5cbiAgLy8gTWFuYWdlcnMgYXJlIGNyZWF0ZWQgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycyBmb3IgZGlmZmVyZW50IHBvaW50ZXJcbiAgLy8gdHlwZXMuXG4gIGlmICh0eXBlID09PSAnbW91c2UnKSB7XG4gICAgbWFuYWdlci5hZGQobmV3IEhhbW1lci5QYW4oeyBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fQUxMLCB0aHJlc2hvbGQ6IDAgfSkpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaCcgfHwgdHlwZSA9PT0gJ3BlbicgfHwgdHlwZSA9PT0gJ2tpbmVjdCcpIHtcbiAgICAvLyBPbiB0b3VjaCBvbmUgd2FudHMgdG8gaGF2ZSBib3RoIHBhbm5pbmcgYW5kIHBpbmNoaW5nLiBUaGUgcGFubmluZ1xuICAgIC8vIHJlY29nbml6ZXIgbmVlZHMgYSB0aHJlc2hvbGQgdG8gYWxsb3cgdGhlIHBpbmNoIHRvIGJlIHJlY29nbml6ZWQuXG4gICAgbWFuYWdlci5hZGQobmV3IEhhbW1lci5QYW4oeyBkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fQUxMLCB0aHJlc2hvbGQ6IDIwLCBwb2ludGVyczogMSB9KSk7XG4gICAgaWYgKCEoYnJvd3Nlci5tc2llICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDEwKSkge1xuICAgICAgLy8gRG8gbm90IGFkZCBwaW5jaCB0byBJRTgtOSB0byBwcmV2ZW50IGZvY3VzIGlzc3VlcyB3aGljaCBwcmV2ZW50IHdoZWVsIHNjcm9sbGluZyBmcm9tXG4gICAgICAvLyB3b3JraW5nLlxuICAgICAgbWFuYWdlci5hZGQobmV3IEhhbW1lci5QaW5jaCgpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFuYWdlcjtcbn07XG5cblxuSGFtbWVyR2VzdHVyZXMucHJvdG90eXBlLl9yZWxlYXNlSGFuZGxlID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICB2YXIga2V5ID0gZ2V0S2V5Rm9yRWxlbWVudEFuZFR5cGUoZWxlbWVudCwgdHlwZSk7XG4gIGlmICh0aGlzLl9yZWZDb3VudFtrZXldKSB7XG4gICAgdGhpcy5fcmVmQ291bnRba2V5XS0tO1xuICAgIGlmICghdGhpcy5fcmVmQ291bnRba2V5XSkge1xuICAgICAgdGhpcy5fbWFuYWdlcnNba2V5XS5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5fbWFuYWdlcnNba2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZWZDb3VudFtrZXldO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBIYW1tZXJHZXN0dXJlc0hhbmRsZShoYW1tZXJHZXN0dXJlcywgbWFuYWdlciwgZWxlbWVudCwgdHlwZSkge1xuICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuICB0aGlzLl9oYW1tZXJHZXN0dXJlcyA9IGhhbW1lckdlc3R1cmVzO1xuICB0aGlzLl9ldmVudEhhbmRsZXJzID0gW107XG59XG5cblxuSGFtbWVyR2VzdHVyZXNIYW5kbGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgdmFyIGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodHlwZSA9PT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgaGFuZGxlcihlKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5fZXZlbnRIYW5kbGVycy5wdXNoKHsgZXZlbnRzOiBldmVudHMsIGhhbmRsZXI6IGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyB9KTtcbiAgdGhpcy5fbWFuYWdlci5vbihldmVudHMsIGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyk7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLl9ldmVudEhhbmRsZXJzW2ldO1xuICAgIHRoaXMuX21hbmFnZXIub2ZmKGV2ZW50SGFuZGxlci5ldmVudHMsIGV2ZW50SGFuZGxlci5oYW5kbGVyKTtcbiAgfVxuXG4gIHRoaXMuX2hhbW1lckdlc3R1cmVzLl9yZWxlYXNlSGFuZGxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3R5cGUpO1xuICB0aGlzLl9tYW5hZ2VyID0gbnVsbDtcbiAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3R5cGUgPSBudWxsO1xuICB0aGlzLl9oYW1tZXJHZXN0dXJlcyA9IG51bGw7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5tYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tYW5hZ2VyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBIYW1tZXJHZXN0dXJlcygpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgS2V5Q29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIFNldHMgdGhlIHZlbG9jaXR5IGFuZCBmcmljdGlvbiBvZiBhIHNpbmdsZSBwYXJhbWV0ZXIgYnkgcHJlc3NpbmcgYW5kXG4gKiB1bnByZXNzaW5nIGEga2V5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXlDb2RlIEtleSB3aGljaCBhY3RpdmF0ZXMgdGhlIG1ldGhvZCB3aGVuIHByZXNzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0byBiZSBjb250cm9sbGVkIChlLmcuIGB4YCwgYHlgIG9yIGB6b29tYClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eSBWZWxvY2l0eSBhdCB3aGljaCB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZSBhXG4gKiBuZWdhdGl2ZSBudW1iZXIgZm9yIG9wcG9zaXRlIGRpcmVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZyaWN0aW9uIEZyaWN0aW9uIGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgc3RvcHNcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1lbnQ9ZG9jdW1lbnRdIERPTSBlbGVtZW50IHdoZXJlIHRoZSBrZXkgZXZlbnRzIGFyZSBsaXN0ZW5lZCB0b1xuICovXG5mdW5jdGlvbiBLZXlDb250cm9sTWV0aG9kKGtleUNvZGUsIHBhcmFtZXRlciwgdmVsb2NpdHksIGZyaWN0aW9uLCBlbGVtZW50KSB7XG4gIGlmKCFrZXlDb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5Q29udHJvbE1ldGhvZDoga2V5Q29kZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IHBhcmFtZXRlciBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXZlbG9jaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5Q29udHJvbE1ldGhvZDogdmVsb2NpdHkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCFmcmljdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IGZyaWN0aW9uIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50IHx8IGRvY3VtZW50O1xuXG4gIHRoaXMuX2tleUNvZGUgPSBrZXlDb2RlO1xuICB0aGlzLl9wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gIHRoaXMuX3ZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuX2ZyaWN0aW9uID0gZnJpY3Rpb247XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlUHJlc3MuYmluZCh0aGlzKTtcbiAgdGhpcy5fa2V5dXBIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpO1xuICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKTtcblxuICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9rZXl1cEhhbmRsZXIpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JsdXJIYW5kbGVyKTtcblxuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufVxuZXZlbnRFbWl0dGVyKEtleUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5dXBIYW5kbGVyKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ibHVySGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVQcmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYoZS5rZXlDb2RlICE9PSB0aGlzLl9rZXlDb2RlKSB7IHJldHVybjsgfVxuXG4gIHRoaXMuX3ByZXNzaW5nID0gdHJ1ZTtcblxuICB0aGlzLl9keW5hbWljcy52ZWxvY2l0eSA9IHRoaXMuX3ZlbG9jaXR5O1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IDA7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVSZWxlYXNlID0gZnVuY3Rpb24oZSkge1xuICBpZihlLmtleUNvZGUgIT09IHRoaXMuX2tleUNvZGUpIHsgcmV0dXJuOyB9XG5cbiAgaWYodGhpcy5fcHJlc3NpbmcpIHtcbiAgICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IHRoaXMuX2ZyaWN0aW9uO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufTtcblxuS2V5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUJsdXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSAwO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlDb250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL0hhbW1lckdlc3R1cmVzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgUGluY2hab29tQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2wgdGhlIHZpZXcgZm92L3pvb20gYnkgcGluY2hpbmcgd2l0aCB0d28gZmluZ2Vycy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyVHlwZSBXaGljaCBIYW1tZXIuanMgcG9pbnRlciB0eXBlIHRvIHVzZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gUGluY2hab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCBwb2ludGVyVHlwZSwgb3B0cykge1xuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcblxuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoc3RhcnQnLCB0aGlzLl9oYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwaW5jaCcsIHRoaXMuX2hhbmRsZUV2ZW50LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoZW5kJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoY2FuY2VsJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xufVxuXG5ldmVudEVtaXR0ZXIoUGluY2hab29tQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUGluY2hab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblBpbmNoWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBzY2FsZSA9IGUuc2NhbGU7XG5cbiAgaWYgKHRoaXMuX2xhc3RFdmVudCkge1xuICAgIHNjYWxlIC89IHRoaXMuX2xhc3RFdmVudC5zY2FsZTtcbiAgfVxuXG4gIHRoaXMuX2R5bmFtaWNzLm9mZnNldCA9IChzY2FsZSAtIDEpICogLTE7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnem9vbScsIHRoaXMuX2R5bmFtaWNzKTtcblxuICB0aGlzLl9sYXN0RXZlbnQgPSBlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBpbmNoWm9vbUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBIYW1tZXJHZXN0dXJlcyA9IHJlcXVpcmUoJy4vSGFtbWVyR2VzdHVyZXMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBtYXhGcmljdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm1heEZyaWN0aW9uO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBzcGVlZDogOCxcbiAgZnJpY3Rpb246IDYsXG4gIG1heEZyaWN0aW9uVGltZTogMC4zXG59O1xuXG5cbi8qKlxuICogQGNsYXNzIFF0dnJDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29udHJvbHMgdGhlIHZpZXcgYnkgaG9sZGluZyB0aGUgbW91c2UgYnV0dG9uIGRvd24gYW5kIG1vdmluZyBpdC5cbiAqIEFsc28ga25vd24gYXMgXCJRVFZSXCIgY29udHJvbCBtb2RlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBmb3IgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJUeXBlIFdoaWNoIEhhbW1lci5qcyBwb2ludGVyIHR5cGUgdG8gdXNlIChlLmcuXG4gKiBgbW91c2VgIG9yIGB0b3VjaGApLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNwZWVkXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5mcmljdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMubWF4RnJpY3Rpb25UaW1lXG4gKi9cbi8vIFRPRE86IGFsbG93IHNwZWVkIG5vdCBjaGFuZ2UgbGluZWFybHkgd2l0aCBkaXN0YW5jZSB0byBjbGljayBzcG90LlxuLy8gUXVhZHJhdGljIG9yIG90aGVyIHdvdWxkIGFsbG93IGEgbGFyZ2VyIHNwZWVkIHJhbmdlLlxuZnVuY3Rpb24gUXR2ckNvbnRyb2xNZXRob2QoZWxlbWVudCwgcG9pbnRlclR5cGUsIG9wdHMpIHtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdGhpcy5fb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblxuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2R5bmFtaWNzID0ge1xuICAgIHg6IG5ldyBEeW5hbWljcygpLFxuICAgIHk6IG5ldyBEeW5hbWljcygpXG4gIH07XG5cbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX2hhbmRsZVN0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX2hhbmRsZVJlbGVhc2UuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbigncGFuY2FuY2VsJywgdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpKTtcbn1cblxuZXZlbnRFbWl0dGVyKFF0dnJDb250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLl91cGRhdGVEeW5hbWljcyhlLCBmYWxzZSk7XG59O1xuXG5cblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCBldmVudCBkcmFnZ2luZyBvdGhlciBET00gZWxlbWVudHMgYW5kIGNhdXNpbmcgc3RyYW5nZSBiZWhhdmlvciBvbiBDaHJvbWVcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuX3VwZGF0ZUR5bmFtaWNzKGUsIHRydWUpO1xuXG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cblxudmFyIHRtcFJlbGVhc2VGcmljdGlvbiA9IFsgbnVsbCwgbnVsbCBdO1xuUXR2ckNvbnRyb2xNZXRob2QucHJvdG90eXBlLl91cGRhdGVEeW5hbWljcyA9IGZ1bmN0aW9uKGUsIHJlbGVhc2UpIHtcbiAgdmFyIGVsZW1lbnRSZWN0ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHdpZHRoID0gZWxlbWVudFJlY3QucmlnaHQgLSBlbGVtZW50UmVjdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudFJlY3QudG9wO1xuICB2YXIgbWF4RGltID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG5cbiAgdmFyIHggPSBlLmRlbHRhWCAvIG1heERpbSAqIHRoaXMuX29wdHMuc3BlZWQ7XG4gIHZhciB5ID0gZS5kZWx0YVkgLyBtYXhEaW0gKiB0aGlzLl9vcHRzLnNwZWVkO1xuXG4gIHRoaXMuX2R5bmFtaWNzLngucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueS5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5ID0geDtcbiAgdGhpcy5fZHluYW1pY3MueS52ZWxvY2l0eSA9IHk7XG5cbiAgaWYgKHJlbGVhc2UpIHtcbiAgICBtYXhGcmljdGlvbih0aGlzLl9vcHRzLmZyaWN0aW9uLCB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5LCB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5LCB0aGlzLl9vcHRzLm1heEZyaWN0aW9uVGltZSwgdG1wUmVsZWFzZUZyaWN0aW9uKTtcbiAgICB0aGlzLl9keW5hbWljcy54LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzBdO1xuICAgIHRoaXMuX2R5bmFtaWNzLnkuZnJpY3Rpb24gPSB0bXBSZWxlYXNlRnJpY3Rpb25bMV07XG4gIH1cblxuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3gnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd5JywgdGhpcy5fZHluYW1pY3MueSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUXR2ckNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBXaGVlbExpc3RlbmVyID0gcmVxdWlyZSgnLi9XaGVlbExpc3RlbmVyJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmcmljdGlvblRpbWU6IDAuMixcbiAgem9vbURlbHRhOiAwLjAwMVxufTtcblxuLyoqXG4gKiBAY2xhc3MgU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDb250cm9scyB0aGUgZm92L3pvb20gdGhyb3VnaCB0aGUgbW91c2Ugd2hlZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbGlzdGVuIGZvciBldmVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmZyaWN0aW9uVGltZT0wLjJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuem9vbURlbHRhPTAuMDAxXVxuICovXG5mdW5jdGlvbiBTY3JvbGxab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCBvcHRzKSB7XG4gIHRoaXMuX29wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcblxuICB0aGlzLl9ldmVudExpc3QgPSBbXTtcblxuICB2YXIgZm4gPSB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZSA/IHRoaXMud2l0aFNtb290aGluZyA6IHRoaXMud2l0aG91dFNtb290aGluZztcbiAgdGhpcy5fd2hlZWxMaXN0ZW5lciA9IG5ldyBXaGVlbExpc3RlbmVyKGVsZW1lbnQsIGZuLmJpbmQodGhpcykpO1xufVxuXG5ldmVudEVtaXR0ZXIoU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblNjcm9sbFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3doZWVsTGlzdGVuZXIuZGVzdHJveSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblNjcm9sbFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS53aXRob3V0U21vb3RoaW5nID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLl9keW5hbWljcy5vZmZzZXQgPSB3aGVlbEV2ZW50RGVsdGEoZSkgKiB0aGlzLl9vcHRzLnpvb21EZWx0YTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd6b29tJywgdGhpcy5fZHluYW1pY3MpO1xuXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG59O1xuXG5cblNjcm9sbFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS53aXRoU21vb3RoaW5nID0gZnVuY3Rpb24oZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBlLnRpbWVTdGFtcDtcblxuICAvLyBSZWNvcmQgZXZlbnQuXG4gIHRoaXMuX2V2ZW50TGlzdC5wdXNoKGUpO1xuXG4gIC8vIFJlbW92ZSBldmVudHMgd2hvc2Ugc21vb3RoaW5nIGhhcyBhbHJlYWR5IGV4cGlyZWQuXG4gIHdoaWxlICh0aGlzLl9ldmVudExpc3RbMF0udGltZVN0YW1wIDwgY3VycmVudFRpbWUgLSB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZSoxMDAwKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0LnNoaWZ0KDApO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBjdXJyZW50IHZlbG9jaXR5IGZyb20gdGhlIHJlY29yZGVkIGV2ZW50cy5cbiAgLy8gRWFjaCB3aGVlbCBtb3ZlbWVudCBjYXVzZXMgYSB2ZWxvY2l0eSBvZiBjaGFuZ2UvZnJpY3Rpb25UaW1lIGR1cmluZyBmcmljdGlvblRpbWUuXG4gIHZhciB2ZWxvY2l0eSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHpvb21DaGFuZ2VGcm9tRXZlbnQgPSB3aGVlbEV2ZW50RGVsdGEodGhpcy5fZXZlbnRMaXN0W2ldKSAqIHRoaXMuX29wdHMuem9vbURlbHRhO1xuICAgIHZlbG9jaXR5ICs9IHpvb21DaGFuZ2VGcm9tRXZlbnQgLyB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZTtcbiAgfVxuXG4gIHRoaXMuX2R5bmFtaWNzLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuX2R5bmFtaWNzLmZyaWN0aW9uID0gTWF0aC5hYnModmVsb2NpdHkpIC8gdGhpcy5fb3B0cy5mcmljdGlvblRpbWU7XG5cbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd6b29tJywgdGhpcy5fZHluYW1pY3MpO1xuXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG59O1xuXG5cbmZ1bmN0aW9uIHdoZWVsRXZlbnREZWx0YShlKSB7XG4gIHZhciBtdWx0aXBsaWVyID0gZS5kZWx0YU1vZGUgPT0gMSA/IDIwIDogMTtcbiAgcmV0dXJuIGUuZGVsdGFZICogbXVsdGlwbGllcjtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjcm9sbFpvb21Db250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgVmVsb2NpdHlDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogU2V0cyB0aGUgdmVsb2NpdHkgYW5kIGZyaWN0aW9uIG9mIGEgc2luZ2xlIHBhcmFtZXRlci5cbiAqXG4gKiBUaGUgdXNlciBzaG91bGQgZW1pdCAnYWN0aXZlJyBhbmQgJ2luYWN0aXZlJyBldmVudHMgaWYgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtZXRlciBUaGUgcGFyYW1ldGVyIHRvIGJlIGNvbnRyb2xsZWQgKGUuZy4gYHhgLCBgeWAgb3IgYHpvb21gKVxuKi9cbmZ1bmN0aW9uIFZlbG9jaXR5Q29udHJvbE1ldGhvZChwYXJhbWV0ZXIpIHtcbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZlbG9jaXR5Q29udHJvbE1ldGhvZDogcGFyYW1ldGVyIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcbn1cbmV2ZW50RW1pdHRlcihWZWxvY2l0eUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblZlbG9jaXR5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcGFyYW1ldGVyJ3MgdmVsb2NpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gdmVsb2NpdHlcbiAqL1xuVmVsb2NpdHlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5zZXRWZWxvY2l0eSA9IGZ1bmN0aW9uKHZlbG9jaXR5KSB7XG4gIHRoaXMuX2R5bmFtaWNzLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwYXJhbWV0ZXIncyBmcmljdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmljdGlvblxuICovXG5WZWxvY2l0eUNvbnRyb2xNZXRob2QucHJvdG90eXBlLnNldEZyaWN0aW9uID0gZnVuY3Rpb24oZnJpY3Rpb24pIHtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWxvY2l0eUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBDcm9zcy1icm93c2VyIG1vdXNlIHdoZWVsIGV2ZW50IGxpc3RlbmVyLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcbi8vIFRoaXMgdmVyc2lvbiByZXF1aXJlcyBldmVudFNoaW0uXG5mdW5jdGlvbiBXaGVlbExpc3RlbmVyKGVsZW0sIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gIHZhciBldmVudE5hbWUgPSBnZXRFdmVudE5hbWUoKTtcblxuICBpZiAoZXZlbnROYW1lID09PSAnd2hlZWwnKSB7XG4gICAgdGhpcy5fZnVuID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fZWxlbSA9IGVsZW07XG4gICAgdGhpcy5fZWxlbS5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2Z1biwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnbW91c2V3aGVlbCcpIHtcbiAgICB0aGlzLl9mdW4gPSBmYWxsYmFja0hhbmRsZXIoY2FsbGJhY2spO1xuICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xuICAgIHRoaXMuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX2Z1biwgdXNlQ2FwdHVyZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbW91c2Ugd2hlZWwgZXZlbnRzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5XaGVlbExpc3RlbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihnZXRFdmVudE5hbWUoKSwgdGhpcy5fZnVuKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuZnVuY3Rpb24gZmFsbGJhY2tIYW5kbGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVXaGVlbEV2ZW50KG9yaWdpbmFsRXZlbnQpIHtcbiAgICBpZiAoIW9yaWdpbmFsRXZlbnQpIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbm9ybWFsaXplZCBldmVudCBvYmplY3QuXG4gICAgdmFyIGV2ZW50ID0ge1xuICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICAgIHRhcmdldDogb3JpZ2luYWxFdmVudC50YXJnZXQgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50LFxuICAgICAgdHlwZTogXCJ3aGVlbFwiLFxuICAgICAgZGVsdGFNb2RlOiAxLFxuICAgICAgZGVsdGFYOiAwLFxuICAgICAgZGVsdGFaOiAwLFxuICAgICAgdGltZVN0YW1wOiBvcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpLFxuICAgICAgcHJldmVudERlZmF1bHQ6IG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQuYmluZChvcmlnaW5hbEV2ZW50KVxuICAgIH07XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGFZLlxuICAgIGV2ZW50LmRlbHRhWSA9IC0gMS80MCAqIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YTtcbiAgICBpZiAob3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGRlbHRhWC5cbiAgICAgIGV2ZW50LmRlbHRhWCA9IC0gMS80MCAqIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVg7XG4gICAgfVxuXG4gICAgLy8gRmlyZSB0aGUgY2FsbGJhY2suXG4gICAgcmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcbiAgfTtcbn1cblxuLy8gRGV0ZWN0IHRoZSBzdXBwb3J0ZWQgd2hlZWwgZXZlbnQgbmFtZSBhbmQgY2FjaGUgdGhlIHJlc3VsdC5cbnZhciBldmVudE5hbWU7XG5mdW5jdGlvbiBnZXRFdmVudE5hbWUoKSB7XG4gIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cbiAgaWYgKCdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkge1xuICAgIC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0ICd3aGVlbCcuXG4gICAgcmV0dXJuIChldmVudE5hbWUgPSAnd2hlZWwnKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCAnbW91c2V3aGVlbCcuXG4gICAgcmV0dXJuIChldmVudE5hbWUgPSAnbW91c2V3aGVlbCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZXZlbnROYW1lID0gbnVsbCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXaGVlbExpc3RlbmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgRHJhZ0NvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL0RyYWcnKTtcbnZhciBRdHZyQ29udHJvbE1ldGhvZCA9IHJlcXVpcmUoJy4vUXR2cicpO1xudmFyIFNjcm9sbFpvb21Db250cm9sTWV0aG9kID0gcmVxdWlyZSgnLi9TY3JvbGxab29tJyk7XG52YXIgUGluY2hab29tQ29udHJvbE1ldGhvZCA9IHJlcXVpcmUoJy4vUGluY2hab29tJyk7XG52YXIgS2V5Q29udHJvbE1ldGhvZCA9IHJlcXVpcmUoJy4vS2V5Jyk7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbW91c2VWaWV3TW9kZTogJ2RyYWcnXG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuZCByZWdpc3RlciBzb21lIGNvbW1vbmx5IHVzZWQge0BsaW5rIENvbnRyb2xNZXRob2R9IGluc3RhbmNlcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGluc3RhbmNlcyBhcmUgcmVnaXN0ZXJlZDpcbiAqICAgLSBtb3VzZVZpZXdEcmFnXG4gKiAgIC0gbW91c2VWaWV3UXR2clxuICogICAtIHRvdWNoVmlld1xuICogICAtIHBpbmNoXG4gKiAgIC0gYXJyb3dLZXlzXG4gKiAgIC0gcGx1c01pbnVzS2V5c1xuICogICAtIHdhc2RLZXlzXG4gKiAgIC0gcWVLZXlzXG4gKlxuICogQHBhcmFtIHtDb250cm9sc30gY29udHJvbHMgV2hlcmUgdG8gcmVnaXN0ZXIgdGhlIGluc3RhbmNlcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBmb3IgZXZlbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7J2RyYWcnfCdxdHZyJ30gbW91c2VWaWV3TW9kZVxuICovXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRDb250cm9scyhjb250cm9scywgZWxlbWVudCwgb3B0cykge1xuICBvcHRzID0gZGVmYXVsdHMob3B0cyB8fCB7fSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHZhciBjb250cm9sTWV0aG9kcyA9IHtcbiAgICBtb3VzZVZpZXdEcmFnOiBuZXcgRHJhZ0NvbnRyb2xNZXRob2QoZWxlbWVudCwgJ21vdXNlJyksXG4gICAgbW91c2VWaWV3UXR2cjogbmV3IFF0dnJDb250cm9sTWV0aG9kKGVsZW1lbnQsICdtb3VzZScpLFxuICAgIHRvdWNoVmlldzogbmV3IERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsICd0b3VjaCcpLFxuICAgIHBpbmNoOiBuZXcgUGluY2hab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCAndG91Y2gnKSxcblxuICAgIGxlZnRBcnJvd0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMzcsICd4JywgLTAuNywgMyksXG4gICAgcmlnaHRBcnJvd0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMzksICd4JywgMC43LCAzKSxcbiAgICB1cEFycm93S2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCgzOCwgJ3knLCAtMC43LCAzKSxcbiAgICBkb3duQXJyb3dLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDQwLCAneScsIDAuNywgMyksXG4gICAgcGx1c0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMTA3LCAnem9vbScsIC0wLjcsIDMpLFxuICAgIG1pbnVzS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCgxMDksICd6b29tJywgMC43LCAzKSxcblxuICAgIHdLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDg3LCAneScsIC0wLjcsIDMpLFxuICAgIGFLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDY1LCAneCcsIC0wLjcsIDMpLFxuICAgIHNLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDgzLCAneScsIDAuNywgMyksXG4gICAgZEtleTogbmV3IEtleUNvbnRyb2xNZXRob2QoNjgsICd4JywgMC43LCAzKSxcbiAgICBxS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg4MSwgJ3JvbGwnLCAwLjcsIDMpLFxuICAgIGVLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDY5LCAncm9sbCcsIC0wLjcsIDMpXG4gIH07XG5cbiAgaWYob3B0cy5zY3JvbGxab29tICE9PSBmYWxzZSkge1xuICAgIGNvbnRyb2xNZXRob2RzLnNjcm9sbFpvb20gPSBuZXcgU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QoZWxlbWVudCk7IC8veyBmcmljdGlvblRpbWU6IDAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2xNZXRob2RHcm91cHMgPSB7XG4gICAgYXJyb3dLZXlzOiBbICdsZWZ0QXJyb3dLZXknLCAncmlnaHRBcnJvd0tleScsICd1cEFycm93S2V5JywgJ2Rvd25BcnJvd0tleScgXSxcbiAgICBwbHVzTWludXNLZXlzOiBbICdwbHVzS2V5JywgJ21pbnVzS2V5JyBdLFxuICAgIHdhc2RLZXlzOiBbICd3S2V5JywgJ2FLZXknLCAnc0tleScsICdkS2V5JyBdLFxuICAgIHFlS2V5czogWyAncUtleScsICdlS2V5JyBdXG4gIH07XG5cblxuICB2YXIgZW5hYmxlZENvbnRyb2xzID0gWyAnc2Nyb2xsWm9vbScsICd0b3VjaFZpZXcnLCAncGluY2gnIF07XG4gIHN3aXRjaCAob3B0cy5tb3VzZVZpZXdNb2RlKSB7XG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICBlbmFibGVkQ29udHJvbHMucHVzaCgnbW91c2VWaWV3RHJhZycpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncXR2cic6XG4gICAgICBlbmFibGVkQ29udHJvbHMucHVzaCgnbW91c2VWaWV3UXR2cicpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW91c2UgdmlldyBtb2RlOiBcIiArIG9wdHMubW91c2VWaWV3TW9kZSk7XG4gIH1cblxuICBmb3IgKHZhciBpZCBpbiBjb250cm9sTWV0aG9kcykge1xuICAgIHZhciBtZXRob2QgPSBjb250cm9sTWV0aG9kc1tpZF07XG4gICAgY29udHJvbHMucmVnaXN0ZXJNZXRob2QoaWQsIG1ldGhvZCk7XG4gICAgaWYgKGVuYWJsZWRDb250cm9scy5pbmRleE9mKGlkKSA+PSAwKSB7XG4gICAgICBjb250cm9scy5lbmFibGVNZXRob2QoaWQpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwSWQgaW4gY29udHJvbE1ldGhvZEdyb3Vwcykge1xuICAgIHZhciBtZXRob2RHcm91cCA9IGNvbnRyb2xNZXRob2RHcm91cHNbZ3JvdXBJZF07XG4gICAgY29udHJvbHMuYWRkTWV0aG9kR3JvdXAoZ3JvdXBJZCwgbWV0aG9kR3JvdXApO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xNZXRob2RzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyRGVmYXVsdENvbnRyb2xzOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWF4RnJpY3Rpb24oZnJpY3Rpb24sIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBtYXhGcmljdGlvblRpbWUsIHJlc3VsdCkge1xuICB2YXIgdmVsb2NpdHkgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHlYLDIpICsgTWF0aC5wb3codmVsb2NpdHlZLDIpKTtcbiAgZnJpY3Rpb24gPSBNYXRoLm1heChmcmljdGlvbiwgdmVsb2NpdHkvbWF4RnJpY3Rpb25UaW1lKTtcbiAgY2hhbmdlVmVjdG9yTm9ybSh2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZnJpY3Rpb24sIHJlc3VsdCk7XG4gIHJlc3VsdFswXSA9IE1hdGguYWJzKHJlc3VsdFswXSk7XG4gIHJlc3VsdFsxXSA9IE1hdGguYWJzKHJlc3VsdFsxXSk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVZlY3Rvck5vcm0oeCwgeSwgbiwgcmVzdWx0KSB7XG4gIHZhciB0aGV0YSA9IE1hdGguYXRhbih5L3gpO1xuICByZXN1bHRbMF0gPSBuICogTWF0aC5jb3ModGhldGEpO1xuICByZXN1bHRbMV0gPSBuICogTWF0aC5zaW4odGhldGEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4RnJpY3Rpb246IG1heEZyaWN0aW9uLFxuICBjaGFuZ2VWZWN0b3JOb3JtOiBjaGFuZ2VWZWN0b3JOb3JtXG59OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKTtcbnZhciBUaWxlU2VhcmNoZXIgPSByZXF1aXJlKCcuLi9UaWxlU2VhcmNoZXInKTtcbnZhciBMcnVNYXAgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9McnVNYXAnKTtcbnZhciBMZXZlbCA9IHJlcXVpcmUoJy4vTGV2ZWwnKTtcbnZhciBtYWtlTGV2ZWxMaXN0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5tYWtlTGV2ZWxMaXN0O1xudmFyIG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0ID0gcmVxdWlyZSgnLi9jb21tb24nKS5tYWtlU2VsZWN0YWJsZUxldmVsTGlzdDtcbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3R5cGUnKTtcbnZhciB2ZWMzID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMztcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcblxudmFyIG5laWdoYm9yc0NhY2hlU2l6ZSA9IDY0O1xuXG4vLyBTb21lIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyByZXF1aXJlIHRpbGVzIHRvIGJlIHBhZGRlZCBhcm91bmQgd2l0aFxuLy8gcmVwZWF0ZWQgcGl4ZWxzIHRvIHByZXZlbnQgdGhlIGFwcGVhcmFuY2Ugb2YgdmlzaWJsZSBzZWFtcyBiZXR3ZWVuIHRpbGVzLlxuLy9cbi8vIEluIG9yZGVyIHRvIHByZXZlbnQgdGhlIHBhZGRpbmcgZnJvbSBiZWluZyB2aXNpYmxlLCB0aGUgdGlsZXMgbXVzdCBiZVxuLy8gcGFkZGVkIGFuZCBzdGFja2VkIHN1Y2ggdGhhdCB0aGUgcGFkZGluZyBvbiBvbmUgb2YgdGhlIHNpZGVzLCB3aGVuIHByZXNlbnQsXG4vLyBzdGFja3MgYmVsb3cgdGhlIG5laWdoYm9yaW5nIHRpbGUgb24gdGhhdCBzaWRlLlxuLy9cbi8vIFRoZSBwYWRkaW5nIHJ1bGVzIGFyZSBhcyBmb2xsb3dzOlxuLy8gKiBEZWZpbmUgYSB0aWxlIHRvIGJlIFgtbWFyZ2luYWwgaWYgaXQgY29udGFjdHMgdGhlIFgtZWRnZSBvZiBpdHMgY3ViZSBmYWNlLlxuLy8gKiBQYWQgdG9wIGlmIHRoZSB0aWxlIGlzIHRvcC1tYXJnaW5hbCBhbmQgdGhlIGZhY2UgaXMgRiBvciBVLlxuLy8gKiBQYWQgYm90dG9tIHVubGVzcyB0aGUgdGlsZSBpcyBib3R0b20tbWFyZ2luYWwgb3IgdGhlIGZhY2UgaXMgRiBvciBELlxuLy8gKiBQYWQgbGVmdCBpZiB0aGUgdGlsZSBpcyBsZWZ0LW1hcmdpbmFsIGFuZCB0aGUgZmFjZSBpcyBGLCBMLCBVIG9yIEQuXG4vLyAqIFBhZCByaWdodCB1bmxlc3MgdGhlIHRpbGUgaXMgcmlnaHQtbWFyZ2luYWwgb3IgdGhlIGZhY2UgaXMgRiwgUiwgVSBvciBELlxuLy9cbi8vIFRoZSBzdGFja2luZyBydWxlcyBhcmUgYXMgZm9sbG93czpcbi8vICogV2l0aGluIGFuIGltYWdlLCBzdGFjayBzbWFsbGVyIHpvb20gbGV2ZWxzIGJlbG93IGxhcmdlciB6b29tIGxldmVscy5cbi8vICogV2l0aGluIGEgbGV2ZWwsIHN0YWNrIHRpbGVzIGJvdHRvbSB0byB0b3AgaW4gRlVETFJCIGZhY2Ugb3JkZXIuXG4vLyAqIFdpdGhpbiBhIGZhY2UsIHN0YWNrIHRpbGVzIGJvdHRvbSB0byB0b3AgaW4gYXNjZW5kaW5nIFkgY29vcmRpbmF0ZSBvcmRlci5cbi8vICogV2l0aGluIGEgcm93LCBzdGFjayB0aWxlcyBib3R0b20gdG8gdG9wIGluIGFzY2VuZGluZyBYIGNvb3JkaW5hdGUgb3JkZXIuXG4vL1xuLy8gQ3J1Y2lhbGx5LCB0aGVzZSBydWxlcyBhZmZlY3QgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSB0aWxlIGNtcCgpIG1ldGhvZCxcbi8vIHdoaWNoIGRldGVybWluZXMgdGhlIHN0YWNraW5nIG9yZGVyLCBhbmQgb2YgdGhlIHBhZCooKSB0aWxlIG1ldGhvZHMsIHdoaWNoXG4vLyBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBwYWRkaW5nIG9uIGVhY2ggb2YgdGhlIGZvdXIgc2lkZXMgb2YgYSB0aWxlLlxuXG4vLyBJbml0aWFscyBmb3IgY3ViZSBmYWNlcyBpbiBzdGFja2luZyBvcmRlci5cbnZhciBmYWNlTGlzdCA9ICdmdWRscmInO1xuXG4vLyBSb3RhdGlvbiBvZiBlYWNoIGZhY2UsIHJlbGF0aXZlIHRvIHRoZSBmcm9udCBmYWNlLlxudmFyIGZhY2VSb3RhdGlvbiA9IHtcbiAgZjogeyB4OiAwLCB5OiAwIH0sXG4gIGI6IHsgeDogMCwgeTogTWF0aC5QSSB9LFxuICBsOiB7IHg6IDAsIHk6IE1hdGguUEkvMiB9LFxuICByOiB7IHg6IDAsIHk6IC1NYXRoLlBJLzIgfSxcbiAgdTogeyB4OiBNYXRoLlBJLzIsIHk6IDAgfSxcbiAgZDogeyB4OiAtTWF0aC5QSS8yLCB5OiAwIH1cbn07XG5cbi8vIFplcm8gdmVjdG9yLlxudmFyIG9yaWdpbiA9IHZlYzMuY3JlYXRlKCk7XG5cbi8vIFJvdGF0ZSBhIHZlY3RvciBpbiBaWFkgb3JkZXIuXG5mdW5jdGlvbiByb3RhdGVWZWN0b3IodmVjLCB6LCB4LCB5KSB7XG4gIGlmICh6KSB7XG4gICAgdmVjMy5yb3RhdGVaKHZlYywgdmVjLCBvcmlnaW4sIHopO1xuICB9XG4gIGlmICh4KSB7XG4gICAgdmVjMy5yb3RhdGVYKHZlYywgdmVjLCBvcmlnaW4sIHgpO1xuICB9XG4gIGlmICh5KSB7XG4gICAgdmVjMy5yb3RhdGVZKHZlYywgdmVjLCBvcmlnaW4sIHkpO1xuICB9XG59XG5cbi8vIE5vcm1hbGl6ZWQgdmVjdG9ycyBwb2ludGluZyB0byB0aGUgY2VudGVyIG9mIGVhY2ggZmFjZS5cbnZhciBmYWNlVmVjdG9ycyA9IHt9O1xuZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlTGlzdC5sZW5ndGg7IGkrKykge1xuICB2YXIgZmFjZSA9IGZhY2VMaXN0W2ldO1xuICB2YXIgcm90YXRpb24gPSBmYWNlUm90YXRpb25bZmFjZV07XG4gIHZhciB2ID0gdmVjMy5mcm9tVmFsdWVzKDAsICAwLCAtMSk7XG4gIHJvdGF0ZVZlY3Rvcih2LCAwLCByb3RhdGlvbi54LCByb3RhdGlvbi55KTtcbiAgZmFjZVZlY3RvcnNbZmFjZV0gPSB2O1xufVxuXG4vLyBNYXAgZWFjaCBmYWNlIHRvIGl0cyBhZGphY2VudCBmYWNlcy5cbi8vIFRoZSBvcmRlciBpcyBhcyBzdWdnZXN0ZWQgYnkgdGhlIGZyb250IGZhY2UuXG52YXIgYWRqYWNlbnRGYWNlID0ge1xuICBmOiBbICdsJywgJ3InLCAndScsICdkJyBdLFxuICBiOiBbICdyJywgJ2wnLCAndScsICdkJyBdLFxuICBsOiBbICdiJywgJ2YnLCAndScsICdkJyBdLFxuICByOiBbICdmJywgJ2InLCAndScsICdkJyBdLFxuICB1OiBbICdsJywgJ3InLCAnYicsICdmJyBdLFxuICBkOiBbICdsJywgJ3InLCAnZicsICdiJyBdXG59O1xuXG4vLyBPZmZzZXRzIHRvIGFwcGx5IHRvIHRoZSAoeCx5KSBjb29yZGluYXRlcyBvZiBhIHRpbGUgdG8gZ2V0IGl0cyBuZWlnaGJvcnMuXG52YXIgbmVpZ2hib3JPZmZzZXRzID0gW1xuICBbICAwLCAgMSBdLCAvLyB0b3BcbiAgWyAgMSwgIDAgXSwgLy8gcmlnaHRcbiAgWyAgMCwgLTEgXSwgLy8gYm90dG9tXG4gIFsgLTEsICAwIF0gIC8vIGxlZnRcbl07XG5cblxuLyoqXG4gKiBAY2xhc3MgQ3ViZVRpbGVcbiAqIEBpbXBsZW1lbnRzIFRpbGVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHRpbGUgaW4gYSBAe0N1YmVHZW9tZXRyeX0uXG4gKi9cbmZ1bmN0aW9uIEN1YmVUaWxlKGZhY2UsIHgsIHksIHosIGdlb21ldHJ5KSB7XG4gIHRoaXMuZmFjZSA9IGZhY2U7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMueiA9IHo7XG4gIHRoaXMuX2dlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gIHRoaXMuX2xldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3pdO1xufVxuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5yb3RYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWNlUm90YXRpb25bdGhpcy5mYWNlXS54O1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUucm90WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFjZVJvdGF0aW9uW3RoaXMuZmFjZV0ueTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLnggKyAwLjUpIC8gdGhpcy5fbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAwLjU7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jZW50ZXJZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwLjUgLSAodGhpcy55ICsgMC41KSAvIHRoaXMuX2xldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMSAvIHRoaXMuX2xldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuc2NhbGVZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxIC8gdGhpcy5fbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsLnRpbGVXaWR0aCgpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC50aWxlSGVpZ2h0KCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5sZXZlbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC53aWR0aCgpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUubGV2ZWxIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsLmhlaWdodCgpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuYXRUb3BMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy56ID09PSAwO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuYXRCb3R0b21MZXZlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy56ID09PSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3QubGVuZ3RoIC0gMTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmF0VG9wRWRnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55ID09PSAwO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuYXRCb3R0b21FZGdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnkgPT09IHRoaXMuX2xldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAtIDE7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5hdExlZnRFZGdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnggPT09IDA7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5hdFJpZ2h0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54ID09PSB0aGlzLl9sZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAtIDE7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5wYWRUb3AgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYXRUb3BFZGdlKCkgJiYgL1tmdV0vLnRlc3QodGhpcy5mYWNlKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnBhZEJvdHRvbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuYXRCb3R0b21FZGdlKCkgfHwgL1tmZF0vLnRlc3QodGhpcy5mYWNlKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnBhZExlZnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYXRMZWZ0RWRnZSgpICYmIC9bZmx1ZF0vLnRlc3QodGhpcy5mYWNlKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnBhZFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5hdFJpZ2h0RWRnZSgpIHx8IC9bZnJ1ZF0vLnRlc3QodGhpcy5mYWNlKTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnZlcnRpY2VzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gW3ZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCksIHZlYzMuY3JlYXRlKCldO1xuICB9XG5cbiAgdmFyIHJvdCA9IGZhY2VSb3RhdGlvblt0aGlzLmZhY2VdO1xuXG4gIGZ1bmN0aW9uIG1ha2VWZXJ0ZXgodmVjLCB4LCB5KSB7XG4gICAgdmVjMy5zZXQodmVjLCB4LCB5LCAtMC41KTtcbiAgICByb3RhdGVWZWN0b3IodmVjLCAwLCByb3QueCwgcm90LnkpO1xuICB9XG5cbiAgdmFyIGxlZnQgPSB0aGlzLmNlbnRlclgoKSAtIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgcmlnaHQgPSB0aGlzLmNlbnRlclgoKSArIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgYm90dG9tID0gdGhpcy5jZW50ZXJZKCkgLSB0aGlzLnNjYWxlWSgpIC8gMjtcbiAgdmFyIHRvcCA9IHRoaXMuY2VudGVyWSgpICsgdGhpcy5zY2FsZVkoKSAvIDI7XG5cbiAgbWFrZVZlcnRleChyZXN1bHRbMF0sIGxlZnQsIHRvcCk7XG4gIG1ha2VWZXJ0ZXgocmVzdWx0WzFdLCByaWdodCwgdG9wKTtcbiAgbWFrZVZlcnRleChyZXN1bHRbMl0sIHJpZ2h0LCBib3R0b20pO1xuICBtYWtlVmVydGV4KHJlc3VsdFszXSwgbGVmdCwgYm90dG9tKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuYXRUb3BMZXZlbCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmFjZSA9IHRoaXMuZmFjZTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIGxldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3pdO1xuICB2YXIgcGFyZW50TGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbei0xXTtcblxuICB2YXIgdGlsZVggPSBNYXRoLmZsb29yKHggLyBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAqIHBhcmVudExldmVsLm51bUhvcml6b250YWxUaWxlcygpKTtcbiAgdmFyIHRpbGVZID0gTWF0aC5mbG9vcih5IC8gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpICogcGFyZW50TGV2ZWwubnVtVmVydGljYWxUaWxlcygpKTtcbiAgdmFyIHRpbGVaID0gei0xO1xuXG4gIHJldHVybiBuZXcgQ3ViZVRpbGUoZmFjZSwgdGlsZVgsIHRpbGVZLCB0aWxlWiwgZ2VvbWV0cnkpO1xuXG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXG4gIGlmICh0aGlzLmF0Qm90dG9tTGV2ZWwoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZhY2UgPSB0aGlzLmZhY2U7XG4gIHZhciB6ID0gdGhpcy56O1xuICB2YXIgeCA9IHRoaXMueDtcbiAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciBsZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6XTtcbiAgdmFyIGNoaWxkTGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3RbeisxXTtcblxuICB2YXIgbkhvcml6ID0gY2hpbGRMZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAvIGxldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgblZlcnQgPSBjaGlsZExldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAvIGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgZm9yICh2YXIgaCA9IDA7IGggPCBuSG9yaXo7IGgrKykge1xuICAgIGZvciAodmFyIHYgPSAwOyB2IDwgblZlcnQ7IHYrKykge1xuICAgICAgdmFyIHRpbGVYID0gbkhvcml6ICogeCArIGg7XG4gICAgICB2YXIgdGlsZVkgPSBuVmVydCAqIHkgKyB2O1xuICAgICAgdmFyIHRpbGVaID0geisxO1xuICAgICAgcmVzdWx0LnB1c2gobmV3IEN1YmVUaWxlKGZhY2UsIHRpbGVYLCB0aWxlWSwgdGlsZVosIGdlb21ldHJ5KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciBjYWNoZSA9IGdlb21ldHJ5Ll9uZWlnaGJvcnNDYWNoZTtcblxuICAvLyBTYXRpc2Z5IGZyb20gY2FjaGUgd2hlbiBhdmFpbGFibGUuXG4gIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQodGhpcyk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG5cbiAgdmFyIHZlYyA9IGdlb21ldHJ5Ll92ZWM7XG5cbiAgdmFyIGZhY2UgPSB0aGlzLmZhY2U7XG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsO1xuXG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1ZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yT2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzBdO1xuICAgIHZhciB5T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzFdO1xuXG4gICAgdmFyIG5ld1ggPSB4ICsgeE9mZnNldDtcbiAgICB2YXIgbmV3WSA9IHkgKyB5T2Zmc2V0O1xuICAgIHZhciBuZXdaID0gejtcbiAgICB2YXIgbmV3RmFjZSA9IGZhY2U7XG5cbiAgICBpZiAobmV3WCA8IDAgfHwgbmV3WCA+PSBudW1YIHx8IG5ld1kgPCAwIHx8IG5ld1kgPj0gbnVtWSkge1xuXG4gICAgICAvLyBJZiB0aGUgbmVpZ2hib3JpbmcgdGlsZSBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IGZhY2UsIGNhbGN1bGF0ZSBhXG4gICAgICAvLyB2ZWN0b3IgcG9pbnRpbmcgdG8gdGhlIGVkZ2UgYmV0d2VlbiB0aGUgdHdvIGZhY2VzIGF0IHRoZSBwb2ludCB0aGVcbiAgICAgIC8vIHRpbGUgYW5kIGl0cyBuZWlnaGJvciBtZWV0LCBhbmQgY29udmVydCBpdCBpbnRvIHRpbGUgY29vcmRpbmF0ZXMgZm9yXG4gICAgICAvLyB0aGUgbmVpZ2hib3JpbmcgZmFjZS5cblxuICAgICAgdmFyIHhDb29yZCA9IHRoaXMuY2VudGVyWCgpO1xuICAgICAgdmFyIHlDb29yZCA9IHRoaXMuY2VudGVyWSgpO1xuXG4gICAgICAvLyBGaXJzdCwgY2FsY3VsYXRlIHRoZSB2ZWN0b3IgYXMgaWYgdGhlIGluaXRpYWwgdGlsZSBiZWxvbmdzIHRvIHRoZVxuICAgICAgLy8gZnJvbnQgZmFjZSwgc28gdGhhdCB0aGUgdGlsZSB4LHkgY29vcmRpbmF0ZXMgbWFwIGRpcmVjdGx5IGludG8gdGhlXG4gICAgICAvLyB4LHkgYXhlcy5cblxuICAgICAgaWYgKG5ld1ggPCAwKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgLTAuNSwgeUNvb3JkLCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVswXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3WCA+PSBudW1YKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgMC41LCB5Q29vcmQsIC0wLjUpO1xuICAgICAgICBuZXdGYWNlID0gYWRqYWNlbnRGYWNlW2ZhY2VdWzFdO1xuICAgICAgfSBlbHNlIGlmIChuZXdZIDwgMCkge1xuICAgICAgICB2ZWMzLnNldCh2ZWMsIHhDb29yZCwgMC41LCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVsyXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3WSA+PSBudW1ZKSB7XG4gICAgICAgIHZlYzMuc2V0KHZlYywgeENvb3JkLCAtMC41LCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVszXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvdDtcblxuICAgICAgLy8gVGhlbiwgcm90YXRlIHRoZSB2ZWN0b3IgaW50byB0aGUgYWN0dWFsIGZhY2UgdGhlIGluaXRpYWwgdGlsZVxuICAgICAgLy8gYmVsb25ncyB0by5cblxuICAgICAgcm90ID0gZmFjZVJvdGF0aW9uW2ZhY2VdO1xuICAgICAgcm90YXRlVmVjdG9yKHZlYywgMCwgcm90LngsIHJvdC55KTtcblxuICAgICAgLy8gRmluYWxseSwgcm90YXRlIHRoZSB2ZWN0b3IgZnJvbSB0aGUgbmVpZ2hib3JpbmcgZmFjZSBpbnRvIHRoZSBmcm9udFxuICAgICAgLy8gZmFjZS4gQWdhaW4sIHRoaXMgaXMgc28gdGhhdCB0aGUgbmVpZ2hib3JpbmcgdGlsZSB4LHkgY29vcmRpbmF0ZXNcbiAgICAgIC8vIG1hcCBkaXJlY3RseSBpbnRvIHRoZSB4LHkgYXhlcy5cblxuICAgICAgcm90ID0gZmFjZVJvdGF0aW9uW25ld0ZhY2VdO1xuICAgICAgcm90YXRlVmVjdG9yKHZlYywgMCwgLXJvdC54LCAtcm90LnkpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG5laWdoYm9yaW5nIHRpbGUgY29vcmRpbmF0ZXMuXG5cbiAgICAgIG5ld1ggPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgKyB2ZWNbMF0pICogbnVtWCksIDAsIG51bVggLSAxKTtcbiAgICAgIG5ld1kgPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgLSB2ZWNbMV0pICogbnVtWSksIDAsIG51bVkgLSAxKTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChuZXcgQ3ViZVRpbGUobmV3RmFjZSwgbmV3WCwgbmV3WSwgbmV3WiwgZ2VvbWV0cnkpKTtcbiAgfVxuXG4gIC8vIFN0b3JlIGludG8gY2FjaGUgdG8gc2F0aXNmeSBmdXR1cmUgcmVxdWVzdHMuXG4gIGNhY2hlLnNldCh0aGlzLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGhhc2goZmFjZUxpc3QuaW5kZXhPZih0aGlzLmZhY2UpLCB0aGlzLnosIHRoaXMueSwgdGhpcy54KTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuICh0aGlzLmdlb21ldHJ5ID09PSB0aGF0Lmdlb21ldHJ5ICYmXG4gICAgICB0aGlzLmZhY2UgPT09IHRoYXQuZmFjZSAmJlxuICAgICAgdGhpcy56ID09PSB0aGF0LnogJiZcbiAgICAgIHRoaXMueSA9PT0gdGhhdC55ICYmXG4gICAgICB0aGlzLnggPT09IHRoYXQueCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiAoY21wKHRoaXMueiwgdGhhdC56KSB8fFxuICBjbXAoZmFjZUxpc3QuaW5kZXhPZih0aGlzLmZhY2UpLCBmYWNlTGlzdC5pbmRleE9mKHRoYXQuZmFjZSkpIHx8XG4gIGNtcCh0aGlzLnksIHRoYXQueSkgfHwgY21wKHRoaXMueCwgdGhhdC54KSk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdDdWJlVGlsZSgnICsgdGlsZS5mYWNlICsgJywgJyArIHRpbGUueCArICcsICcgKyB0aWxlLnkgKyAnLCAnICsgdGlsZS56ICsgJyknO1xufTtcblxuXG5mdW5jdGlvbiBDdWJlTGV2ZWwobGV2ZWxQcm9wZXJ0aWVzKSB7XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmNhbGwodGhpcywgbGV2ZWxQcm9wZXJ0aWVzKTtcblxuICB0aGlzLl9zaXplID0gbGV2ZWxQcm9wZXJ0aWVzLnNpemU7XG4gIHRoaXMuX3RpbGVTaXplID0gbGV2ZWxQcm9wZXJ0aWVzLnRpbGVTaXplO1xuXG4gIGlmICh0aGlzLl9zaXplICUgdGhpcy5fdGlsZVNpemUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIHNpemUgaXMgbm90IG11bHRpcGxlIG9mIHRpbGUgc2l6ZTogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpemUgKyAnICcgKyB0aGlzLl90aWxlU2l6ZSk7XG4gIH1cbn1cblxuaW5oZXJpdHMoQ3ViZUxldmVsLCBMZXZlbCk7XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG5cbkN1YmVMZXZlbC5wcm90b3R5cGUudGlsZVdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aWxlU2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS50aWxlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aWxlU2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS5fdmFsaWRhdGVXaXRoUGFyZW50TGV2ZWwgPSBmdW5jdGlvbihwYXJlbnRMZXZlbCkge1xuXG4gIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLnRpbGVXaWR0aCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodCgpO1xuICB2YXIgbnVtSG9yaXpvbnRhbCA9IHRoaXMubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1WZXJ0aWNhbCA9IHRoaXMubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIHZhciBwYXJlbnRXaWR0aCA9IHBhcmVudExldmVsLndpZHRoKCk7XG4gIHZhciBwYXJlbnRIZWlnaHQgPSBwYXJlbnRMZXZlbC5oZWlnaHQoKTtcbiAgdmFyIHBhcmVudFRpbGVXaWR0aCA9IHBhcmVudExldmVsLnRpbGVXaWR0aCgpO1xuICB2YXIgcGFyZW50VGlsZUhlaWdodCA9IHBhcmVudExldmVsLnRpbGVIZWlnaHQoKTtcbiAgdmFyIHBhcmVudE51bUhvcml6b250YWwgPSBwYXJlbnRMZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIHBhcmVudE51bVZlcnRpY2FsID0gcGFyZW50TGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIGlmICh3aWR0aCAlIHBhcmVudFdpZHRoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCB3aWR0aCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICsgJyB2cy4gJyArIHBhcmVudFdpZHRoKTtcbiAgfVxuXG4gIGlmIChoZWlnaHQgJSBwYXJlbnRIZWlnaHQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGhlaWdodCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArICcgdnMuICcgKyBwYXJlbnRIZWlnaHQpO1xuICB9XG5cbiAgaWYgKG51bUhvcml6b250YWwgJSBwYXJlbnROdW1Ib3Jpem9udGFsICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgaG9yaXpvbnRhbCB0aWxlcyBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICBudW1Ib3Jpem9udGFsICsgXCIgKFwiICsgd2lkdGggKyAnLycgKyB0aWxlV2lkdGggKyAnKScgKyBcIiB2cy4gXCIgK1xuICAgICAgcGFyZW50TnVtSG9yaXpvbnRhbCArIFwiIChcIiArIHBhcmVudFdpZHRoICsgJy8nICsgcGFyZW50VGlsZVdpZHRoICsgJyknKTtcbiAgfVxuXG4gIGlmIChudW1WZXJ0aWNhbCAlIHBhcmVudE51bVZlcnRpY2FsICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgdmVydGljYWwgdGlsZXMgbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgbnVtVmVydGljYWwgKyBcIiAoXCIgKyBoZWlnaHQgKyAnLycgKyB0aWxlSGVpZ2h0ICsgJyknICsgXCIgdnMuIFwiICtcbiAgICAgIHBhcmVudE51bVZlcnRpY2FsICsgXCIgKFwiICsgcGFyZW50SGVpZ2h0ICsgJy8nICsgcGFyZW50VGlsZUhlaWdodCArICcpJyk7XG4gIH1cblxufTtcblxuXG4vKipcbiAqIEBjbGFzcyBDdWJlR2VvbWV0cnlcbiAqIEBpbXBsZW1lbnRzIEdlb21ldHJ5XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgR2VvbWV0cnl9IGltcGxlbWVudGF0aW9uIHN1aXRhYmxlIGZvciB0aWxlZCBjdWJlIGltYWdlcyB3aXRoXG4gKiBtdWx0aXBsZSByZXNvbHV0aW9uIGxldmVscy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHJlc3RyaWN0aW9ucyBhcHBseTpcbiAqICAgLSBBbGwgdGlsZXMgaW4gYSBsZXZlbCBtdXN0IGJlIHNxdWFyZSBhbmQgZm9ybSBhIHJlY3Rhbmd1bGFyIGdyaWQ7XG4gKiAgIC0gVGhlIHNpemUgb2YgYSBsZXZlbCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIHRpbGUgc2l6ZTtcbiAqICAgLSBUaGUgc2l6ZSBvZiBhIGxldmVsIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgcGFyZW50IGxldmVsIHNpemU7XG4gKiAgIC0gVGhlIG51bWJlciBvZiB0aWxlcyBpbiBhIGxldmVsIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgbnVtYmVyIG9mIHRpbGVzXG4gKiAgICAgaW4gdGhlIHBhcmVudCBsZXZlbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBsZXZlbFByb3BlcnRpZXNMaXN0IExldmVsIGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLnNpemUgQ3ViZSBmYWNlIHNpemUgaW4gcGl4ZWxzXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLnRpbGVTaXplIFRpbGUgc2l6ZSBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gQ3ViZUdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBtYWtlTGV2ZWxMaXN0KGxldmVsUHJvcGVydGllc0xpc3QsIEN1YmVMZXZlbCk7XG4gIHRoaXMuc2VsZWN0YWJsZUxldmVsTGlzdCA9IG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5sZXZlbExpc3RbaV0uX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsKHRoaXMubGV2ZWxMaXN0W2ktMV0pO1xuICB9XG5cbiAgdGhpcy5fdGlsZVNlYXJjaGVyID0gbmV3IFRpbGVTZWFyY2hlcih0aGlzKTtcblxuICB0aGlzLl9uZWlnaGJvcnNDYWNoZSA9IG5ldyBMcnVNYXAobmVpZ2hib3JzQ2FjaGVTaXplKTtcblxuICB0aGlzLl92ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gIHRoaXMuX3ZpZXdTaXplID0ge307XG59XG5cblxuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkN1YmVHZW9tZXRyeS5wcm90b3R5cGUubGV2ZWxUaWxlcyA9IGZ1bmN0aW9uKGxldmVsLCByZXN1bHQpIHtcblxuICB2YXIgbGV2ZWxJbmRleCA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICB2YXIgbWF4WCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbiAgdmFyIG1heFkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICBmb3IgKHZhciBmID0gMDsgZiA8IGZhY2VMaXN0Lmxlbmd0aDsgZisrKSB7XG4gICAgdmFyIGZhY2UgPSBmYWNlTGlzdFtmXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBtYXhYOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IG1heFk7IHkrKykge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgQ3ViZVRpbGUoZmFjZSwgeCwgeSwgbGV2ZWxJbmRleCwgdGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5fY2xvc2VzdFRpbGUgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdmVjO1xuXG4gIC8vIENvbXB1dGUgYSB2aWV3IHJheSBpbnRvIHRoZSBjZW50cmFsIHNjcmVlbiBwb2ludC5cbiAgdmVjNC5zZXQocmF5LCAwLCAwLCAxLCAxKTtcbiAgdmVjNC50cmFuc2Zvcm1NYXQ0KHJheSwgcmF5LCB2aWV3LmludmVyc2VQcm9qZWN0aW9uKCkpO1xuXG4gIHZhciBtaW5BbmdsZSA9IEluZmluaXR5O1xuICB2YXIgY2xvc2VzdEZhY2UgPSBudWxsO1xuXG4gIC8vIEZpbmQgdGhlIGZhY2Ugd2hvc2UgdmVjdG9yIG1ha2VzIGEgbWluaW1hbCBhbmdsZSB3aXRoIHRoZSB2aWV3IHJheS5cbiAgLy8gVGhpcyBpcyB0aGUgZmFjZSBpbnRvIHdoaWNoIHRoZSB2aWV3IHJheSBwb2ludHMuXG4gIGZvciAodmFyIGZhY2UgaW4gZmFjZVZlY3RvcnMpIHtcbiAgICB2YXIgdmVjdG9yID0gZmFjZVZlY3RvcnNbZmFjZV07XG4gICAgLy8gRm9yIGEgc21hbGwgYW5nbGUgYmV0d2VlbiB0d28gbm9ybWFsaXplZCB2ZWN0b3JzLCBhbmdsZSB+IDEtY29zKGFuZ2xlKS5cbiAgICB2YXIgYW5nbGUgPSAxIC0gdmVjMy5kb3QodmVjdG9yLCByYXkpO1xuICAgIGlmIChhbmdsZSA8IG1pbkFuZ2xlKSB7XG4gICAgICBtaW5BbmdsZSA9IGFuZ2xlO1xuICAgICAgY2xvc2VzdEZhY2UgPSBmYWNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByb2plY3QgdmlldyByYXkgb250byBjdWJlLCBpLmUuLCBub3JtYWxpemUgdGhlIGNvb3JkaW5hdGUgd2l0aFxuICAvLyBsYXJnZXN0IGFic29sdXRlIHZhbHVlIHRvIMKxMC41LlxuICB2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5hYnMocmF5WzBdKSwgTWF0aC5hYnMocmF5WzFdKSwgTWF0aC5hYnMocmF5WzJdKSkgLyAwLjU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmF5W2ldID0gcmF5W2ldIC8gbWF4O1xuICB9XG5cbiAgLy8gUm90YXRlIHZpZXcgcmF5IGludG8gZnJvbnQgZmFjZS5cbiAgdmFyIHJvdCA9IGZhY2VSb3RhdGlvbltjbG9zZXN0RmFjZV07XG4gIHJvdGF0ZVZlY3RvcihyYXksIDAsIC1yb3QueCwgLXJvdC55KTtcblxuICAvLyBHZXQgdGhlIGRlc2lyZWQgem9vbSBsZXZlbC5cbiAgdmFyIHRpbGVaID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1ZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIC8vIEZpbmQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlIHRoYXQgdGhlIHZpZXcgcmF5IHBvaW50cyBpbnRvLlxuICB2YXIgdGlsZVggPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgKyByYXlbMF0pICogbnVtWCksIDAsIG51bVggLSAxKTtcbiAgdmFyIHRpbGVZID0gY2xhbXAoTWF0aC5mbG9vcigoMC41IC0gcmF5WzFdKSAqIG51bVkpLCAwLCBudW1ZIC0gMSk7XG5cbiAgcmV0dXJuIG5ldyBDdWJlVGlsZShjbG9zZXN0RmFjZSwgdGlsZVgsIHRpbGVZLCB0aWxlWiwgdGhpcyk7XG59O1xuXG5cbkN1YmVHZW9tZXRyeS5wcm90b3R5cGUudmlzaWJsZVRpbGVzID0gZnVuY3Rpb24odmlldywgbGV2ZWwsIHJlc3VsdCkge1xuICB2YXIgdmlld1NpemUgPSB0aGlzLl92aWV3U2l6ZTtcbiAgdmFyIHRpbGVTZWFyY2hlciA9IHRoaXMuX3RpbGVTZWFyY2hlcjtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgdmlldy5zaXplKHZpZXdTaXplKTtcbiAgaWYgKHZpZXdTaXplLndpZHRoID09PSAwIHx8IHZpZXdTaXplLmhlaWdodCA9PT0gMCkge1xuICAgIC8vIE5vIHRpbGVzIGFyZSB2aXNpYmxlIGlmIHRoZSB2aWV3cG9ydCBpcyBlbXB0eS5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHN0YXJ0aW5nVGlsZSA9IHRoaXMuX2Nsb3Nlc3RUaWxlKHZpZXcsIGxldmVsKTtcbiAgdmFyIGNvdW50ID0gdGlsZVNlYXJjaGVyLnNlYXJjaCh2aWV3LCBzdGFydGluZ1RpbGUsIHJlc3VsdCk7XG4gIGlmICghY291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXJ0aW5nIHRpbGUgaXMgbm90IHZpc2libGUnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkN1YmVHZW9tZXRyeS5UaWxlID0gQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5UaWxlID0gQ3ViZVRpbGU7XG5DdWJlR2VvbWV0cnkudHlwZSA9IEN1YmVHZW9tZXRyeS5wcm90b3R5cGUudHlwZSA9ICdjdWJlJztcbkN1YmVUaWxlLnR5cGUgPSBDdWJlVGlsZS5wcm90b3R5cGUudHlwZSA9ICdjdWJlJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEN1YmVHZW9tZXRyeTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgTGV2ZWwgPSByZXF1aXJlKCcuL0xldmVsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvdHlwZScpO1xuXG5cbi8qKlxuICogQGNsYXNzIEVxdWlyZWN0VGlsZVxuICogQGltcGxlbWVudHMgVGlsZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgdGlsZSBpbiBhbiBAe0VxdWlyZWN0R2VvbWV0cnl9LlxuICovXG5mdW5jdGlvbiBFcXVpcmVjdFRpbGUoeiwgZ2VvbWV0cnkpIHtcbiAgdGhpcy56ID0gejtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG59XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5yb3RYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnJvdFkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMC41O1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDAuNTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zY2FsZVggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDE7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuc2NhbGVZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsLnRpbGVIZWlnaHQoKTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5sZXZlbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC53aWR0aCgpO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmxldmVsSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC5oZWlnaHQoKTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5hdFRvcExldmVsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnogPT09IDA7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuYXRCb3R0b21MZXZlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy56ID09PSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3QubGVuZ3RoIC0gMTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5hdFRvcEVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuYXRCb3R0b21FZGdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmF0TGVmdEVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuYXRSaWdodEVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUucGFkVG9wID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5wYWRCb3R0b20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnBhZExlZnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnBhZFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYXRUb3BMZXZlbCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBFcXVpcmVjdFRpbGUodGhpcy56IC0gMSwgdGhpcy5fZ2VvbWV0cnkpO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICh0aGlzLmF0Qm90dG9tTGV2ZWwoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgcmVzdWx0LnB1c2gobmV3IEVxdWlyZWN0VGlsZSh0aGlzLnogKyAxLCB0aGlzLl9nZW9tZXRyeSkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW107XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaGFzaCh0aGlzLnopO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkgPT09IHRoYXQuZ2VvbWV0cnkgJiYgdGhpcy56ID09PSB0aGF0Lno7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gY21wKHRoaXMueiwgdGhhdC56KTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFcXVpcmVjdFRpbGUoJyArIHRpbGUueiArICcpJztcbn07XG5cblxuZnVuY3Rpb24gRXF1aXJlY3RMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBsZXZlbFByb3BlcnRpZXMpO1xuICB0aGlzLl93aWR0aCA9IGxldmVsUHJvcGVydGllcy53aWR0aDtcbn1cblxuaW5oZXJpdHMoRXF1aXJlY3RMZXZlbCwgTGV2ZWwpO1xuXG5cbkVxdWlyZWN0TGV2ZWwucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuRXF1aXJlY3RMZXZlbC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aC8yO1xufTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS50aWxlV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3dpZHRoO1xufTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS50aWxlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aC8yO1xufTtcblxuXG4vKipcbiAqIEBjbGFzcyBFcXVpcmVjdEdlb21ldHJ5XG4gKiBAaW1wbGVtZW50cyBHZW9tZXRyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIEdlb21ldHJ5fSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgZXF1aXJlY3Rhbmd1bGFyIGltYWdlcyB3aXRoIGFcbiAqIDI6MSBhc3BlY3QgcmF0aW8uXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gbGV2ZWxQcm9wZXJ0aWVzTGlzdCBMZXZlbCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS53aWR0aCBMZXZlbCB3aWR0aCBpbiBwaXhlbHNcbiovXG5mdW5jdGlvbiBFcXVpcmVjdEdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBjb21tb24ubWFrZUxldmVsTGlzdChsZXZlbFByb3BlcnRpZXNMaXN0LCBFcXVpcmVjdExldmVsKTtcbiAgdGhpcy5zZWxlY3RhYmxlTGV2ZWxMaXN0ID0gY29tbW9uLm1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcbn1cblxuXG5FcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLmxldmVsVGlsZXMgPSBmdW5jdGlvbihsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciBsZXZlbEluZGV4ID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgcmVzdWx0LnB1c2gobmV3IEVxdWlyZWN0VGlsZShsZXZlbEluZGV4LCB0aGlzKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsLCByZXN1bHQpIHtcbiAgdmFyIHRpbGUgPSBuZXcgRXF1aXJlY3RUaWxlKHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpLCB0aGlzKTtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICByZXN1bHQubGVuZ3RoID0gMDtcbiAgcmVzdWx0LnB1c2godGlsZSk7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkuVGlsZSA9IEVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBFcXVpcmVjdFRpbGU7XG5FcXVpcmVjdEdlb21ldHJ5LnR5cGUgPSBFcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2VxdWlyZWN0JztcbkVxdWlyZWN0VGlsZS50eXBlID0gRXF1aXJlY3RUaWxlLnByb3RvdHlwZS50eXBlID0gJ2VxdWlyZWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWlyZWN0R2VvbWV0cnk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi4vdXRpbC9oYXNoJyk7XG52YXIgVGlsZVNlYXJjaGVyID0gcmVxdWlyZSgnLi4vVGlsZVNlYXJjaGVyJyk7XG52YXIgTHJ1TWFwID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvTHJ1TWFwJyk7XG52YXIgTGV2ZWwgPSByZXF1aXJlKCcuL0xldmVsJyk7XG52YXIgbWFrZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZUxldmVsTGlzdDtcbnZhciBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZVNlbGVjdGFibGVMZXZlbExpc3Q7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3R5cGUnKTtcbnZhciB2ZWMyID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMjtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcblxudmFyIG5laWdoYm9yc0NhY2hlU2l6ZSA9IDY0O1xuXG4vLyBTb21lIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyByZXF1aXJlIHRpbGVzIHRvIGJlIHBhZGRlZCBhcm91bmQgd2l0aFxuLy8gcmVwZWF0ZWQgcGl4ZWxzIHRvIHByZXZlbnQgdGhlIGFwcGVhcmFuY2Ugb2YgdmlzaWJsZSBzZWFtcyBiZXR3ZWVuIHRpbGVzLlxuLy9cbi8vIEluIG9yZGVyIHRvIHByZXZlbnQgdGhlIHBhZGRpbmcgZnJvbSBiZWluZyB2aXNpYmxlLCB0aGUgdGlsZXMgbXVzdCBiZVxuLy8gcGFkZGVkIGFuZCBzdGFja2VkIHN1Y2ggdGhhdCB0aGUgcGFkZGluZyBvbiBvbmUgb2YgdGhlIHNpZGVzLCB3aGVuIHByZXNlbnQsXG4vLyBzdGFja3MgYmVsb3cgdGhlIG5laWdoYm9yaW5nIHRpbGUgb24gdGhhdCBzaWRlLlxuLy9cbi8vIFBhZGRpbmcgcnVsZXM6XG4vLyAqIFBhZCB0aWxlcyBvbiB0aGUgcmlnaHQgYW5kIG9uIHRoZSBib3R0b20uXG4vL1xuLy8gU3RhY2tpbmcgcnVsZXM6XG4vLyAqIFdpdGhpbiBhbiBpbWFnZSwgc3RhY2sgc21hbGxlciB6b29tIGxldmVscyBiZWxvdyBsYXJnZXIgem9vbSBsZXZlbHMuXG4vLyAqIFdpdGhpbiBhIGxldmVsLCBzdGFjayB0aWxlcyBib3R0b20gdG8gdG9wIGluIGFzY2VuZGluZyBZIGNvb3JkaW5hdGUgb3JkZXIuXG4vLyAqIFdpdGhpbiBhIHJvdywgc3RhY2sgdGlsZXMgYm90dG9tIHRvIHRvcCBpbiBhc2NlbmRpbmcgWCBjb29yZGluYXRlIG9yZGVyLlxuXG4vLyBPZmZzZXRzIHRvIGFwcGx5IHRvIHRoZSAoeCx5KSBjb29yZGluYXRlcyBvZiBhIHRpbGUgdG8gZ2V0IGl0cyBuZWlnaGJvcnMuXG52YXIgbmVpZ2hib3JPZmZzZXRzID0gW1xuICBbICAwLCAgMSBdLCAvLyB0b3BcbiAgWyAgMSwgIDAgXSwgLy8gcmlnaHRcbiAgWyAgMCwgLTEgXSwgLy8gYm90dG9tXG4gIFsgLTEsICAwIF0gIC8vIGxlZnRcbl07XG5cblxuLyoqXG4gKiBAY2xhc3MgRmxhdFRpbGVcbiAqIEBpbXBsZW1lbnRzIFRpbGVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHRpbGUgaW4gYSB7QGxpbmsgRmxhdEdlb21ldHJ5fS5cbiAqL1xuZnVuY3Rpb24gRmxhdFRpbGUoeCwgeSwgeiwgZ2VvbWV0cnkpIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG59XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnJvdFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5yb3RZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbiAgcmV0dXJuICh0aGlzLnggKiB0aWxlV2lkdGggKyAwLjUgKiB0aGlzLndpZHRoKCkpIC8gbGV2ZWxXaWR0aCAtIDAuNTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5fbGV2ZWwudGlsZUhlaWdodCgpO1xuICByZXR1cm4gMC41IC0gKHRoaXMueSAqIHRpbGVIZWlnaHQgKyAwLjUgKiB0aGlzLmhlaWdodCgpKSAvIGxldmVsSGVpZ2h0O1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuc2NhbGVYID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbFdpZHRoID0gdGhpcy5fbGV2ZWwud2lkdGgoKTtcbiAgcmV0dXJuIHRoaXMud2lkdGgoKSAvIGxldmVsV2lkdGg7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHJldHVybiB0aGlzLmhlaWdodCgpIC8gbGV2ZWxIZWlnaHQ7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbiAgaWYgKHRoaXMuYXRSaWdodEVkZ2UoKSkge1xuICAgIHZhciB3aWR0aFJlbWFpbmRlciA9IG1vZChsZXZlbFdpZHRoLCB0aWxlV2lkdGgpO1xuICAgIHJldHVybiB3aWR0aFJlbWFpbmRlciB8fCB0aWxlV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVXaWR0aDtcbiAgfVxufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbEhlaWdodCA9IHRoaXMuX2xldmVsLmhlaWdodCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IHRoaXMuX2xldmVsLnRpbGVIZWlnaHQoKTtcbiAgaWYgKHRoaXMuYXRCb3R0b21FZGdlKCkpIHtcbiAgICB2YXIgaGVpZ2h0UmVtYWluZGVyID0gbW9kKGxldmVsSGVpZ2h0LCB0aWxlSGVpZ2h0KTtcbiAgICByZXR1cm4gaGVpZ2h0UmVtYWluZGVyIHx8IHRpbGVIZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVIZWlnaHQ7XG4gIH1cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmxldmVsV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsLndpZHRoKCk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5sZXZlbEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5hdFRvcExldmVsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnogPT09IDA7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5hdEJvdHRvbUxldmVsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnogPT09IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdC5sZW5ndGggLSAxO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuYXRUb3BFZGdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnkgPT09IDA7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5hdEJvdHRvbUVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueSA9PT0gdGhpcy5fbGV2ZWwubnVtVmVydGljYWxUaWxlcygpIC0gMTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmF0TGVmdEVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueCA9PT0gMDtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmF0UmlnaHRFZGdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnggPT09IHRoaXMuX2xldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnBhZFRvcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5wYWRCb3R0b20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLmF0Qm90dG9tRWRnZSgpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUucGFkTGVmdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5wYWRSaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuYXRSaWdodEVkZ2UoKTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnZlcnRpY2VzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gW3ZlYzIuY3JlYXRlKCksIHZlYzIuY3JlYXRlKCksIHZlYzIuY3JlYXRlKCksIHZlYzIuY3JlYXRlKCldO1xuICB9XG5cbiAgdmFyIGxlZnQgPSB0aGlzLmNlbnRlclgoKSAtIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgcmlnaHQgPSB0aGlzLmNlbnRlclgoKSArIHRoaXMuc2NhbGVYKCkgLyAyO1xuICB2YXIgYm90dG9tID0gdGhpcy5jZW50ZXJZKCkgLSB0aGlzLnNjYWxlWSgpIC8gMjtcbiAgdmFyIHRvcCA9IHRoaXMuY2VudGVyWSgpICsgdGhpcy5zY2FsZVkoKSAvIDI7XG5cbiAgdmVjMi5zZXQocmVzdWx0WzBdLCBsZWZ0LCB0b3ApO1xuICB2ZWMyLnNldChyZXN1bHRbMV0sIHJpZ2h0LCB0b3ApO1xuICB2ZWMyLnNldChyZXN1bHRbMl0sIHJpZ2h0LCBib3R0b20pO1xuICB2ZWMyLnNldChyZXN1bHRbM10sIGxlZnQsIGJvdHRvbSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuXG5cbiAgaWYgKHRoaXMuYXRUb3BMZXZlbCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcblxuICB2YXIgeiA9IHRoaXMueiAtIDE7XG4gIC8vIFRPRE86IEN1cnJlbnRseSBhc3N1bWluZyBlYWNoIGxldmVsIGlzIGRvdWJsZSB0aGUgc2l6ZSBvZiBwcmV2aW91cyBvbmUuXG4gIC8vIEZpeCB0byBzdXBwb3J0IG90aGVyIG11bHRpcGxlcy5cbiAgdmFyIHggPSBNYXRoLmZsb29yKHRoaXMueCAvIDIpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IodGhpcy55IC8gMik7XG5cbiAgcmV0dXJuIG5ldyBGbGF0VGlsZSh4LCB5LCB6LCBnZW9tZXRyeSk7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICh0aGlzLmF0Qm90dG9tTGV2ZWwoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gIHZhciB6ID0gdGhpcy56ICsgMTtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgLy8gVE9ETzogQ3VycmVudGx5IGFzc3VtaW5nIGVhY2ggbGV2ZWwgaXMgZG91YmxlIHRoZSBzaXplIG9mIHByZXZpb3VzIG9uZS5cbiAgLy8gRml4IHRvIHN1cHBvcnQgb3RoZXIgbXVsdGlwbGVzLlxuICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoMip0aGlzLnggICwgMip0aGlzLnkgICwgeiwgZ2VvbWV0cnkpKTtcbiAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKDIqdGhpcy54ICAsIDIqdGhpcy55KzEsIHosIGdlb21ldHJ5KSk7XG4gIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSgyKnRoaXMueCsxLCAyKnRoaXMueSAgLCB6LCBnZW9tZXRyeSkpO1xuICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoMip0aGlzLngrMSwgMip0aGlzLnkrMSwgeiwgZ2VvbWV0cnkpKTtcblxuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIGNhY2hlID0gZ2VvbWV0cnkuX25laWdoYm9yc0NhY2hlO1xuXG4gIC8vIFNhdGlzZnkgZnJvbSBjYWNoZSB3aGVuIGF2YWlsYWJsZS5cbiAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldCh0aGlzKTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cblxuICB2YXIgeCA9IHRoaXMueDtcbiAgdmFyIHkgPSB0aGlzLnk7XG4gIHZhciB6ID0gdGhpcy56O1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbDtcblxuICB2YXIgbnVtWCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbiAgdmFyIG51bVkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yT2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzBdO1xuICAgIHZhciB5T2Zmc2V0ID0gbmVpZ2hib3JPZmZzZXRzW2ldWzFdO1xuXG4gICAgdmFyIG5ld1ggPSB4ICsgeE9mZnNldDtcbiAgICB2YXIgbmV3WSA9IHkgKyB5T2Zmc2V0O1xuICAgIHZhciBuZXdaID0gejtcblxuICAgIGlmICgwIDw9IG5ld1ggJiYgbmV3WCA8PSBudW1YICYmIDAgPD0gbmV3WSAmJiBuZXdZIDw9IG51bVkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZShuZXdYLCBuZXdZLCBuZXdaLCBnZW9tZXRyeSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0b3JlIGludG8gY2FjaGUgdG8gc2F0aXNmeSBmdXR1cmUgcmVxdWVzdHMuXG4gIGNhY2hlLnNldCh0aGlzLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGhhc2godGhpcy56LCB0aGlzLnksIHRoaXMueCk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiAodGhpcy5nZW9tZXRyeSA9PT0gdGhhdC5nZW9tZXRyeSAmJlxuICAgICAgdGhpcy56ID09PSB0aGF0LnogJiYgdGhpcy55ID09PSB0aGF0LnkgJiYgdGhpcy54ID09PSB0aGF0LngpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gKGNtcCh0aGlzLnosIHRoYXQueikgfHwgY21wKHRoaXMueSwgdGhhdC55KSB8fCBjbXAodGhpcy54LCB0aGF0LngpKTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ0ZsYXRUaWxlKCcgKyB0aWxlLnggKyAnLCAnICsgdGlsZS55ICsgJywgJyArIHRpbGUueiArICcpJztcbn07XG5cblxuZnVuY3Rpb24gRmxhdExldmVsKGxldmVsUHJvcGVydGllcykge1xuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5jYWxsKHRoaXMsIGxldmVsUHJvcGVydGllcyk7XG5cbiAgdGhpcy5fd2lkdGggPSBsZXZlbFByb3BlcnRpZXMud2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IGxldmVsUHJvcGVydGllcy5oZWlnaHQ7XG4gIHRoaXMuX3RpbGVXaWR0aCA9IGxldmVsUHJvcGVydGllcy50aWxlV2lkdGg7XG4gIHRoaXMuX3RpbGVIZWlnaHQgPSBsZXZlbFByb3BlcnRpZXMudGlsZUhlaWdodDtcbn1cblxuaW5oZXJpdHMoRmxhdExldmVsLCBMZXZlbCk7XG5cblxuRmxhdExldmVsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59O1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUudGlsZVdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aWxlV2lkdGg7XG59O1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUudGlsZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGlsZUhlaWdodDtcbn07XG5cblxuRmxhdExldmVsLnByb3RvdHlwZS5fdmFsaWRhdGVXaXRoUGFyZW50TGV2ZWwgPSBmdW5jdGlvbihwYXJlbnRMZXZlbCkge1xuXG4gIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLnRpbGVXaWR0aCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodCgpO1xuXG4gIHZhciBwYXJlbnRXaWR0aCA9IHBhcmVudExldmVsLndpZHRoKCk7XG4gIHZhciBwYXJlbnRIZWlnaHQgPSBwYXJlbnRMZXZlbC5oZWlnaHQoKTtcbiAgdmFyIHBhcmVudFRpbGVXaWR0aCA9IHBhcmVudExldmVsLnRpbGVXaWR0aCgpO1xuICB2YXIgcGFyZW50VGlsZUhlaWdodCA9IHBhcmVudExldmVsLnRpbGVIZWlnaHQoKTtcblxuICBpZiAod2lkdGggJSBwYXJlbnRXaWR0aCAhPT0gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0xldmVsIHdpZHRoIG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgIHdpZHRoICsgJyB2cy4gJyArIHBhcmVudFdpZHRoKTtcbiAgfVxuXG4gIGlmIChoZWlnaHQgJSBwYXJlbnRIZWlnaHQgIT09IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdMZXZlbCBoZWlnaHQgbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICsgJyB2cy4gJyArIHBhcmVudEhlaWdodCk7XG4gIH1cblxuICBpZiAodGlsZVdpZHRoICUgcGFyZW50VGlsZVdpZHRoICE9PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignTGV2ZWwgdGlsZSB3aWR0aCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgICB0aWxlV2lkdGggKyAnIHZzLiAnICsgcGFyZW50VGlsZVdpZHRoKTtcbiAgfVxuXG4gIGlmICh0aWxlSGVpZ2h0ICUgcGFyZW50VGlsZUhlaWdodCAhPT0gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0xldmVsIHRpbGUgaGVpZ2h0IG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgIHRpbGVIZWlnaHQgKyAnIHZzLiAnICsgcGFyZW50VGlsZUhlaWdodCk7XG4gIH1cblxufTtcblxuXG4vKipcbiAqIEBjbGFzcyBGbGF0R2VvbWV0cnlcbiAqIEBpbXBsZW1lbnRzIEdlb21ldHJ5XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgR2VvbWV0cnl9IGltcGxlbWVudGF0aW9uIHN1aXRhYmxlIGZvciB0aWxlZCBmbGF0IGltYWdlcyB3aXRoXG4gKiBtdWx0aXBsZSByZXNvbHV0aW9uIGxldmVscy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHJlc3RyaWN0aW9ucyBhcHBseTpcbiAqICAgLSBBbGwgdGlsZXMgbXVzdCBiZSBzcXVhcmUsIGV4Y2VwdCB3aGVuIGluIHRoZSBsYXN0IHJvdyBvciBjb2x1bW4gcG9zaXRpb24sXG4gKiAgICAgYW5kIG11c3QgZm9ybSBhIHJlY3Rhbmd1bGFyIGdyaWQ7XG4gKiAgIC0gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBsZXZlbCBtdXN0IGJlIG11bHRpcGxlcyBvZiB0aGUgcGFyZW50IGxldmVsXG4gKiAgICAgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBsZXZlbFByb3BlcnRpZXNMaXN0IExldmVsIGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLndpZHRoIExldmVsIHdpZHRoIGluIHBpeGVsc1xuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS50aWxlV2lkdGggVGlsZSB3aWR0aCBpbiBwaXhlbHMgZm9yXG4gKiAgICAgICAgICAgICAgICAgc3F1YXJlIHRpbGVzXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLmhlaWdodCBMZXZlbCBoZWlnaHQgaW4gcGl4ZWxzXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLnRpbGVIZWlnaHQgVGlsZSBoZWlnaHQgaW4gcGl4ZWxzIGZvclxuICogICAgICAgICAgICAgICAgIHNxdWFyZSB0aWxlc1xuICovXG5mdW5jdGlvbiBGbGF0R2VvbWV0cnkobGV2ZWxQcm9wZXJ0aWVzTGlzdCkge1xuICBpZiAodHlwZShsZXZlbFByb3BlcnRpZXNMaXN0KSAhPT0gJ2FycmF5Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignTGV2ZWwgbGlzdCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICB0aGlzLmxldmVsTGlzdCA9IG1ha2VMZXZlbExpc3QobGV2ZWxQcm9wZXJ0aWVzTGlzdCwgRmxhdExldmVsKTtcbiAgdGhpcy5zZWxlY3RhYmxlTGV2ZWxMaXN0ID0gbWFrZVNlbGVjdGFibGVMZXZlbExpc3QodGhpcy5sZXZlbExpc3QpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmxldmVsTGlzdFtpXS5fdmFsaWRhdGVXaXRoUGFyZW50TGV2ZWwodGhpcy5sZXZlbExpc3RbaS0xXSk7XG4gIH1cblxuICB0aGlzLl90aWxlU2VhcmNoZXIgPSBuZXcgVGlsZVNlYXJjaGVyKHRoaXMpO1xuXG4gIHRoaXMuX25laWdoYm9yc0NhY2hlID0gbmV3IExydU1hcChuZWlnaGJvcnNDYWNoZVNpemUpO1xuXG4gIHRoaXMuX3ZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgdGhpcy5fdmlld1NpemUgPSB7fTtcbn1cblxuXG5GbGF0R2VvbWV0cnkucHJvdG90eXBlLm1heFRpbGVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtYXhUaWxlU2l6ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsTGlzdFtpXTtcbiAgICBtYXhUaWxlU2l6ZSA9IE1hdGgubWF4KG1heFRpbGVTaXplLCBsZXZlbC50aWxlV2lkdGgsIGxldmVsLnRpbGVIZWlnaHQpO1xuICB9XG4gIHJldHVybiBtYXhUaWxlU2l6ZTtcbn07XG5cblxuRmxhdEdlb21ldHJ5LnByb3RvdHlwZS5sZXZlbFRpbGVzID0gZnVuY3Rpb24obGV2ZWwsIHJlc3VsdCkge1xuXG4gIHZhciBsZXZlbEluZGV4ID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHZhciBtYXhYID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAxO1xuICB2YXIgbWF4WSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAtIDE7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgfVxuXG4gIGZvciAodmFyIHggPSAwOyB4IDw9IG1heFg7IHgrKykge1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IG1heFk7IHkrKykge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKHgsIHksIGxldmVsSW5kZXgsIHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cbkZsYXRHZW9tZXRyeS5wcm90b3R5cGUuX2Nsb3Nlc3RUaWxlID0gZnVuY3Rpb24odmlldywgbGV2ZWwpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3ZlYztcblxuICAvLyBDb21wdXRlIGEgdmlldyByYXkgaW50byB0aGUgY2VudHJhbCBzY3JlZW4gcG9pbnQuXG4gIHZlYzQuc2V0KHJheSwgMCwgMCwgMSwgMSk7XG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgdmlldy5pbnZlcnNlUHJvamVjdGlvbigpKTtcblxuICAvLyBDb21wdXRlIHRoZSBpbWFnZSBjb29yZGluYXRlcyB0aGF0IHRoZSB2aWV3IHJheSBwb2ludHMgaW50by5cbiAgdmFyIHggPSAwLjUgKyByYXlbMF07XG4gIHZhciB5ID0gMC41IC0gcmF5WzFdO1xuXG4gIC8vIEdldCB0aGUgZGVzaXJlZCB6b29tIGxldmVsLlxuICB2YXIgdGlsZVogPSB0aGlzLmxldmVsTGlzdC5pbmRleE9mKGxldmVsKTtcbiAgdmFyIGxldmVsV2lkdGggPSBsZXZlbC53aWR0aCgpO1xuICB2YXIgbGV2ZWxIZWlnaHQgPSBsZXZlbC5oZWlnaHQoKTtcbiAgdmFyIHRpbGVXaWR0aCA9IGxldmVsLnRpbGVXaWR0aCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IGxldmVsLnRpbGVIZWlnaHQoKTtcbiAgdmFyIG51bVggPSBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIG51bVkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG5cbiAgLy8gRmluZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUgdGhhdCB0aGUgdmlldyByYXkgcG9pbnRzIGludG8uXG4gIHZhciB0aWxlWCA9IGNsYW1wKE1hdGguZmxvb3IoeCAqIGxldmVsV2lkdGggLyB0aWxlV2lkdGgpLCAwLCBudW1YIC0gMSk7XG4gIHZhciB0aWxlWSA9IGNsYW1wKE1hdGguZmxvb3IoeSAqIGxldmVsSGVpZ2h0IC8gdGlsZUhlaWdodCksIDAsIG51bVkgLSAxKTtcblxuICByZXR1cm4gbmV3IEZsYXRUaWxlKHRpbGVYLCB0aWxlWSwgdGlsZVosIHRoaXMpO1xufTtcblxuXG5GbGF0R2VvbWV0cnkucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsLCByZXN1bHQpIHtcbiAgdmFyIHZpZXdTaXplID0gdGhpcy5fdmlld1NpemU7XG4gIHZhciB0aWxlU2VhcmNoZXIgPSB0aGlzLl90aWxlU2VhcmNoZXI7XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gIHZpZXcuc2l6ZSh2aWV3U2l6ZSk7XG4gIGlmICh2aWV3U2l6ZS53aWR0aCA9PT0gMCB8fCB2aWV3U2l6ZS5oZWlnaHQgPT09IDApIHtcbiAgICAvLyBObyB0aWxlcyBhcmUgdmlzaWJsZSBpZiB0aGUgdmlld3BvcnQgaXMgZW1wdHkuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBzdGFydGluZ1RpbGUgPSB0aGlzLl9jbG9zZXN0VGlsZSh2aWV3LCBsZXZlbCk7XG4gIHZhciBjb3VudCA9IHRpbGVTZWFyY2hlci5zZWFyY2godmlldywgc3RhcnRpbmdUaWxlLCByZXN1bHQpO1xuICBpZiAoIWNvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFydGluZyB0aWxlIGlzIG5vdCB2aXNpYmxlJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5GbGF0R2VvbWV0cnkuVGlsZSA9IEZsYXRHZW9tZXRyeS5wcm90b3R5cGUuVGlsZSA9IEZsYXRUaWxlO1xuRmxhdEdlb21ldHJ5LnR5cGUgPSBGbGF0R2VvbWV0cnkucHJvdG90eXBlLnR5cGUgPSAnZmxhdCc7XG5GbGF0VGlsZS50eXBlID0gRmxhdFRpbGUucHJvdG90eXBlLnR5cGUgPSAnZmxhdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGbGF0R2VvbWV0cnk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIExldmVsKGxldmVsUHJvcGVydGllcykge1xuICB0aGlzLl9mYWxsYmFja09ubHkgPSAhIWxldmVsUHJvcGVydGllcy5mYWxsYmFja09ubHk7XG59XG5cbkxldmVsLnByb3RvdHlwZS5udW1Ib3Jpem9udGFsVGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLndpZHRoKCkgLyB0aGlzLnRpbGVXaWR0aCgpKTtcbn07XG5cbkxldmVsLnByb3RvdHlwZS5udW1WZXJ0aWNhbFRpbGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLmNlaWwodGhpcy5oZWlnaHQoKSAvIHRoaXMudGlsZUhlaWdodCgpKTtcbn07XG5cbkxldmVsLnByb3RvdHlwZS5mYWxsYmFja09ubHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrT25seTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGV2ZWw7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY21wID0gcmVxdWlyZSgnLi4vdXRpbC9jbXAnKTtcblxuZnVuY3Rpb24gbWFrZUxldmVsTGlzdChsZXZlbFByb3BlcnRpZXNMaXN0LCBMZXZlbENsYXNzKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbFByb3BlcnRpZXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKG5ldyBMZXZlbENsYXNzKGxldmVsUHJvcGVydGllc0xpc3RbaV0pKTtcbiAgfVxuXG4gIGxpc3Quc29ydChmdW5jdGlvbihsZXZlbDEsIGxldmVsMikge1xuICAgIHJldHVybiBjbXAobGV2ZWwxLndpZHRoKCksIGxldmVsMi53aWR0aCgpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KGxldmVsTGlzdCkge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFsZXZlbExpc3RbaV0uX2ZhbGxiYWNrT25seSkge1xuICAgICAgbGlzdC5wdXNoKGxldmVsTGlzdFtpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFsaXN0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VsZWN0YWJsZSBsZXZlbHMgaW4gbGlzdCcpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYWtlTGV2ZWxMaXN0OiBtYWtlTGV2ZWxMaXN0LFxuICBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdDogbWFrZVNlbGVjdGFibGVMZXZlbExpc3Rcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8vIFN0YWdlcy5cbiAgV2ViR2xTdGFnZTogcmVxdWlyZSgnLi9zdGFnZXMvV2ViR2wnKSxcbiAgQ3NzU3RhZ2U6IHJlcXVpcmUoJy4vc3RhZ2VzL0NzcycpLFxuICBGbGFzaFN0YWdlOiByZXF1aXJlKCcuL3N0YWdlcy9GbGFzaCcpLFxuXG4gIC8vIFJlbmRlcmVycy5cbiAgV2ViR2xDdWJlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXJzL1dlYkdsQ3ViZScpLFxuICBXZWJHbEZsYXRSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcnMvV2ViR2xGbGF0JyksXG4gIFdlYkdsRXF1aXJlY3RSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcnMvV2ViR2xFcXVpcmVjdCcpLFxuICBDc3NDdWJlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXJzL0Nzc0N1YmUnKSxcbiAgQ3NzRmxhdFJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy9Dc3NGbGF0JyksXG4gIEZsYXNoQ3ViZVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy9GbGFzaEN1YmUnKSxcbiAgRmxhc2hGbGF0UmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXJzL0ZsYXNoRmxhdCcpLFxuICByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnM6IHJlcXVpcmUoJy4vcmVuZGVyZXJzL3JlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycycpLFxuXG4gIC8vIEdlb21ldHJpZXMuXG4gIEN1YmVHZW9tZXRyeTogcmVxdWlyZSgnLi9nZW9tZXRyaWVzL0N1YmUnKSxcbiAgRmxhdEdlb21ldHJ5OiByZXF1aXJlKCcuL2dlb21ldHJpZXMvRmxhdCcpLFxuICBFcXVpcmVjdEdlb21ldHJ5OiByZXF1aXJlKCcuL2dlb21ldHJpZXMvRXF1aXJlY3QnKSxcblxuICAvLyBWaWV3cy5cbiAgUmVjdGlsaW5lYXJWaWV3OiByZXF1aXJlKCcuL3ZpZXdzL1JlY3RpbGluZWFyJyksXG4gIEZsYXRWaWV3OiByZXF1aXJlKCcuL3ZpZXdzL0ZsYXQnKSxcblxuICAvLyBTb3VyY2VzLlxuICBJbWFnZVVybFNvdXJjZTogcmVxdWlyZSgnLi9zb3VyY2VzL0ltYWdlVXJsJyksXG4gIFNpbmdsZUFzc2V0U291cmNlOiByZXF1aXJlKCcuL3NvdXJjZXMvU2luZ2xlQXNzZXQnKSxcblxuICAvLyBBc3NldHMuXG4gIFN0YXRpY0Fzc2V0OiByZXF1aXJlKCcuL2Fzc2V0cy9TdGF0aWMnKSxcbiAgRHluYW1pY0Fzc2V0OiByZXF1aXJlKCcuL2Fzc2V0cy9EeW5hbWljJyksXG5cbiAgLy8gVGV4dHVyZSBzdG9yZS5cbiAgVGV4dHVyZVN0b3JlOiByZXF1aXJlKCcuL1RleHR1cmVTdG9yZScpLFxuXG4gIC8vIExheWVyLlxuICBMYXllcjogcmVxdWlyZSgnLi9MYXllcicpLFxuXG4gIC8vIFJlbmRlciBsb29wLlxuICBSZW5kZXJMb29wOiByZXF1aXJlKCcuL1JlbmRlckxvb3AnKSxcblxuICAvLyBDb250cm9scy5cbiAgS2V5Q29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9LZXknKSxcbiAgRHJhZ0NvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvRHJhZycpLFxuICBRdHZyQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9RdHZyJyksXG4gIFNjcm9sbFpvb21Db250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1Njcm9sbFpvb20nKSxcbiAgUGluY2hab29tQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9QaW5jaFpvb20nKSxcbiAgVmVsb2NpdHlDb250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1ZlbG9jaXR5JyksXG4gIEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvRWxlbWVudFByZXNzJyksXG4gIENvbnRyb2xzOiByZXF1aXJlKCcuL2NvbnRyb2xzL0NvbnRyb2xzJyksXG4gIER5bmFtaWNzOiByZXF1aXJlKCcuL2NvbnRyb2xzL0R5bmFtaWNzJyksXG5cbiAgLy8gSGlnaC1sZXZlbCBBUEkuXG4gIFZpZXdlcjogcmVxdWlyZSgnLi9WaWV3ZXInKSxcbiAgU2NlbmU6IHJlcXVpcmUoJy4vU2NlbmUnKSxcblxuICAvLyBIb3RzcG90cy5cbiAgSG90c3BvdDogcmVxdWlyZSgnLi9Ib3RzcG90JyksXG4gIEhvdHNwb3RDb250YWluZXI6IHJlcXVpcmUoJy4vSG90c3BvdENvbnRhaW5lcicpLFxuXG4gIC8vIEVmZmVjdHMuXG4gIGNvbG9yRWZmZWN0czogcmVxdWlyZSgnLi9jb2xvckVmZmVjdHMnKSxcblxuICAvLyBNaXNjZWxsYW5lb3VzIGZ1bmN0aW9ucy5cbiAgcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHM6IHJlcXVpcmUoJy4vY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMnKSxcbiAgYXV0b3JvdGF0ZTogcmVxdWlyZSgnLi9hdXRvcm90YXRlJyksXG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnMuXG4gIHV0aWw6IHtcbiAgICBhc3luYzogcmVxdWlyZSgnLi91dGlsL2FzeW5jJyksXG4gICAgY2FuY2VsaXplOiByZXF1aXJlKCcuL3V0aWwvY2FuY2VsaXplJyksXG4gICAgY2hhaW46IHJlcXVpcmUoJy4vdXRpbC9jaGFpbicpLFxuICAgIGNsYW1wOiByZXF1aXJlKCcuL3V0aWwvY2xhbXAnKSxcbiAgICBjbGVhck93blByb3BlcnRpZXM6IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKSxcbiAgICBjbXA6IHJlcXVpcmUoJy4vdXRpbC9jbXAnKSxcbiAgICBjb21wb3NlOiByZXF1aXJlKCcuL3V0aWwvY29tcG9zZScpLFxuICAgIGNvbnZlcnRGb3Y6IHJlcXVpcmUoJy4vdXRpbC9jb252ZXJ0Rm92JyksXG4gICAgZGVjaW1hbDogcmVxdWlyZSgnLi91dGlsL2RlY2ltYWwnKSxcbiAgICBkZWZhdWx0czogcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyksXG4gICAgZGVmZXI6IHJlcXVpcmUoJy4vdXRpbC9kZWZlcicpLFxuICAgIGRlZ1RvUmFkOiByZXF1aXJlKCcuL3V0aWwvZGVnVG9SYWQnKSxcbiAgICBkZWxheTogcmVxdWlyZSgnLi91dGlsL2RlbGF5JyksXG4gICAgZG9tOiByZXF1aXJlKCcuL3V0aWwvZG9tJyksXG4gICAgZXh0ZW5kOiByZXF1aXJlKCcuL3V0aWwvZXh0ZW5kJyksXG4gICAgaGFzaDogcmVxdWlyZSgnLi91dGlsL2hhc2gnKSxcbiAgICBpbmhlcml0czogcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyksXG4gICAgbW9kOiByZXF1aXJlKCcuL3V0aWwvbW9kJyksXG4gICAgbm9vcDogcmVxdWlyZSgnLi91dGlsL25vb3AnKSxcbiAgICBub3c6IHJlcXVpcmUoJy4vdXRpbC9ub3cnKSxcbiAgICBvbmNlOiByZXF1aXJlKCcuL3V0aWwvb25jZScpLFxuICAgIHBpeGVsUmF0aW86IHJlcXVpcmUoJy4vdXRpbC9waXhlbFJhdGlvJyksXG4gICAgcmFkVG9EZWc6IHJlcXVpcmUoJy4vdXRpbC9yYWRUb0RlZycpLFxuICAgIHJlYWw6IHJlcXVpcmUoJy4vdXRpbC9yZWFsJyksXG4gICAgcmV0cnk6IHJlcXVpcmUoJy4vdXRpbC9yZXRyeScpLFxuICAgIHR3ZWVuOiByZXF1aXJlKCcuL3V0aWwvdHdlZW4nKSxcbiAgICB0eXBlOiByZXF1aXJlKCcuL3V0aWwvdHlwZScpXG4gIH0sXG5cbiAgLy8gRXhwb3NlIGRlcGVuZGVuY2llcyBmb3IgY2xpZW50cyB0byB1c2UuXG4gIGRlcGVuZGVuY2llczoge1xuICAgIGJvd3NlcjogcmVxdWlyZSgnYm93c2VyJyksXG4gICAgZ2xNYXRyaXg6IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLFxuICAgIGV2ZW50RW1pdHRlcjogcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyksXG4gICAgaGFtbWVyanM6IHJlcXVpcmUoJ2hhbW1lcmpzJylcbiAgfVxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEZsYXNoQXNzZXQgPSByZXF1aXJlKCcuLi9hc3NldHMvRmxhc2gnKTtcbnZhciBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCcuLi9OZXR3b3JrRXJyb3InKTtcbnZhciBvbmNlID0gcmVxdWlyZSgnLi4vdXRpbC9vbmNlJyk7XG5cbi8vIFRPRE86IE1vdmUgdGhlIGxvYWQgcXVldWUgaW50byB0aGUgbG9hZGVyLlxuXG4vKipcbiAqIEBjbGFzcyBGbGFzaEltYWdlTG9hZGVyXG4gKiBAaW1wbGVtZW50cyBJbWFnZUxvYWRlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIExvYWRlcn0gZm9yIEZsYXNoIGltYWdlcy5cbiAqXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgc3RhZ2Ugd2hpY2ggaXMgZ29pbmcgdG8gcmVxdWVzdCBpbWFnZXMgdG8gYmUgbG9hZGVkLlxuICovXG5mdW5jdGlvbiBGbGFzaEltYWdlTG9hZGVyKHN0YWdlKSB7XG4gIGlmIChzdGFnZS50eXBlICE9PSAnZmxhc2gnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSB0eXBlIGluY29tcGF0aWJsZSB3aXRoIGxvYWRlcicpO1xuICB9XG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG59XG5cbi8qKlxuICogTG9hZHMgYW4ge0BsaW5rIEFzc2V0fSBmcm9tIGFuIGltYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgaW1hZ2UgVVJMLlxuICogQHBhcmFtIHs/UmVjdH0gcmVjdCBBIHtAbGluayBSZWN0fSBkZXNjcmliaW5nIGEgcG9ydGlvbiBvZiB0aGUgaW1hZ2UsIG9yIG51bGxcbiAqICAgICB0byB1c2UgdGhlIGZ1bGwgaW1hZ2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgQXNzZXQpfSBkb25lIFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IEEgZnVuY3Rpb24gdG8gY2FuY2VsIGxvYWRpbmcuXG4gKi9cbkZsYXNoSW1hZ2VMb2FkZXIucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVybCwgcmVjdCwgZG9uZSkge1xuICB2YXIgc3RhZ2UgPSB0aGlzLl9zdGFnZTtcbiAgdmFyIGZsYXNoRWxlbWVudCA9IHN0YWdlLmZsYXNoRWxlbWVudCgpO1xuXG4gIHZhciB4ID0gcmVjdCAmJiByZWN0LnggfHwgMDtcbiAgdmFyIHkgPSByZWN0ICYmIHJlY3QueSB8fCAwO1xuICB2YXIgd2lkdGggPSByZWN0ICYmIHJlY3Qud2lkdGggfHwgMTtcbiAgdmFyIGhlaWdodCA9IHJlY3QgJiYgcmVjdC5oZWlnaHQgfHwgMTtcblxuICB2YXIgaW1hZ2VJZCA9IGZsYXNoRWxlbWVudC5sb2FkSW1hZ2UodXJsLCB3aWR0aCwgaGVpZ2h0LCB4LCB5KTtcblxuICBkb25lID0gb25jZShkb25lKTtcblxuICAvLyBUT0RPOiB1c2UgYSBzaW5nbGUgY2FsbGJhY2sgZm9yIGFsbCBpbWFnZUxvYWRlZCBldmVudHMuXG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soZXJyLCBjYWxsYmFja0lkKSB7XG4gICAgLy8gVGhlcmUgaXMgYSBzaW5nbGUgY2FsbGJhY2sgZm9yIGFsbCBsb2FkIGV2ZW50cywgc28gbWFrZSBzdXJlIHRoaXNcbiAgICAvLyBpcyB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChjYWxsYmFja0lkICE9PSBpbWFnZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhZ2UucmVtb3ZlRmxhc2hDYWxsYmFja0xpc3RlbmVyKCdpbWFnZUxvYWRlZCcsIGNhbGxiYWNrKTtcblxuICAgIC8vIFRPRE86IGlzIHRoZXJlIGFueSB3YXkgdG8gZGlzdGluZ3Vpc2ggYSBuZXR3b3JrIGVycm9yIGZyb20gb3RoZXJcbiAgICAvLyBraW5kcyBvZiBlcnJvcnM/IEZvciBub3cgd2UgYWx3YXlzIHJldHVybiBOZXR3b3JrRXJyb3Igc2luY2UgdGhpc1xuICAgIC8vIHByZXZlbnRzIGltYWdlcyB0byBiZSByZXRyaWVkIGNvbnRpbnVvdXNseSB3aGlsZSB3ZSBhcmUgb2ZmbGluZS5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBkb25lKG5ldyBOZXR3b3JrRXJyb3IoJ05ldHdvcmsgZXJyb3I6ICcgKyB1cmwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZShudWxsLCBuZXcgRmxhc2hBc3NldChmbGFzaEVsZW1lbnQsIGltYWdlSWQpKTtcbiAgICB9XG4gIH1cblxuICBzdGFnZS5hZGRGbGFzaENhbGxiYWNrTGlzdGVuZXIoJ2ltYWdlTG9hZGVkJywgY2FsbGJhY2spO1xuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBmbGFzaEVsZW1lbnQuY2FuY2VsSW1hZ2UoaW1hZ2VJZCk7XG4gICAgc3RhZ2UucmVtb3ZlRmxhc2hDYWxsYmFja0xpc3RlbmVyKCdpbWFnZUxvYWRlZCcsIGNhbGxiYWNrKTtcbiAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gY2FuY2VsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbGFzaEltYWdlTG9hZGVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhdGljQXNzZXQgPSByZXF1aXJlKCcuLi9hc3NldHMvU3RhdGljJyk7XG52YXIgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnLi4vTmV0d29ya0Vycm9yJyk7XG52YXIgb25jZSA9IHJlcXVpcmUoJy4uL3V0aWwvb25jZScpO1xuXG4vLyBOLkIuIEh0bWxJbWFnZUxvYWRlciBpcyBicm9rZW4gb24gSUU4IGZvciBpbWFnZXMgdGhhdCByZXF1aXJlIHJlc2l6aW5nLCBkdWVcbi8vIHRvIHRoZSB1bmF2YWlsYWJsZSBIVE1MNSBjYW52YXMgZWxlbWVudCBhbmQgdGhlIG5hdHVyYWxXaWR0aC9uYXR1cmFsSGVpZ2h0XG4vLyBwcm9wZXJ0aWVzIG9mIGltYWdlIGVsZW1lbnRzLiBUaGlzIGlzIGN1cnJlbnRseSBub3QgYSBwcm9ibGVtIGJlY2F1c2UgdGhlXG4vLyBIVE1MLWJhc2VkIHJlbmRlcmVycyAoV2ViR0wgYW5kIENTUykgZG8gbm90IHdvcmsgb24gSUU4IGFueXdheS4gSXQgY291bGRcbi8vIGJlY29tZSBhIHByb2JsZW0gaW4gdGhlIGZ1dHVyZSBpZiB3ZSBkZWNpZGUgdG8gc3VwcG9ydCBDU1MgcmVuZGVyaW5nIG9mIGZsYXRcbi8vIHBhbm9yYW1hcyBvbiBJRTguXG5cbi8vIFRPRE86IE1vdmUgdGhlIGxvYWQgcXVldWUgaW50byB0aGUgbG9hZGVyLlxuXG4vKipcbiAqIEBjbGFzcyBIdG1sSW1hZ2VMb2FkZXJcbiAqIEBpbXBsZW1lbnRzIEltYWdlTG9hZGVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgTG9hZGVyfSBmb3IgSFRNTCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHN0YWdlIHdoaWNoIGlzIGdvaW5nIHRvIHJlcXVlc3QgaW1hZ2VzIHRvIGJlIGxvYWRlZC5cbiAqL1xuZnVuY3Rpb24gSHRtbEltYWdlTG9hZGVyKHN0YWdlKSB7XG4gIGlmIChzdGFnZS50eXBlICE9PSAnd2ViZ2wnICYmIHN0YWdlLnR5cGUgIT09ICdjc3MnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSB0eXBlIGluY29tcGF0aWJsZSB3aXRoIGxvYWRlcicpO1xuICB9XG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG59XG5cbi8qKlxuICogTG9hZHMgYW4ge0BsaW5rIEFzc2V0fSBmcm9tIGFuIGltYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgaW1hZ2UgVVJMLlxuICogQHBhcmFtIHs/UmVjdH0gcmVjdCBBIHtAbGluayBSZWN0fSBkZXNjcmliaW5nIGEgcG9ydGlvbiBvZiB0aGUgaW1hZ2UsIG9yIG51bGxcbiAqICAgICB0byB1c2UgdGhlIGZ1bGwgaW1hZ2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgQXNzZXQpfSBkb25lIFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IEEgZnVuY3Rpb24gdG8gY2FuY2VsIGxvYWRpbmcuXG4gKi9cbkh0bWxJbWFnZUxvYWRlci5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJsLCByZWN0LCBkb25lKSB7XG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAvLyBBbGxvdyBjcm9zcy1kb21haW4gaW1hZ2UgbG9hZGluZy5cbiAgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBiZSBhYmxlIHRvIGNyZWF0ZSBXZWJHTCB0ZXh0dXJlcyBmcm9tIGltYWdlcyBmZXRjaGVkXG4gIC8vIGZyb20gYSBkaWZmZXJlbnQgZG9tYWluLiBOb3RlIHRoYXQgc2V0dGluZyB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIHRvXG4gIC8vICdhbm9ueW1vdXMnIHdpbGwgdHJpZ2dlciBhIENPUlMgcHJlZmxpZ2h0IGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIGJ1dCBub1xuICAvLyBjcmVkZW50aWFscyAoY29va2llcyBvciBIVFRQIGF1dGgpIHdpbGwgYmUgc2VudDsgdG8gZG8gc28sIHRoZSBhdHRyaWJ1dGVcbiAgLy8gd291bGQgaGF2ZSB0byBiZSBzZXQgdG8gJ3VzZS1jcmVkZW50aWFscycgaW5zdGVhZC4gVW5mb3J0dW5hdGVseSwgdGhpcyBpc1xuICAvLyBub3QgYSBzYWZlIGNob2ljZSwgYXMgaXQgY2F1c2VzIHJlcXVlc3RzIHRvIGZhaWwgd2hlbiB0aGUgcmVzcG9uc2UgY29udGFpbnNcbiAgLy8gYW4gQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luIGhlYWRlciB3aXRoIGEgd2lsZGNhcmQuIFNlZSB0aGUgc2VjdGlvblxuICAvLyBcIkNyZWRlbnRpYWxlZCByZXF1ZXN0cyBhbmQgd2lsZGNhcmRzXCIgb246XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQ09SU1xuICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICB2YXIgeCA9IHJlY3QgJiYgcmVjdC54IHx8IDA7XG4gIHZhciB5ID0gcmVjdCAmJiByZWN0LnkgfHwgMDtcbiAgdmFyIHdpZHRoID0gcmVjdCAmJiByZWN0LndpZHRoIHx8IDE7XG4gIHZhciBoZWlnaHQgPSByZWN0ICYmIHJlY3QuaGVpZ2h0IHx8IDE7XG5cbiAgZG9uZSA9IG9uY2UoZG9uZSk7XG5cbiAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgd2lkdGggPT09IDEgJiYgaGVpZ2h0ID09PSAxKSB7XG4gICAgICBkb25lKG51bGwsIG5ldyBTdGF0aWNBc3NldChpbWcpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB4ICo9IGltZy5uYXR1cmFsV2lkdGg7XG4gICAgICB5ICo9IGltZy5uYXR1cmFsSGVpZ2h0O1xuICAgICAgd2lkdGggKj0gaW1nLm5hdHVyYWxXaWR0aDtcbiAgICAgIGhlaWdodCAqPSBpbWcubmF0dXJhbEhlaWdodDtcblxuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgZG9uZShudWxsLCBuZXcgU3RhdGljQXNzZXQoY2FudmFzKSk7XG4gICAgfVxuICB9O1xuXG4gIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYW55IHdheSB0byBkaXN0aW5ndWlzaCBhIG5ldHdvcmsgZXJyb3IgZnJvbSBvdGhlclxuICAgIC8vIGtpbmRzIG9mIGVycm9ycz8gRm9yIG5vdyB3ZSBhbHdheXMgcmV0dXJuIE5ldHdvcmtFcnJvciBzaW5jZSB0aGlzXG4gICAgLy8gcHJldmVudHMgaW1hZ2VzIHRvIGJlIHJldHJpZWQgY29udGludW91c2x5IHdoaWxlIHdlIGFyZSBvZmZsaW5lLlxuICAgIGRvbmUobmV3IE5ldHdvcmtFcnJvcignTmV0d29yayBlcnJvcjogJyArIHVybCkpO1xuICB9O1xuXG4gIGltZy5zcmMgPSB1cmw7XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgaW1nLnNyYyA9ICcnO1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxJbWFnZUxvYWRlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1hcCA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL01hcCcpO1xudmFyIGRlY2ltYWwgPSByZXF1aXJlKCcuLi91dGlsL2RlY2ltYWwnKTtcbnZhciBzZXRPdmVyZmxvd0hpZGRlbiA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0T3ZlcmZsb3dIaWRkZW47XG52YXIgc2V0Tm9Qb2ludGVyRXZlbnRzID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKS5zZXROb1BvaW50ZXJFdmVudHM7XG52YXIgc2V0TnVsbFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0TnVsbFRyYW5zZm9ybTtcbnZhciBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldFRyYW5zZm9ybTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVidWcgPSB0eXBlb2YgTUFSWklQQU5PREVCVUcgIT09ICd1bmRlZmluZWQnICYmIE1BUlpJUEFOT0RFQlVHLmNzcztcblxuXG5mdW5jdGlvbiB0aWxlQ21wKGEsIGIpIHtcbiAgcmV0dXJuIGEuY21wKGIpO1xufVxuXG5cbmZ1bmN0aW9uIENzc0Jhc2VSZW5kZXJlcihyb290LCBxdWlya3MsIHRpbGVDbGFzcykge1xuXG4gIHRoaXMuX3Jvb3QgPSByb290O1xuXG4gIHRoaXMuX2Jyb3dzZXJRdWlya3MgPSBxdWlya3M7XG5cbiAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciB0aGlzIHJlbmRlcmVyJ3MgdGlsZXMsIHNvIHdlIGNhbiBzdHlsZSB0aGVtXG4gIC8vIGFzIGEgd2hvbGUgc2VwYXJhdGVseSBmcm9tIG90aGVyIHJlbmRlcmVycyBpbiB0aGUgc2FtZSBzdGFnZS5cbiAgdmFyIGRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcm9vdC5hcHBlbmRDaGlsZChkb21FbGVtZW50KTtcblxuICBkb21FbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAvLyBGb3Igc29tZSB3ZWlyZCByZWFzb24sIHRoaXMgcHJldmVudHMgZmxpY2tlcmluZyBvbiBTYWZhcmkgRGVza3RvcC5cbiAgc2V0T3ZlcmZsb3dIaWRkZW4oZG9tRWxlbWVudCk7XG5cbiAgLy8gUHJldmVudCB0b3VjaCBldmVudHMgb24gdGlsZXMgZnJvbSBtZXNzaW5nIHVwIHBpbmNoaW5nIGdlc3R1cmVzIG9uIGlPUy5cbiAgc2V0Tm9Qb2ludGVyRXZlbnRzKGRvbUVsZW1lbnQpO1xuXG4gIGlmICh0aGlzLl9icm93c2VyUXVpcmtzLnVzZU51bGxUcmFuc2Zvcm0pIHtcbiAgICBzZXROdWxsVHJhbnNmb3JtKGRvbUVsZW1lbnQpO1xuICB9XG5cbiAgdGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuICB0aGlzLl9vbGRUaWxlTGlzdCA9IFtdO1xuICB0aGlzLl9uZXdUaWxlTGlzdCA9IFtdO1xuXG4gIHRoaXMuX3RleHR1cmVNYXAgPSBuZXcgTWFwKCk7XG59XG5cblxuQ3NzQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jvb3QucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5Dc3NCYXNlUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgcmVjdCkge1xuICB2YXIgZG9tRWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudDtcblxuICAvLyBTZXQgdmlld3BvcnQgZWZmZWN0LlxuICB2YXIgc3RhZ2VXaWR0aCA9IHRoaXMuX3Jvb3QuY2xpZW50V2lkdGg7XG4gIHZhciBzdGFnZUhlaWdodCA9IHRoaXMuX3Jvb3QuY2xpZW50SGVpZ2h0O1xuICBkb21FbGVtZW50LnN0eWxlLmxlZnQgPSBkZWNpbWFsKHN0YWdlV2lkdGggKiByZWN0LmxlZnQpICsgJ3B4JztcbiAgZG9tRWxlbWVudC5zdHlsZS50b3AgPSBkZWNpbWFsKHN0YWdlSGVpZ2h0ICogcmVjdC50b3ApICsgJ3B4JztcbiAgZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IGRlY2ltYWwoc3RhZ2VXaWR0aCAqIHJlY3Qud2lkdGgpICsgJ3B4JztcbiAgZG9tRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBkZWNpbWFsKHN0YWdlSGVpZ2h0ICogcmVjdC5oZWlnaHQpICsgJ3B4JztcblxuICAvLyBTZXQgb3BhY2l0eSBlZmZlY3QuXG4gIHZhciBvcGFjaXR5ID0gMS4wO1xuICB2YXIgZWZmZWN0cyA9IGxheWVyLmVmZmVjdHMoKTtcbiAgaWYgKGVmZmVjdHMgJiYgZWZmZWN0cy5vcGFjaXR5ICE9IG51bGwpIHtcbiAgICBvcGFjaXR5ID0gZWZmZWN0cy5vcGFjaXR5O1xuICB9XG4gIGRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgLy8gQ2xlYXIgdGVtcG9yYXJ5IHZhcmlhYmxlcy5cbiAgdGhpcy5fbmV3VGlsZUxpc3QubGVuZ3RoID0gMDtcbiAgdGhpcy5fdGV4dHVyZU1hcC5jbGVhcigpO1xufTtcblxuXG5Dc3NCYXNlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRpbGUgPSBmdW5jdGlvbih0aWxlLCB0ZXh0dXJlKSB7XG4gIHRoaXMuX25ld1RpbGVMaXN0LnB1c2godGlsZSk7XG4gIHRoaXMuX3RleHR1cmVNYXAuc2V0KHRpbGUsIHRleHR1cmUpO1xufTtcblxuXG5Dc3NCYXNlUmVuZGVyZXIucHJvdG90eXBlLmVuZExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcblxuICB2YXIgZG9tRWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudDtcbiAgdmFyIG9sZFRpbGVMaXN0ID0gdGhpcy5fb2xkVGlsZUxpc3Q7XG4gIHZhciBuZXdUaWxlTGlzdCA9IHRoaXMuX25ld1RpbGVMaXN0O1xuICB2YXIgdGV4dHVyZU1hcCA9IHRoaXMuX3RleHR1cmVNYXA7XG4gIHZhciBvbGRJbmRleCwgbmV3SW5kZXgsIG9sZFRpbGUsIG5ld1RpbGU7XG4gIHZhciB0ZXh0dXJlLCBjYW52YXM7XG4gIHZhciBjdXJyZW50Tm9kZSwgbmV4dE5vZGU7XG5cbiAgdmFyIHZpZXcgPSBsYXllci52aWV3KCk7XG5cbiAgLy8gSXRlcmF0ZSB0aGUgb2xkIGFuZCBuZXcgdGlsZSBsaXN0cyBpbiBhIGNvbnNpc3RlbnQgb3JkZXIgYW5kIHBlcmZvcm1cbiAgLy8gaW5zZXJ0aW9ucyBhbmQgcmVtb3ZhbHMgYXMgd2UgZ28uIFRoaXMgbWluaW1pemVzIHRoZSBudW1iZXIgb2YgRE9NXG4gIC8vIG9wZXJhdGlvbnMgcGVyZm9ybWVkLlxuXG4gIC8vIE5laXRoZXIgdGhlIHRpbGUgbGlzdCBub3IgdGhlIHRleHR1cmUgbGlzdCBtYXkgY29udGFpbiBkdXBsaWNhdGVzLFxuICAvLyBvdGhlcndpc2UgdGhpcyBsb2dpYyB3aWxsIGZhaWwuXG5cbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmIChkb21FbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAhPT0gb2xkVGlsZUxpc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdET00gbm90IGluIHN5bmMgd2l0aCB0aWxlIGxpc3QnKTtcbiAgfVxuXG4gIG5ld1RpbGVMaXN0LnNvcnQodGlsZUNtcCk7XG5cbiAgb2xkSW5kZXggPSAwO1xuICBvbGRUaWxlID0gb2xkVGlsZUxpc3Rbb2xkSW5kZXhdO1xuICBjdXJyZW50Tm9kZSA9IGRvbUVsZW1lbnQuZmlyc3RDaGlsZDtcblxuICBmb3IgKG5ld0luZGV4ID0gMDsgbmV3SW5kZXggPCBuZXdUaWxlTGlzdC5sZW5ndGg7IG5ld0luZGV4KyspIHtcblxuICAgIG5ld1RpbGUgPSBuZXdUaWxlTGlzdFtuZXdJbmRleF07XG5cbiAgICAvLyBJdGVyYXRlIG9sZCBsaXN0IHVudGlsIGl0IGNhdGNoZXMgdXAgd2l0aCB0aGUgbmV3IGxpc3QuXG4gICAgd2hpbGUgKG9sZEluZGV4IDwgb2xkVGlsZUxpc3QubGVuZ3RoKSB7XG5cbiAgICAgIGlmIChvbGRUaWxlLmNtcChuZXdUaWxlKSA+PSAwKSB7XG4gICAgICAgIC8vIENhdWdodCB1cC5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIFRpbGUgaXMgbm8gbG9uZ2VyIHZpc2libGUuXG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgRE9NLlxuICAgICAgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQ2hpbGQoY3VycmVudE5vZGUpO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgIG9sZFRpbGUgPSBvbGRUaWxlTGlzdFsrK29sZEluZGV4XTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHRleHR1cmUgZm9yIHRoZSBjdXJyZW50IHRpbGUuXG4gICAgdGV4dHVyZSA9IHRleHR1cmVNYXAuZ2V0KG5ld1RpbGUpO1xuICAgIGNhbnZhcyA9IHRleHR1cmUgPyB0ZXh0dXJlLl9jYW52YXMgOiBudWxsO1xuXG4gICAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyaW5nIHRpbGUgd2l0aCBtaXNzaW5nIHRleHR1cmUnKTtcbiAgICB9XG5cbiAgICBpZiAob2xkVGlsZSAmJiBvbGRUaWxlLmNtcChuZXdUaWxlKSA9PT0gMCkge1xuICAgICAgLy8gVGhlIG9sZCBhbmQgbmV3IHRpbGUgYXJlIHRoZSBzYW1lLlxuXG4gICAgICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgICAgIGlmIChjYW52YXMgIT0gY3VycmVudE5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdET00gbm90IGluIHN5bmMgd2l0aCB0aWxlIGxpc3QnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICAgIG9sZFRpbGUgPSBvbGRUaWxlTGlzdFsrK29sZEluZGV4XTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbmV3IHRpbGUgY29tZXMgYmVmb3JlIHRoZSBvbGQgdGlsZS5cbiAgICAgIC8vIEluc2VydCBpdCBpbnRvIHRoZSBET00uXG4gICAgICBkb21FbGVtZW50Lmluc2VydEJlZm9yZShjYW52YXMsIGN1cnJlbnROb2RlKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIENTUyB0cmFuc2Zvcm0gb24gdGhlIGN1cnJlbnQgdGlsZS5cbiAgICBzZXRUcmFuc2Zvcm0oY2FudmFzLCB0aGlzLmNhbGN1bGF0ZVRyYW5zZm9ybShuZXdUaWxlLCB0ZXh0dXJlLCB2aWV3KSk7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGlsZScsIG5ld1RpbGUuc3RyKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB0aWxlcyB0aGF0IGFyZSBubyBsb25nZXIgdmlzaWJsZSBmcm9tIHRoZSBET00uXG4gIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgIG5leHROb2RlID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgZG9tRWxlbWVudC5yZW1vdmVDaGlsZChjdXJyZW50Tm9kZSk7XG4gICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxuXG4gIC8vIENvbnNpc3RlbnR5IGNoZWNrLlxuICBpZiAoZG9tRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggIT09IG5ld1RpbGVMaXN0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRE9NIG5vdCBpbiBzeW5jIHdpdGggdGlsZSBsaXN0Jyk7XG4gIH1cblxuICAvLyBUaGUgb2xkIGFuZCBuZXcgdGlsZSBsaXN0cyBzd2FwIHJvbGVzIGJldHdlZW4gaXRlcmF0aW9ucy5cbiAgdmFyIHRtcCA9IHRoaXMuX29sZFRpbGVMaXN0O1xuICB0aGlzLl9vbGRUaWxlTGlzdCA9IHRoaXMuX25ld1RpbGVMaXN0O1xuICB0aGlzLl9uZXdUaWxlTGlzdCA9IHRtcDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDc3NCYXNlUmVuZGVyZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdWJlVGlsZSA9IHJlcXVpcmUoJy4uL2dlb21ldHJpZXMvQ3ViZScpLlRpbGU7XG52YXIgQ3NzQmFzZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9Dc3NCYXNlJyk7XG52YXIgZGVjaW1hbCA9IHJlcXVpcmUoJy4uL3V0aWwvZGVjaW1hbCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xuXG5cbi8qKlxuICogQGNsYXNzIENzc0N1YmVSZW5kZXJlclxuICogQGltcGxlbWVudHMgUmVuZGVyZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHJlbmRlcmVyIGZvciB7QGxpbmsgQ3ViZUdlb21ldHJ5fSBhbmQge0BsaW5rIFJlY3RpbGluZWFyVmlld30sIGFwcHJvcHJpYXRlXG4gKiBmb3IgYSB7QGxpbmsgQ3NzU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBDc3NDdWJlUmVuZGVyZXIocm9vdCwgcXVpcmtzKSB7XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmNhbGwodGhpcywgcm9vdCwgcXVpcmtzLCBDdWJlVGlsZSk7XG59XG5cbmluaGVyaXRzKENzc0N1YmVSZW5kZXJlciwgQ3NzQmFzZVJlbmRlcmVyKTtcblxuXG5Dc3NDdWJlUmVuZGVyZXIucHJvdG90eXBlLmNhbGN1bGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmUsIHZpZXcpIHtcblxuICB2YXIgcGFkU2l6ZSA9IHRoaXMuX2Jyb3dzZXJRdWlya3MucGFkU2l6ZTtcbiAgdmFyIHJldmVyc2VMZXZlbERlcHRoID0gdGhpcy5fYnJvd3NlclF1aXJrcy5yZXZlcnNlTGV2ZWxEZXB0aDtcbiAgdmFyIHBlcnNwZWN0aXZlTnVkZ2UgPSB0aGlzLl9icm93c2VyUXVpcmtzLnBlcnNwZWN0aXZlTnVkZ2U7XG5cbiAgdmFyIHRyYW5zZm9ybSA9ICcnO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgY3ViZSBzaXplIGZvciB0aGlzIGxldmVsLlxuICB2YXIgY3ViZVNpemUgPSByZXZlcnNlTGV2ZWxEZXB0aCA/IDI1NiAtIHRpbGUueiA6IHRpbGUubGV2ZWxXaWR0aCgpO1xuXG4gIC8vIFBsYWNlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aWxlIGF0IHZpZXdwb3J0IGNlbnRlciB0byBzZXJ2ZSBhcyB0aGUgY2VudGVyXG4gIC8vIG9mIHJvdGF0aW9uLlxuICAvLyBXZSBkbyBub3Qgcm90YXRlIGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIHRpbGUgYmVjYXVzZSwgZm9yIHNvbWUgbXlzdGVyaW91c1xuICAvLyByZWFzb24sIHRoaXMgc2VlbXMgdG8gb2NjYXNpb25hbGx5IGNyYXNoIENocm9tZS5cbiAgdmFyIHNpemUgPSB2aWV3LnNpemUoKTtcbiAgdmFyIHZpZXdwb3J0V2lkdGggPSBzaXplLndpZHRoO1xuICB2YXIgdmlld3BvcnRIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGUzZCgnICsgZGVjaW1hbCh2aWV3cG9ydFdpZHRoLzIpICsgJ3B4LCAnICsgZGVjaW1hbCh2aWV3cG9ydEhlaWdodC8yKSArICdweCwgMHB4KSAnO1xuXG4gIC8vIFNldCB0aGUgcGVyc3BlY3RpdmUgZGVwdGguXG4gIHZhciBwZXJzcGVjdGl2ZSA9IDAuNSAqIHZpZXdwb3J0SGVpZ2h0IC8gTWF0aC50YW4odmlldy5mb3YoKSAvIDIpO1xuICB2YXIgZGlzdGFuY2UgPSBwZXJzcGVjdGl2ZSArIHBlcnNwZWN0aXZlTnVkZ2U7XG4gIHRyYW5zZm9ybSArPSAncGVyc3BlY3RpdmUoJyArIGRlY2ltYWwocGVyc3BlY3RpdmUpICsgJ3B4KSB0cmFuc2xhdGVaKCcgKyBkZWNpbWFsKGRpc3RhbmNlKSArICdweCkgJztcblxuICAvLyBTZXQgdGhlIGNhbWVyYSByb3RhdGlvbi5cbiAgdmFyIHZpZXdSb3RaID0gLXZpZXcucm9sbCgpO1xuICB2YXIgdmlld1JvdFggPSAtdmlldy5waXRjaCgpO1xuICB2YXIgdmlld1JvdFkgPSB2aWV3LnlhdygpO1xuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVooJyArIGRlY2ltYWwodmlld1JvdFopICsgJ3JhZCkgcm90YXRlWCgnICsgZGVjaW1hbCh2aWV3Um90WCkgKyAncmFkKSByb3RhdGVZKCcgKyBkZWNpbWFsKHZpZXdSb3RZKSArICdyYWQpICc7XG5cbiAgLy8gU2V0IHRoZSBjdWJlIGZhY2Ugb3JpZW50YXRpb24uXG4gIHZhciB0aWxlUm90WCA9IC10aWxlLnJvdFgoKTtcbiAgdmFyIHRpbGVSb3RZID0gdGlsZS5yb3RZKCk7XG4gIHRyYW5zZm9ybSArPSAncm90YXRlWCgnICsgZGVjaW1hbCh0aWxlUm90WCkgKyAncmFkKSByb3RhdGVZKCcgKyBkZWNpbWFsKHRpbGVSb3RZKSArICdyYWQpICc7XG5cbiAgLy8gTW92ZSB0aWxlIGludG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgY3ViZSBmYWNlLlxuICB2YXIgY29ybmVyWCA9IHRpbGUuY2VudGVyWCgpIC0gdGlsZS5zY2FsZVgoKSAvIDI7XG4gIHZhciBjb3JuZXJZID0gLSh0aWxlLmNlbnRlclkoKSArIHRpbGUuc2NhbGVZKCkgLyAyKTtcbiAgdmFyIHRyYW5zbFggPSBjb3JuZXJYICogY3ViZVNpemU7XG4gIHZhciB0cmFuc2xZID0gY29ybmVyWSAqIGN1YmVTaXplO1xuICB2YXIgdHJhbnNsWiA9IC1jdWJlU2l6ZSAvIDI7XG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlM2QoJyArIGRlY2ltYWwodHJhbnNsWCkgKyAncHgsICcgKyBkZWNpbWFsKHRyYW5zbFkpICsgJ3B4LCAnICsgZGVjaW1hbCh0cmFuc2xaKSArICdweCkgJztcblxuICAvLyBTY2FsZSB0aWxlIGludG8gY29ycmVjdCBzaXplLlxuICBpZiAocmV2ZXJzZUxldmVsRGVwdGgpIHtcbiAgICB2YXIgc2NhbGVYID0gY3ViZVNpemUgKiB0aWxlLnNjYWxlWCgpIC8gdGlsZS53aWR0aCgpO1xuICAgIHZhciBzY2FsZVkgPSBjdWJlU2l6ZSAqIHRpbGUuc2NhbGVZKCkgLyB0aWxlLmhlaWdodCgpO1xuICAgIHRyYW5zZm9ybSArPSAnc2NhbGUoJyArIGRlY2ltYWwoc2NhbGVYKSArICcsICcgKyBkZWNpbWFsKHNjYWxlWSkgKyAnKSAnO1xuICB9XG5cbiAgLy8gQ29tcGVuc2F0ZSBmb3IgcGFkZGluZyBhcm91bmQgdGhlIHRpbGUuXG4gIHZhciBwYWRMZWZ0ID0gdGlsZS5wYWRMZWZ0KCkgPyBwYWRTaXplIDogMDtcbiAgdmFyIHBhZFRvcCA9IHRpbGUucGFkVG9wKCkgPyBwYWRTaXplIDogMDtcbiAgaWYgKHBhZExlZnQgIT09IDAgfHwgcGFkVG9wICE9PSAwKSB7XG4gICAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGUzZCgnICsgZGVjaW1hbCgtcGFkTGVmdCkgKyAncHgsICcgKyBkZWNpbWFsKC1wYWRUb3ApICsgJ3B4LCAwKSAnO1xuICB9XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTtcblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENzc0N1YmVSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEZsYXRUaWxlID0gcmVxdWlyZSgnLi4vZ2VvbWV0cmllcy9GbGF0JykuVGlsZTtcbnZhciBDc3NCYXNlUmVuZGVyZXIgPSByZXF1aXJlKCcuL0Nzc0Jhc2UnKTtcbnZhciBkZWNpbWFsID0gcmVxdWlyZSgnLi4vdXRpbC9kZWNpbWFsJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG5cblxuLyoqXG4gKiBAY2xhc3MgQ3NzRmxhdFJlbmRlcmVyXG4gKiBAaW1wbGVtZW50cyBSZW5kZXJlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgcmVuZGVyZXIgZm9yIHtAbGluayBGbGF0R2VvbWV0cnl9IGFuZCB7QGxpbmsgRmxhdFZpZXd9LCBhcHByb3ByaWF0ZSBmb3IgYVxuICoge0BsaW5rIENzc1N0YWdlfS5cbiAqXG4gKiBNb3N0IHVzZXJzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MuIFJlbmRlcmVycyBhcmUgY3JlYXRlZCBhbmRcbiAqIGRlc3Ryb3llZCBieSB7QGxpbmsgU3RhZ2V9IGFzIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gQ3NzRmxhdFJlbmRlcmVyKHJvb3QsIHF1aXJrcykge1xuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5jYWxsKHRoaXMsIHJvb3QsIHF1aXJrcywgRmxhdFRpbGUpO1xufVxuXG5pbmhlcml0cyhDc3NGbGF0UmVuZGVyZXIsIENzc0Jhc2VSZW5kZXJlcik7XG5cblxuQ3NzRmxhdFJlbmRlcmVyLnByb3RvdHlwZS5jYWxjdWxhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbih0aWxlLCB0ZXh0dXJlLCB2aWV3KSB7XG5cbiAgdmFyIHBhZFNpemUgPSB0aGlzLl9icm93c2VyUXVpcmtzLnBhZFNpemU7XG5cbiAgdmFyIHRyYW5zZm9ybSA9ICcnO1xuXG4gIC8vIFBsYWNlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aWxlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LlxuICB2YXIgdmlld3BvcnRXaWR0aCA9IHZpZXcud2lkdGgoKTtcbiAgdmFyIHZpZXdwb3J0SGVpZ2h0ID0gdmlldy5oZWlnaHQoKTtcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVYKCcgKyBkZWNpbWFsKHZpZXdwb3J0V2lkdGgvMikgKyAncHgpIHRyYW5zbGF0ZVkoJyArIGRlY2ltYWwodmlld3BvcnRIZWlnaHQvMikgKyAncHgpICc7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSB6b29tIGZhY3Rvci5cbiAgdmFyIHpvb21YID0gdmlld3BvcnRXaWR0aCAvIHZpZXcuX3pvb21YKCk7XG4gIHZhciB6b29tWSA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlldy5fem9vbVkoKTtcblxuICAvLyBNb3ZlIHRpbGUgaW50byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBpbWFnZS5cbiAgdmFyIGNvcm5lclggPSB0aWxlLmNlbnRlclgoKSAtIHRpbGUuc2NhbGVYKCkgLyAyICsgMC41O1xuICB2YXIgY29ybmVyWSA9IDAuNSAtIHRpbGUuY2VudGVyWSgpIC0gdGlsZS5zY2FsZVkoKSAvIDI7XG4gIHZhciB0cmFuc2xYID0gY29ybmVyWCAqIHpvb21YO1xuICB2YXIgdHJhbnNsWSA9IGNvcm5lclkgKiB6b29tWTtcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVYKCcgKyBkZWNpbWFsKHRyYW5zbFgpICsgJ3B4KSB0cmFuc2xhdGVZKCcgKyBkZWNpbWFsKHRyYW5zbFkpICsgJ3B4KSAnO1xuXG4gIC8vIEFwcGx5IHZpZXcgb2Zmc2V0cy5cbiAgdmFyIG9mZlggPSAtdmlldy54KCkgKiB6b29tWDtcbiAgdmFyIG9mZlkgPSAtdmlldy55KCkgKiB6b29tWTtcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVYKCcgKyBkZWNpbWFsKG9mZlgpICsgJ3B4KSB0cmFuc2xhdGVZKCcgKyBkZWNpbWFsKG9mZlkpICsgJ3B4KSAnO1xuXG4gIC8vIENvbXBlbnNhdGUgZm9yIHBhZGRpbmcgYXJvdW5kIHRoZSB0aWxlLlxuICB2YXIgcGFkTGVmdCA9IHRpbGUucGFkTGVmdCgpID8gcGFkU2l6ZSA6IDA7XG4gIHZhciBwYWRUb3AgPSB0aWxlLnBhZFRvcCgpID8gcGFkU2l6ZSA6IDA7XG4gIGlmIChwYWRMZWZ0ICE9PSAwIHx8IHBhZFRvcCAhPT0gMCkge1xuICAgIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWCgnICsgZGVjaW1hbCgtcGFkTGVmdCkgKyAncHgpIHRyYW5zbGF0ZVkoJyArIGRlY2ltYWwoLXBhZFRvcCkgKyAncHgpICc7XG4gIH1cblxuICAvLyBTY2FsZSB0aWxlIGludG8gY29ycmVjdCBzaXplLlxuICB2YXIgc2NhbGVYID0gem9vbVggLyB0aWxlLmxldmVsV2lkdGgoKTtcbiAgdmFyIHNjYWxlWSA9IHpvb21ZIC8gdGlsZS5sZXZlbEhlaWdodCgpO1xuICB0cmFuc2Zvcm0gKz0gJ3NjYWxlKCcgKyBkZWNpbWFsKHNjYWxlWCkgKyAnLCAnICsgZGVjaW1hbChzY2FsZVkpICsgJykgJztcblxuICByZXR1cm4gdHJhbnNmb3JtO1xuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ3NzRmxhdFJlbmRlcmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvTWFwJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuXG5mdW5jdGlvbiB0aWxlQ21wKGEsIGIpIHtcbiAgcmV0dXJuIGEuY21wKGIpO1xufVxuXG5cbmZ1bmN0aW9uIEZsYXNoQmFzZVJlbmRlcmVyKGZsYXNoRWxlbWVudCwgbGF5ZXJJZCwgcXVpcmtzLCB0aWxlQ2xhc3MpIHtcblxuICB0aGlzLl9mbGFzaEVsZW1lbnQgPSBmbGFzaEVsZW1lbnQ7XG4gIHRoaXMuX2xheWVySWQgPSBsYXllcklkO1xuICB0aGlzLl9xdWlya3MgPSBxdWlya3M7XG5cbiAgdGhpcy5fdGlsZUxpc3QgPSBbXTtcblxuICB0aGlzLl90ZXh0dXJlTWFwID0gbmV3IE1hcCgpO1xuXG4gIC8vIFdoZXRoZXIgdGhlIEZsYXNoIGxheWVyIGZvciB0aGlzIHJlbmRlcmVyIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAvLyBieSBjYWxsaW5nIGZsYXNoRWxlbWVudC5jcmVhdGVMYXllcigpLiBOb3RlIHRoYXQgd2UgY2Fubm90IGRvIHRoaXNcbiAgLy8gcmlnaHQgaGVyZSBiZWNhdXNlIEZsYXNoIG1heSBub3QgYmUgaW5pdGlhbGl6ZWQgeWV0LlxuICB0aGlzLl9sYXllckNyZWF0ZWQgPSBmYWxzZTtcbn1cblxuXG5GbGFzaEJhc2VSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fbGF5ZXJDcmVhdGVkKSB7XG4gICAgdGhpcy5fZmxhc2hFbGVtZW50LmRlc3Ryb3lMYXllcih0aGlzLl9sYXllcklkKTtcbiAgfVxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbkZsYXNoQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zdGFydExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcbiAgaWYgKCF0aGlzLl9mbGFzaEVsZW1lbnQuaXNSZWFkeSB8fCAhdGhpcy5fZmxhc2hFbGVtZW50LmlzUmVhZHkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXRoaXMuX2xheWVyQ3JlYXRlZCkge1xuICAgIHRoaXMuX2ZsYXNoRWxlbWVudC5jcmVhdGVMYXllcih0aGlzLl9sYXllcklkKTtcbiAgICB0aGlzLl9sYXllckNyZWF0ZWQgPSB0cnVlO1xuICB9XG4gIHRoaXMuX3RpbGVMaXN0Lmxlbmd0aCA9IDA7XG4gIHRoaXMuX3RleHR1cmVNYXAuY2xlYXIoKTtcbn07XG5cblxuRmxhc2hCYXNlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRpbGUgPSBmdW5jdGlvbih0aWxlLCB0ZXh0dXJlKSB7XG4gIHRoaXMuX3RpbGVMaXN0LnB1c2godGlsZSk7XG4gIHRoaXMuX3RleHR1cmVNYXAuc2V0KHRpbGUsIHRleHR1cmUpO1xufTtcblxuXG5GbGFzaEJhc2VSZW5kZXJlci5wcm90b3R5cGUuZW5kTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgcmVjdCkge1xuICBpZiAoIXRoaXMuX2ZsYXNoRWxlbWVudC5pc1JlYWR5IHx8ICF0aGlzLl9mbGFzaEVsZW1lbnQuaXNSZWFkeSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU29ydCB0aWxlcyBzbyB0aGV5IGFyZSByZW5kZXJlZCBpbiBhbiBvcmRlciBjb2hlcmVudCB3aXRoIHRoZWlyIHBhZGRpbmcuXG4gIHZhciB0aWxlTGlzdCA9IHRoaXMuX3RpbGVMaXN0O1xuICB0aWxlTGlzdC5zb3J0KHRpbGVDbXApO1xuXG4gIHRoaXMuX3JlbmRlck9uRmxhc2gobGF5ZXIsIHJlY3QpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZsYXNoQmFzZVJlbmRlcmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmxhc2hCYXNlUmVuZGVyZXIgPSByZXF1aXJlKCcuL0ZsYXNoQmFzZScpO1xudmFyIEN1YmVUaWxlID0gcmVxdWlyZSgnLi4vZ2VvbWV0cmllcy9DdWJlJykuVGlsZTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxudmFyIHJhZFRvRGVnID0gcmVxdWlyZSgnLi4vdXRpbC9yYWRUb0RlZycpO1xuXG5cbi8qKlxuICogQGNsYXNzIEZsYXNoQ3ViZVJlbmRlcmVyXG4gKiBAaW1wbGVtZW50cyBSZW5kZXJlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgcmVuZGVyZXIgZm9yIHtAbGluayBDdWJlR2VvbWV0cnl9IGFuZCB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fSwgYXBwcm9wcmlhdGVcbiAqIGZvciBhIHtAbGluayBGbGFzaFN0YWdlfS5cbiAqXG4gKiBNb3N0IHVzZXJzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MuIFJlbmRlcmVycyBhcmUgY3JlYXRlZCBhbmRcbiAqIGRlc3Ryb3llZCBieSB7QGxpbmsgU3RhZ2V9IGFzIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gRmxhc2hDdWJlUmVuZGVyZXIoZmxhc2hFbGVtZW50LCBsYXllcklkLCBxdWlya3MpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBmbGFzaEVsZW1lbnQsIGxheWVySWQsIHF1aXJrcywgQ3ViZVRpbGUpO1xuICB0aGlzLl9mbGFzaFRpbGVMaXN0ID0gW107XG59XG5cbmluaGVyaXRzKEZsYXNoQ3ViZVJlbmRlcmVyLCBGbGFzaEJhc2VSZW5kZXJlcik7XG5cblxuRmxhc2hDdWJlUmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXJPbkZsYXNoID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcblxuICB2YXIgZmxhc2hFbGVtZW50ID0gdGhpcy5fZmxhc2hFbGVtZW50O1xuICB2YXIgbGF5ZXJJZCA9IHRoaXMuX2xheWVySWQ7XG4gIHZhciBwYWRTaXplID0gdGhpcy5fcXVpcmtzLnBhZFNpemU7XG5cbiAgdmFyIHRpbGVMaXN0ID0gdGhpcy5fdGlsZUxpc3Q7XG4gIHZhciB0ZXh0dXJlTWFwID0gdGhpcy5fdGV4dHVyZU1hcDtcblxuICB2YXIgZmxhc2hUaWxlTGlzdCA9IHRoaXMuX2ZsYXNoVGlsZUxpc3Q7XG4gIGZsYXNoVGlsZUxpc3QubGVuZ3RoID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRpbGUgPSB0aWxlTGlzdFtpXTtcbiAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVNYXAuZ2V0KHRpbGUpO1xuICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJpbmcgdGlsZSB3aXRoIG1pc3NpbmcgdGV4dHVyZScpO1xuICAgIH1cblxuICAgIC8vIEdldCBwYWRkaW5nIHNpemVzLlxuICAgIHZhciBwYWRUb3AgPSB0aWxlLnBhZFRvcCgpID8gcGFkU2l6ZSA6IDA7XG4gICAgdmFyIHBhZEJvdHRvbSA9IHRpbGUucGFkQm90dG9tKCkgPyBwYWRTaXplIDogMDtcbiAgICB2YXIgcGFkTGVmdCA9IHRpbGUucGFkTGVmdCgpID8gcGFkU2l6ZSA6IDA7XG4gICAgdmFyIHBhZFJpZ2h0ID0gdGlsZS5wYWRSaWdodCgpID8gcGFkU2l6ZSA6IDA7XG5cbiAgICBmbGFzaFRpbGVMaXN0LnB1c2goe1xuICAgICAgdGV4dHVyZUlkOiB0ZXh0dXJlLl90ZXh0dXJlSWQsXG4gICAgICBmYWNlOiB0aWxlLmZhY2UsXG4gICAgICB3aWR0aDogdGlsZS53aWR0aCgpLFxuICAgICAgaGVpZ2h0OiB0aWxlLmhlaWdodCgpLFxuICAgICAgY2VudGVyWDogdGlsZS5jZW50ZXJYKCksXG4gICAgICBjZW50ZXJZOiB0aWxlLmNlbnRlclkoKSxcbiAgICAgIHJvdFg6IHJhZFRvRGVnKHRpbGUucm90WCgpKSxcbiAgICAgIHJvdFk6IHJhZFRvRGVnKHRpbGUucm90WSgpKSxcbiAgICAgIGxldmVsU2l6ZTogdGlsZS5sZXZlbFdpZHRoKCksXG4gICAgICBwYWRUb3A6IHBhZFRvcCxcbiAgICAgIHBhZEJvdHRvbTogcGFkQm90dG9tLFxuICAgICAgcGFkTGVmdDogcGFkTGVmdCxcbiAgICAgIHBhZFJpZ2h0OiBwYWRSaWdodFxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2V0IHZpZXdwb3J0IHBvc2l0aW9uIGFuZCBzaXplLlxuICB2YXIgc3RhZ2VXaWR0aCA9IHRoaXMuX2ZsYXNoRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgdmFyIHN0YWdlSGVpZ2h0ID0gdGhpcy5fZmxhc2hFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgdmFyIHZpZXdwb3J0WCA9IHN0YWdlV2lkdGggKiByZWN0Lng7XG4gIHZhciB2aWV3cG9ydFkgPSBzdGFnZUhlaWdodCAqIHJlY3QueTtcbiAgdmFyIHZpZXdwb3J0V2lkdGggPSBzdGFnZVdpZHRoICogcmVjdC53aWR0aDtcbiAgdmFyIHZpZXdwb3J0SGVpZ2h0ID0gc3RhZ2VIZWlnaHQgKiByZWN0LmhlaWdodDtcblxuICAvLyBHZXQgb3BhY2l0eSB2YWx1ZS5cbiAgdmFyIG9wYWNpdHkgPSAxLjA7XG4gIHZhciBlZmZlY3RzID0gbGF5ZXIuZWZmZWN0cygpO1xuICBpZiAoZWZmZWN0cyAmJiBlZmZlY3RzLm9wYWNpdHkgIT0gbnVsbCkge1xuICAgIG9wYWNpdHkgPSBlZmZlY3RzLm9wYWNpdHk7XG4gIH1cblxuICAvLyBHZXQgdmlldyBwYXJhbWV0ZXJzLlxuICB2YXIgdmlldyA9IGxheWVyLnZpZXcoKTtcbiAgdmFyIHlhdyA9IHZpZXcueWF3KCk7XG4gIHZhciBwaXRjaCA9IHZpZXcucGl0Y2goKTtcbiAgdmFyIHJvbGwgPSB2aWV3LnJvbGwoKTtcbiAgdmFyIGZvdiA9IHZpZXcuZm92KCk7XG5cbiAgZmxhc2hFbGVtZW50LmRyYXdDdWJlVGlsZXMoXG4gICAgICBsYXllcklkLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgdmlld3BvcnRYLCB2aWV3cG9ydFksIG9wYWNpdHksXG4gICAgICB5YXcsIHBpdGNoLCByb2xsLCBmb3YsIGZsYXNoVGlsZUxpc3QpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZsYXNoQ3ViZVJlbmRlcmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmxhc2hCYXNlUmVuZGVyZXIgPSByZXF1aXJlKCcuL0ZsYXNoQmFzZScpO1xudmFyIEZsYXRUaWxlID0gcmVxdWlyZSgnLi4vZ2VvbWV0cmllcy9GbGF0JykuVGlsZTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxuXG4vKipcbiAqIEBjbGFzcyBGbGFzaEZsYXRSZW5kZXJlclxuICogQGltcGxlbWVudHMgUmVuZGVyZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHJlbmRlcmVyIGZvciB7QGxpbmsgRmxhdEdlb21ldHJ5fSBhbmQge0BsaW5rIEZsYXRWaWV3fSwgYXBwcm9wcmlhdGUgZm9yIGFcbiAqIHtAbGluayBGbGFzaFN0YWdlfS5cbiAqXG4gKiBNb3N0IHVzZXJzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MuIFJlbmRlcmVycyBhcmUgY3JlYXRlZCBhbmRcbiAqIGRlc3Ryb3llZCBieSB7QGxpbmsgU3RhZ2V9IGFzIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gRmxhc2hGbGF0UmVuZGVyZXIoZmxhc2hFbGVtZW50LCBsYXllcklkLCBxdWlya3MpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBmbGFzaEVsZW1lbnQsIGxheWVySWQsIHF1aXJrcywgRmxhdFRpbGUpO1xuICB0aGlzLl9mbGFzaFRpbGVMaXN0ID0gW107XG59XG5cbmluaGVyaXRzKEZsYXNoRmxhdFJlbmRlcmVyLCBGbGFzaEJhc2VSZW5kZXJlcik7XG5cblxuRmxhc2hGbGF0UmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXJPbkZsYXNoID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcblxuICB2YXIgZmxhc2hFbGVtZW50ID0gdGhpcy5fZmxhc2hFbGVtZW50O1xuICB2YXIgbGF5ZXJJZCA9IHRoaXMuX2xheWVySWQ7XG4gIHZhciBwYWRTaXplID0gdGhpcy5fcXVpcmtzLnBhZFNpemU7XG5cbiAgdmFyIHRpbGVMaXN0ID0gdGhpcy5fdGlsZUxpc3Q7XG4gIHZhciB0ZXh0dXJlTWFwID0gdGhpcy5fdGV4dHVyZU1hcDtcblxuICB2YXIgZmxhc2hUaWxlTGlzdCA9IHRoaXMuX2ZsYXNoVGlsZUxpc3Q7XG4gIGZsYXNoVGlsZUxpc3QubGVuZ3RoID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRpbGUgPSB0aWxlTGlzdFtpXTtcbiAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVNYXAuZ2V0KHRpbGUpO1xuICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJpbmcgdGlsZSB3aXRoIG1pc3NpbmcgdGV4dHVyZScpO1xuICAgIH1cblxuICAgIC8vIEdldCBwYWRkaW5nIHNpemVzLlxuICAgIHZhciBwYWRUb3AgPSB0aWxlLnBhZFRvcCgpID8gcGFkU2l6ZSA6IDA7XG4gICAgdmFyIHBhZEJvdHRvbSA9IHRpbGUucGFkQm90dG9tKCkgPyBwYWRTaXplIDogMDtcbiAgICB2YXIgcGFkTGVmdCA9IHRpbGUucGFkTGVmdCgpID8gcGFkU2l6ZSA6IDA7XG4gICAgdmFyIHBhZFJpZ2h0ID0gdGlsZS5wYWRSaWdodCgpID8gcGFkU2l6ZSA6IDA7XG5cbiAgICBmbGFzaFRpbGVMaXN0LnB1c2goe1xuICAgICAgdGV4dHVyZUlkOiB0ZXh0dXJlLl90ZXh0dXJlSWQsXG4gICAgICB3aWR0aDogdGlsZS53aWR0aCgpLFxuICAgICAgaGVpZ2h0OiB0aWxlLmhlaWdodCgpLFxuICAgICAgY2VudGVyWDogdGlsZS5jZW50ZXJYKCksXG4gICAgICBjZW50ZXJZOiB0aWxlLmNlbnRlclkoKSxcbiAgICAgIHNjYWxlWDogdGlsZS5zY2FsZVgoKSxcbiAgICAgIHNjYWxlWTogdGlsZS5zY2FsZVkoKSxcbiAgICAgIGxldmVsV2lkdGg6IHRpbGUubGV2ZWxXaWR0aCgpLFxuICAgICAgbGV2ZWxIZWlnaHQ6IHRpbGUubGV2ZWxIZWlnaHQoKSxcbiAgICAgIHBhZFRvcDogcGFkVG9wLFxuICAgICAgcGFkQm90dG9tOiBwYWRCb3R0b20sXG4gICAgICBwYWRMZWZ0OiBwYWRMZWZ0LFxuICAgICAgcGFkUmlnaHQ6IHBhZFJpZ2h0XG4gICAgfSk7XG4gIH1cblxuICAvLyBHZXQgdmlld3BvcnQgcG9zaXRpb24gYW5kIHNpemUuXG4gIHZhciBzdGFnZVdpZHRoID0gdGhpcy5fZmxhc2hFbGVtZW50LmNsaWVudFdpZHRoO1xuICB2YXIgc3RhZ2VIZWlnaHQgPSB0aGlzLl9mbGFzaEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB2YXIgdmlld3BvcnRYID0gc3RhZ2VXaWR0aCAqIHJlY3QueDtcbiAgdmFyIHZpZXdwb3J0WSA9IHN0YWdlSGVpZ2h0ICogcmVjdC55O1xuICB2YXIgdmlld3BvcnRXaWR0aCA9IHN0YWdlV2lkdGggKiByZWN0LndpZHRoO1xuICB2YXIgdmlld3BvcnRIZWlnaHQgPSBzdGFnZUhlaWdodCAqIHJlY3QuaGVpZ2h0O1xuXG4gIC8vIEdldCBvcGFjaXR5IHZhbHVlLlxuICB2YXIgb3BhY2l0eSA9IDEuMDtcbiAgdmFyIGVmZmVjdHMgPSBsYXllci5lZmZlY3RzKCk7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMub3BhY2l0eSAhPSBudWxsKSB7XG4gICAgb3BhY2l0eSA9IGVmZmVjdHMub3BhY2l0eTtcbiAgfVxuXG4gIC8vIEdldCB2aWV3IHBhcmFtZXRlcnMuXG4gIHZhciB2aWV3ID0gbGF5ZXIudmlldygpO1xuICB2YXIgeCA9IHZpZXcueCgpO1xuICB2YXIgeSA9IHZpZXcueSgpO1xuICB2YXIgem9vbVggPSB2aWV3Ll96b29tWCgpO1xuICB2YXIgem9vbVkgPSB2aWV3Ll96b29tWSgpO1xuXG4gIGZsYXNoRWxlbWVudC5kcmF3RmxhdFRpbGVzKFxuICAgICAgbGF5ZXJJZCwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIHZpZXdwb3J0WCwgdmlld3BvcnRZLCBvcGFjaXR5LFxuICAgICAgeCwgeSwgem9vbVgsIHpvb21ZLCBmbGFzaFRpbGVMaXN0KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGbGFzaEZsYXRSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcblxudmFyIHZlcnRleFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4Tm9ybWFsJyk7XG52YXIgZnJhZ21lbnRTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL2ZyYWdtZW50Tm9ybWFsJyk7XG5cbnZhciB2ZXJ0ZXhJbmRpY2VzID0gWzAsIDEsIDIsIDAsIDIsIDNdO1xudmFyIHZlcnRleFBvc2l0aW9ucyA9IFstMC41LCAtMC41LCAwLjAsIDAuNSwgLTAuNSwgMC4wLCAwLjUsIDAuNSwgMC4wLCAtMC41LCAwLjUsIDAuMF07XG52YXIgdGV4dHVyZUNvb3JkcyA9IFswLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMF07XG5cbnZhciBhdHRyaWJMaXN0ID0gWydhVmVydGV4UG9zaXRpb24nLCAnYVRleHR1cmVDb29yZCddO1xudmFyIHVuaWZvcm1MaXN0ID0gW1xuICAndURlcHRoJywgJ3VPcGFjaXR5JywgJ3VTYW1wbGVyJywgJ3VQcm9qTWF0cml4JywgJ3VWaWV3cG9ydE1hdHJpeCcsXG4gICd1Q29sb3JPZmZzZXQnLCAndUNvbG9yTWF0cml4J1xuXTtcblxuXG5mdW5jdGlvbiBXZWJHbEJhc2VSZW5kZXJlcihnbCkge1xuICB0aGlzLmdsID0gZ2w7XG5cbiAgLy8gVGhlIHByb2plY3Rpb24gbWF0cml4IHBvc2l0aW9ucyB0aGUgdGlsZXMgaW4gd29ybGQgc3BhY2UuXG4gIC8vIFdlIGNvbXB1dGUgaXQgaW4gSmF2YXNjcmlwdCBiZWNhdXNlIGxhY2sgb2YgcHJlY2lzaW9uIGluIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gIC8vIGNhdXNlcyBzZWFtcyB0byBhcHBlYXIgYmV0d2VlbiBhZGphY2VudCB0aWxlcyBhdCBsYXJnZSB6b29tIGxldmVscy5cbiAgdGhpcy5wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUaGUgdmlld3BvcnQgbWF0cml4IHJlc3BvbnNpYmxlIGZvciB2aWV3cG9ydCBjbGFtcGluZy5cbiAgLy8gU2VlIHNldFZpZXdwb3J0KCkgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIGhvdyBpdCB3b3Jrcy5cbiAgdGhpcy52aWV3cG9ydE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVHJhbnNsYXRpb24gYW5kIHNjYWxlIHZlY3RvcnMgZm9yIHRpbGVzLlxuICB0aGlzLnRyYW5zbGF0ZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG4gIHRoaXMuc2NhbGVWZWN0b3IgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gIHRoaXMuY29uc3RhbnRCdWZmZXJzID0gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpO1xuXG4gIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYkxpc3QsIHVuaWZvcm1MaXN0KTtcbn1cblxuV2ViR2xCYXNlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgZGVzdHJveUNvbnN0YW50QnVmZmVycyh0aGlzLmdsLCB0aGlzLmNvbnN0YW50QnVmZmVycyk7XG4gIGRlc3Ryb3lTaGFkZXJQcm9ncmFtKHRoaXMuZ2wsIHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zdGFydExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcbiAgdmFyIHZpZXdwb3J0TWF0cml4ID0gdGhpcy52aWV3cG9ydE1hdHJpeDtcblxuICBnbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuXG4gIGVuYWJsZUF0dHJpYnV0ZXMoZ2wsIHNoYWRlclByb2dyYW0pO1xuXG4gIHNldFZpZXdwb3J0KGdsLCBsYXllciwgcmVjdCwgdmlld3BvcnRNYXRyaXgpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVZpZXdwb3J0TWF0cml4LCBmYWxzZSwgdmlld3BvcnRNYXRyaXgpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudmVydGV4UG9zaXRpb25zKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtLmFWZXJ0ZXhQb3NpdGlvbiwgMywgZ2wuRkxPQVQsIGdsLkZBTFNFLCAwLCAwKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy50ZXh0dXJlQ29vcmRzKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJQcm9ncmFtLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgMCk7XG5cbiAgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zKGdsLCBsYXllci5lZmZlY3RzKCksIHtcbiAgICBvcGFjaXR5OiBzaGFkZXJQcm9ncmFtLnVPcGFjaXR5LFxuICAgIGNvbG9yT2Zmc2V0OiBzaGFkZXJQcm9ncmFtLnVDb2xvck9mZnNldCxcbiAgICBjb2xvck1hdHJpeDogc2hhZGVyUHJvZ3JhbS51Q29sb3JNYXRyaXhcbiAgfSk7XG59O1xuXG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5lbmRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICBkaXNhYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG59O1xuXG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUaWxlID0gZnVuY3Rpb24odGlsZSwgdGV4dHVyZSwgbGF5ZXIsIGxheWVyWikge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuICB2YXIgcHJvak1hdHJpeCA9IHRoaXMucHJvak1hdHJpeDtcbiAgdmFyIHRyYW5zbGF0ZVZlY3RvciA9IHRoaXMudHJhbnNsYXRlVmVjdG9yO1xuICB2YXIgc2NhbGVWZWN0b3IgPSB0aGlzLnNjYWxlVmVjdG9yO1xuXG4gIHRyYW5zbGF0ZVZlY3RvclswXSA9IHRpbGUuY2VudGVyWCgpO1xuICB0cmFuc2xhdGVWZWN0b3JbMV0gPSB0aWxlLmNlbnRlclkoKTtcbiAgdHJhbnNsYXRlVmVjdG9yWzJdID0gLTAuNTtcblxuICBzY2FsZVZlY3RvclswXSA9IHRpbGUuc2NhbGVYKCk7XG4gIHNjYWxlVmVjdG9yWzFdID0gdGlsZS5zY2FsZVkoKTtcbiAgc2NhbGVWZWN0b3JbMl0gPSAxLjA7XG5cbiAgbWF0NC5jb3B5KHByb2pNYXRyaXgsIGxheWVyLnZpZXcoKS5wcm9qZWN0aW9uKCkpO1xuICBtYXQ0LnJvdGF0ZVgocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGlsZS5yb3RYKCkpO1xuICBtYXQ0LnJvdGF0ZVkocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGlsZS5yb3RZKCkpO1xuICBtYXQ0LnRyYW5zbGF0ZShwcm9qTWF0cml4LCBwcm9qTWF0cml4LCB0cmFuc2xhdGVWZWN0b3IpO1xuICBtYXQ0LnNjYWxlKHByb2pNYXRyaXgsIHByb2pNYXRyaXgsIHNjYWxlVmVjdG9yKTtcblxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVByb2pNYXRyaXgsIGZhbHNlLCBwcm9qTWF0cml4KTtcblxuICBzZXREZXB0aChnbCwgc2hhZGVyUHJvZ3JhbSwgbGF5ZXJaLCB0aWxlLnopO1xuXG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhJbmRpY2VzKTtcbiAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGV4SW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEJhc2VSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlc2UgYXJlIHVzZWQgdG8gc2V0IHRoZSBXZWJHbCBkZXB0aCBmb3IgYSB0aWxlLlxudmFyIE1BWF9MQVlFUlMgPSAyNTY7IC8vIE1heCBudW1iZXIgb2YgbGF5ZXJzIHBlciBzdGFnZS5cbnZhciBNQVhfTEVWRUxTID0gMjU2OyAvLyBNYXggbnVtYmVyIG9mIGxldmVscyBwZXIgbGF5ZXIuXG5cbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciB2ZWMzID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMztcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxuXG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoZ2wsIHR5cGUsIHNyYykge1xuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdGhyb3cgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmliTGlzdCwgdW5pZm9ybUxpc3QpIHtcblxuICB2YXIgdmVydGV4U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTcmMpO1xuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTcmMpO1xuXG4gIHZhciBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgdGhyb3cgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0cmliID0gYXR0cmliTGlzdFtpXTtcbiAgICBzaGFkZXJQcm9ncmFtW2F0dHJpYl0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBhdHRyaWIpO1xuICAgIGlmIChzaGFkZXJQcm9ncmFtW2F0dHJpYl0gPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIGhhcyBubyAnICsgYXR0cmliICsgJyBhdHRyaWJ1dGUnKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaWZvcm1MaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHVuaWZvcm0gPSB1bmlmb3JtTGlzdFtqXTtcbiAgICBzaGFkZXJQcm9ncmFtW3VuaWZvcm1dID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIHVuaWZvcm0pO1xuICAgIGlmIChzaGFkZXJQcm9ncmFtW3VuaWZvcm1dID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgcHJvZ3JhbSBoYXMgbm8gJyArIHVuaWZvcm0gKyAnIHVuaWZvcm0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hhZGVyUHJvZ3JhbTtcbn1cblxuXG5mdW5jdGlvbiBkZXN0cm95U2hhZGVyUHJvZ3JhbShnbCwgc2hhZGVyUHJvZ3JhbSkge1xuICB2YXIgc2hhZGVyTGlzdCA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhzaGFkZXJQcm9ncmFtKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkZXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoYWRlciA9IHNoYWRlckxpc3RbaV07XG4gICAgZ2wuZGV0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gIH1cbiAgZ2wuZGVsZXRlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVDb25zdGFudEJ1ZmZlcihnbCwgdGFyZ2V0LCB1c2FnZSwgdmFsdWUpIHtcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKHRhcmdldCwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YSh0YXJnZXQsIHZhbHVlLCB1c2FnZSk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0ZXhJbmRpY2VzOiBjcmVhdGVDb25zdGFudEJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBuZXcgVWludDE2QXJyYXkodmVydGV4SW5kaWNlcykpLFxuICAgIHZlcnRleFBvc2l0aW9uczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG5ldyBGbG9hdDMyQXJyYXkodmVydGV4UG9zaXRpb25zKSksXG4gICAgdGV4dHVyZUNvb3JkczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG5ldyBGbG9hdDMyQXJyYXkodGV4dHVyZUNvb3JkcykpXG4gIH07XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveUNvbnN0YW50QnVmZmVycyhnbCwgY29uc3RhbnRCdWZmZXJzKSB7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudmVydGV4SW5kaWNlcyk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudmVydGV4UG9zaXRpb25zKTtcbiAgZ2wuZGVsZXRlQnVmZmVyKGNvbnN0YW50QnVmZmVycy50ZXh0dXJlQ29vcmRzKTtcbn1cblxuXG5mdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKSB7XG4gIHZhciBudW1BdHRycyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJzOyBpKyspIHtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGRpc2FibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKSB7XG4gIHZhciBudW1BdHRycyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJzOyBpKyspIHtcbiAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl90ZXh0dXJlKTtcbiAgZ2wudW5pZm9ybTFpKHNoYWRlclByb2dyYW0udVNhbXBsZXIsIDApO1xufVxuXG5cbmZ1bmN0aW9uIHNldERlcHRoKGdsLCBzaGFkZXJQcm9ncmFtLCBsYXllclosIHRpbGVaKSB7XG4gIHZhciBkZXB0aCA9ICgoKGxheWVyWiArIDEpICogTUFYX0xFVkVMUykgLSB0aWxlWikgLyAoTUFYX0xFVkVMUyAqIE1BWF9MQVlFUlMpO1xuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51RGVwdGgsIGRlcHRoKTtcbn1cblxuXG52YXIgZGVmYXVsdE9wYWNpdHkgPSAxLjA7XG52YXIgZGVmYXVsdENvbG9yT2Zmc2V0ID0gdmVjNC5jcmVhdGUoKTtcbnZhciBkZWZhdWx0Q29sb3JNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xubWF0NC5pZGVudGl0eShkZWZhdWx0Q29sb3JNYXRyaXgpO1xuXG5mdW5jdGlvbiBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMoZ2wsIGVmZmVjdHMsIHVuaWZvcm1zKSB7XG4gIHZhciBvcGFjaXR5ID0gZGVmYXVsdE9wYWNpdHk7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMub3BhY2l0eSAhPSBudWxsKSB7XG4gICAgb3BhY2l0eSA9IGVmZmVjdHMub3BhY2l0eTtcbiAgfVxuICBnbC51bmlmb3JtMWYodW5pZm9ybXMub3BhY2l0eSwgb3BhY2l0eSk7XG5cbiAgdmFyIGNvbG9yT2Zmc2V0ID0gZGVmYXVsdENvbG9yT2Zmc2V0O1xuICBpZiAoZWZmZWN0cyAmJiBlZmZlY3RzLmNvbG9yT2Zmc2V0KSB7XG4gICAgY29sb3JPZmZzZXQgPSBlZmZlY3RzLmNvbG9yT2Zmc2V0O1xuICB9XG4gIGdsLnVuaWZvcm00ZnYodW5pZm9ybXMuY29sb3JPZmZzZXQsIGNvbG9yT2Zmc2V0KTtcblxuICB2YXIgY29sb3JNYXRyaXggPSBkZWZhdWx0Q29sb3JNYXRyaXg7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMuY29sb3JNYXRyaXgpIHtcbiAgICBjb2xvck1hdHJpeCA9IGVmZmVjdHMuY29sb3JNYXRyaXg7XG4gIH1cbiAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3Jtcy5jb2xvck1hdHJpeCwgZmFsc2UsIGNvbG9yTWF0cml4KTtcbn1cblxuXG4vLyBUZW1wb3JhcnkgdmVjdG9ycyBmb3Igc2V0Vmlld3BvcnQuXG52YXIgdHJhbnNsYXRlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcbnZhciBzY2FsZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG5cblxuLy8gU2V0cyB0aGUgV2ViR0wgdmlld3BvcnQgYW5kIHJldHVybnMgYSB2aWV3cG9ydCBjbGFtcGluZyBjb21wZW5zYXRpb24gbWF0cml4LlxuLy9cbi8vIE5lZ2F0aXZlIHZpZXdwb3J0IG9yaWdpbiBjb29yZGluYXRlcyBjYXVzZSByZW5kZXJpbmcgaXNzdWVzLiBMZXR0aW5nIHRoZVxuLy8gdmlld3BvcnQgZGltZW5zaW9ucyBleHRlbmQgYmV5b25kIHRoZSB2aXNpYmxlIGFyZWEgZG8gbm90IHNlZW0gdG8gY2F1c2Vcbi8vIHJlbmRlcmluZyBpc3N1ZXMsIGJ1dCB0aGV5IG1heSBzdGlsbCBoYXZlIGFuIGltcGFjdCBvbiBwZXJmb3JtYW5jZS5cbi8vIFRoZXJlZm9yZSwgd2hlbiB0aGUgc2NlbmUncyByZWN0IGlzIG5vdCBmdWxseSBjb250YWluZWQgaW4gdGhlIHJlbmRlcmluZ1xuLy8gYXJlYSwgd2UgY2xhbXAgdGhlIHZpZXdwb3J0IHRvIHRoZSByZW5kZXJpbmcgYXJlYSwgYW5kIHJldHVybiBhIGNvbXBlbnNhdGlvblxuLy8gbWF0cml4IHRvIHNjYWxlIGFuZCB0cmFuc2xhdGUgdmVydGljZXMgYWNjb3JkaW5nbHkuXG5mdW5jdGlvbiBzZXRWaWV3cG9ydChnbCwgbGF5ZXIsIHJlY3QsIHZpZXdwb3J0TWF0cml4KSB7XG4gIGlmIChyZWN0LnggPT09IDAgJiYgcmVjdC53aWR0aCA9PT0gMSAmJiByZWN0LnkgPT09IDAgJiYgcmVjdC5oZWlnaHQgPT09IDEpIHtcbiAgICAvLyBGYXN0IHBhdGggZm9yIGZ1bGwgcmVjdC5cbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgIG1hdDQuaWRlbnRpdHkodmlld3BvcnRNYXRyaXgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvZmZzZXRYID0gcmVjdC54O1xuICB2YXIgY2xhbXBlZE9mZnNldFggPSBjbGFtcChvZmZzZXRYLCAwLCAxKTtcbiAgdmFyIGxlZnRFeGNlc3MgPSBjbGFtcGVkT2Zmc2V0WCAtIG9mZnNldFg7XG4gIHZhciBtYXhDbGFtcGVkV2lkdGggPSAxIC0gY2xhbXBlZE9mZnNldFg7XG4gIHZhciBjbGFtcGVkV2lkdGggPSBjbGFtcChyZWN0LndpZHRoIC0gbGVmdEV4Y2VzcywgMCwgbWF4Q2xhbXBlZFdpZHRoKTtcbiAgdmFyIHJpZ2h0RXhjZXNzID0gcmVjdC53aWR0aCAtIGNsYW1wZWRXaWR0aDtcblxuICB2YXIgb2Zmc2V0WSA9IDEgLSByZWN0LmhlaWdodCAtIHJlY3QueTtcbiAgdmFyIGNsYW1wZWRPZmZzZXRZID0gY2xhbXAob2Zmc2V0WSwgMCwgMSk7XG4gIHZhciBib3R0b21FeGNlc3MgPSBjbGFtcGVkT2Zmc2V0WSAtIG9mZnNldFk7XG4gIHZhciBtYXhDbGFtcGVkSGVpZ2h0ID0gMSAtIGNsYW1wZWRPZmZzZXRZO1xuICB2YXIgY2xhbXBlZEhlaWdodCA9IGNsYW1wKHJlY3QuaGVpZ2h0IC0gYm90dG9tRXhjZXNzLCAwLCBtYXhDbGFtcGVkSGVpZ2h0KTtcbiAgdmFyIHRvcEV4Y2VzcyA9IHJlY3QuaGVpZ2h0IC0gY2xhbXBlZEhlaWdodDtcblxuICB2ZWMzLnNldChcbiAgICBzY2FsZVZlY3RvcixcbiAgICByZWN0LndpZHRoIC8gY2xhbXBlZFdpZHRoLFxuICAgIHJlY3QuaGVpZ2h0IC8gY2xhbXBlZEhlaWdodCxcbiAgICAxKTtcblxuICB2ZWMzLnNldChcbiAgICB0cmFuc2xhdGVWZWN0b3IsXG4gICAgKHJpZ2h0RXhjZXNzIC0gbGVmdEV4Y2VzcykgLyBjbGFtcGVkV2lkdGgsXG4gICAgKHRvcEV4Y2VzcyAtIGJvdHRvbUV4Y2VzcykgLyBjbGFtcGVkSGVpZ2h0LFxuICAgIDApO1xuXG4gIG1hdDQuaWRlbnRpdHkodmlld3BvcnRNYXRyaXgpO1xuICBtYXQ0LnRyYW5zbGF0ZSh2aWV3cG9ydE1hdHJpeCwgdmlld3BvcnRNYXRyaXgsIHRyYW5zbGF0ZVZlY3Rvcik7XG4gIG1hdDQuc2NhbGUodmlld3BvcnRNYXRyaXgsIHZpZXdwb3J0TWF0cml4LCBzY2FsZVZlY3Rvcik7XG5cbiAgZ2wudmlld3BvcnQoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoICogY2xhbXBlZE9mZnNldFgsXG4gICAgICAgICAgICAgIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgKiBjbGFtcGVkT2Zmc2V0WSxcbiAgICAgICAgICAgICAgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoICogY2xhbXBlZFdpZHRoLFxuICAgICAgICAgICAgICBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0ICogY2xhbXBlZEhlaWdodCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTaGFkZXJQcm9ncmFtOiBjcmVhdGVTaGFkZXJQcm9ncmFtLFxuICBkZXN0cm95U2hhZGVyUHJvZ3JhbTogZGVzdHJveVNoYWRlclByb2dyYW0sXG4gIGNyZWF0ZUNvbnN0YW50QnVmZmVyczogY3JlYXRlQ29uc3RhbnRCdWZmZXJzLFxuICBkZXN0cm95Q29uc3RhbnRCdWZmZXJzOiBkZXN0cm95Q29uc3RhbnRCdWZmZXJzLFxuICBlbmFibGVBdHRyaWJ1dGVzOiBlbmFibGVBdHRyaWJ1dGVzLFxuICBkaXNhYmxlQXR0cmlidXRlczogZGlzYWJsZUF0dHJpYnV0ZXMsXG4gIHNldFRleHR1cmU6IHNldFRleHR1cmUsXG4gIHNldERlcHRoOiBzZXREZXB0aCxcbiAgc2V0Vmlld3BvcnQ6IHNldFZpZXdwb3J0LFxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXM6IHNldHVwUGl4ZWxFZmZlY3RVbmlmb3Jtc1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQmFzZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9XZWJHbEJhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xDdWJlUmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEN1YmVHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9LCBhcHByb3ByaWF0ZVxuICogZm9yIGEge0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEN1YmVSZW5kZXJlcigpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoV2ViR2xDdWJlUmVuZGVyZXIsIFdlYkdsQmFzZVJlbmRlcmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEN1YmVSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcblxudmFyIHZlcnRleFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4RXF1aXJlY3QnKTtcbnZhciBmcmFnbWVudFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZnJhZ21lbnRFcXVpcmVjdCcpO1xuXG52YXIgdmVydGV4SW5kaWNlcyA9IFswLCAxLCAyLCAwLCAyLCAzXTtcbnZhciB2ZXJ0ZXhQb3NpdGlvbnMgPSBbLTEuMCwgLTEuMCwgMC4wLCAxLjAsIC0xLjAsIDAuMCwgMS4wLCAxLjAsIDAuMCwgLTEuMCwgMS4wLCAwLjBdO1xudmFyIHRleHR1cmVDb29yZHMgPSBbMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjBdO1xuXG52YXIgYXR0cmliTGlzdCA9IFsnYVZlcnRleFBvc2l0aW9uJ107XG52YXIgdW5pZm9ybUxpc3QgPSBbXG4gICd1RGVwdGgnLCAndU9wYWNpdHknLCAndVNhbXBsZXInLCAndUludlByb2pNYXRyaXgnLCAndVZpZXdwb3J0TWF0cml4JyxcbiAgJ3VDb2xvck9mZnNldCcsICd1Q29sb3JNYXRyaXgnLCAndVRleHR1cmVYJywgJ3VUZXh0dXJlWScsICd1VGV4dHVyZVdpZHRoJyxcbiAgJ3VUZXh0dXJlSGVpZ2h0J1xuXTtcblxuXG4vKipcbiAqIEBjbGFzcyBXZWJHbEVxdWlyZWN0UmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEVxdWlyZWN0R2VvbWV0cnl9IGFuZCB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fSxcbiAqIGFwcHJvcHJpYXRlIGZvciB7QGxpbmsgV2ViR2xTdGFnZX0uXG4gKlxuICogTW9zdCB1c2VycyBkbyBub3QgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLiBSZW5kZXJlcnMgYXJlIGNyZWF0ZWQgYW5kXG4gKiBkZXN0cm95ZWQgYnkge0BsaW5rIFN0YWdlfSBhcyBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIFdlYkdsRXF1aXJlY3RSZW5kZXJlcihnbCkge1xuICB0aGlzLmdsID0gZ2w7XG5cbiAgLy8gVGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXG4gIHRoaXMuaW52UHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIHZpZXdwb3J0IG1hdHJpeCByZXNwb25zaWJsZSBmb3Igdmlld3BvcnQgY2xhbXBpbmcuXG4gIC8vIFNlZSBzZXRWaWV3cG9ydCgpIGZvciBhbiBleHBsYW5hdGlvbiBvZiBob3cgaXQgd29ya3MuXG4gIHRoaXMudmlld3BvcnRNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIHRoaXMuY29uc3RhbnRCdWZmZXJzID0gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpO1xuXG4gIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYkxpc3QsIHVuaWZvcm1MaXN0KTtcbn1cblxuV2ViR2xFcXVpcmVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnModGhpcy5nbCwgdGhpcy5jb25zdGFudEJ1ZmZlcnMpO1xuICBkZXN0cm95U2hhZGVyUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnNoYWRlclByb2dyYW0pO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbldlYkdsRXF1aXJlY3RSZW5kZXJlci5wcm90b3R5cGUuc3RhcnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICB2YXIgY29uc3RhbnRCdWZmZXJzID0gdGhpcy5jb25zdGFudEJ1ZmZlcnM7XG4gIHZhciBpbnZQcm9qTWF0cml4ID0gdGhpcy5pbnZQcm9qTWF0cml4O1xuICB2YXIgdmlld3BvcnRNYXRyaXggPSB0aGlzLnZpZXdwb3J0TWF0cml4O1xuXG4gIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgZW5hYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG5cbiAgc2V0Vmlld3BvcnQoZ2wsIGxheWVyLCByZWN0LCB2aWV3cG9ydE1hdHJpeCk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51Vmlld3BvcnRNYXRyaXgsIGZhbHNlLCB2aWV3cG9ydE1hdHJpeCk7XG5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhQb3NpdGlvbnMpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclByb2dyYW0uYVZlcnRleFBvc2l0aW9uLCAzLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDApO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnRleHR1cmVDb29yZHMpO1xuXG4gIC8vIENvbXB1dGUgYW5kIHNldCB0aGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgbWF0NC5jb3B5KGludlByb2pNYXRyaXgsIGxheWVyLnZpZXcoKS5wcm9qZWN0aW9uKCkpO1xuICBtYXQ0LmludmVydChpbnZQcm9qTWF0cml4LCBpbnZQcm9qTWF0cml4KTtcblxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udUludlByb2pNYXRyaXgsIGZhbHNlLCBpbnZQcm9qTWF0cml4KTtcblxuICAvLyBDb21wdXRlIGFuZCBzZXQgdGhlIHRleHR1cmUgc2NhbGUgYW5kIGNyb3Agb2Zmc2V0cy5cbiAgdmFyIHRleHR1cmVDcm9wID0gbGF5ZXIuZWZmZWN0cygpLnRleHR1cmVDcm9wIHx8IHt9O1xuICB2YXIgdGV4dHVyZVggPSB0ZXh0dXJlQ3JvcC54ICE9IG51bGwgPyB0ZXh0dXJlQ3JvcC54IDogMDtcbiAgdmFyIHRleHR1cmVZID0gdGV4dHVyZUNyb3AueSAhPSBudWxsID8gdGV4dHVyZUNyb3AueSA6IDA7XG4gIHZhciB0ZXh0dXJlV2lkdGggPSB0ZXh0dXJlQ3JvcC53aWR0aCAhPSBudWxsID8gdGV4dHVyZUNyb3Aud2lkdGggOiAxO1xuICB2YXIgdGV4dHVyZUhlaWdodCA9IHRleHR1cmVDcm9wLmhlaWdodCAhPSBudWxsID8gdGV4dHVyZUNyb3AuaGVpZ2h0IDogMTtcblxuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51VGV4dHVyZVgsIHRleHR1cmVYKTtcbiAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW0udVRleHR1cmVZLCB0ZXh0dXJlWSk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVUZXh0dXJlV2lkdGgsIHRleHR1cmVXaWR0aCk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVUZXh0dXJlSGVpZ2h0LCB0ZXh0dXJlSGVpZ2h0KTtcblxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMoZ2wsIGxheWVyLmVmZmVjdHMoKSwge1xuICAgIG9wYWNpdHk6IHNoYWRlclByb2dyYW0udU9wYWNpdHksXG4gICAgY29sb3JPZmZzZXQ6IHNoYWRlclByb2dyYW0udUNvbG9yT2Zmc2V0LFxuICAgIGNvbG9yTWF0cml4OiBzaGFkZXJQcm9ncmFtLnVDb2xvck1hdHJpeFxuICB9KTtcbn07XG5cblxuV2ViR2xFcXVpcmVjdFJlbmRlcmVyLnByb3RvdHlwZS5lbmRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICBkaXNhYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG59O1xuXG5cbldlYkdsRXF1aXJlY3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGlsZSA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmUsIGxheWVyLCBsYXllclopIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcblxuICBzZXREZXB0aChnbCwgc2hhZGVyUHJvZ3JhbSwgbGF5ZXJaLCB0aWxlLnopO1xuXG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhJbmRpY2VzKTtcbiAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGV4SW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEVxdWlyZWN0UmVuZGVyZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBXZWJHbEJhc2VSZW5kZXJlciA9IHJlcXVpcmUoJy4vV2ViR2xCYXNlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG5cbi8qKlxuICogQGNsYXNzIFdlYkdsRmxhdFJlbmRlcmVyXG4gKiBAaW1wbGVtZW50cyBSZW5kZXJlclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgcmVuZGVyZXIgZm9yIHtAbGluayBGbGF0R2VvbWV0cnl9IGFuZCB7QGxpbmsgRmxhdFZpZXd9LCBhcHByb3ByaWF0ZSBmb3IgYVxuICoge0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEZsYXRSZW5kZXJlcigpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoV2ViR2xGbGF0UmVuZGVyZXIsIFdlYkdsQmFzZVJlbmRlcmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEZsYXRSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQ3ViZSA9IHJlcXVpcmUoJy4vV2ViR2xDdWJlJyk7XG52YXIgV2ViR2xGbGF0ID0gcmVxdWlyZSgnLi9XZWJHbEZsYXQnKTtcbnZhciBXZWJHbEVxdWlyZWN0ID0gcmVxdWlyZSgnLi9XZWJHbEVxdWlyZWN0Jyk7XG5cbnZhciBDc3NDdWJlID0gcmVxdWlyZSgnLi9Dc3NDdWJlJyk7XG52YXIgQ3NzRmxhdCA9IHJlcXVpcmUoJy4vQ3NzRmxhdCcpO1xuXG52YXIgRmxhc2hDdWJlID0gcmVxdWlyZSgnLi9GbGFzaEN1YmUnKTtcbnZhciBGbGFzaEZsYXQgPSByZXF1aXJlKCcuL0ZsYXNoRmxhdCcpO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbGwga25vd24gcmVuZGVyZXJzIGZvciB0aGUgZ2l2ZW4gc3RhZ2UgdHlwZSBpbnRvIHRoYXQgc3RhZ2UuXG4gKiBNb3N0IHVzZXJzIHdpbGwgbm90IG5lZWQgdG8gcmVnaXN0ZXIgcmVuZGVyZXJzLCBhcyB7QGxpbmsgVmlld2VyfSBkb2VzIGl0IGZvclxuICogdGhlbS5cbiAqXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgc3RhZ2Ugd2hlcmUgdGhlIHJlbmRlcmVycyBhcmUgdG8gYmUgcmVnaXN0ZXJlZC5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHN0YWdlIHR5cGUgaXMgdW5rbm93bi5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzKHN0YWdlKSB7XG4gIHN3aXRjaCAoc3RhZ2UudHlwZSkge1xuICAgIGNhc2UgJ3dlYmdsJzpcbiAgICAgIHN0YWdlLnJlZ2lzdGVyUmVuZGVyZXIoJ2ZsYXQnLCAnZmxhdCcsIFdlYkdsRmxhdCk7XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdjdWJlJywgJ3JlY3RpbGluZWFyJywgV2ViR2xDdWJlKTtcbiAgICAgIHN0YWdlLnJlZ2lzdGVyUmVuZGVyZXIoJ2VxdWlyZWN0JywgJ3JlY3RpbGluZWFyJywgV2ViR2xFcXVpcmVjdCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjc3MnOlxuICAgICAgc3RhZ2UucmVnaXN0ZXJSZW5kZXJlcignZmxhdCcsICdmbGF0JywgQ3NzRmxhdCk7XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdjdWJlJywgJ3JlY3RpbGluZWFyJywgQ3NzQ3ViZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmbGFzaCc6XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdmbGF0JywgJ2ZsYXQnLCBGbGFzaEZsYXQpO1xuICAgICAgc3RhZ2UucmVnaXN0ZXJSZW5kZXJlcignY3ViZScsICdyZWN0aWxpbmVhcicsIEZsYXNoQ3ViZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN0YWdlIHR5cGU6ICcgKyBzdGFnZS50eXBlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4nI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIJyxcbidwcmVjaXNpb24gaGlnaHAgZmxvYXQ7JyxcbicjZWxzZScsXG4ncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQnLFxuJyNlbmRpZicsXG5cbid1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuJ3VuaWZvcm0gZmxvYXQgdU9wYWNpdHk7Jyxcbid1bmlmb3JtIGZsb2F0IHVUZXh0dXJlWDsnLFxuJ3VuaWZvcm0gZmxvYXQgdVRleHR1cmVZOycsXG4ndW5pZm9ybSBmbG9hdCB1VGV4dHVyZVdpZHRoOycsXG4ndW5pZm9ybSBmbG9hdCB1VGV4dHVyZUhlaWdodDsnLFxuJ3VuaWZvcm0gdmVjNCB1Q29sb3JPZmZzZXQ7Jyxcbid1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4OycsXG5cbid2YXJ5aW5nIHZlYzQgdlJheTsnLFxuXG4nY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0OycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG4nICBmbG9hdCByID0gaW52ZXJzZXNxcnQodlJheS54ICogdlJheS54ICsgdlJheS55ICogdlJheS55ICsgdlJheS56ICogdlJheS56KTsnLFxuJyAgZmxvYXQgcGhpICA9IGFjb3ModlJheS55ICogcik7JyxcbicgIGZsb2F0IHRoZXRhID0gYXRhbih2UmF5LngsIC0xLjAqdlJheS56KTsnLFxuJyAgZmxvYXQgcyA9IDAuNSArIDAuNSAqIHRoZXRhIC8gUEk7JyxcbicgIGZsb2F0IHQgPSAxLjAgLSBwaGkgLyBQSTsnLFxuXG4nICBzID0gcyAqIHVUZXh0dXJlV2lkdGggKyB1VGV4dHVyZVg7JyxcbicgIHQgPSB0ICogdVRleHR1cmVIZWlnaHQgKyB1VGV4dHVyZVk7JyxcblxuJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMihzLCB0KSkgKiB1Q29sb3JNYXRyaXggKyB1Q29sb3JPZmZzZXQ7JyxcbicgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiYSAqIHVPcGFjaXR5KTsnLFxuJ30nXG5dLmpvaW4oJ1xcbicpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbicjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gnLFxuJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDsnLFxuJyNlbHNlJyxcbidwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuJyNlbmRpZicsXG5cbid1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuJ3VuaWZvcm0gZmxvYXQgdU9wYWNpdHk7Jyxcbid1bmlmb3JtIHZlYzQgdUNvbG9yT2Zmc2V0OycsXG4ndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDsnLFxuXG4ndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcblxuJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbicgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yTWF0cml4ICsgdUNvbG9yT2Zmc2V0OycsXG4nICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYmEgKiB1T3BhY2l0eSk7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4nYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uOycsXG5cbid1bmlmb3JtIGZsb2F0IHVEZXB0aDsnLFxuJ3VuaWZvcm0gbWF0NCB1Vmlld3BvcnRNYXRyaXg7Jyxcbid1bmlmb3JtIG1hdDQgdUludlByb2pNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjNCB2UmF5OycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG4nICB2UmF5ID0gdUludlByb2pNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54eSwgMS4wLCAxLjApOycsXG4nICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLnh5LCB1RGVwdGgsIDEuMCk7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4nYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uOycsXG4nYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsnLFxuXG4ndW5pZm9ybSBmbG9hdCB1RGVwdGg7Jyxcbid1bmlmb3JtIG1hdDQgdVZpZXdwb3J0TWF0cml4OycsXG4ndW5pZm9ybSBtYXQ0IHVQcm9qTWF0cml4OycsXG5cbid2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuXG4ndm9pZCBtYWluKHZvaWQpIHsnLFxuJyAgZ2xfUG9zaXRpb24gPSB1Vmlld3BvcnRNYXRyaXggKiB1UHJvak1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLnh5LCAwLjAsIDEuMCk7JyxcbicgIGdsX1Bvc2l0aW9uLnogPSB1RGVwdGggKiBnbF9Qb3NpdGlvbi53OycsXG4nICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxuJ30nXG5dLmpvaW4oJ1xcbicpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnLi4vTmV0d29ya0Vycm9yJyk7XG52YXIgV29ya1Bvb2wgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9Xb3JrUG9vbCcpO1xudmFyIGNoYWluID0gcmVxdWlyZSgnLi4vdXRpbC9jaGFpbicpO1xudmFyIGRlbGF5ID0gcmVxdWlyZSgnLi4vdXRpbC9kZWxheScpO1xudmFyIG5vdyA9IHJlcXVpcmUoJy4uL3V0aWwvbm93Jyk7XG5cblxuLy8gTWFwIHRlbXBsYXRlIHByb3BlcnRpZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyB0aWxlIHByb3BlcnRpZXMuXG52YXIgdGVtcGxhdGVQcm9wZXJ0aWVzID0ge1xuICB4OiAneCcsXG4gIHk6ICd5JyxcbiAgejogJ3onLFxuICBmOiAnZmFjZSdcbn07XG5cbi8vIERlZmF1bHQgZmFjZSBvcmRlciBmb3IgY3ViZSBtYXBzLlxudmFyIGRlZmF1bHRDdWJlTWFwRmFjZU9yZGVyID0gJ2JkZmxydSc7XG5cbi8vIERlZmF1bHQgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCByZXF1ZXN0cy5cbnZhciBkZWZhdWx0Q29uY3VycmVuY3kgPSA0O1xuXG4vLyBEZWZhdWx0IG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXRyeWluZyBmYWlsZWQgcmVxdWVzdHMuXG52YXIgZGVmYXVsdFJldHJ5RGVsYXkgPSAxMDAwMDtcblxuXG4vKipcbiAqIEBjbGFzcyBJbWFnZVVybFNvdXJjZVxuICogQGltcGxlbWVudHMgU291cmNlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgU291cmNlfSB0aGF0IGxvYWRzIHtAbGluayBBc3NldCBhc3NldHN9IGZyb20gaW1hZ2VzIGdpdmVuIGEgVVJMIGFuZFxuICogYSBjcm9wIHJlY3RhbmdsZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3VyY2VGcm9tVGlsZSBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgdGlsZSBhbmQgcmV0dXJuc1xuICogYSBgeyB1cmwsIHJlY3QgfWAgb2JqZWN0LCB3aGVyZSBgdXJsYCBpcyBhbiBpbWFnZSBVUkwgYW5kIGByZWN0YCwgd2hlblxuICogcHJlc2VudCwgaXMgYW4gYHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9YCBvYmplY3QgaW4gbm9ybWFsaXplZCBjb29yZGluYXRlc1xuICogZGVub3RpbmcgdGhlIHBvcnRpb24gb2YgdGhlIGltYWdlIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuY29uY3VycmVuY3k9NF0gTWF4aW11bSBudW1iZXIgb2YgdGlsZXMgdG8gcmVxdWVzdCBhdFxuICogICAgIHRoZSBzYW1lIHRpbWUuIFRoZSBsaW1pdCBpcyBwZXIge0BsaW5rIEltYWdlU291cmNlVXJsfSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZXRyeURlbGF5PTEwMDAwXSBUaW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuICogICAgIHJldHJ5aW5nIGEgZmFpbGVkIHJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIEltYWdlVXJsU291cmNlKHNvdXJjZUZyb21UaWxlLCBvcHRzKSB7XG5cbiAgb3B0cyA9IG9wdHMgPyBvcHRzIDoge307XG5cbiAgdGhpcy5fbG9hZFBvb2wgPSBuZXcgV29ya1Bvb2woe1xuICAgIGNvbmN1cnJlbmN5OiBvcHRzLmNvbmN1cnJlbmN5IHx8IGRlZmF1bHRDb25jdXJyZW5jeVxuICB9KTtcblxuICB0aGlzLl9yZXRyeURlbGF5ID0gb3B0cy5yZXRyeURlbGF5IHx8IGRlZmF1bHRSZXRyeURlbGF5O1xuICB0aGlzLl9yZXRyeU1hcCA9IHt9O1xuXG4gIHRoaXMuX3NvdXJjZUZyb21UaWxlID0gc291cmNlRnJvbVRpbGU7XG59XG5cbmV2ZW50RW1pdHRlcihJbWFnZVVybFNvdXJjZSk7XG5cblxuSW1hZ2VVcmxTb3VyY2UucHJvdG90eXBlLmxvYWRBc3NldCA9IGZ1bmN0aW9uKHN0YWdlLCB0aWxlLCBkb25lKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciByZXRyeURlbGF5ID0gdGhpcy5fcmV0cnlEZWxheTtcbiAgdmFyIHJldHJ5TWFwID0gdGhpcy5fcmV0cnlNYXA7XG5cbiAgdmFyIHRpbGVTb3VyY2UgPSB0aGlzLl9zb3VyY2VGcm9tVGlsZSh0aWxlKTtcbiAgdmFyIHVybCA9IHRpbGVTb3VyY2UudXJsO1xuICB2YXIgcmVjdCA9IHRpbGVTb3VyY2UucmVjdDtcblxuICB2YXIgbG9hZEltYWdlID0gc3RhZ2UubG9hZEltYWdlLmJpbmQoc3RhZ2UsIHVybCwgcmVjdCk7XG5cbiAgdmFyIGxvYWRGbiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAvLyBUT0RPOiBEZWR1cGxpY2F0ZSBsb2FkIHJlcXVlc3RzIGZvciB0aGUgc2FtZSBVUkwuIEFsdGhvdWdoIHRoZSBicm93c2VyXG4gICAgLy8gbWlnaHQgYmUgc21hcnQgZW5vdWdoIHRvIGF2b2lkIGR1cGxpY2F0ZSByZXF1ZXN0cywgdGhleSBhcmUgc3RpbGwgdW5kdWx5XG4gICAgLy8gaW1wYWN0ZWQgYnkgdGhlIGNvbmN1cnJlbmN5IHBhcmFtZXRlci5cbiAgICByZXR1cm4gc2VsZi5fbG9hZFBvb2wucHVzaChsb2FkSW1hZ2UsIGZ1bmN0aW9uKGVyciwgYXNzZXQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgbmV0d29yayBlcnJvciBvY2N1cnJlZCwgd2FpdCBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICAgICAgcmV0cnlNYXBbdXJsXSA9IG5vdygpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnbmV0d29ya0Vycm9yJywgYXNzZXQsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZShlcnIsIHRpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT24gYSBzdWNjZXNzZnVsIGZldGNoLCBmb3JnZXQgdGhlIHByZXZpb3VzIHRpbWVvdXQuXG4gICAgICAgIGRlbGV0ZSByZXRyeU1hcFt1cmxdO1xuICAgICAgICBkb25lKG51bGwsIHRpbGUsIGFzc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGFyZSByZXRyeWluZyBhIGZhaWxlZCByZXF1ZXN0LlxuICB2YXIgZGVsYXlBbW91bnQ7XG4gIHZhciBsYXN0VGltZSA9IHJldHJ5TWFwW3VybF07XG4gIGlmIChsYXN0VGltZSAhPSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgdmFyIGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIGxhc3RUaW1lO1xuICAgIGlmIChlbGFwc2VkIDwgcmV0cnlEZWxheSkge1xuICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICBkZWxheUFtb3VudCA9IHJldHJ5RGVsYXkgLSBlbGFwc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXRyeSB0aW1lb3V0IGV4cGlyZWQ7IHBlcmZvcm0gdGhlIHJlcXVlc3QgYXQgb25jZS5cbiAgICAgIGRlbGF5QW1vdW50ID0gMDtcbiAgICAgIGRlbGV0ZSByZXRyeU1hcFt1cmxdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxheUZuID0gZGVsYXkuYmluZChudWxsLCBkZWxheUFtb3VudCk7XG5cbiAgcmV0dXJuIGNoYWluKGRlbGF5Rm4sIGxvYWRGbikoZG9uZSk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBJbWFnZVVybFNvdXJjZSBmcm9tIGEgc3RyaW5nIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGlsZSBVUkwgdGVtcGxhdGUsIHdoaWNoIG1heSBjb250YWluIHRoZSBmb2xsb3dpbmdcbiAqICAgIHBsYWNlaG9sZGVyczpcbiAqICAgIC0gYHtmfWAgOiB0aWxlIGZhY2UgKG9uZSBvZiBgYmAsIGBkYCwgYGZgLCBgbGAsIGByYCwgYHVgKVxuICogICAgLSBge3p9YCA6IHRpbGUgbGV2ZWwgaW5kZXggKDAgaXMgdGhlIHNtYWxsZXN0IGxldmVsKVxuICogICAgLSBge3h9YCA6IHRpbGUgaG9yaXpvbnRhbCBpbmRleFxuICogICAgLSBge3l9YCA6IHRpbGUgdmVydGljYWwgaW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIEluIGFkZGl0aW9uIHRvIHRoZSBvcHRpb25zIGFscmVhZHkgc3VwcG9ydGVkIGJ5IHRoZVxuICogICAgIHtAbGluayBJbWFnZVVybFNvdXJjZX0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5jdWJlTWFwUHJldmlld1VybCBVUkwgdG8gdXNlIGFzIHRoZSBwcmV2aWV3IGxldmVsLlxuICogICAgIFRoaXMgbXVzdCBiZSBhIHNpbmdsZSBpbWFnZSBjb250YWluaW5nIHNpeCBjdWJlIGZhY2VzIGxhaWQgb3V0XG4gKiAgICAgdmVydGljYWxseSBhY2NvcmRpbmcgdG8gdGhlIGZhY2Ugb3JkZXIgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmN1YmVNYXBQcmV2aWV3RmFjZU9yZGVyPSdiZGZscnUnXSBGYWNlIG9yZGVyIHdpdGhpblxuICogICAgIHRoZSBwcmV2aWV3IGltYWdlLlxuICovXG5JbWFnZVVybFNvdXJjZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24odXJsLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBmYWNlT3JkZXIgPSBvcHRzICYmIG9wdHMuY3ViZU1hcFByZXZpZXdGYWNlT3JkZXIgfHwgZGVmYXVsdEN1YmVNYXBGYWNlT3JkZXI7XG5cbiAgdmFyIHVybEZuID0gb3B0cy5jdWJlTWFwUHJldmlld1VybCA/IHdpdGhQcmV2aWV3IDogd2l0aG91dFByZXZpZXc7XG5cbiAgcmV0dXJuIG5ldyBJbWFnZVVybFNvdXJjZSh1cmxGbiwgb3B0cyk7XG5cbiAgZnVuY3Rpb24gd2l0aG91dFByZXZpZXcodGlsZSkge1xuICAgIHZhciB0aWxlVXJsID0gdXJsO1xuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGVtcGxhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgdGVtcGxhdGVQcm9wZXJ0eSA9IHRlbXBsYXRlUHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICB2YXIgcmVnRXhwID0gcHJvcGVydHlSZWdFeHAocHJvcGVydHkpO1xuICAgICAgdmFyIHZhbHVlRnJvbVRpbGUgPSB0aWxlLmhhc093blByb3BlcnR5KHRlbXBsYXRlUHJvcGVydHkpID8gdGlsZVt0ZW1wbGF0ZVByb3BlcnR5XSA6ICcnO1xuICAgICAgdGlsZVVybCA9IHRpbGVVcmwucmVwbGFjZShyZWdFeHAsIHZhbHVlRnJvbVRpbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHVybDogdGlsZVVybCB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFByZXZpZXcodGlsZSkge1xuICAgIGlmICh0aWxlLnogPT09IDApIHtcbiAgICAgIHJldHVybiBjdWJlTWFwVXJsKHRpbGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB3aXRob3V0UHJldmlldyh0aWxlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjdWJlTWFwVXJsKHRpbGUpIHtcbiAgICB2YXIgeSA9IGZhY2VPcmRlci5pbmRleE9mKHRpbGUuZmFjZSkgLyA2O1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwsXG4gICAgICByZWN0OiB7IHg6IDAsIHk6IHksIHdpZHRoOiAxLCBoZWlnaHQ6IDEvNiB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcHJvcGVydHlSZWdFeHAocHJvcGVydHkpIHtcbiAgdmFyIHJlZ0V4cFN0ciA9ICdcXFxceygnICsgcHJvcGVydHkgKyAnKVxcXFx9JztcbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnRXhwU3RyLCAnZycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlVXJsU291cmNlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBTaW5nbGVBc3NldFNvdXJjZVxuICogQGltcGxlbWVudHMgU291cmNlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgU291cmNlfSB0aGF0IGFsd2F5cyBwcm92aWRlcyB0aGUgc2FtZSB7QGxpbmsgQXNzZXR9LlxuICpcbiAqIEBwYXJhbSB7QXNzZXR9IGFzc2V0IFRoZSBhc3NldC5cbiovXG5mdW5jdGlvbiBTaW5nbGVBc3NldFNvdXJjZShhc3NldCkge1xuICB0aGlzLl9hc3NldCA9IGFzc2V0O1xufVxuXG5TaW5nbGVBc3NldFNvdXJjZS5wcm90b3R5cGUuYXNzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fzc2V0O1xufTtcblxuU2luZ2xlQXNzZXRTb3VyY2UucHJvdG90eXBlLmxvYWRBc3NldCA9IGZ1bmN0aW9uKHN0YWdlLCB0aWxlLCBkb25lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZG9uZShudWxsLCB0aWxlLCBzZWxmLl9hc3NldCk7XG4gIH0sIDApO1xuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGNhbmNlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2luZ2xlQXNzZXRTb3VyY2U7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdGFnZSA9IHJlcXVpcmUoJy4vU3RhZ2UnKTtcbnZhciBIdG1sSW1hZ2VMb2FkZXIgPSByZXF1aXJlKCcuLi9sb2FkZXJzL0h0bWxJbWFnZScpO1xudmFyIGNzc1N1cHBvcnRlZCA9IHJlcXVpcmUoJy4uL3N1cHBvcnQvQ3NzJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIHNldEFic29sdXRlID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKS5zZXRBYnNvbHV0ZTtcbnZhciBzZXRGdWxsU2l6ZSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0RnVsbFNpemU7XG52YXIgc2V0TnVsbFRyYW5zZm9ybU9yaWdpbiA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0TnVsbFRyYW5zZm9ybU9yaWdpbjtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG5cbi8vIEJyb3dzZXItc3BlY2lmaWMgd29ya2Fyb3VuZHMuXG52YXIgYnJvd3NlclF1aXJrcyA9IHtcblxuICAvLyBPbiBtb3N0IGJyb3dzZXJzIHdlIG5lZWQgdG8gcGFkIHRoZSB0aWxlIGVkZ2VzIHdpdGggcmVwZWF0ZWQgcGl4ZWxzIHNvXG4gIC8vIHRoYXQgdGhlIGJvcmRlcnMgYmV0d2VlbiBuZWlnaGJvcmluZyB0aWxlcyBhcmVuJ3QgYXBwYXJlbnQuXG4gIC8vIE9uIGlPUyB0aGlzIGlzbid0IHJlcXVpcmVkLCBidXQgd2UgbXVzdCBkaXNhYmxlIGl0IGJlY2F1c2UgdGhlIHBhZGRpbmcgaXNcbiAgLy8gaW5jb3JyZWN0bHkgcmVuZGVyZWQgb24gdG9wIG9mIHRoZSBuZWlnaGJvcmluZyB0aWxlLlxuICBwYWRTaXplOiBicm93c2VyLmlvcyA/IDAgOiAzLFxuXG4gIC8vIEluIG9yZGVyIHRvIHByZXZlbnQgZmFsbGJhY2sgdGlsZXMgZnJvbSBvdmVybGFwcGluZyB0aGVpciBjaGlsZHJlbiwgaU9TXG4gIC8vIHJlcXVpcmVzIHNtYWxsZXIgem9vbSBsZXZlbHMgdG8gYmUgcGxhY2VkIGJlbG93IGxhcmdlciB6b29tIGxldmVscyBpblxuICAvLyB0aGUgQ1NTIDNEIGNvb3JkaW5hdGUgc3BhY2UuXG4gIHJldmVyc2VMZXZlbERlcHRoOiBicm93c2VyLmlvcyxcblxuICAvLyBBIG51bGwgdHJhbnNmb3JtIG9uIHRoZSBsYXllciBlbGVtZW50IGlzIHJlcXVpcmVkIHNvIHRoYXQgdHJhbnNpdGlvbnNcbiAgLy8gYmV0d2VlbiBsYXllcnMgd29yayBvbiBpT1MuXG4gIHVzZU51bGxUcmFuc2Zvcm06IGJyb3dzZXIuaW9zLFxuXG4gIC8vIE9uIFdlYmtpdCBhbmQgR2Vja28gYnJvd3NlcnMsIHNvbWUgdGlsZXMgYmVjb21lIGludmlzaWJsZSBhdCBjZXJ0YWluXG4gIC8vIGFuZ2xlcywgdXN1YWxseSBub24tZmxvb3IgdGlsZXMgd2hlbiBsb29raW5nIHN0cmFpZ2h0IGRvd24uIFNldHRpbmcgdGhlXG4gIC8vIHRyYW5zbGF0ZVogZm9sbG93aW5nIHRoZSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gdG8gYSBzbGlnaHRseSBsYXJnZXIgdmFsdWVcbiAgLy8gdGhhbiB0aGUgbGF0dGVyIHNlZW1zIHRvIHdvcmsgYXJvdW5kIHRoaXMgZ2xpdGNoLlxuICBwZXJzcGVjdGl2ZU51ZGdlOiBicm93c2VyLndlYmtpdCB8fCBicm93c2VyLmdlY2tvID8gMC4wMDEgOiAwXG5cbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgQ3NzU3RhZ2VcbiAqIEBleHRlbmRzIFN0YWdlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgU3RhZ2V9IGltcGxlbWVudGF0aW9uIHVzaW5nIENTUyAzRCBUcmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKlxuICogQWxzbyBzZWUgdGhlIGF2YWlsYWJsZSB7QGxpbmsgU3RhZ2V9IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIENzc1N0YWdlKG9wdHMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLl9sb2FkZXIgPSBuZXcgSHRtbEltYWdlTG9hZGVyKHRoaXMpO1xuXG4gIHRoaXMuX2RvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICBzZXRBYnNvbHV0ZSh0aGlzLl9kb21FbGVtZW50KTtcbiAgc2V0RnVsbFNpemUodGhpcy5fZG9tRWxlbWVudCk7XG5cbiAgLy8gTi5CLiB0aGUgQ1NTIHN0YWdlIHJlcXVpcmVzIGRldmljZSBhZGFwdGF0aW9uIHRvIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaFxuICAvLyB0aGUgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCI+IHRhZyBvbiB0aGUgY29udGFpbmluZyBkb2N1bWVudC5cbiAgLy8gRmFpbHVyZSB0byBkbyBzbyB3aWxsIGNhdXNlIGNsaXBwaW5nIGFuZCBwYWRkaW5nIGJ1Z3MgdG8gb2NjdXIsXG4gIC8vIGF0IGxlYXN0IG9uIGlPUyA8PSA3LlxufVxuXG5pbmhlcml0cyhDc3NTdGFnZSwgU3RhZ2UpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuQ3NzU3RhZ2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gRGVsZWdhdGUgY2xlYXJpbmcgb3duIHByb3BlcnRpZXMgdG8gdGhlIFN0YWdlIGRlc3RydWN0b3IuXG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG5cbkNzc1N0YWdlLnN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY3NzU3VwcG9ydGVkKCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5Dc3NTdGFnZS5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZG9tRWxlbWVudDtcbn07XG5cblxuQ3NzU3RhZ2UucHJvdG90eXBlLnNldFNpemVGb3JUeXBlID0gZnVuY3Rpb24oKSB7fTtcblxuXG5Dc3NTdGFnZS5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJsLCByZWN0LCBkb25lKSB7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZEltYWdlKHVybCwgcmVjdCwgZG9uZSk7XG59O1xuXG5cbkNzc1N0YWdlLnByb3RvdHlwZS52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuOyAvLyBhbHdheXMgdmFsaWRcbn07XG5cblxuQ3NzU3RhZ2UucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24oUmVuZGVyZXIpIHtcbiAgcmV0dXJuIG5ldyBSZW5kZXJlcih0aGlzLl9kb21FbGVtZW50LCBicm93c2VyUXVpcmtzKTtcbn07XG5cbkNzc1N0YWdlLnByb3RvdHlwZS5kZXN0cm95UmVuZGVyZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICByZW5kZXJlci5kZXN0cm95KCk7XG59O1xuXG5cbkNzc1N0YWdlLnByb3RvdHlwZS5zdGFydEZyYW1lID0gZnVuY3Rpb24oKSB7fTtcblxuXG5Dc3NTdGFnZS5wcm90b3R5cGUuZW5kRnJhbWUgPSBmdW5jdGlvbigpIHt9O1xuXG5cbkNzc1N0YWdlLnByb3RvdHlwZS50YWtlU25hcHNob3QgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDc3NTdGFnZTogdGFrZVNuYXBzaG90IG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuXG5Dc3NTdGFnZS50eXBlID0gQ3NzU3RhZ2UucHJvdG90eXBlLnR5cGUgPSAnY3NzJztcblxuXG5mdW5jdGlvbiBDc3NUZXh0dXJlKHN0YWdlLCB0aWxlLCBhc3NldCkge1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgc2V0QWJzb2x1dGUoY2FudmFzKTtcbiAgc2V0TnVsbFRyYW5zZm9ybU9yaWdpbihjYW52YXMpO1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fdGltZXN0YW1wID0gbnVsbDtcbiAgdGhpcy5yZWZyZXNoKHRpbGUsIGFzc2V0KTtcblxufVxuXG5cbkNzc1RleHR1cmUucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbih0aWxlLCBhc3NldCkge1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZC5cbiAgdmFyIHRpbWVzdGFtcCA9IGFzc2V0LnRpbWVzdGFtcCgpO1xuICBpZiAodGltZXN0YW1wID09PSB0aGlzLl90aW1lc3RhbXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBHZXQgYXNzZXQgZWxlbWVudC5cbiAgdmFyIGVsZW1lbnQgPSBhc3NldC5lbGVtZW50KCk7XG5cbiAgLy8gR2V0IHRpbGUgZGltZW5zaW9ucy5cbiAgdmFyIHRpbGVXaWR0aCA9IHRpbGUud2lkdGgoKTtcbiAgdmFyIHRpbGVIZWlnaHQgPSB0aWxlLmhlaWdodCgpO1xuXG4gIC8vIEdldCBwYWRkaW5nIHNpemVzLlxuICB2YXIgcGFkU2l6ZSA9IGJyb3dzZXJRdWlya3MucGFkU2l6ZTtcbiAgdmFyIHBhZFRvcCA9IHRpbGUucGFkVG9wKCkgPyBwYWRTaXplIDogMDtcbiAgdmFyIHBhZEJvdHRvbSA9IHRpbGUucGFkQm90dG9tKCkgPyBwYWRTaXplIDogMDtcbiAgdmFyIHBhZExlZnQgPSB0aWxlLnBhZExlZnQoKSA/IHBhZFNpemUgOiAwO1xuICB2YXIgcGFkUmlnaHQgPSB0aWxlLnBhZFJpZ2h0KCkgPyBwYWRTaXplIDogMDtcblxuICAvLyBTZXQgY2FudmFzIHNpemUuXG4gIGNhbnZhcy53aWR0aCA9IHBhZExlZnQgKyB0aWxlV2lkdGggKyBwYWRSaWdodDtcbiAgY2FudmFzLmhlaWdodCA9IHBhZFRvcCArIHRpbGVIZWlnaHQgKyBwYWRCb3R0b207XG5cbiAgLy8gRHJhdyBpbWFnZS5cbiAgY3R4LmRyYXdJbWFnZShlbGVtZW50LCBwYWRMZWZ0LCBwYWRUb3AsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCk7XG5cbiAgdmFyIGk7XG5cbiAgLy8gRHJhdyB0b3AgcGFkZGluZy5cbiAgZm9yIChpID0gMDsgaSA8IHBhZFRvcDsgaSsrKSB7XG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIHBhZExlZnQsIHBhZFRvcCwgdGlsZVdpZHRoLCAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRMZWZ0LCBpLCB0aWxlV2lkdGgsIDEpO1xuICB9XG5cbiAgLy8gRHJhdyBsZWZ0IHBhZGRpbmcuXG4gIGZvciAoaSA9IDA7IGkgPCBwYWRMZWZ0OyBpKyspIHtcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgcGFkTGVmdCwgcGFkVG9wLCAxLCB0aWxlSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpLCBwYWRUb3AsIDEsIHRpbGVIZWlnaHQpO1xuICB9XG5cbiAgLy8gRHJhdyBib3R0b20gcGFkZGluZy5cbiAgZm9yIChpID0gMDsgaSA8IHBhZEJvdHRvbTsgaSsrKSB7XG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIHBhZExlZnQsIHBhZFRvcCArIHRpbGVIZWlnaHQgLSAxLCB0aWxlV2lkdGgsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhZExlZnQsIHBhZFRvcCArIHRpbGVIZWlnaHQgKyBpLCB0aWxlV2lkdGgsIDEpO1xuICB9XG5cbiAgLy8gRHJhdyByaWdodCBwYWRkaW5nLlxuICBmb3IgKGkgPSAwOyBpIDwgcGFkUmlnaHQ7IGkrKykge1xuICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCBwYWRMZWZ0ICsgdGlsZVdpZHRoIC0gMSwgcGFkVG9wLCAxLCB0aWxlSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRMZWZ0ICsgdGlsZVdpZHRoICsgaSwgcGFkVG9wLCAxLCB0aWxlSGVpZ2h0KTtcbiAgfVxuXG59O1xuXG5cbkNzc1RleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETzogaW52ZXN0aWdhdGUgd2hldGhlciBrZWVwaW5nIGEgcG9vbCBvZiBjYW52YXNlcyBpbnN0ZWFkIG9mXG4gIC8vIGNyZWF0aW5nIG5ldyBvbmVzIG9uIGRlbWFuZCBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5Dc3NTdGFnZS5UZXh0dXJlQ2xhc3MgPSBDc3NTdGFnZS5wcm90b3R5cGUuVGV4dHVyZUNsYXNzID0gQ3NzVGV4dHVyZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENzc1N0YWdlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhZ2UgPSByZXF1aXJlKCcuL1N0YWdlJyk7XG52YXIgRmxhc2hJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uL2xvYWRlcnMvRmxhc2hJbWFnZScpO1xudmFyIGZsYXNoU3VwcG9ydGVkID0gcmVxdWlyZSgnLi4vc3VwcG9ydC9GbGFzaCcpO1xudmFyIFdvcmtRdWV1ZSA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL1dvcmtRdWV1ZScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIGRlZmVyID0gcmVxdWlyZSgnLi4vdXRpbC9kZWZlcicpO1xudmFyIHNldEFic29sdXRlID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKS5zZXRBYnNvbHV0ZTtcbnZhciBzZXRGdWxsU2l6ZSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0RnVsbFNpemU7XG52YXIgc2V0QmxvY2tpbmcgPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldEJsb2NraW5nO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8vIERlZmF1bHQgRmxhc2ggd21vZGUuXG52YXIgZGVmYXVsdFdNb2RlID0gJ3RyYW5zcGFyZW50JztcblxuLy8gRGVmYXVsdCBGbGFzaCBTV0YgcGF0aC4gQnkgZGVmYXVsdCwgZXhwZWN0IHRoZSBTV0YgdG8gYmUgbmFtZWQgbWFyemlwYW5vLnN3ZlxuLy8gYW5kIGxvY2F0ZWQgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBjdXJyZW50IHNjcmlwdC4gVGhlIGRlZmF1bHQgcGF0aFxuLy8gbWF5IGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyB0aGUgYHN3ZlBhdGhgIG9wdGlvbiBpbnRvIHRoZSBWaWV3ZXIgb3IgU3RhZ2Vcbi8vIGNvbnN0cnVjdG9yLlxudmFyIGRlZmF1bHRTd2ZQYXRoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICBpZiAoIXNjcmlwdCkge1xuICAgIC8vIFRoaXMgd2lsbCBwcm9kdWNlIHRoZSB3cm9uZyByZXN1bHQgaWYgdGhlIGN1cnJlbnQgc2NyaXB0IGlzIGxvYWRlZCB3aXRoXG4gICAgLy8gdGhlIGBhc3luY2Agb3IgYGRlZmVyYCBvcHRpb25zLCBvciBleGVjJ2VkIGZyb20gYSBzdHJpbmcuIFRoZSB1c2VyIGlzXG4gICAgLy8gZXhwZWN0ZWQgdG8gc3VwcGx5IGEgY3VzdG9tIGBzd2ZQYXRoYCBpbiB0aGVzZSBjYXNlcy5cbiAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICBzY3JpcHQgPSBzY3JpcHRzLmxlbmd0aCA/IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGgtMV0gOiBudWxsO1xuICB9XG4gIGlmICghc2NyaXB0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhdGggPSBzY3JpcHQuc3JjO1xuICB2YXIgc2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gIGlmIChzbGFzaCA+PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgc2xhc2ggKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGggKyAnbWFyemlwYW5vLnN3Zic7XG59KCk7XG5cbi8vIENhbGxiYWNrcyBtdXN0IGJlIGV4cG9zZWQgaW4gYSBnbG9iYWwgb2JqZWN0IHRvIGJlIGNhbGxlZCBmcm9tIEZsYXNoLlxuLy8gVGhlIGdsb2JhbCBvYmplY3QgbWFwcyBlYWNoIHN0YWdlIElEIGludG8gdGhlIHJlc3BlY3RpdmUgY2FsbGJhY2tzLlxuLy8gVG8gcHJldmVudCBtdWx0aXBsZSBNYXJ6aXBhbm8gaW5zdGFuY2VzIGZyb20gY2xvYmJlcmluZyB0aGUgY2FsbGJhY2tzXG4vLyBmb3IgZWFjaCBvdGhlcidzIHN0YWdlcywgdGhlIG5leHQgYXZhaWxhYmxlIHN0YWdlIElEIG11c3QgYmUgc2hhcmVkIGFtb25nXG4vLyB0aGUgaW5zdGFuY2VzLiBXZSBjYWNoZSB0aGlzIHZhbHVlIGluIGEgc3BlY2lhbCBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsXG4vLyBjYWxsYmFjayBvYmplY3QuXG52YXIgY2FsbGJhY2tPYmplY3ROYW1lID0gJ01hcnppcGFub0ZsYXNoQ2FsbGJhY2tNYXAnO1xuaWYgKCEoY2FsbGJhY2tPYmplY3ROYW1lIGluIHdpbmRvdykpIHtcbiAgd2luZG93W2NhbGxiYWNrT2JqZWN0TmFtZV0gPSB7IF9fbmV4dDogMCB9O1xufVxuXG4vLyBHZXQgdGhlIG5leHQgYXZhaWxhYmxlIEZsYXNoIHN0YWdlIElELlxuZnVuY3Rpb24gbmV4dEZsYXNoU3RhZ2VJZCgpIHtcbiAgcmV0dXJuIHdpbmRvd1tjYWxsYmFja09iamVjdE5hbWVdLl9fbmV4dCsrO1xufVxuXG4vLyBOYW1lcyBvZiB0aGUgY2FsbGJhY2tzIGNhbGxlZCBmcm9tIEZsYXNoLiBQcmVzZW50bHkgdGhlcmUgaXMgb25seSBvbmUuXG52YXIgY2FsbGJhY2tOYW1lcyA9IFsgJ2ltYWdlTG9hZGVkJyBdO1xuXG4vLyBCcm93c2VyLXNwZWNpZmljIHdvcmthcm91bmRzLlxudmFyIGZsYXNoUXVpcmtzID0ge1xuICAvLyBIb3cgbWFueSByZXBlYXRlZCBwaXhlbHMgdG8gYWRkIGFyb3VuZCB0aWxlIGVkZ2VzIHRvIHN1cHByZXNzIHZpc2libGUgc2VhbXMuXG4gIHBhZFNpemU6IDNcbn07XG5cbi8qKlxuICogQGNsYXNzIEZsYXNoU3RhZ2VcbiAqIEBleHRlbmRzIFN0YWdlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgU3RhZ2V9IGltcGxlbWVudGF0aW9uIHVzaW5nIEZsYXNoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMud21vZGU9J3RyYW5zcGFyZW50J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5zd2ZQYXRoXVxuICpcbiAqIFRoZSBgd21vZGVgIG9wdGlvbiBjb250cm9scyB0cmFuc3BhcmVuY3ksIGxheWVyaW5nIGFuZCBjb21wb3NpdGluZyBvZiB0aGVcbiAqIEZsYXNoIGVsZW1lbnQgaW50byB0aGUgd2ViIHBhZ2UuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZTpcbiAqIGh0dHA6Ly9oZWxweC5hZG9iZS5jb20vZmxhc2gva2IvZmxhc2gtb2JqZWN0LWVtYmVkLXRhZy1hdHRyaWJ1dGVzLmh0bWxcbiAqXG4gKiBUaGUgYHN3ZlBhdGhgIG9wdGlvbiBkZW5vdGVzIHRoZSBwYXRoIHRvIHRoZSBgbWFyemlwYW5vLnN3ZmAgZmlsZS4gSXRcbiAqIGRlZmF1bHRzIHRvIHRoZSBsb2NhdGlvbiBvZiBgbWFyemlwYW5vLmpzYCBieSBsb29raW5nIGZvciBhIHNjcmlwdCB0YWcgd2l0aFxuICogdGhhdCBuYW1lLlxuICpcbiAqIEFsc28gc2VlIHRoZSBhdmFpbGFibGUge0BsaW5rIFN0YWdlfSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBGbGFzaFN0YWdlKG9wdHMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLl93bW9kZSA9IG9wdHMgJiYgb3B0cy53bW9kZSB8fCBkZWZhdWx0V01vZGU7XG4gIHRoaXMuX3N3ZlBhdGggPSBvcHRzICYmIG9wdHMuc3dmUGF0aCB8fCBkZWZhdWx0U3dmUGF0aDtcblxuICBpZiAoIWRlZmF1bHRTd2ZQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFNXRiBwYXRoJyk7XG4gIH1cblxuICAvLyBTZXR1cCBKYXZhU2NyaXB0IGNhbGxiYWNrcyB0byBiZSBjYWxsZWQgZnJvbSBGbGFzaCBsYW5kIHdoZW5cbiAgLy8gYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMgdGVybWluYXRlLlxuICB0aGlzLl9mbGFzaFN0YWdlSWQgPSBuZXh0Rmxhc2hTdGFnZUlkKCk7XG4gIHRoaXMuX2NhbGxiYWNrc09iaiA9IHdpbmRvd1tjYWxsYmFja09iamVjdE5hbWVdW3RoaXMuX2ZsYXNoU3RhZ2VJZF0gPSB7fTtcbiAgdGhpcy5fc3RhZ2VDYWxsYmFja3NPYmpWYXJOYW1lID0gY2FsbGJhY2tPYmplY3ROYW1lICsgJ1snICsgdGhpcy5fZmxhc2hTdGFnZUlkICsgJ10nO1xuICB0aGlzLl9jYWxsYmFja0xpc3RlbmVycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9jYWxsYmFja3NPYmpbY2FsbGJhY2tOYW1lc1tpXV0gPSB0aGlzLl9jYWxsTGlzdGVuZXJzKGNhbGxiYWNrTmFtZXNbaV0pO1xuICB9XG5cbiAgdGhpcy5fbG9hZGVyID0gbmV3IEZsYXNoSW1hZ2VMb2FkZXIodGhpcyk7XG5cbiAgLy8gUXVldWUgZm9yIGxvYWRJbWFnZSBjYWxscy5cbiAgLy8gVGhlIHF1ZXVlIHN0YXJ0cyBwYXVzZWQgc28gdGhhdCBsb2FkSW1hZ2UgY2FsbHMgb2NjdXJyaW5nIGJlZm9yZSBGbGFzaFxuICAvLyBpcyByZWFkeSBkbyBub3Qgc3RhcnQgcmlnaHQgYXdheSAoYXMgdGhleSB3b3VsZCBmYWlsKS5cbiAgLy8gVE9ETzogVGhpcyBpcyBhd2t3YXJkLiBUaGUgc3RhZ2UgbXVzdCBzaWduYWwgdGhhdCBpdCdzIHJlYWR5IHRvIGxvYWRcbiAgLy8gaW1hZ2VzLCBidXQgcXVldWluZyBzaG91bGQgb3RoZXJ3aXNlIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBsb2FkZXIuXG4gIHRoaXMuX2xvYWRJbWFnZVF1ZXVlID0gbmV3IFdvcmtRdWV1ZSgpO1xuICB0aGlzLl9sb2FkSW1hZ2VRdWV1ZS5wYXVzZSgpO1xuXG4gIC8vIFdoZXRoZXIgZmxhc2ggaXMgcmVhZHkgdG8gYmUgY2FsbGVkIGZyb20gSmF2YVNjcmlwdC5cbiAgdGhpcy5fZmxhc2hSZWFkeSA9IGZhbHNlO1xuXG4gIC8vIEFkZCBhbiBJRCB0byBlYWNoIHJlbmRlcmVyL2xheWVyLCBzbyB0aGF0IGl0IGNhbiBiZSBpZGVudGlmaWVkIHdpdGhpblxuICAvLyB0aGUgQWN0aW9uU2NyaXB0IHByb2dyYW0uXG4gIHRoaXMuX25leHRMYXllcklkID0gMDtcblxuICAvLyBDcmVhdGUgdGhlIERPTSBlbGVtZW50cy5cbiAgdmFyIGVsZW1lbnRzID0gY3JlYXRlRG9tRWxlbWVudHModGhpcy5fc3dmUGF0aCwgdGhpcy5fZmxhc2hTdGFnZUlkLCB0aGlzLl9zdGFnZUNhbGxiYWNrc09ialZhck5hbWUpO1xuICB0aGlzLl9kb21FbGVtZW50ID0gZWxlbWVudHMucm9vdDtcbiAgdGhpcy5fYmxvY2tpbmdFbGVtZW50ID0gZWxlbWVudHMuYmxvY2tpbmc7XG4gIHRoaXMuX2ZsYXNoRWxlbWVudCA9IGVsZW1lbnRzLmZsYXNoO1xuXG4gIC8vIFdha2UgdXAgdGhlIHJlbmRlciBsb29wIHdoZW4gd2UgYXJlIHJlYWR5IChvbmx5IGFmdGVyIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSlcbiAgdGhpcy5fY2hlY2tSZWFkeVRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fY2hlY2tSZWFkeS5iaW5kKHRoaXMpLCA1MCk7XG59XG5cbmluaGVyaXRzKEZsYXNoU3RhZ2UsIFN0YWdlKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkZsYXNoU3RhZ2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93W2NhbGxiYWNrT2JqZWN0TmFtZV1bdGhpcy5fZmxhc2hTdGFnZUlkXSA9IG51bGw7XG4gIGlmICh0aGlzLl9jaGVja1JlYWR5VGltZXIgIT0gbnVsbCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tSZWFkeVRpbWVyKTtcbiAgfVxuICAvLyBEZWxlZ2F0ZSBjbGVhcmluZyBvd24gcHJvcGVydGllcyB0byB0aGUgU3RhZ2UgZGVzdHJ1Y3Rvci5cbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8ucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbn07XG5cblxuRmxhc2hTdGFnZS5zdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZsYXNoU3VwcG9ydGVkKCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbkZsYXNoU3RhZ2UucHJvdG90eXBlLmRvbUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2RvbUVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBGbGFzaCBlbGVtZW50LlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuRmxhc2hTdGFnZS5wcm90b3R5cGUuZmxhc2hFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mbGFzaEVsZW1lbnQ7XG59O1xuXG5cbkZsYXNoU3RhZ2UucHJvdG90eXBlLnNldFNpemVGb3JUeXBlID0gZnVuY3Rpb24oKSB7fTtcblxuXG5GbGFzaFN0YWdlLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIHJlY3QsIGRvbmUpIHtcbiAgLy8gVE9ETzogTW92ZSB0aGUgcXVldWluZyBpbnRvIHRoZSBsb2FkZXIsIHdoaWNoIGF2b2lkcyB0aGlzIG5vbnNlbnNlLlxuICB2YXIgbG9hZEZuID0gdGhpcy5fbG9hZGVyLmxvYWRJbWFnZS5iaW5kKHRoaXMuX2xvYWRlciwgdXJsLCByZWN0KTtcbiAgcmV0dXJuIHRoaXMuX2xvYWRJbWFnZVF1ZXVlLnB1c2gobG9hZEZuLCBkb25lKTtcbn07XG5cblxuRmxhc2hTdGFnZS5wcm90b3R5cGUudmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHJldHVybjsgLy8gYWx3YXlzIHZhbGlkXG59O1xuXG5cbkZsYXNoU3RhZ2UucHJvdG90eXBlLmFkZEZsYXNoQ2FsbGJhY2tMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrTmFtZSwgZikge1xuICB0aGlzLl9jYWxsYmFja0xpc3RlbmVyc1tjYWxsYmFja05hbWVdID0gdGhpcy5fY2FsbGJhY2tMaXN0ZW5lcnNbY2FsbGJhY2tOYW1lXSB8fCBbXTtcbiAgdGhpcy5fY2FsbGJhY2tMaXN0ZW5lcnNbY2FsbGJhY2tOYW1lXS5wdXNoKGYpO1xufTtcblxuXG5GbGFzaFN0YWdlLnByb3RvdHlwZS5yZW1vdmVGbGFzaENhbGxiYWNrTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFja05hbWUsIGYpIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2NhbGxiYWNrTGlzdGVuZXJzW2NhbGxiYWNrTmFtZV0gfHwgW107XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGYpO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5cbkZsYXNoU3RhZ2UucHJvdG90eXBlLl9jYWxsTGlzdGVuZXJzID0gZnVuY3Rpb24oY2FsbGJhY2tOYW1lKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjYWxsTGlzdGVuZXJzKCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBzZWxmLl9jYWxsYmFja0xpc3RlbmVyc1tjYWxsYmFja05hbWVdIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBKYXZhU2NyaXB0IGV4ZWN1dGVkIG9uIGNhbGxzIGZyb20gRmxhc2ggZG9lcyBub3QgdGhyb3cgZXhjZXB0aW9ucy5cbiAgICAgIC8vIEV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgaW4gYSBuZXcgc3RhY2sgZnJhbWUgZml4ZXMgdGhpcy5cbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGRlZmVyKGxpc3RlbmVyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuRmxhc2hTdGFnZS5wcm90b3R5cGUuX2NoZWNrUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9mbGFzaEVsZW1lbnQgfHxcbiAgICAgICF0aGlzLl9mbGFzaEVsZW1lbnQuaXNSZWFkeSB8fFxuICAgICAgIXRoaXMuX2ZsYXNoRWxlbWVudC5pc1JlYWR5KCkpIHtcbiAgICAvLyBOb3QgcmVhZHkgeWV0LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1hcmsgYXMgcmVhZHkuXG4gIHRoaXMuX2ZsYXNoUmVhZHkgPSB0cnVlO1xuXG4gIC8vIERpc2FibGUgaW50ZXJ2YWwgdGltZXIuXG4gIGNsZWFyVGltZW91dCh0aGlzLl9jaGVja1JlYWR5VGltZXIpO1xuICB0aGlzLl9jaGVja1JlYWR5VGltZXIgPSBudWxsO1xuXG4gIC8vIFJlc3VtZSBpbWFnZSBsb2FkaW5nIHF1ZXVlLlxuICB0aGlzLl9sb2FkSW1hZ2VRdWV1ZS5yZXN1bWUoKTtcblxuICAvLyBGb3JjZSBuZXh0IHJlbmRlci5cbiAgdGhpcy5lbWl0KCdyZW5kZXJJbnZhbGlkJyk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZURvbUVsZW1lbnRzKHN3ZlBhdGgsIGlkLCBzdGFnZUNhbGxiYWNrc09ialZhck5hbWUpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHJvb3RFbGVtZW50KTtcbiAgc2V0RnVsbFNpemUocm9vdEVsZW1lbnQpO1xuXG4gIC8vIFRoZSBGbGFzaCBvYmplY3QgbXVzdCBoYXZlIGBpZGAgYW5kIGBuYW1lYCBhdHRyaWJ1dGVzLCBvdGhlcndpc2VcbiAgLy8gRXh0ZXJuYWxJbnRlcmZhY2UgY2FsbHMgd2lsbCBub3Qgd29yay5cbiAgdmFyIGVsZW1lbnRJZCA9IFwibWFyemlwYW5vLWZsYXNoLXN0YWdlLVwiICsgaWQ7XG5cbiAgdmFyIG9iamVjdFN0ciA9ICc8b2JqZWN0IGlkPVwiJyArIGVsZW1lbnRJZCArICdcIiBuYW1lPVwiJyArIGVsZW1lbnRJZCArICdcIiB0eXBlPVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIiBkYXRhPVwiJyArIHN3ZlBhdGggKyAnXCI+JztcblxuICB2YXIgcGFyYW1zU3RyID0gJyc7XG4gIHBhcmFtc1N0ciArPSAnPHBhcmFtIG5hbWU9XCJtb3ZpZVwiIHZhbHVlPVwiJyArIHN3ZlBhdGggKyAnXCIgLz4nO1xuICBwYXJhbXNTdHIgKz0gJzxwYXJhbSBuYW1lPVwiYWxsb3dzY3JpcHRhY2Nlc3NcIiB2YWx1ZT1cImFsd2F5c1wiIC8+JztcbiAgcGFyYW1zU3RyICs9ICc8cGFyYW0gbmFtZT1cImZsYXNodmFyc1wiIHZhbHVlPVwiY2FsbGJhY2tzT2JqTmFtZT0nICsgc3RhZ2VDYWxsYmFja3NPYmpWYXJOYW1lICsgJ1wiIC8+JztcbiAgcGFyYW1zU3RyICs9ICc8cGFyYW0gbmFtZT1cIndtb2RlXCIgdmFsdWU9XCJ0cmFuc3BhcmVudFwiIC8+JztcblxuICBvYmplY3RTdHIgKz0gcGFyYW1zU3RyO1xuICBvYmplY3RTdHIgKz0gJzwvb2JqZWN0Pic7XG5cbiAgLy8gRW1iZWQgRmxhc2ggaW50byB0aGUgRE9NLlxuICAvLyBBZGRpbmcgY2hpbGRyZW4gaW50byBhbiA8b2JqZWN0PiBlbGVtZW50IGRvZXNuJ3Qgd29yaywgc28gd2UgY3JlYXRlIGFcbiAgLy8gdGVtcG9yYXJ5IGVsZW1lbnQgYW5kIHNldCBpdHMgaW5uZXJIVE1MLlxuICB2YXIgdG1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0bXBFbGVtZW50LmlubmVySFRNTCA9IG9iamVjdFN0cjtcbiAgdmFyIGZsYXNoRWxlbWVudCA9IHRtcEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgc2V0QWJzb2x1dGUoZmxhc2hFbGVtZW50KTtcbiAgc2V0RnVsbFNpemUoZmxhc2hFbGVtZW50KTtcbiAgcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQoZmxhc2hFbGVtZW50KTtcblxuICAvLyBDcmVhdGUgYmxvY2tpbmcgZWxlbWVudCB0byBwcmV2ZW50IGV2ZW50cyBmcm9tIGJlaW5nIGNhdWdodCBieSBGbGFzaC5cbiAgdmFyIGJsb2NraW5nRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzZXRBYnNvbHV0ZShibG9ja2luZ0VsZW1lbnQpO1xuICBzZXRGdWxsU2l6ZShibG9ja2luZ0VsZW1lbnQpO1xuICBzZXRCbG9ja2luZyhibG9ja2luZ0VsZW1lbnQpO1xuICByb290RWxlbWVudC5hcHBlbmRDaGlsZChibG9ja2luZ0VsZW1lbnQpO1xuXG4gIHJldHVybiB7IHJvb3Q6IHJvb3RFbGVtZW50LCBmbGFzaDogZmxhc2hFbGVtZW50LCBibG9ja2luZzogYmxvY2tpbmdFbGVtZW50IH07XG59XG5cblxuRmxhc2hTdGFnZS5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbihSZW5kZXJlcikge1xuICByZXR1cm4gbmV3IFJlbmRlcmVyKHRoaXMuX2ZsYXNoRWxlbWVudCwgKyt0aGlzLl9uZXh0TGF5ZXJJZCwgZmxhc2hRdWlya3MpO1xufTtcblxuXG5GbGFzaFN0YWdlLnByb3RvdHlwZS5kZXN0cm95UmVuZGVyZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICByZW5kZXJlci5kZXN0cm95KCk7XG59O1xuXG5cbkZsYXNoU3RhZ2UucHJvdG90eXBlLnN0YXJ0RnJhbWUgPSBmdW5jdGlvbigpIHt9O1xuXG5cbkZsYXNoU3RhZ2UucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24oKSB7fTtcblxuXG5GbGFzaFN0YWdlLnByb3RvdHlwZS50YWtlU25hcHNob3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyBWYWxpZGF0ZSBhcmd1bWVudC5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eTtcblxuICAvLyBTZXQgZGVmYXVsdCBxdWFsaXR5IGlmIGl0IGlzIG5vdCBwYXNzZWQgaW4uXG4gIGlmICh0eXBlb2YgcXVhbGl0eSA9PSAndW5kZWZpbmVkJykge1xuICAgIHF1YWxpdHkgPSA3NTtcbiAgfVxuXG4gIC8vIFRocm93IGlmIHF1YWxpdHkgaXMgb2YgaW52bGlkIHR5cGUgb3Igb3V0IG9mIGJvdW5kcy5cbiAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAnbnVtYmVyJyB8fCBxdWFsaXR5IDwgMCB8fCBxdWFsaXR5ID4gMTAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGFzaFN0YWdlOiBTbmFwc2hvdCBxdWFsaXR5IG5lZWRzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwJyk7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHNuYXBzaG90IGJ5IGV4ZWN1dGluZyBhIGZsYXNoLWV4cG9ydGVkIG1ldGhvZC5cbiAgcmV0dXJuIHRoaXMuX2ZsYXNoRWxlbWVudC50YWtlU25hcHNob3QocXVhbGl0eSk7XG59O1xuXG5cbkZsYXNoU3RhZ2UudHlwZSA9IEZsYXNoU3RhZ2UucHJvdG90eXBlLnR5cGUgPSAnZmxhc2gnO1xuXG5cbmZ1bmN0aW9uIEZsYXNoVGV4dHVyZShzdGFnZSwgdGlsZSwgYXNzZXQpIHtcblxuICAvLyBHZXQgaW1hZ2UgaWQuXG4gIHZhciBpbWFnZUlkID0gYXNzZXQuZWxlbWVudCgpO1xuXG4gIC8vIEdldCB0aWxlIGRpbWVuc2lvbnMuXG4gIHZhciB0aWxlV2lkdGggPSB0aWxlLndpZHRoKCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGlsZS5oZWlnaHQoKTtcblxuICAvLyBHZXQgcGFkZGluZyBzaXplcy5cbiAgdmFyIHBhZFNpemUgPSBmbGFzaFF1aXJrcy5wYWRTaXplO1xuICB2YXIgcGFkVG9wID0gdGlsZS5wYWRUb3AoKSA/IHBhZFNpemUgOiAwO1xuICB2YXIgcGFkQm90dG9tID0gdGlsZS5wYWRCb3R0b20oKSA/IHBhZFNpemUgOiAwO1xuICB2YXIgcGFkTGVmdCA9IHRpbGUucGFkTGVmdCgpID8gcGFkU2l6ZSA6IDA7XG4gIHZhciBwYWRSaWdodCA9IHRpbGUucGFkUmlnaHQoKSA/IHBhZFNpemUgOiAwO1xuXG4gIHZhciB0ZXh0dXJlSWQgPSBzdGFnZS5fZmxhc2hFbGVtZW50LmNyZWF0ZVRleHR1cmUoaW1hZ2VJZCwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBwYWRUb3AsIHBhZEJvdHRvbSwgcGFkTGVmdCwgcGFkUmlnaHQpO1xuXG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG4gIHRoaXMuX3RleHR1cmVJZCA9IHRleHR1cmVJZDtcbn1cblxuXG5GbGFzaFRleHR1cmUucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbih0aWxlLCBhc3NldCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlcXVpcmVkIGZvciB0aGUgRmxhc2ggc3RhZ2UgdG8gc3VwcG9ydCBkeW5hbWljIHRleHR1cmVzLlxuICAvLyBIb3dldmVyLCB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGR5bmFtaWMgdGV4dHVyZXMgdGhhdCB3b3JrIHdpdGggdGhlXG4gIC8vIEZsYXNoIHN0YWdlLlxufTtcblxuXG5GbGFzaFRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhZ2UuX2ZsYXNoRWxlbWVudC5kZXN0cm95VGV4dHVyZSh0aGlzLl90ZXh0dXJlSWQpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbkZsYXNoU3RhZ2UuVGV4dHVyZUNsYXNzID0gRmxhc2hTdGFnZS5wcm90b3R5cGUuVGV4dHVyZUNsYXNzID0gRmxhc2hUZXh0dXJlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmxhc2hTdGFnZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgUmVuZGVyZXJSZWdpc3RyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgUmVuZGVyZXJSZWdpc3RyeSBtYXBzIHBhaXJzIG9mIHtAbGluayBHZW9tZXRyeX0gYW5kIHtAbGluayBWaWV3fSB0eXBlIGludG9cbiAqIHRoZSBhcHByb3ByaWF0ZSB7QGxpbmsgUmVuZGVyZXJ9IGNsYXNzLiBJdCBpcyB1c2VkIGJ5IGEge0BsaW5rIFN0YWdlfSB0b1xuICogZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJlciBmb3IgYSB7QGxpbmsgTGF5ZXJ9LlxuICpcbiAqIFNlZSBhbHNvIHtAbGluayBTdGFnZSNyZWdpc3RlclJlbmRlcmVyfS5cbiAqL1xuZnVuY3Rpb24gUmVuZGVyZXJSZWdpc3RyeSgpIHtcbiAgdGhpcy5fcmVuZGVyZXJzID0ge307XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgcmVuZGVyZXIgZm9yIHRoZSBnaXZlbiBnZW9tZXRyeSBhbmQgdmlldyB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IGdlb21ldHJ5VHlwZSBUaGUgZ2VvbWV0cnkgdHlwZSwgYXMgZ2l2ZW4gYnlcbiAqICAgICB7QGxpbmsgR2VvbWV0cnkjdHlwZX0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld1R5cGUgVGhlIHZpZXcgdHlwZSwgYXMgZ2l2ZW4gYnkge0BsaW5rIFZpZXcjdHlwZX0uXG4gKiBAcGFyYW0geyp9IFJlbmRlcmVyIFRoZSByZW5kZXJlciBjbGFzcy5cbiAqL1xuUmVuZGVyZXJSZWdpc3RyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZ2VvbWV0cnlUeXBlLCB2aWV3VHlwZSwgUmVuZGVyZXIpIHtcbiAgaWYgKCF0aGlzLl9yZW5kZXJlcnNbZ2VvbWV0cnlUeXBlXSkge1xuICAgIHRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdID0ge307XG4gIH1cbiAgdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV1bdmlld1R5cGVdID0gUmVuZGVyZXI7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgcmVuZGVyZXIgZm9yIHRoZSBnaXZlbiBnZW9tZXRyeSBhbmQgdmlldyB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IGdlb21ldHJ5VHlwZSBUaGUgZ2VvbWV0cnkgdHlwZSwgYXMgZ2l2ZW4gYnlcbiAqICAgICB7QGxpbmsgR2VvbWV0cnkjdHlwZX0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld1R5cGUgVGhlIHZpZXcgdHlwZSwgYXMgZ2l2ZW4gYnkge0BsaW5rIFZpZXcjdHlwZX0uXG4gKiBAcGFyYW0geyp9IFJlbmRlcmVyIFRoZSByZW5kZXJlciBjbGFzcywgb3IgbnVsbCBpZiBubyBzdWNoIHJlbmRlcmVyIGhhcyBiZWVuXG4gKiByZWdpc3RlcmVkLlxuICovXG5SZW5kZXJlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihnZW9tZXRyeVR5cGUsIHZpZXdUeXBlKSB7XG4gIHZhciBSZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdICYmXG4gICAgICB0aGlzLl9yZW5kZXJlcnNbZ2VvbWV0cnlUeXBlXVt2aWV3VHlwZV07XG4gIHJldHVybiBSZW5kZXJlciB8fCBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlclJlZ2lzdHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgV29ya1F1ZXVlID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvV29ya1F1ZXVlJyk7XG52YXIgY2FsY1JlY3QgPSByZXF1aXJlKCcuLi91dGlsL2NhbGNSZWN0Jyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCcuLi91dGlsL2FzeW5jJyk7XG52YXIgY2FuY2VsaXplID0gcmVxdWlyZSgnLi4vdXRpbC9jYW5jZWxpemUnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgUmVuZGVyZXJSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVuZGVyZXJSZWdpc3RyeScpO1xuXG5mdW5jdGlvbiBmb3J3YXJkVGlsZUNtcCh0MSwgdDIpIHtcbiAgcmV0dXJuIHQxLmNtcCh0Mik7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VUaWxlQ21wKHQxLCB0Mikge1xuICByZXR1cm4gLXQxLmNtcCh0Mik7XG59XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBzdGFnZSBoYXMgYmVlbiByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWJsZSBXaGV0aGVyIGFsbCB0aWxlcyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB3aXRob3V0XG4gKiAgICAgbWlzc2luZyB0ZXh0dXJlcyBvciByZXNvcnRpbmcgdG8gZmFsbGJhY2tzLlxuICogQGV2ZW50IFN0YWdlI3JlbmRlckNvbXBsZXRlXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGFnZSBoYXZlIGJlZW4gaW52YWxpZGF0ZWQgYW5kIG11c3QgYmVcbiAqIHJlbmRlcmVkIGFnYWluLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBieSB0aGUge0BsaW5rIFJlbmRlckxvb3B9IGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBldmVudCBTdGFnZSNyZW5kZXJJbnZhbGlkXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlIFN0YWdlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBTdGFnZSBpcyBhIGNvbnRhaW5lciB3aXRoIHRoZSBhYmlsaXR5IHRvIHJlbmRlciBhIHN0YWNrIG9mXG4gKiB7QGxpbmsgTGF5ZXIgbGF5ZXJzfS5cbiAqXG4gKiBUaGlzIGlzIGEgc3VwZXJjbGFzcyBjb250YWluaW5nIGxvZ2ljIHRoYXQgaXMgY29tbW9uIHRvIGFsbCBpbXBsZW1lbnRhdGlvbnM7XG4gKiBpdCBzaG91bGQgbmV2ZXIgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Ugb25lIG9mIHRoZVxuICogc3ViY2xhc3Nlczoge0BsaW5rIFdlYkdsU3RhZ2V9LCB7QGxpbmsgQ3NzU3RhZ2V9IG9yIHtAbGluayBGbGFzaFN0YWdlfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wcm9ncmVzc2l2ZT1mYWxzZV1cbiAqXG4gKiBPcHRpb25zIGxpc3RlZCBoZXJlIG1heSBiZSBwYXNzZWQgaW50byB0aGUgYG9wdHNgIGNvbnN0cnVjdG9yIGFyZ3VtZW50IG9mXG4gKiBzdWJjbGFzc2VzLlxuICpcbiAqIFRoZSBgcHJvZ3Jlc3NpdmVgIG9wdGlvbiBjb250cm9scyB3aGV0aGVyIHJlc29sdXRpb24gbGV2ZWxzIGFyZSBsb2FkZWQgaW5cbiAqIG9yZGVyLCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LiBUaGlzIHJlc3VsdHMgaW4gYSBtb3JlIHBsZWFzaW5nIGVmZmVjdCB3aGVuXG4gKiB6b29taW5nIHBhc3Qgc2V2ZXJhbCBsZXZlbHMgaW4gYSBsYXJnZSBwYW5vcmFtYXMsIGJ1dCBjb25zdW1lcyBhZGRpdGlvbmFsXG4gKiBiYW5kd2lkdGguXG4gKi9cbmZ1bmN0aW9uIFN0YWdlKG9wdHMpIHtcbiAgdGhpcy5fcHJvZ3Jlc3NpdmUgPSAhIShvcHRzICYmIG9wdHMucHJvZ3Jlc3NpdmUpO1xuXG4gIC8vIFRoZSBsaXN0IG9mIGxheWVycyBpbiBkaXNwbGF5IG9yZGVyIChiYWNrZ3JvdW5kIHRvIGZvcmVncm91bmQpLlxuICB0aGlzLl9sYXllcnMgPSBbXTtcblxuICAvLyBUaGUgbGlzdCBvZiByZW5kZXJlcnM7IHRoZSBpLXRoIHJlbmRlcmVyIGlzIGZvciB0aGUgaS10aCBsYXllci5cbiAgdGhpcy5fcmVuZGVyZXJzID0gW107XG5cbiAgLy8gVGhlIGxpc3RzIG9mIHRpbGVzIHRvIGxvYWQgYW5kIHJlbmRlciwgcG9wdWxhdGVkIGR1cmluZyByZW5kZXIoKS5cbiAgdGhpcy5fdGlsZXNUb0xvYWQgPSBbXTtcbiAgdGhpcy5fdGlsZXNUb1JlbmRlciA9IFtdO1xuXG4gIC8vIFRlbXBvcmFyeSB0aWxlIGxpc3RzLlxuICB0aGlzLl90bXBWaXNpYmxlID0gW107XG4gIHRoaXMuX3RtcENoaWxkcmVuID0gW107XG5cbiAgLy8gQ2FjaGVkIHN0YWdlIGRpbWVuc2lvbnMuXG4gIC8vIFN0YXJ0IHdpdGggemVybywgd2hpY2ggaW5oaWJpdHMgcmVuZGVyaW5nIHVudGlsIHNldFNpemUoKSBpcyBjYWxsZWQuXG4gIHRoaXMuX3dpZHRoID0gMDtcbiAgdGhpcy5faGVpZ2h0ID0gMDtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHJlY3QuXG4gIHRoaXMuX3RtcFJlY3QgPSB7fTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHNpemUuXG4gIHRoaXMuX3RtcFNpemUgPSB7fTtcblxuICAvLyBXb3JrIHF1ZXVlIGZvciBjcmVhdGVUZXh0dXJlLlxuICB0aGlzLl9jcmVhdGVUZXh0dXJlV29ya1F1ZXVlID0gbmV3IFdvcmtRdWV1ZSgpO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGVtaXQgZXZlbnQgd2hlbiByZW5kZXIgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkID0gdGhpcy5fZW1pdFJlbmRlckludmFsaWQuYmluZCh0aGlzKTtcblxuICAvLyBUaGUgcmVuZGVyZXIgcmVnaXN0cnkgbWFwcyBlYWNoIGdlb21ldHJ5L3ZpZXcgcGFpciBpbnRvIHRoZSByZXNwZWN0aXZlXG4gIC8vIFJlbmRlcmVyIGNsYXNzLlxuICB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5ID0gbmV3IFJlbmRlcmVyUmVnaXN0cnkoKTtcbn1cblxuZXZlbnRFbWl0dGVyKFN0YWdlKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGF5ZXJzKCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB7QGxpbmsgUmVuZGVyZXJ9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9XG4gKiB0eXBlLlxuICpcbiAqIFRoZSB7QGxpbmsgcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzfSB1dGlsaXR5IGZ1bmN0aW9uIG1heSBiZSB1c2VkIHRvXG4gKiByZWdpc3RlciBhbGwga25vd24gcmVuZGVyZXJzIGZvciBhIHN0YWdlIHR5cGUgaW50byB0aGF0IHN0YWdlLiBNb3N0IHVzZXJzXG4gKiB3aWxsIG5vdCBuZWVkIHRvIHJlZ2lzdGVyIHJlbmRlcmVycywgYXMge0BsaW5rIFZpZXdlcn0gZG9lcyBpdCBmb3IgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLlxuICovXG5TdGFnZS5wcm90b3R5cGUucmVnaXN0ZXJSZW5kZXJlciA9IGZ1bmN0aW9uKGdlb21ldHJ5VHlwZSwgdmlld1R5cGUsIFJlbmRlcmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5LnNldChnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqXG4gKiBNdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5TdGFnZS5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgZG9tRWxlbWVudCcpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgc3RhZ2Ugd2lkdGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblN0YWdlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBzdGFnZSBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblN0YWdlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHN0YWdlIGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1NpemU9fSBzaXplXG4gKi9cblN0YWdlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICBzaXplID0gc2l6ZSB8fCB7fTtcbiAgc2l6ZS53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICBzaXplLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzdGFnZSBkaW1lbnNpb25zLlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHNpemUgdXBkYXRlIGxvZ2ljIGNvbW1vbiB0byBhbGwgc3RhZ2UgdHlwZXMuIFN1YmNsYXNzZXNcbiAqIG11c3QgZGVmaW5lIHRoZSB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZUZvclR5cGV9IG1ldGhvZCB0byBwZXJmb3JtIHRoZWlyIG93blxuICogbG9naWMuXG4gKlxuICogQHBhcmFtIHtTaXplfSBzaXplXG4gKi9cblN0YWdlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aGlzLl93aWR0aCA9IHNpemUud2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gIHRoaXMuc2V0U2l6ZUZvclR5cGUoKTsgLy8gbXVzdCBiZSBkZWZpbmVkIGJ5IHN1YmNsYXNzZXMuXG5cbiAgdGhpcy5lbWl0KCdyZXNpemUnKTtcbiAgdGhpcy5fZW1pdFJlbmRlckludmFsaWQoKTtcbn07XG5cblxuLyoqXG4gKiBDYWxsIHtAbGluayBTdGFnZSNzZXRTaXplfSBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHNpemUgdXBkYXRlIGxvZ2ljIHNwZWNpZmljIHRvIGEgc3RhZ2UgdHlwZS4gSXQgaXMgY2FsbGVkIGJ5XG4gKiB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZX0gYWZ0ZXIgdGhlIGJhc2UgY2xhc3MgaGFzIGJlZW4gdXBkYXRlZCB0byByZWZsZWN0IHRoZVxuICogbmV3IHNpemUsIGJ1dCBiZWZvcmUgYW55IGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge1NpemV9IHNpemVcbiAqL1xuU3RhZ2UucHJvdG90eXBlLnNldFNpemVGb3JUeXBlID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgc2V0U2l6ZUZvclR5cGUnKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkcyBhbiB7QGxpbmsgQXNzZXR9IGZyb20gYW4gaW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBpbWFnZSBVUkwuXG4gKiBAcGFyYW0gez9SZWN0fSByZWN0IEEge0BsaW5rIFJlY3R9IGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSwgb3IgbnVsbFxuICogICAgIHRvIHVzZSB0aGUgZnVsbCBpbWFnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCBBc3NldCl9IGRvbmUgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBmdW5jdGlvbiB0byBjYW5jZWwgbG9hZGluZy5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgbG9hZEltYWdlJyk7XG59O1xuXG5cblN0YWdlLnByb3RvdHlwZS5fZW1pdFJlbmRlckludmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdyZW5kZXJJbnZhbGlkJyk7XG59O1xuXG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCB0aGUgbGF5ZXIgaXMgdmFsaWQgZm9yIHRoaXMgc3RhZ2UsIHRocm93aW5nIGFuIGV4Y2VwdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxheWVyIGlzIG5vdCB2YWxpZCBmb3IgdGhpcyBzdGFnZS5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgdmFsaWRhdGVMYXllcicpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBiZWxvbmdpbmcgdG8gdGhlIHN0YWdlLiBUaGVcbiAqIHJldHVybmVkIGxpc3QgaXMgaW4gZGlzcGxheSBvcmRlciwgYmFja2dyb3VuZCB0byBmb3JlZ3JvdW5kLlxuICogQHJldHVybiB7TGF5ZXJbXX1cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmxpc3RMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IHVuaW50ZW5kZWQgbXV0YXRpb24gYnkgdGhlIGNhbGxlci5cbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9sYXllcnMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEge0BsaW5rIExheWVyIGxheWVyfSBiZWxvbmdzIHRvIHRoZSBzdGFnZS5cbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5TdGFnZS5wcm90b3R5cGUuaGFzTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICByZXR1cm4gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpID49IDA7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIHtAbGluayBMYXllciBsYXllcn0gaW50byB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gYWRkLlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBpIFRoZSBvcHRpb25hbCBwb3NpdGlvbiwgd2hlcmUgMCDiiaQgaSDiiaQgbiBhbmQgbiBpc1xuICogICAgIHRoZSBjdXJyZW50IG51bWJlciBvZiBsYXllcnMuIFRoZSBkZWZhdWx0IGlzIG4sIHdoaWNoIGluc2VydHMgYXQgdGhlXG4gKiAgICAgdG9wIG9mIHRoZSBkaXNwbGF5IHN0YWNrLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgYWxyZWFkeSBiZWxvbmdzIHRvIHRoZSBzdGFnZSBvciBpZiB0aGUgcG9zaXRpb25cbiAqICAgICBpcyBpbnZhbGlkLlxuICovXG5TdGFnZS5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgaSkge1xuICBpZiAodGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheWVyIGFscmVhZHkgaW4gc3RhZ2UnKTtcbiAgfVxuXG4gIGlmIChpID09IG51bGwpIHtcbiAgICBpID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcbiAgfVxuICBpZiAoaSA8IDAgfHwgaSA+IHRoaXMuX2xheWVycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGF5ZXIgcG9zaXRpb24nKTtcbiAgfVxuXG4gIHRoaXMudmFsaWRhdGVMYXllcihsYXllcik7IC8vIG11c3QgYmUgZGVmaW5lZCBieSBzdWJjbGFzc2VzLlxuXG4gIHZhciBnZW9tZXRyeVR5cGUgPSBsYXllci5nZW9tZXRyeSgpLnR5cGU7XG4gIHZhciB2aWV3VHlwZSA9IGxheWVyLnZpZXcoKS50eXBlO1xuICB2YXIgcmVuZGVyZXJDbGFzcyA9IHRoaXMuX3JlbmRlcmVyUmVnaXN0cnkuZ2V0KGdlb21ldHJ5VHlwZSwgdmlld1R5cGUpO1xuICBpZiAoIXJlbmRlcmVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vICcgKyB0aGlzLnR5cGUgKyAnIHJlbmRlcmVyIGF2YWlhYmxlIGZvciAnICtcbiAgICAgICAgZ2VvbWV0cnlUeXBlICsgJyBnZW9tZXRyeSBhbmQgJyArIHZpZXdUeXBlICsgJyB2aWV3Jyk7XG4gIH1cbiAgdmFyIHJlbmRlcmVyID0gdGhpcy5jcmVhdGVSZW5kZXJlcihyZW5kZXJlckNsYXNzKTtcblxuICB0aGlzLl9sYXllcnMuc3BsaWNlKGksIDAsIGxheWVyKTtcbiAgdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpLCAwLCByZW5kZXJlcik7XG5cbiAgLy8gTGlzdGVuZXJzIGZvciByZW5kZXIgaW52YWxpZC5cbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZWZmZWN0c0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZml4ZWRMZXZlbENoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogTW92ZXMgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGludG8gYSBkaWZmZXJlbnQgcG9zaXRpb24gaW4gdGhlIGRpc3BsYXkgc3RhY2suXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW92ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGlvbiwgd2hlcmUgMCDiiaQgaSDiiaQgbi0xIGFuZCBuIGlzIHRoZSBjdXJyZW50IG51bWJlclxuICogICAgIG9mIGxheWVycy5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxheWVyIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgc3RhZ2Ugb3IgaWYgdGhlIHBvc2l0aW9uXG4gKiAgICAgaXMgaW52YWxpZC5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLm1vdmVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYXllciBpbiBzdGFnZScpO1xuICB9XG5cbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fbGF5ZXJzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsYXllciBwb3NpdGlvbicpO1xuICB9XG5cbiAgbGF5ZXIgPSB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG5cbiAgdGhpcy5fbGF5ZXJzLnNwbGljZShpLCAwLCBsYXllcik7XG4gIHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaSwgMCwgcmVuZGVyZXIpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIHtAbGluayBMYXllcn0gZnJvbSB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gcmVtb3ZlLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzdGFnZS5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGxheWVyIGluIHN0YWdlJyk7XG4gIH1cblxuICB2YXIgcmVtb3ZlZExheWVyID0gdGhpcy5fbGF5ZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG4gIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuXG4gIHRoaXMuZGVzdHJveVJlbmRlcmVyKHJlbmRlcmVyKTtcblxuICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgcmVtb3ZlZExheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lbWl0UmVuZGVySW52YWxpZCk7XG4gIHJlbW92ZWRMYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdmaXhlZExldmVsQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwge0BsaW5rIExheWVyIGxheWVyc30gZnJvbSB0aGUgc3RhZ2UuXG4gKi9cblN0YWdlLnByb3RvdHlwZS5yZW1vdmVBbGxMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuX2xheWVycy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FsbGVkIGJlZm9yZSBhIGZyYW1lIGlzIHJlbmRlcmVkLlxuICpcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICovXG5TdGFnZS5wcm90b3R5cGUuc3RhcnRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgc3RhcnRGcmFtZScpO1xufTtcblxuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIGZyYW1lIGlzIHJlbmRlcmVkLlxuICpcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICovXG5TdGFnZS5wcm90b3R5cGUuZW5kRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIGVuZEZyYW1lJyk7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyIHRoZSBjdXJyZW50IGZyYW1lLiBVc3VhbGx5IGNhbGxlZCBmcm9tIGEge0BsaW5rIFJlbmRlckxvb3B9LlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHJlbmRlcmluZyBsb2dpYyBjb21tb24gdG8gYWxsIHN0YWdlIHR5cGVzLiBTdWJjbGFzc2VzXG4gKiBkZWZpbmUgdGhlIHN0YXJ0RnJhbWUoKSBhbmQgZW5kRnJhbWUoKSBtZXRob2RzIHRvIHBlcmZvcm0gdGhlaXIgb3duIGxvZ2ljLlxuICovXG5TdGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpLCBqO1xuXG4gIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xuICB2YXIgdGlsZXNUb1JlbmRlciA9IHRoaXMuX3RpbGVzVG9SZW5kZXI7XG5cbiAgdmFyIHN0YWJsZVN0YWdlID0gdHJ1ZTtcbiAgdmFyIHN0YWJsZUxheWVyO1xuXG4gIC8vIEdldCB0aGUgc3RhZ2UgZGltZW5zaW9ucy5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgdmFyIHJlY3QgPSB0aGlzLl90bXBSZWN0O1xuICB2YXIgc2l6ZSA9IHRoaXMuX3RtcFNpemU7XG5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXJ0RnJhbWUoKTsgLy8gZGVmaW5lZCBieSBzdWJjbGFzc2VzXG5cbiAgLy8gU2lnbmFsIHN0YXJ0IG9mIGZyYW1lIHRvIHRoZSB0ZXh0dXJlIHN0b3Jlcy5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5zdGFydEZyYW1lKCk7XG4gIH1cblxuICAvLyBSZW5kZXIgbGF5ZXJzLlxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xuICAgIHZhciBlZmZlY3RzID0gbGF5ZXIuZWZmZWN0cygpO1xuICAgIHZhciB2aWV3ID0gbGF5ZXIudmlldygpO1xuICAgIHZhciB0ZXh0dXJlU3RvcmUgPSBsYXllci50ZXh0dXJlU3RvcmUoKTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcnNbaV07XG4gICAgdmFyIGRlcHRoID0gdGhpcy5fbGF5ZXJzLmxlbmd0aCAtIGk7XG4gICAgdmFyIHRpbGUsIHRleHR1cmU7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSByZWN0IGVmZmVjdCBpbnRvIGEgbm9ybWFsaXplZCByZWN0LlxuICAgIC8vIFRPRE86IGF2b2lkIGRvaW5nIHRoaXMgb24gZXZlcnkgZnJhbWUuXG4gICAgY2FsY1JlY3Qod2lkdGgsIGhlaWdodCwgZWZmZWN0cyAmJiBlZmZlY3RzLnJlY3QsIHJlY3QpO1xuXG4gICAgaWYgKHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XG4gICAgICAvLyBTa2lwIHJlbmRlcmluZyBvbiBhIG51bGwgdmlld3BvcnQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgc2l6ZS5cbiAgICBzaXplLndpZHRoID0gcmVjdC53aWR0aCAqIHRoaXMuX3dpZHRoO1xuICAgIHNpemUuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiB0aGlzLl9oZWlnaHQ7XG4gICAgdmlldy5zZXRTaXplKHNpemUpO1xuXG4gICAgLy8gU2lnbmFsIHN0YXJ0IG9mIGxheWVyIHRvIHRoZSByZW5kZXJlci5cbiAgICByZW5kZXJlci5zdGFydExheWVyKGxheWVyLCByZWN0KTtcblxuICAgIC8vIFdlIHJlbmRlciB3aXRoIGJvdGggYWxwaGEgYmxlbmRpbmcgYW5kIGRlcHRoIHRlc3RpbmcgZW5hYmxlZC4gVGh1cywgd2hlblxuICAgIC8vIHJlbmRlcmluZyBhIHN1YnNlcXVlbnQgcGl4ZWwgYXQgdGhlIHNhbWUgbG9jYXRpb24gdGhhbiBhbiBleGlzdGluZyBvbmUsXG4gICAgLy8gdGhlIHN1YnNlcXVlbnQgcGl4ZWwgZ2V0cyBkaXNjYXJkZWQgdW5sZXNzIGl0IGhhcyBzbWFsbGVyIGRlcHRoLCBhbmQgaXNcbiAgICAvLyBvdGhlcndpc2UgY29tcG9zaXRlZCB3aXRoIHRoZSBleGlzdGluZyBwaXhlbC5cbiAgICAvL1xuICAgIC8vIFdoZW4gdXNpbmcgZmFsbGJhY2sgdGlsZXMgdG8gZmlsbCBhIGdhcCBpbiB0aGUgcHJlZmVycmVkIHJlc29sdXRpb25cbiAgICAvLyBsZXZlbCwgd2UgcHJlZmVyIGhpZ2hlciByZXNvbHV0aW9uIGZhbGxiYWNrcyB0byBsb3dlciByZXNvbHV0aW9uIG9uZXMuXG4gICAgLy8gSG93ZXZlciwgd2hlcmUgZmFsbGJhY2tzIG92ZXJsYXAsIHdlIHdhbnQgaGlnaGVyIHJlc29sdXRpb24gb25lcyB0b1xuICAgIC8vIHByZXZhaWwsIGFuZCB3ZSBkb24ndCB3YW50IG11bHRpcGxlIGZhbGxiYWNrcyB0byBiZSBjb21wb3NpdGVkIHdpdGggZWFjaFxuICAgIC8vIG90aGVyLCBhcyB0aGF0IHdvdWxkIHByb2R1Y2UgYSBiYWQgcmVzdWx0IHdoZW4gc2VtaXRyYW5zcGFyZW50IHRleHR1cmVzXG4gICAgLy8gYXJlIGludm9sdmVkLlxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYWNoaWV2ZSB0aGlzIHdpdGhpbiB0aGUgY29uc3RyYWludHMgb2YgYWxwaGEgYmxlbmRpbmcgYW5kXG4gICAgLy8gZGVwdGggdGVzdGluZywgdGhlIGRlcHRoIG9mIGEgdGlsZSBtdXN0IGJlIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gaXRzXG4gICAgLy8gcmVzb2x1dGlvbiwgYW5kIGhpZ2hlci1yZXNvbHV0aW9uIHRpbGVzIG11c3QgYmUgcmVuZGVyZWQgYmVmb3JlIGxvd2VyLVxuICAgIC8vIHJlc29sdXRpb24gb25lcy5cblxuICAgIC8vIENvbGxlY3QgdGhlIGxpc3RzIG9mIHRpbGVzIHRvIGxvYWQgYW5kIHJlbmRlci5cbiAgICBzdGFibGVMYXllciA9IHRoaXMuX2NvbGxlY3RUaWxlcyhsYXllciwgdGV4dHVyZVN0b3JlKTtcblxuICAgIC8vIE1hcmsgYWxsIHRoZSB0aWxlcyB3aG9zZSB0ZXh0dXJlcyBtdXN0IGJlIGxvYWRlZC5cbiAgICAvLyBUaGlzIHdpbGwgZWl0aGVyIHRyaWdnZXIgbG9hZGluZyAoZm9yIHRleHR1cmVzIG5vdCB5ZXQgbG9hZGVkKSBvclxuICAgIC8vIHByZXZlbnQgdW5sb2FkaW5nIChmb3IgdGV4dHVyZXMgYWxyZWFkeSBsb2FkZWQpLlxuICAgIGZvciAoaiA9IDA7IGogPCB0aWxlc1RvTG9hZC5sZW5ndGg7IGorKykge1xuICAgICAgdGlsZSA9IHRpbGVzVG9Mb2FkW2pdO1xuICAgICAgdGV4dHVyZVN0b3JlLm1hcmtUaWxlKHRpbGUpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB0aWxlcy5cbiAgICBmb3IgKGogPSAwOyBqIDwgdGlsZXNUb1JlbmRlci5sZW5ndGg7IGorKykge1xuICAgICAgdGlsZSA9IHRpbGVzVG9SZW5kZXJbal07XG4gICAgICB0ZXh0dXJlID0gdGV4dHVyZVN0b3JlLnRleHR1cmUodGlsZSk7XG4gICAgICByZW5kZXJlci5yZW5kZXJUaWxlKHRpbGUsIHRleHR1cmUsIGxheWVyLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgbGF5ZXIuZW1pdCgncmVuZGVyQ29tcGxldGUnLCBzdGFibGVMYXllcik7XG4gICAgaWYgKCFzdGFibGVMYXllcikge1xuICAgICAgc3RhYmxlU3RhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTaWduYWwgZW5kIG9mIGxheWVyIHRvIHRoZSByZW5kZXJlci5cbiAgICByZW5kZXJlci5lbmRMYXllcihsYXllciwgcmVjdCk7XG4gIH1cblxuICAvLyBTaWduYWwgZW5kIG9mIGZyYW1lIHRvIHRoZSB0ZXh0dXJlIHN0b3Jlcy5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5lbmRGcmFtZSgpO1xuICB9XG5cbiAgdGhpcy5lbmRGcmFtZSgpOyAvLyBkZWZpbmVkIGJ5IHN1YmNsYXNzZXNcblxuICB0aGlzLmVtaXQoJ3JlbmRlckNvbXBsZXRlJywgc3RhYmxlU3RhZ2UpO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0VGlsZXMgPSBmdW5jdGlvbihsYXllciwgdGV4dHVyZVN0b3JlKSB7XG4gIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xuICB2YXIgdGlsZXNUb1JlbmRlciA9IHRoaXMuX3RpbGVzVG9SZW5kZXI7XG4gIHZhciB0bXBWaXNpYmxlID0gdGhpcy5fdG1wVmlzaWJsZTtcblxuICB0aWxlc1RvTG9hZC5sZW5ndGggPSAwO1xuICB0aWxlc1RvUmVuZGVyLmxlbmd0aCA9IDA7XG4gIHRtcFZpc2libGUubGVuZ3RoID0gMDtcblxuICBsYXllci52aXNpYmxlVGlsZXModG1wVmlzaWJsZSk7XG5cbiAgdmFyIGlzU3RhYmxlID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcFZpc2libGUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGlsZSA9IHRtcFZpc2libGVbaV07XG4gICAgdmFyIG5lZWRzRmFsbGJhY2s7XG4gICAgdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSk7XG4gICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XG4gICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgYXZhaWxhYmxlLlxuICAgICAgLy8gTm8gZmFsbGJhY2sgaXMgcmVxdWlyZWQuXG4gICAgICBuZWVkc0ZhbGxiYWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9jb2xsZWN0VGlsZVRvUmVuZGVyKHRpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgdW5hdmFpbGFibGUuXG4gICAgICAvLyBDb2xsZWN0IGNoaWxkcmVuIGZvciByZW5kZXJpbmcgYXMgYSBmYWxsYmFjay5cbiAgICAgIG5lZWRzRmFsbGJhY2sgPSB0aGlzLl9jb2xsZWN0Q2hpbGRyZW4odGlsZSwgdGV4dHVyZVN0b3JlKTtcbiAgICAgIGlzU3RhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENvbGxlY3QgYWxsIHBhcmVudHMgZm9yIGxvYWRpbmcsIGFuZCB0aGUgY2xvc2VzdCBwYXJlbnQgZm9yIHJlbmRlcmluZyBpZlxuICAgIC8vIGEgZmFsbGJhY2sgaXMgcmVxdWlyZWQuXG4gICAgdGhpcy5fY29sbGVjdFBhcmVudHModGlsZSwgdGV4dHVyZVN0b3JlLCBuZWVkc0ZhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNvcnQgdGlsZXMgdG8gbG9hZCBpbiBhc2NlbmRpbmcgcmVzb2x1dGlvbiBvcmRlci5cbiAgdGlsZXNUb0xvYWQuc29ydChmb3J3YXJkVGlsZUNtcCk7XG5cbiAgLy8gU29ydCB0aWxlcyB0byByZW5kZXIgaW4gZGVzY2VuZGluZyByZXNvbHV0aW9uIG9yZGVyLlxuICB0aWxlc1RvUmVuZGVyLnNvcnQocmV2ZXJzZVRpbGVDbXApO1xuXG4gIHJldHVybiBpc1N0YWJsZTtcbn07XG5cblN0YWdlLnByb3RvdHlwZS5fY29sbGVjdENoaWxkcmVuID0gZnVuY3Rpb24odGlsZSwgdGV4dHVyZVN0b3JlKSB7XG4gIHZhciB0bXBDaGlsZHJlbiA9IHRoaXMuX3RtcENoaWxkcmVuO1xuXG4gIHZhciBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcblxuICAvLyBGYWxsIGJhY2sgYXMgbWFueSBsZXZlbHMgYXMgbmVjZXNzYXJ5IG9uIHNpbmdsZS1jaGlsZCBnZW9tZXRyaWVzLCBidXQgZG9cbiAgLy8gbm90IGdvIGJleW9uZCBpbW1lZGlhdGUgY2hpbGRyZW4gb24gbXVsdGlwbGUtY2hpbGQgZ2VvbWV0cmllcywgdG8gYXZvaWRcbiAgLy8gZXhwbG9yaW5nIGFuIGV4cG9uZW50aWFsIG51bWJlciBvZiB0aWxlcy5cbiAgZG8ge1xuICAgIHRtcENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaWYgKCF0aWxlLmNoaWxkcmVuKHRtcENoaWxkcmVuKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aWxlID0gdG1wQ2hpbGRyZW5baV07XG4gICAgICBpZiAodGV4dHVyZVN0b3JlLnRleHR1cmUodGlsZSkpIHtcbiAgICAgICAgdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSk7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5lZWRzRmFsbGJhY2sgJiYgdG1wQ2hpbGRyZW4ubGVuZ3RoID09PSAxKVxuXG4gIHJldHVybiBuZWVkc0ZhbGxiYWNrO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0UGFyZW50cyA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmVTdG9yZSwgbmVlZHNGYWxsYmFjaykge1xuICAvLyBSZWN1cnNpdmVseSB2aXNpdCBwYXJlbnQgdGlsZXMgdW50aWw6XG4gIC8vICAgLSBhbGwgcGFyZW50cyBoYXZlIGJlZW4gbWFya2VkIGZvciBsb2FkaW5nLCBpZiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXNcbiAgLy8gICAgIGVuYWJsZWQ7IGFuZFxuICAvLyAgIC0gYXQgbGVhc3Qgb25lIHBhcmVudCBoYXMgYmVlbiBtYXJrZWQgZm9yIGJvdGggbG9hZGluZyBhbmQgcmVuZGVyaW5nLCBpZlxuICAvLyAgICAgYSBmYWxsYmFjayBpcyByZXF1aXJlZC5cbiAgdmFyIG5lZWRzTG9hZGluZyA9IHRoaXMuX3Byb2dyZXNzaXZlO1xuICB3aGlsZSAoKG5lZWRzTG9hZGluZyB8fCBuZWVkc0ZhbGxiYWNrKSAmJiAodGlsZSA9IHRpbGUucGFyZW50KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmVlZHNGYWxsYmFjaykge1xuICAgICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XG4gICAgICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3Byb2dyZXNzaXZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2NvbGxlY3RUaWxlVG9Mb2FkKHRpbGUpKSB7XG4gICAgICBuZWVkc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWRzRmFsbGJhY2s7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9Mb2FkID0gZnVuY3Rpb24odGlsZSkge1xuICByZXR1cm4gdGhpcy5fY29sbGVjdFRpbGVJbnRvTGlzdCh0aWxlLCB0aGlzLl90aWxlc1RvTG9hZCk7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9SZW5kZXIgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHJldHVybiB0aGlzLl9jb2xsZWN0VGlsZUludG9MaXN0KHRpbGUsIHRoaXMuX3RpbGVzVG9SZW5kZXIpO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0VGlsZUludG9MaXN0ID0gZnVuY3Rpb24odGlsZSwgdGlsZUxpc3QpIHtcbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2hldGhlciBpdCdzIHdvcnRoIGl0IHRvIG1ha2UgdGhpcyBiZXR0ZXIgdGhhbiBPKG7CsikuXG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRpbGUuZXF1YWxzKHRpbGVMaXN0W2ldKSkge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghZm91bmQpIHtcbiAgICB0aWxlTGlzdC5wdXNoKHRpbGUpO1xuICB9XG4gIHJldHVybiAhZm91bmQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgZm9yIHRoZSBnaXZlbiB0aWxlIGFuZCBhc3NldC4gQ2FsbGVkIGJ5IHtAbGluayBUZXh0dXJlU3RvcmV9LlxuICogQHBhcmFtIHtUaWxlfSB0aWxlXG4gKiBAcGFyYW0ge0Fzc2V0fSBhc3NldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5TdGFnZS5wcm90b3R5cGUuY3JlYXRlVGV4dHVyZSA9IGZ1bmN0aW9uKHRpbGUsIGFzc2V0LCBkb25lKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG1ha2VUZXh0dXJlKCkge1xuICAgIHJldHVybiBuZXcgc2VsZi5UZXh0dXJlQ2xhc3Moc2VsZiwgdGlsZSwgYXNzZXQpO1xuICB9XG5cbiAgdmFyIGZuID0gY2FuY2VsaXplKGFzeW5jKG1ha2VUZXh0dXJlKSk7XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVRleHR1cmVXb3JrUXVldWUucHVzaChmbiwgZnVuY3Rpb24oZXJyLCB0ZXh0dXJlKSB7XG4gICAgZG9uZShlcnIsIHRpbGUsIGFzc2V0LCB0ZXh0dXJlKTtcbiAgfSk7XG5cbn07XG5cbi8qKlxuICogVGhlIHN0YWdlIHR5cGUsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJlciBmb3IgYSBnaXZlblxuICogZ2VvbWV0cnkgYW5kIHZpZXcuXG4gKlxuICogS25vd24gdmFsdWVzIGFyZSBgXCJ3ZWJnbFwiYCwgYFwiY3NzXCJgIGFuZCBgXCJmbGFzaFwiYC5cbiAqXG4gKiBTZWUgYWxzbyB7QGxpbmsgU3RhZ2UjcmVnaXN0ZXJSZW5kZXJlcn0uXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9XG4gKiBAbmFtZSBTdGFnZSN0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGFnZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0YWdlID0gcmVxdWlyZSgnLi9TdGFnZScpO1xudmFyIEh0bWxJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uL2xvYWRlcnMvSHRtbEltYWdlJyk7XG52YXIgd2ViR2xTdXBwb3J0ZWQgPSByZXF1aXJlKCcuLi9zdXBwb3J0L1dlYkdsJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbC9pbmhlcml0cycpO1xudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcbnZhciBpc3BvdCA9IHJlcXVpcmUoJy4uL3V0aWwvaXNwb3QnKTtcbnZhciBzZXRBYnNvbHV0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJykuc2V0QWJzb2x1dGU7XG52YXIgc2V0RnVsbFNpemUgPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldEZ1bGxTaXplO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBNQVJaSVBBTk9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgTUFSWklQQU5PREVCVUcud2ViR2w7XG5cblxuLy8gQnJvd3Nlci1zcGVjaWZpYyB3b3JrYXJvdW5kcy5cbnZhciBicm93c2VyUXVpcmtzID0ge1xuICAvLyBXaGV0aGVyIHRvIHVzZSB0ZXhJbWFnZTJEIGluc3RlYWQgb2YgdGV4U3ViSW1hZ2UyRCB3aGVuIHJlcGFpbnRpbmcgYW5cbiAgLy8gZXhpc3RpbmcgdGV4dHVyZSBmcm9tIGEgdmlkZW8gZWxlbWVudC4gT24gbW9zdCBicm93c2VycyB0ZXhTdWJJbWFnZTJEIGlzXG4gIC8vIGZhc3RlciwgYnV0IG9uIENocm9tZSB0aGUgcGVyZm9ybWFuY2UgZGVncmFkZXMgc2lnbmlmaWNhbnRseS4gU2VlOlxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MTI1NDJcbiAgdmlkZW9Vc2VUZXhJbWFnZTJEOiBicm93c2VyLmNocm9tZVxufTtcblxuXG5mdW5jdGlvbiBpbml0V2ViR2xDb250ZXh0KGNhbnZhcywgb3B0cykge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXG4gICAgYW50aWFsaWFzOiAhIShvcHRzICYmIG9wdHMuYW50aWFsaWFzKSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ICEhKG9wdHMgJiYgb3B0cy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpXG4gIH07XG5cbiAgaWYgKGRlYnVnICYmIHR5cGVvZiBXZWJHTERlYnVnVXRpbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5sb2coJ1VzaW5nIFdlYkdMIGxvc3QgY29udGV4dCBzaW11bGF0b3InKTtcbiAgICBjYW52YXMgPSBXZWJHTERlYnVnVXRpbHMubWFrZUxvc3RDb250ZXh0U2ltdWxhdGluZ0NhbnZhcyhjYW52YXMpO1xuICB9XG5cbiAgLy8gS2VlcCBzdXBwb3J0L1dlYkdsLmpzIGluIHN5bmMgd2l0aCB0aGlzLlxuICB2YXIgZ2wgPSAoY2FudmFzLmdldENvbnRleHQpICYmIChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucykpO1xuXG4gIGlmICghZ2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgV2ViR0wgY29udGV4dCcpO1xuICB9XG5cbiAgaWYgKGRlYnVnICYmIHR5cGVvZiBXZWJHTERlYnVnVXRpbHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBnbCA9IFdlYkdMRGVidWdVdGlscy5tYWtlRGVidWdDb250ZXh0KGdsKTtcbiAgICBjb25zb2xlLmxvZygnVXNpbmcgV2ViR0wgZGVidWcgY29udGV4dCcpO1xuICB9XG5cbiAgcmV0dXJuIGdsO1xufVxuXG4vKipcbiAqIEBjbGFzcyBXZWJHbFN0YWdlXG4gKiBAZXh0ZW5kcyBTdGFnZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIFN0YWdlfSBpbXBsZW1lbnRhdGlvbiB1c2luZyBXZWJHbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5hbnRpYWxpYXM9ZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZ2VuZXJhdGVNaXBtYXBzPWZhbHNlXVxuICpcbiAqIFRoZSBgYW50aWFsaWFzYCBhbmQgYHByZXNlcnZlRHJhd2luZ0J1ZmZlcmAgb3B0aW9ucyBjb250cm9sIHRoZSBXZWJHTFxuICogY29udGV4dCBhdHRyaWJ1dGVzIG9mIHRoZSBzYW1lIG5hbWUuIFRoZSBgYWxwaGFgIGFuZCBgcHJlbXVsdGlwbGllZEFscGhhYFxuICogV2ViR0wgY29udGV4dCBhdHRyaWJ1dGVzIGFyZSBzZXQgdG8gdGhlaXIgZGVmYXVsdCB0cnVlIHZhbHVlIGFuZCBjYW5ub3RcbiAqIGJlIG92ZXJyaWRlbjsgdGhpcyBhbGxvd3Mgc2VtaXRyYW5zcGFyZW50IHRleHR1cmVzIHRvIGJlIGNvbXBvc2l0ZWQgd2l0aFxuICogdGhlIHBhZ2UuIFNlZTpcbiAqIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzLzEuMC8jV0VCR0xDT05URVhUQVRUUklCVVRFU1xuICpcbiAqIFRoZSBgZ2VuZXJhdGVNaXBtYXBzYCBvcHRpb24gY29udHJvbHMgdGV4dHVyZSBtaXBtYXAgZ2VuZXJhdGlvbi4gTWlwbWFwc1xuICogbWF5IGltcHJvdmUgcmVuZGVyaW5nIHF1YWxpdHksIGF0IHRoZSBjb3N0IG9mIGluY3JlYXNlZCBtZW1vcnkgdXNhZ2UuXG4gKiBEdWUgdG8gdGVjaG5pY2FsIGxpbWl0YXRpb25zLCB0aGV5IGFyZSBvbmx5IGdlbmVyYXRlZCBmb3IgdGV4dHVyZXMgd2hvc2VcbiAqIGRpbWVuc2lvbnMgYXJlIGEgcG93ZXIgb2YgdHdvLiBTZWU6XG4gKiBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC93aWtpL1dlYkdMX2FuZF9PcGVuR0xfRGlmZmVyZW5jZXMjTm9uLVBvd2VyX29mX1R3b19UZXh0dXJlX1N1cHBvcnRcbiAqXG4gKiBBbHNvIHNlZSB0aGUgYXZhaWxhYmxlIHtAbGluayBTdGFnZX0gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gV2ViR2xTdGFnZShvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMuX2dlbmVyYXRlTWlwbWFwcyA9IG9wdHMuZ2VuZXJhdGVNaXBtYXBzICE9IG51bGwgP1xuICAgIG9wdHMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG5cbiAgdGhpcy5fbG9hZGVyID0gbmV3IEh0bWxJbWFnZUxvYWRlcih0aGlzKTtcblxuICB0aGlzLl9kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgc2V0QWJzb2x1dGUodGhpcy5fZG9tRWxlbWVudCk7XG4gIHNldEZ1bGxTaXplKHRoaXMuX2RvbUVsZW1lbnQpO1xuXG4gIHRoaXMuX2dsID0gaW5pdFdlYkdsQ29udGV4dCh0aGlzLl9kb21FbGVtZW50LCBvcHRzKTtcblxuICB0aGlzLl9oYW5kbGVDb250ZXh0TG9zcyA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnd2ViZ2xjb250ZXh0bG9zdCcpO1xuICAgIHNlbGYuX2dsID0gbnVsbDtcbiAgfTtcblxuICAvLyBIYW5kbGUgV2ViR2wgY29udGV4dCBsb3NzLlxuICB0aGlzLl9kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLl9oYW5kbGVDb250ZXh0TG9zcyk7XG5cbiAgLy8gV2ViR2wgcmVuZGVyZXJzIGFyZSBzaW5nbGV0b25zIGZvciBhIGdpdmVuIHN0YWdlLiBUaGlzIGxpc3Qgc3RvcmVzIHRoZVxuICAvLyBleGlzdGluZyByZW5kZXJlcnMgc28gdGhleSBjYW4gYmUgcmV1c2VkIGFjcm9zcyBsYXllcnMgd2l0aCB0aGUgc2FtZVxuICAvLyBnZW9tZXRyeSBhbmQgdmlldyB0eXBlLlxuICB0aGlzLl9yZW5kZXJlckluc3RhbmNlcyA9IFtdO1xufVxuXG5pbmhlcml0cyhXZWJHbFN0YWdlLCBTdGFnZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2hhbmRsZUNvbnRleHRMb3NzKTtcbiAgLy8gRGVsZWdhdGUgY2xlYXJpbmcgb3duIHByb3BlcnRpZXMgdG8gdGhlIFN0YWdlIGRlc3RydWN0b3IuXG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG5cbldlYkdsU3RhZ2Uuc3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB3ZWJHbFN1cHBvcnRlZCgpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgRE9NIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuV2ViR2xTdGFnZS5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZG9tRWxlbWVudDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dCB9XG4gKi9cbldlYkdsU3RhZ2UucHJvdG90eXBlLndlYkdsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZ2w7XG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLnNldFNpemVGb3JUeXBlID0gZnVuY3Rpb24oKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gIC8vXG4gIC8vIFRoZSBzaXplIGlzIG9idGFpbmVkIGJ5IHRha2luZyB0aGUgc3RhZ2UgZGltZW5zaW9ucywgd2hpY2ggYXJlIHNldCBpbiBDU1NcbiAgLy8gcGl4ZWxzLCBhbmQgbXVsdGlwbHlpbmcgdGhlbSBieSB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLiBDcnVjaWFsbHksIHRoaXNcbiAgLy8gbXVzdCBiZSB0aGUgb25seSBwbGFjZSB3aGVyZSB0aGUgV2ViR0wgcmVuZGVyaW5nIHBpcGVsaW5lIGFjY2Vzc2VzIHRoZVxuICAvLyBwaXhlbCByYXRpbzsgc3Vic2VxdWVudCB1c2VzIHNob3VsZCByZWZlcmVuY2UgdGhlIGBkcmF3aW5nQnVmZmVyV2lkdGhgIGFuZFxuICAvLyBgZHJhd2luZ0J1ZmZlckhlaWdodGAgcHJvcGVydGllcyBvbiB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0LiBGYWlsaW5nIHRvXG4gIC8vIGRvIHNvIHdpbGwgYnJlYWsgdGhlIHJlbmRlcmluZyBpZiB0aGUgcGl4ZWwgcmF0aW8gY2hhbmdlcyBidXQgdGhlIHN0YWdlXG4gIC8vIHNpemUgZG9lcyBub3QsIGUuZy4gd2hlbiBtb3ZpbmcgdGhlIHdpbmRvdyBhY3Jvc3Mgc2NyZWVucy5cbiAgdmFyIHJhdGlvID0gcGl4ZWxSYXRpbygpO1xuICB0aGlzLl9kb21FbGVtZW50LndpZHRoID0gcmF0aW8gKiB0aGlzLl93aWR0aDtcbiAgdGhpcy5fZG9tRWxlbWVudC5oZWlnaHQgPSByYXRpbyAqIHRoaXMuX2hlaWdodDtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJsLCByZWN0LCBkb25lKSB7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZEltYWdlKHVybCwgcmVjdCwgZG9uZSk7XG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLm1heFRleHR1cmVTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICB2YXIgdGlsZVNpemUgPSBsYXllci5nZW9tZXRyeSgpLm1heFRpbGVTaXplKCk7XG4gIHZhciBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemUoKTtcbiAgaWYgKHRpbGVTaXplID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheWVyIGhhcyBsZXZlbCB3aXRoIHRpbGUgc2l6ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIHRleHR1cmUgc2l6ZSAoJyArIHRpbGVTaXplICsgJyB2cy4gJyArIG1heFRleHR1cmVTaXplICsgJyknKTtcbiAgfVxufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uKFJlbmRlcmVyKSB7XG4gIHZhciByZW5kZXJlckluc3RhbmNlcyA9IHRoaXMuX3JlbmRlcmVySW5zdGFuY2VzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRlcmVySW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlbmRlcmVySW5zdGFuY2VzW2ldIGluc3RhbmNlb2YgUmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiByZW5kZXJlckluc3RhbmNlc1tpXTtcbiAgICB9XG4gIH1cbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHRoaXMuX2dsKTtcbiAgcmVuZGVyZXJJbnN0YW5jZXMucHVzaChyZW5kZXJlcik7XG4gIHJldHVybiByZW5kZXJlcjtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUuZGVzdHJveVJlbmRlcmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgdmFyIHJlbmRlcmVySW5zdGFuY2VzID0gdGhpcy5fcmVuZGVyZXJJbnN0YW5jZXM7XG4gIGlmICh0aGlzLl9yZW5kZXJlcnMuaW5kZXhPZihyZW5kZXJlcikgPCAwKSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIHZhciBpbmRleCA9IHJlbmRlcmVySW5zdGFuY2VzLmluZGV4T2YocmVuZGVyZXIpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZW5kZXJlckluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5zdGFydEZyYW1lID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdsID0gdGhpcy5fZ2w7XG5cbiAgaWYgKCFnbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIFdlYkdMIGNvbnRleHQgLSBtYXliZSBjb250ZXh0IHdhcyBsb3N0PycpO1xuICB9XG5cbiAgLy8gU2V0IHRoZSBXZWJHTCB2aWV3cG9ydC5cbiAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblxuICAvLyBDbGVhciBmcmFtZWJ1ZmZlci5cbiAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgLy8gRW5hYmxlIGRlcHRoIHRlc3RpbmcuXG4gIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcblxuICAvLyBFbmFibGUgYmxlbmRpbmcuIE9ORSBhbmQgT05FX01JTlVTX1NSQ19BTFBIQSBhcmUgdGhlIHJpZ2h0IGNob2ljZXMgZm9yXG4gIC8vIHByZW11bHRpcGxpZWQgdGV4dHVyZXMuXG4gIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLmVuZEZyYW1lID0gZnVuY3Rpb24oKSB7fTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS50YWtlU25hcHNob3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gIC8vIFZhbGlkYXRlIHBhc3NlZCBhcmd1bWVudFxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBxdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5O1xuXG4gIC8vIFNldCBkZWZhdWx0IHF1YWxpdHkgaWYgaXQgaXMgbm90IHBhc3NlZFxuICBpZiAodHlwZW9mIHF1YWxpdHkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBxdWFsaXR5ID0gNzU7XG4gIH1cblxuICAvLyBUaHJvdyBpZiBxdWFsaXR5IGlzIG9mIGludmxpZCB0eXBlIG9yIG91dCBvZiBib3VuZHNcbiAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAnbnVtYmVyJyB8fCBxdWFsaXR5IDwgMCB8fCBxdWFsaXR5ID4gMTAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTFN0YWdlOiBTbmFwc2hvdCBxdWFsaXR5IG5lZWRzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwJyk7XG4gIH1cblxuICAvLyBDYW52YXMgbWV0aG9kIFwidG9EYXRhVVJMXCIgbmVlZHMgdG8gYmUgY2FsbGVkIGluIHRoZSBzYW1lXG4gIC8vIGNvbnRleHQgYXMgd2hlcmUgdGhlIGFjdHVhbCByZW5kZXJpbmcgaXMgZG9uZS4gSGVuY2UgdGhpcy5cbiAgdGhpcy5yZW5kZXIoKTtcblxuICAvLyBSZXR1cm4gdGhlIHNuYXBzaG90XG4gIHJldHVybiB0aGlzLl9kb21FbGVtZW50LnRvRGF0YVVSTCgnaW1hZ2UvanBlZycscXVhbGl0eS8xMDApO1xufVxuXG5cbldlYkdsU3RhZ2UudHlwZSA9IFdlYkdsU3RhZ2UucHJvdG90eXBlLnR5cGUgPSAnd2ViZ2wnO1xuXG5cbmZ1bmN0aW9uIFdlYkdsVGV4dHVyZShzdGFnZSwgdGlsZSwgYXNzZXQpIHtcbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbiAgdGhpcy5fZ2wgPSBzdGFnZS5fZ2w7XG4gIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICB0aGlzLl90aW1lc3RhbXAgPSBudWxsO1xuICB0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IG51bGw7XG4gIHRoaXMucmVmcmVzaCh0aWxlLCBhc3NldCk7XG59XG5cblxuV2ViR2xUZXh0dXJlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24odGlsZSwgYXNzZXQpIHtcblxuICB2YXIgZ2wgPSB0aGlzLl9nbDtcbiAgdmFyIHN0YWdlID0gdGhpcy5fc3RhZ2U7XG4gIHZhciB0ZXh0dXJlO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZC5cbiAgdmFyIHRpbWVzdGFtcCA9IGFzc2V0LnRpbWVzdGFtcCgpO1xuICBpZiAodGltZXN0YW1wID09PSB0aGlzLl90aW1lc3RhbXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZXQgYXNzZXQgZWxlbWVudC5cbiAgdmFyIGVsZW1lbnQgPSBhc3NldC5lbGVtZW50KCk7XG5cbiAgLy8gR2V0IGFzc2V0IGRpbWVuc2lvbnMuXG4gIHZhciB3aWR0aCA9IGFzc2V0LndpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBhc3NldC5oZWlnaHQoKTtcblxuICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5faGVpZ2h0KSB7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBkaW1lbnNpb25zIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCByZWZyZXNoLCBjcmVhdGVcbiAgICAvLyBhIG5ldyB0ZXh0dXJlIHdpdGggdGhlIGNvcnJlY3Qgc2l6ZS5cblxuICAgIC8vIENoZWNrIGlmIHRleHR1cmUgZGltZW5zaW9ucyB3b3VsZCBleGNlZWQgdGhlIG1heGltdW0gdGV4dHVyZSBzaXplLlxuICAgIHZhciBtYXhTaXplID0gc3RhZ2UubWF4VGV4dHVyZVNpemUoKTtcbiAgICBpZiAod2lkdGggPiBtYXhTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUgd2lkdGggbGFyZ2VyIHRoYW4gbWF4IHNpemUgKCcgKyB3aWR0aCArICcgdnMuICcgKyBtYXhTaXplICsgJyknKTtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IG1heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSBoZWlnaHQgbGFyZ2VyIHRoYW4gbWF4IHNpemUgKCcgKyBoZWlnaHQgKyAnIHZzLiAnICsgbWF4U2l6ZSArICcpJyk7XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHRoZSBjdXJyZW50IHRleHR1cmUgaWYgaXQgZXhpc3RzLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBDaHJvbWUgb24gQW5kcm9pZC4gSWYgaXQgaXNuJ3QgZG9uZSB0aGUgdGV4dHVyZXNcbiAgICAvLyBkbyBub3QgcmVuZGVyIHdoZW4gdGhlIHNpemUgY2hhbmdlcy5cbiAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgdGV4dHVyZSBtdXN0IGJlIHByZW11bHRpcGxpZWQgYnkgYWxwaGEgdG8gZW5zdXJlIGNvcnJlY3QgYmxlbmRpbmcgb2ZcbiAgICAvLyBzZW1pdHJhbnNwYXJlbnQgdGV4dHVyZXMuIEZvciBkZXRhaWxzLCBzZWU6XG4gICAgLy8gaHR0cDovL3d3dy5yZWFsdGltZXJlbmRlcmluZy5jb20vYmxvZy9ncHVzLXByZWZlci1wcmVtdWx0aXBsaWNhdGlvbi9cbiAgICB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZWxlbWVudCk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIGRpbWVuc2lvbnMgcmVtYWluIHRoZSBzYW1lLCByZXBhaW50IHRoZSBleGlzdGluZyB0ZXh0dXJlLlxuICAgIC8vIFJlcGFpbnRpbmcgd2l0aCB0ZXhTdWJJbWFnZTJEIGlzIHVzdWFsbHkgZmFzdGVyIHRoYW4gd2l0aCB0ZXhJbWFnZTJELFxuICAgIC8vIGV4Y2VwdCBpbiB0aGUgY2FzZSBub3RlZCBpbiBicm93c2VyUXVpcmtzLlxuXG4gICAgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBicm93c2VyUXVpcmtzLnZpZGVvVXNlVGV4SW1hZ2UyRCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB0aGUgY29ycmVzcG9uZGluZyBzdGFnZSBvcHRpb24gaXMgc2V0IGFuZCB0aGUgdGV4dHVyZVxuICAvLyBkaW1lbnNpb25zIGFyZSBwb3dlcnMgb2YgdHdvLlxuICBpZiAoc3RhZ2UuX2dlbmVyYXRlTWlwbWFwcyAmJiBpc3BvdCh3aWR0aCkgJiYgaXNwb3QoaGVpZ2h0KSkge1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XG4gICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gIH1cblxuICAvLyBDbGFtcCB0ZXh0dXJlIHRvIGVkZ2VzLlxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgLy8gVW5iaW5kIHRleHR1cmUuXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG4gIC8vIFVwZGF0ZSB0ZXh0dXJlIGRpbWVuc2lvbnMgYW5kIHRpbWVzdGFtcC5cbiAgdGhpcy5fdGltZXN0YW1wID0gdGltZXN0YW1wO1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbn07XG5cblxuV2ViR2xUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgdGhpcy5fZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl90ZXh0dXJlKTtcbiAgfVxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbldlYkdsU3RhZ2UuVGV4dHVyZUNsYXNzID0gV2ViR2xTdGFnZS5wcm90b3R5cGUuVGV4dHVyZUNsYXNzID0gV2ViR2xUZXh0dXJlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR2xTdGFnZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHByZWZpeFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKS5wcmVmaXhQcm9wZXJ0eTtcblxuLy8gRGV0ZWN0IENTUyAzRCB0cmFuc2Zvcm1zIHN1cHBvcnQuIEFkYXB0ZWQgZnJvbSBNb2Rlcm5penIuXG5mdW5jdGlvbiBjaGVja0Nzc1N1cHBvcnRlZCgpIHtcbiAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSAncGVyc3BlY3RpdmUnIENTUyBwcm9wZXJ0eSBvciBhIHZlbmRvci1wcmVmaXhlZFxuICAvLyB2YXJpYW50IGlzIGF2YWlsYWJsZS5cbiAgdmFyIHBlcnNwZWN0aXZlUHJvcGVydHkgPSBwcmVmaXhQcm9wZXJ0eSgncGVyc3BlY3RpdmUnKTtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdXBwb3J0ZWQgPSB0eXBlb2YgZWwuc3R5bGVbcGVyc3BlY3RpdmVQcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnO1xuXG4gIC8vIENlcnRhaW4gdmVyc2lvbnMgb2YgQ2hyb21lIGRpc2FibGUgM0QgdHJhbnNmb3JtcyBldmVuIHRob3VnaCB0aGUgQ1NTXG4gIC8vIHByb3BlcnR5IGV4aXN0cy4gSW4gdGhvc2UgY2FzZXMsIHdlIHVzZSB0aGUgZm9sbG93aW5nIG1lZGlhIHF1ZXJ5LFxuICAvLyB3aGljaCBvbmx5IHN1Y2NlZWRzIGlmIHRoZSBmZWF0dXJlIGlzIGluZGVlZCBlbmFibGVkLlxuICBpZiAoc3VwcG9ydGVkICYmIHBlcnNwZWN0aXZlUHJvcGVydHkgPT09ICdXZWJraXRQZXJzcGVjdGl2ZScpIHtcbiAgICB2YXIgaWQgPSAnX19tYXJ6aXBhbm9fdGVzdF9jc3MzZF9zdXBwb3J0X18nO1xuICAgIHZhciBzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3QudGV4dENvbnRlbnQgPSAnQG1lZGlhKC13ZWJraXQtdHJhbnNmb3JtLTNkKXsjJyArIGlkICsgJ3toZWlnaHQ6IDNweDt9KSc7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdCk7XG4gICAgZWwuaWQgPSBpZDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICAvLyBUaGUgb2Zmc2V0SGVpZ2h0IHNlZW1zIHRvIGJlIGRpZmZlcmVudCB0aGFuIDMgYXQgc29tZSB6b29tIGxldmVscyBvblxuICAgIC8vIENocm9tZSAoYW5kIG1heWJlIG90aGVyIGJyb3dzZXJzKS4gVGVzdCBmb3IgPiAwIGluc3RlYWQuXG4gICAgc3VwcG9ydGVkID0gZWwub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBzdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0KTtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5cbi8vIENhY2hlIHJlc3VsdC5cbnZhciBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBjc3NTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgcmV0dXJuIChzdXBwb3J0ZWQgPSBjaGVja0Nzc1N1cHBvcnRlZCgpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NTdXBwb3J0ZWQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIERldGVjdCBzdXBwb3J0ZWQgRmxhc2ggdmVyc2lvbi4gUmV0dXJucyBbbWFqb3IsIG1pbm9yLCByZXZdIG9yIG51bGwuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9zd2ZvYmplY3RcbmZ1bmN0aW9uIGRldGVjdEZsYXNoVmVyc2lvbigpIHtcbiAgdmFyIHBsYXllclZlcnNpb24gPSBudWxsO1xuXG4gIHZhciBwbHVnaW5zID0gbmF2aWdhdG9yLnBsdWdpbnM7XG4gIHZhciBtaW1lVHlwZXMgPSBuYXZpZ2F0b3IubWltZVR5cGVzO1xuXG4gIHZhciBkID0gbnVsbDtcblxuICBpZiAocGx1Z2lucyAmJiBwbHVnaW5zWydTaG9ja3dhdmUgRmxhc2gnXSAmJiBtaW1lVHlwZXMgJiZcbiAgICAgIG1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXSAmJlxuICAgICAgbWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pIHtcbiAgICBkID0gcGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoJ10uZGVzY3JpcHRpb247XG4gICAgZCA9IGQucmVwbGFjZSgvXi4qXFxzKyhcXFMrXFxzK1xcUyskKS8sICckMScpO1xuICAgIHBsYXllclZlcnNpb24gPSBbMCwgMCwgMF07XG4gICAgcGxheWVyVmVyc2lvblswXSA9IHBhcnNlSW50KGQucmVwbGFjZSgvXiguKilcXC4uKiQvLCAnJDEnKSwgMTApO1xuICAgIHBsYXllclZlcnNpb25bMV0gPSBwYXJzZUludChkLnJlcGxhY2UoL14uKlxcLiguKilcXHMuKiQvLCAnJDEnKSwgMTApO1xuICAgIHBsYXllclZlcnNpb25bMl0gPSAvW2EtekEtWl0vLnRlc3QoZCkgPyBwYXJzZUludChkLnJlcGxhY2UoL14uKlthLXpBLVpdKyguKikkLywgJyQxJyksIDEwKSA6IDA7XG4gIH1cbiAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGEgPSBuZXcgQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKTtcbiAgICAgIGlmIChhICYmIChkID0gYS5HZXRWYXJpYWJsZSgnJHZlcnNpb24nKSkpIHtcbiAgICAgICAgZCA9IGQuc3BsaXQoJyAnKVsxXS5zcGxpdCgnLCcpO1xuICAgICAgICBwbGF5ZXJWZXJzaW9uID0gW3BhcnNlSW50KGRbMF0sIDEwKSwgcGFyc2VJbnQoZFsxXSwgMTApLCBwYXJzZUludChkWzJdLCAxMCldO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge31cbiAgfVxuXG4gIHJldHVybiBwbGF5ZXJWZXJzaW9uO1xufVxuXG4vLyBGbGFzaCBzdXBwb3J0IGRldGVjdGlvbi5cbmZ1bmN0aW9uIGNoZWNrRmxhc2hTdXBwb3J0ZWQoKSB7XG4gIHZhciB2ZXJzaW9uID0gZGV0ZWN0Rmxhc2hWZXJzaW9uKCk7XG4gIC8vIE9ubHkgc3VwcG9ydCAxMC4xIGFuZCBhYm92ZS4gRmxhc2ggMTAuMCBkb2VzIG5vdCB3b3JrIGZvciBzb21lIHJlYXNvbi5cbiAgcmV0dXJuIHZlcnNpb24gJiYgKHZlcnNpb25bMF0gPj0gMTEgfHwgKHZlcnNpb25bMF0gPT09IDEwICYmIHZlcnNpb25bMV0gPj0gMSkpO1xufVxuXG4vLyBDYWNoZSByZXN1bHQuXG52YXIgc3VwcG9ydGVkO1xuZnVuY3Rpb24gZmxhc2hTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgcmV0dXJuIChzdXBwb3J0ZWQgPSBjaGVja0ZsYXNoU3VwcG9ydGVkKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXNoU3VwcG9ydGVkO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEZXRlY3QgV2ViR2wgc3VwcG9ydC5cbi8vIEtlZXAgc3RhZ2VzL1dlYkdsLmpzIGluIHN5bmMgd2l0aCB0aGlzLlxuZnVuY3Rpb24gY2hlY2tXZWJHbFN1cHBvcnRlZCgpIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCAmJiAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKSk7XG4gIHJldHVybiAhIWdsO1xufVxuXG4vLyBDYWNoZSByZXN1bHQuXG52YXIgc3VwcG9ydGVkO1xuZnVuY3Rpb24gd2ViR2xTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgcmV0dXJuIChzdXBwb3J0ZWQgPSBjaGVja1dlYkdsU3VwcG9ydGVkKCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdlYkdsU3VwcG9ydGVkO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xuXG4vLyBEZXRlY3QgQ1NTIHBvaW50ZXItZXZlbnRzIHN1cHBvcnQuXG5mdW5jdGlvbiBjaGVja0Nzc1BvaW50ZXJFdmVudHNTdXBwb3J0ZWQoKSB7XG5cbiAgLy8gQ2hlY2sgZm9yIGV4aXN0ZW5jZSBvZiBDU1MgcHJvcGVydHkuXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5zdHlsZTtcbiAgc3R5bGUuY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czphdXRvJztcbiAgdmFyIGhhc0Nzc1Byb3BlcnR5ID0gc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xuXG4gIC8vIFRoZSBhYm92ZSByZXN1bHQgaXMgc3B1cmlvdXMgb24gZW11bGF0aW9uIG1vZGUgZm9yIElFIDgtMTAuXG4gIHZhciBpc09sZElFID0gYnJvd3Nlci5tc2llICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDExO1xuXG4gIHJldHVybiBoYXNDc3NQcm9wZXJ0eSAmJiAhaXNPbGRJRTtcbn1cblxuLy8gQ2FjaGUgcmVzdWx0LlxudmFyIHN1cHBvcnRlZDtcbmZ1bmN0aW9uIGNzc1BvaW50ZXJFdmVudHNTdXBwb3J0ZWQoKSB7XG4gIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gIH1cbiAgcmV0dXJuIChzdXBwb3J0ZWQgPSBjaGVja0Nzc1BvaW50ZXJFdmVudHNTdXBwb3J0ZWQoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3NzUG9pbnRlckV2ZW50c1N1cHBvcnRlZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVHJhbnNmb3JtIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBhbiBhc3luY2hyb25vdXMgb25lLlxuZnVuY3Rpb24gYXN5bmMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jZWQoZG9uZSkge1xuICAgIHZhciBlcnIsIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gZm4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRvbmUoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUobnVsbCwgcmV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgUmVjdFNwZWN9IGludG8gYW4gZXF1aXZhbGVudCB7QGxpbmsgUmVjdH0uXG4gKlxuICogQSB7QGxpbmsgUmVjdFNwZWN9IGlzIGEgY29udmVuaWVudCB1c2VyIEFQSSBmb3JtYXQsIHByb3ZpZGluZyBkZWZhdWx0IHZhbHVlc1xuICogYW5kIHRoZSBmbGV4aWJpbGl0eSBvZiBzcGVjaWZ5aW5nIGFic29sdXRlLCByZWxhdGl2ZSBvciBtaXhlZCBkaW1lbnNpb25zLlxuICpcbiAqIEEge0BsaW5rIFJlY3R9IGlzIGEgbW9yZSBjb252ZW5pZW50IGZvcm1hdCBmb3IgdGhlIHJlbmRlcmluZyBwaXBlbGluZS4gSXQgaXNcbiAqIGFsd2F5cyBleHByZXNzZWQgaW4gbm9ybWFsaXplZCBjb29yZGluYXRlcywgYW5kIGFsbCBpdHMgcHJvcGVydGllcyBhcmVcbiAqIGd1YXJhbnRlZWQgdG8gYmUgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxXaWR0aCBUaGUgdG90YWwgd2lkdGggb2YgdGhlIHJlbmRlcmluZyBhcmVhIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbEhlaWdodCBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoZSByZW5kZXJpbmcgYXJlYSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge1JlY3RTcGVjfSBzcGVjIFRoZSBpbnB1dCBzcGVjLCBkZWZhdWx0aW5nIHRvIHRoZSBmdWxsIHJlbmRlcmluZyBhcmVhXG4gKiAgICAgaWYgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge1JlY3R9IHJlc3VsdCBUaGUgb3V0cHV0IHNwZWMuIElmIHRoZSBhcmd1bWVudCBpcyBwcmVzZW50LCBpdCBpc1xuICogICAgIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQ7IG90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWN0KHRvdGFsV2lkdGgsIHRvdGFsSGVpZ2h0LCBzcGVjLCByZXN1bHQpIHtcblxuICByZXN1bHQgPSByZXN1bHQgfHwge307XG5cbiAgdmFyIHdpZHRoO1xuICBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMuYWJzb2x1dGVXaWR0aCAhPSBudWxsKSB7XG4gICAgd2lkdGggPSBzcGVjLmFic29sdXRlV2lkdGggLyB0b3RhbFdpZHRoO1xuICB9IGVsc2UgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLnJlbGF0aXZlV2lkdGggIT0gbnVsbCkge1xuICAgIHdpZHRoID0gc3BlYy5yZWxhdGl2ZVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gMTtcbiAgfVxuXG4gIHZhciBoZWlnaHQ7XG4gIGlmIChzcGVjICYmIHNwZWMuYWJzb2x1dGVIZWlnaHQgIT0gbnVsbCkge1xuICAgIGhlaWdodCA9IHNwZWMuYWJzb2x1dGVIZWlnaHQgLyB0b3RhbEhlaWdodDtcbiAgfSBlbHNlIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5yZWxhdGl2ZUhlaWdodCAhPSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gc3BlYy5yZWxhdGl2ZUhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSAxO1xuICB9XG5cbiAgdmFyIHg7XG4gIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5hYnNvbHV0ZVggIT0gbnVsbCkge1xuICAgIHggPSBzcGVjLmFic29sdXRlWCAvIHRvdGFsV2lkdGg7XG4gIH0gZWxzZSBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMucmVsYXRpdmVYICE9IG51bGwpIHtcbiAgICB4ID0gc3BlYy5yZWxhdGl2ZVg7XG4gIH0gZWxzZSB7XG4gICAgeCA9IDA7XG4gIH1cblxuICB2YXIgeTtcbiAgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLmFic29sdXRlWSAhPSBudWxsKSB7XG4gICAgeSA9IHNwZWMuYWJzb2x1dGVZIC8gdG90YWxIZWlnaHQ7XG4gIH0gZWxzZSBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMucmVsYXRpdmVZICE9IG51bGwpIHtcbiAgICB5ID0gc3BlYy5yZWxhdGl2ZVk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IDA7XG4gIH1cblxuICByZXN1bHQueCA9IHg7XG4gIHJlc3VsdC55ID0geTtcbiAgcmVzdWx0LndpZHRoID0gd2lkdGg7XG4gIHJlc3VsdC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWxjUmVjdDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG9uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcblxuLy8gQSBjYW5jZWxhYmxlIGZ1bmN0aW9uIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiAoaS5lLiwgb25lIHdob3NlIGxhc3Rcbi8vIGFyZ3VtZW50IGlzIGEgY2FsbGJhY2sgcmVjZWl2aW5nIGFuIGVycm9yIHBsdXMgemVybyBvciBtb3JlIHJldHVybiB2YWx1ZXMpXG4vLyB0aGF0IChzeW5jaHJvbm91c2x5KSByZXR1cm5zIGEgY2FuY2VsKCkgZnVuY3Rpb24uIENhbGxpbmcgY2FuY2VsKCkgc2hvdWxkXG4vLyBhYm9ydCB0aGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBhbmQgY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgYXJndW1lbnRzXG4vLyB0aGF0IHdlcmUgcGFzc2VkIGludG8gY2FuY2VsKCkuIENhbGxpbmcgY2FuY2VsKCkgdHdpY2UsIGFzIHdpdGggY2FsbGJhY2tzLFxuLy8gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc2FmZS5cblxuLy8gV3JhcCBhIG5vbi1jYW5jZWxsYWJsZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBhIGNhbmNlbGFibGUgb25lLlxuLy9cbi8vIENhbGxpbmcgY2FuY2VsKCkgb24gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgbm90IGludGVycnVwdCB0aGUgZXhlY3V0aW9uXG4vLyBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb247IGl0IHdpbGwgbWVyZWx5IGlnbm9yZSBpdHMgcmV0dXJuIHZhbHVlLlxuLy9cbi8vIFVzdWFsbHksIGluc3RlYWQgb2Ygd3JhcHBpbmcgeW91ciBmdW5jdGlvbiwgeW91IHdhbnQgdG8gaW1wbGVtZW50IGNhbmNlbCgpXG4vLyB5b3Vyc2VsZiBpbiBvcmRlciB0byBoYXZlIHNvbWUgYWJvcnQgbG9naWMuIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBwcm92aWRlcyBhXG4vLyBzdHJhaWdoZm9yd2FyZCBzb2x1dGlvbiBmb3IgY2FzZXMgaW4gd2hpY2ggbm8gY3VzdG9tIGFib3J0IGxvZ2ljIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gY2FuY2VsaXplKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjYW5jZWxpemVkKCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5jZWxpemVkOiBleHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIHZhciBkb25lID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gb25jZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pO1xuXG4gICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIGNhbmNlbDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5jZWxpemU7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub29wID0gcmVxdWlyZSgnLi9ub29wJyk7XG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgaXRzIGFyZ3VtZW50cyAod2hpY2ggc2hvdWxkIGJlIGNhbmNlbGFibGVzKVxuLy8gaW4gc2VxdWVuY2UsIHNvIHRoYXQgZWFjaCBvZiB0aGVtIHBhc3NlcyBpdHMgcmV0dXJuIHZhbHVlcyB0byB0aGUgbmV4dC5cbi8vIEV4ZWN1dGlvbiBpcyBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgYW4gZXJyb3I7IGluIHRoYXQgY2FzZVxuLy8gdGhlIGxhc3QgZnVuY3Rpb24gaW4gdGhlIHNlcXVlbmNlIGlzIGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbi8vIFNlZSB1dGlsL2NhbmNlbGl6ZS5qcyBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2hhdCBjYW5jZWxhYmxlcyBhcmUuXG5mdW5jdGlvbiBjaGFpbigpIHtcblxuICAvLyBUaGUgbGlzdCBvZiBmdW5jdGlvbnMgdG8gY2hhaW4gdG9nZXRoZXIuXG4gIHZhciBhcmdMaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZCgpIHtcblxuICAgIC8vIExpc3Qgb2YgcmVtYWluaW5nIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZC5cbiAgICAvLyBNYWtlIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgbGlzdCBzbyB3ZSBjYW4gbXV0YXRlIHRoZSBmb3JtZXIgd2hpbGVcbiAgICAvLyBwcmVzZXJ2aW5nIHRoZSBsYXR0ZXIgaW50YWN0IGZvciBmdXR1cmUgaW52b2NhdGlvbnMgb2YgdGhlIGNoYWluLlxuICAgIHZhciBmbkxpc3QgPSBhcmdMaXN0LnNsaWNlKDApO1xuXG4gICAgLy8gQ3VycmVudGx5IGV4ZWN1dGluZyBmdW5jdGlvbi5cbiAgICB2YXIgZm4gPSBudWxsO1xuXG4gICAgLy8gQ2FuY2VsIG1ldGhvZCBmb3IgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgZnVuY3Rpb24uXG4gICAgdmFyIGNmbiA9IG51bGw7XG5cbiAgICAvLyBBcmd1bWVudHMgZm9yIHRoZSBmaXJzdCBmdW5jdGlvbi5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IFtdO1xuXG4gICAgLy8gQ2FsbGJhY2sgZm9yIHRoZSBjaGFpbi5cbiAgICB2YXIgZG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdIDogbm9vcDtcblxuICAgIC8vIEV4ZWN1dGUgdGhlIG5leHQgZnVuY3Rpb24gaW4gdGhlIGNoYWluLlxuICAgIC8vIFJlY2VpdmVzIHRoZSBlcnJvciBhbmQgcmV0dXJuIHZhbHVlcyBmcm9tIHRoZSBwcmV2aW91cyBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuXG4gICAgICAvLyBFeHRyYWN0IGVycm9yIGZyb20gYXJndW1lbnRzLlxuICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgLy8gQWJvcnQgY2hhaW4gb24gZXJyb3IuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZuID0gY2ZuID0gbnVsbDtcbiAgICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRlcm1pbmF0ZSBpZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb25zIGxlZnQgaW4gdGhlIGNoYWluLlxuICAgICAgaWYgKCFmbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGZuID0gY2ZuID0gbnVsbDtcbiAgICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgZnVuY3Rpb24gaW4gdGhlIGNoYWluLlxuICAgICAgZm4gPSBmbkxpc3Quc2hpZnQoKTtcbiAgICAgIHZhciBfZm4gPSBmbjtcblxuICAgICAgLy8gRXh0cmFjdCBhcmd1bWVudHMgdG8gcGFzcyBpbnRvIHRoZSBuZXh0IGZ1bmN0aW9uLlxuICAgICAgdmFyIHJldCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIC8vIENhbGwgbmV4dCBmdW5jdGlvbiB3aXRoIHByZXZpb3VzIHJldHVybiB2YWx1ZSBhbmQgY2FsbCBiYWNrIGV4ZWMuXG4gICAgICByZXQucHVzaChleGVjKTtcbiAgICAgIHZhciBfY2ZuID0gZm4uYXBwbHkobnVsbCwgcmV0KTsgLy8gZm4obnVsbCwgcmV0Li4uLCBleGVjKVxuXG4gICAgICAvLyBEZXRlY3Qgd2hlbiBmbiBoYXMgY29tcGxldGVkIHN5bmNocm9ub3VzbHkgYW5kIGRvIG5vdCBjbG9iYmVyIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgaW4gdGhhdCBjYXNlLiBZb3UncmUgbm90IGV4cGVjdGVkIHRvIHVuZGVyc3RhbmQgdGhpcy5cbiAgICAgIGlmIChfZm4gIT09IGZuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGNhbmNlbCBtZXRob2QgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIGZ1bmN0aW9uLlxuICAgICAgLy8gRGV0ZWN0IGNoYWluaW5nIG9uIG5vbi1jYW5jZWxsYWJsZSBmdW5jdGlvbi5cbiAgICAgIGlmICh0eXBlb2YgX2NmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluOiBjaGFpbmluZyBvbiBub24tY2FuY2VsbGFibGUgZnVuY3Rpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNmbiA9IF9jZm47XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBDYW5jZWwgY2hhaW4gZXhlY3V0aW9uLlxuICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlmIChjZm4pIHtcbiAgICAgICAgY2ZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgY2hhaW4gZXhlY3V0aW9uLlxuICAgIC8vIFdlIGNhbGwgZXhlYyBhcyBpZiBsaW5raW5nIGZyb20gYSBwcmV2aW91cyBmdW5jdGlvbiBpbiB0aGUgY2hhaW4sXG4gICAgLy8gZXhjZXB0IHRoYXQgdGhlIGVycm9yIGlzIGFsd2F5cyBudWxsLiBBcyBhIGNvbnNlcXVlbmNlLCBjaGFpbmluZyBvbiBhblxuICAgIC8vIGVtcHR5IGxpc3QgeWllbGRzIHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgZXhlYy5hcHBseShudWxsLCBhcmdzKTsgLy8gZXhlYyhudWxsLCBhcmdzLi4uKVxuXG4gICAgcmV0dXJuIGNhbmNlbDtcblxuICB9O1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhaW47XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhbXA7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZXRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIHRvIHVuZGVmaW5lZC4gVGhpcyBtYXkgYmUgY2FsbGVkIGJ5XG4vLyBkZXN0cnVjdG9ycyB0byBhdm9pZCByZXRhaW5pbmcgcmVmZXJlbmNlcyBhbmQgaGVscCBkZXRlY3QgaW5jb3JyZWN0IHVzZSBvZlxuLy8gZGVzdHJveWVkIGluc3RhbmNlcy5cbmZ1bmN0aW9uIGNsZWFyT3duUHJvcGVydGllcyhvYmopIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBvYmpbcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xlYXJPd25Qcm9wZXJ0aWVzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjbXAoeCwgeSkge1xuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHggPiB5KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY21wOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICogQ29tcG9zZSBtdWx0aXBsZSBmdW5jdGlvbnNcbiAgKlxuICAqIGBjb21wb3NlKGYsIGcpYCByZXR1cm5zIGBmdW5jdGlvbih4KSB7IHJldHVybiBmKGcoeCkpOyB9YFxuICAqXG4gICogQG1lbWJlcm9mIHV0aWxcbiAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZ1bmN0aW9ucyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKi9cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIHZhciBmbkxpc3QgPSBhcmd1bWVudHM7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wb3NlZChpbml0aWFsQXJnKSB7XG4gICAgdmFyIHJldCA9IGluaXRpYWxBcmc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IGZuTGlzdFtpXTtcbiAgICAgIHJldCA9IGZuLmNhbGwobnVsbCwgcmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb3NlOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb252ZXJ0IGZvdlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBjb252ZXJ0IGZyb20gaGZvdiB0byB2Zm92IG9uZSB3b3VsZCBjYWxsIFxuICogYGNvbnZlcnQoaGZvdiwgd2lkdGgsIGhlaWdodClgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBjb252ZXJ0KGZvdiwgZnJvbURpbWVuc2lvbiwgdG9EaW1lbnNpb24pIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4odG9EaW1lbnNpb24gKiBNYXRoLnRhbihmb3YgLyAyKSAvIGZyb21EaW1lbnNpb24pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gaHRvdihmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCB3aWR0aCwgaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIGh0b2QoZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgd2lkdGgsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiB2dG9oKGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIGhlaWdodCwgd2lkdGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gdnRvZChmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCBoZWlnaHQsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBkdG9oKGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSwgd2lkdGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gZHRvdihmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCksIGhlaWdodCk7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZSB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnZlcnQ6IGNvbnZlcnQsXG4gIGh0b3Y6IGh0b3YsXG4gIGh0b2Q6IGh0b2QsXG4gIHZ0b2g6IHZ0b2gsXG4gIHZ0b2Q6IHZ0b2QsXG4gIGR0b2g6IGR0b2gsXG4gIGR0b3Y6IGR0b3Zcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIENvbnZlcnQgYSBudW1iZXIgdG8gYSBzdHJpbmcgaW4gZGVjaW1hbCBub3RhdGlvbi5cbmZ1bmN0aW9uIGRlY2ltYWwoeCkge1xuICAvLyBEb3VibGUtcHJlY2lzaW9uIGZsb2F0cyBoYXZlIDE1IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXRzLlxuICByZXR1cm4geC50b1ByZWNpc2lvbigxNSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjaW1hbDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKG9iaiwgZGVmYXVsdHNPYmopIHtcbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzT2JqKSB7XG4gICAgaWYgKCEoa2V5IGluIG9iaikpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNPYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0czsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmVyKGZuLCBhcmdzKSB7XG4gIGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuICAgIGlmIChhcmdzICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG4gIHNldFRpbWVvdXQoZGVmZXJyZWQsIDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmVyOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWdUb1JhZChkZWcpIHtcbiAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVnVG9SYWQ7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQZXJmb3JtIGEgY2FuY2VsYWJsZSBkZWxheS5cbi8vIFNlZSB1dGlsL2NhbmNlbGl6ZS5qcyBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2hhdCBjYW5jZWxhYmxlcyBhcmUuXG5mdW5jdGlvbiBkZWxheShtcywgZG9uZSkge1xuXG4gIC8vIFdvcmsgYXJvdW5kIElFOCBidWcgd2hlcmVieSBhIHNldFRpbWVvdXQgY2FsbGJhY2sgbWF5IHN0aWxsIGJlIGNhbGxlZFxuICAvLyBhZnRlciB0aGUgY29ycmVzcG9uZGluZyBjbGVhclRpbWVvdXQgaXMgaW52b2tlZC5cbiAgdmFyIHRpbWVyID0gbnVsbDtcblxuICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgaWYgKHRpbWVyICE9IG51bGwpIHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIGRvbmUobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRpbWVyID0gc2V0VGltZW91dChmaW5pc2gsIG1zKTtcblxuICByZXR1cm4gY2FuY2VsO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVsYXk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gcHJlZml4UHJvcGVydHkocHJvcGVydHkpIHtcblxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gIHZhciBwcmVmaXhMaXN0ID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4TGlzdFtpXTtcbiAgICB2YXIgY2FwaXRhbGl6ZWRQcm9wZXJ0eSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IHByZWZpeCArIGNhcGl0YWxpemVkUHJvcGVydHk7XG5cbiAgICBpZiAocHJlZml4ZWRQcm9wZXJ0eSBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkUHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BlcnR5O1xuXG59XG5cblxuZnVuY3Rpb24gZ2V0V2l0aFZlbmRvclByZWZpeChwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IHByZWZpeFByb3BlcnR5KHByb3BlcnR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3BlcnR5V2l0aFZlbmRvclByZWZpeChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbcHJlZml4ZWRQcm9wZXJ0eV07XG4gIH07XG5cbn1cblxuXG5mdW5jdGlvbiBzZXRXaXRoVmVuZG9yUHJlZml4KHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gcHJlZml4UHJvcGVydHkocHJvcGVydHkpO1xuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvcGVydHlXaXRoVmVuZG9yUHJlZml4KGVsZW1lbnQsIHZhbCkge1xuICAgIHJldHVybiAoZWxlbWVudC5zdHlsZVtwcmVmaXhlZFByb3BlcnR5XSA9IHZhbCk7XG4gIH07XG59XG5cblxudmFyIHNldFRyYW5zZm9ybSA9IHNldFdpdGhWZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybScpO1xudmFyIHNldFRyYW5zZm9ybU9yaWdpbiA9IHNldFdpdGhWZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybU9yaWdpbicpO1xuXG5cbmZ1bmN0aW9uIHNldE51bGxUcmFuc2Zvcm0oZWxlbWVudCkge1xuICBzZXRUcmFuc2Zvcm0oZWxlbWVudCwgJ3RyYW5zbGF0ZVooMCknKTtcbn1cblxuXG5mdW5jdGlvbiBzZXROdWxsVHJhbnNmb3JtT3JpZ2luKGVsZW1lbnQpIHtcbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGVsZW1lbnQsICcwIDAgMCcpO1xufVxuXG5cbmZ1bmN0aW9uIHNldEFic29sdXRlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG59XG5cblxuZnVuY3Rpb24gc2V0UGl4ZWxQb3NpdGlvbihlbGVtZW50LCB4LCB5KSB7XG4gIGVsZW1lbnQuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICBlbGVtZW50LnN0eWxlLnRvcCA9IHkgKyAncHgnO1xufVxuXG5cbmZ1bmN0aW9uIHNldFBpeGVsU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn1cblxuXG5mdW5jdGlvbiBzZXROdWxsU2l6ZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSBlbGVtZW50LnN0eWxlLmhlaWdodCA9IDA7XG59XG5cblxuZnVuY3Rpb24gc2V0RnVsbFNpemUoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLndpZHRoID0gZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG59XG5cblxuZnVuY3Rpb24gc2V0T3ZlcmZsb3dIaWRkZW4oZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG59XG5cblxuZnVuY3Rpb24gc2V0T3ZlcmZsb3dWaXNpYmxlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcbn1cblxuXG5mdW5jdGlvbiBzZXROb1BvaW50ZXJFdmVudHMoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG59XG5cblxuZnVuY3Rpb24gc2V0QmxvY2tpbmcoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjMDAwJztcbiAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICBlbGVtZW50LnN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PTApJztcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJlZml4UHJvcGVydHk6IHByZWZpeFByb3BlcnR5LFxuICBnZXRXaXRoVmVuZG9yUHJlZml4OiBnZXRXaXRoVmVuZG9yUHJlZml4LFxuICBzZXRXaXRoVmVuZG9yUHJlZml4OiBzZXRXaXRoVmVuZG9yUHJlZml4LFxuICBzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybSxcbiAgc2V0VHJhbnNmb3JtT3JpZ2luOiBzZXRUcmFuc2Zvcm1PcmlnaW4sXG4gIHNldE51bGxUcmFuc2Zvcm06IHNldE51bGxUcmFuc2Zvcm0sXG4gIHNldE51bGxUcmFuc2Zvcm1PcmlnaW46IHNldE51bGxUcmFuc2Zvcm1PcmlnaW4sXG4gIHNldEFic29sdXRlOiBzZXRBYnNvbHV0ZSxcbiAgc2V0UGl4ZWxQb3NpdGlvbjogc2V0UGl4ZWxQb3NpdGlvbixcbiAgc2V0UGl4ZWxTaXplOiBzZXRQaXhlbFNpemUsXG4gIHNldE51bGxTaXplOiBzZXROdWxsU2l6ZSxcbiAgc2V0RnVsbFNpemU6IHNldEZ1bGxTaXplLFxuICBzZXRPdmVyZmxvd0hpZGRlbjogc2V0T3ZlcmZsb3dIaWRkZW4sXG4gIHNldE92ZXJmbG93VmlzaWJsZTogc2V0T3ZlcmZsb3dWaXNpYmxlLFxuICBzZXROb1BvaW50ZXJFdmVudHM6IHNldE5vUG9pbnRlckV2ZW50cyxcbiAgc2V0QmxvY2tpbmc6IHNldEJsb2NraW5nXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBleHRlbmQob2JqLCBzb3VyY2VPYmopIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZU9iaikge1xuICAgIG9ialtrZXldID0gc291cmNlT2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgZ2xvYmFsIG9iamVjdC5cbnZhciBnbG9iYWxPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbE9iamVjdDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gSmVua2lucyBvbmUtYXQtYS10aW1lIGhhc2hcbi8vIGh0dHA6Ly93d3cuYnVydGxlYnVydGxlLm5ldC9ib2IvaGFzaC9kb29icy5odG1sXG4vLyBJbnB1dDogYW4gYXJyYXkgb2YgaW50ZWdlcnNcbi8vIE91dHB1dDogYW4gaW50ZWdlclxuXG5mdW5jdGlvbiBoYXNoKCkge1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGsgPSBhcmd1bWVudHNbaV07XG4gICAgaCArPSBrO1xuICAgIGggKz0gayA8PCAxMDtcbiAgICBoIF49IGsgPj4gNjtcbiAgfVxuICBoICs9IGggPDwgMztcbiAgaCBePSBoID4+IDExO1xuICBoICs9IGggPDwgMTU7XG4gIHJldHVybiBoID49IDAgPyBoIDogLWg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIE1ha2UgY3RvciBhIHN1YmNsYXNzIG9mIHN1cGVyQ3Rvci5cbi8vIERvIG5vdCBkZXBlbmQgb24gRVM1IE9iamVjdC5jcmVhdGUgc2VtYW50aWNzIGJlY2F1c2Ugb2Ygb2xkZXIgYnJvd3NlcnMuXG5mdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uKCkge307XG4gIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmhlcml0czsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJldHVybnMgd2hldGhlciBuIGlzIGEgcG93ZXIgb2YgdHdvLlxuZnVuY3Rpb24gaXNwb3Qobikge1xuICByZXR1cm4gKG4gJiAobiAtIDEpKSA9PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzcG90OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bG8gb3BlcmF0aW9uXG4gKlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXZpZGVuZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpdmlzb3JcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFZhbHVlIGluIHJhbmdlIGBbMCxkaXZpc29yW2BcbiAqL1xuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgcmV0dXJuICgrYSAlIChiID0gK2IpICsgYikgJSBiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXROb3coKSB7XG4gIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIHJldHVybiBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBkYXRlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vdygpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgdmFyIHZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24gb25jZWQoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB2YWx1ZSA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmNlOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRQaXhlbFJhdGlvID0gMTtcblxuZnVuY3Rpb24gcGl4ZWxSYXRpbygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNjcmVlbiA9IHdpbmRvdy5zY3JlZW47XG4gICAgICBpZiAoc2NyZWVuICYmIHNjcmVlbi5kZXZpY2VYRFBJICYmIHNjcmVlbi5sb2dpY2FsWERQSSkge1xuICAgICAgICByZXR1cm4gc2NyZWVuLmRldmljZVhEUEkgLyBzY3JlZW4ubG9naWNhbFhEUEk7XG4gICAgICB9IGVsc2UgaWYgKHNjcmVlbiAmJiBzY3JlZW4uc3lzdGVtWERQSSAmJiBzY3JlZW4ubG9naWNhbFhEUEkpIHtcbiAgICAgICAgcmV0dXJuIHNjcmVlbi5zeXN0ZW1YRFBJIC8gc2NyZWVuLmxvZ2ljYWxYRFBJO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFBpeGVsUmF0aW87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGl4ZWxSYXRpbztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNzc1N1cHBvcnRlZCA9IHJlcXVpcmUoJy4uL3N1cHBvcnQvQ3NzJyk7XG52YXIgc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi9kb20nKS5zZXRUcmFuc2Zvcm07XG52YXIgc2V0UGl4ZWxQb3NpdGlvbiA9IHJlcXVpcmUoJy4vZG9tJykuc2V0UGl4ZWxQb3NpdGlvbjtcbnZhciBkZWNpbWFsID0gcmVxdWlyZSgnLi9kZWNpbWFsJyk7XG5cbi8vIFRoaXMgY2Fubm90IGJlbG9uZyBpbiB1dGlsL2RvbS5qcyBiZWNhdXNlIHN1cHBvcnQvQ3NzIGFsc28gZGVwZW5kcyBvbiBpdFxuLy8gYW5kIGl0IHdvdWxkIGNhdXNlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblxuZnVuY3Rpb24gcG9zaXRpb25BYnNvbHV0ZWx5KGVsZW1lbnQsIHgsIHksIGV4dHJhVHJhbnNmb3Jtcykge1xuICBleHRyYVRyYW5zZm9ybXMgPSBleHRyYVRyYW5zZm9ybXMgfHwgJyc7XG4gIGlmIChjc3NTdXBwb3J0ZWQoKSkge1xuICAgIC8vIFVzZSBDU1MgM0QgdHJhbnNmb3JtcyB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZW0uXG4gICAgLy8gQSB0cmFuc2xhdGVaKDApIHRyYW5zZm9ybSBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBDaHJvbWUgYnkgY3JlYXRpbmcgYVxuICAgIC8vIG5ldyBsYXllciBmb3IgdGhlIGVsZW1lbnQsIHdoaWNoIHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlcGFpbnRzLlxuICAgIHZhciB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnICsgZGVjaW1hbCh4KSArICdweCkgdHJhbnNsYXRlWSgnICsgZGVjaW1hbCh5KSArICdweCkgdHJhbnNsYXRlWigwKSAnICsgZXh0cmFUcmFuc2Zvcm1zO1xuICAgIHNldFRyYW5zZm9ybShlbGVtZW50LCB0cmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGwgYmFjayB0byBhYnNvbHV0ZSBwb3NpdGlvbmluZy5cbiAgICBzZXRQaXhlbFBvc2l0aW9uKGVsZW1lbnQsIHgsIHkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXRpb25BYnNvbHV0ZWx5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICByZXR1cm4gcmFkICogMTgwIC8gTWF0aC5QSTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByYWRUb0RlZzsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJlYWwoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWw7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vLyBSZXR1cm4gYSBjYW5jZWxhYmxlIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgZm4gaW4gYSBsb29wIHVudGlsIGl0IHJldHVybnNcbi8vIHN1Y2Nlc3NmdWxseS5cbmZ1bmN0aW9uIHJldHJ5KGZuKSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJldHJpZWQoKSB7XG5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IFtdO1xuICAgIHZhciBkb25lID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gOiBub29wO1xuXG4gICAgdmFyIGNmbiA9IG51bGw7XG4gICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICghZXJyIHx8IGNhbmNlbGVkKSB7XG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNmbiA9IGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyZ3MucHVzaChleGVjKTtcbiAgICBleGVjKHRydWUpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIGNmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgfTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm93ID0gcmVxdWlyZSgnLi9ub3cnKTtcblxuZnVuY3Rpb24gdHdlZW4oZHVyYXRpb24sIHVwZGF0ZSwgZG9uZSkge1xuICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gIGZ1bmN0aW9uIHJ1blVwZGF0ZSgpIHtcbiAgICBpZihjYW5jZWxsZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHR3ZWVuVmFsID0gKG5vdygpIC0gc3RhcnRUaW1lKS9kdXJhdGlvbjtcbiAgICBpZih0d2VlblZhbCA8IDEpIHtcbiAgICAgIHVwZGF0ZSh0d2VlblZhbCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuVXBkYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoMSk7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKDApO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuVXBkYXRlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHdlZW47IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB0eXBlKHgpIHtcbiAgdmFyIHR5cCA9IHR5cGVvZiB4O1xuICBpZiAodHlwID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR5cDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgdmVjNCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzQ7XG52YXIgcGl4ZWxSYXRpbyA9IHJlcXVpcmUoJy4uL3V0aWwvcGl4ZWxSYXRpbycpO1xudmFyIHJlYWwgPSByZXF1aXJlKCcuLi91dGlsL3JlYWwnKTtcbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBEZWZhdWx0IHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4vLyBTdGFydCB3aXRoIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhvc2UgdmFsdWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbnZhciBkZWZhdWx0V2lkdGggPSAwO1xudmFyIGRlZmF1bHRIZWlnaHQgPSAwO1xuXG4vLyBEZWZhdWx0IHZpZXcgcGFyYW1ldGVycy5cbnZhciBkZWZhdWx0WCA9IDAuNTtcbnZhciBkZWZhdWx0WSA9IDAuNTtcbnZhciBkZWZhdWx0Wm9vbSA9IDE7XG5cbi8vIENvbnN0YW50IHZhbHVlcyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBmcnVzdHVtIGN1bGxpbmcgbG9naWMuXG4vLyBwbGFuZUF4ZXNbaV0gaW5kaWNhdGVzIHRoZSBjb29yZGluYXRlIHZhbHVlIHRoYXQgZGVmaW5lcyBhIGZydXN0dW0gcGxhbmUuXG4vLyBwbGFuZUNtcFtpXSBpbmRpY2F0ZXMgaG93IHBvaW50IGFuZCBwbGFuZSBjb29yZGluYXRlcyBzaG91bGQgYmUgY29tcGFyZWRcbi8vIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBwb2ludCBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiB0aGUgcGxhbmUuXG52YXIgcGxhbmVBeGVzID0gW1xuICAxLCAvLyB0b3BcbiAgMCwgLy8gcmlnaHRcbiAgMSwgLy8gYm90dG9tXG4gIDAgIC8vIGxlZnRcbl07XG52YXIgcGxhbmVDbXAgPSBbXG4gIC0xLCAvLyB0b3BcbiAgLTEsIC8vIHJpZ2h0XG4gICAxLCAvLyBib3R0b21cbiAgIDEgIC8vIGxlZnRcbl07XG5cbi8vIEEgem9vbSBvZiBleGFjdGx5IDAgYnJlYWtzIHNvbWUgY29tcHV0YXRpb25zLCBzbyB3ZSBmb3JjZSBhIG1pbmltdW0gcG9zaXRpdmVcbi8vIHZhbHVlLiBXZSB1c2UgNiBkZWNpbWFsIHBsYWNlcyBmb3IgdGhlIGVwc2lsb24gdmFsdWUgdG8gYXZvaWQgYnJva2VuXG4vLyByZW5kZXJpbmcgZHVlIHRvIGxvc3Mgb2YgcHJlY2lzaW9uIGluIGZsb2F0aW5nIHBvaW50IGNvbXB1dGF0aW9ucy5cbnZhciB6b29tTGltaXRFcHNpbG9uID0gMC4wMDAwMDE7XG5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZsYXRWaWV3UGFyYW1zXG4gKlxuICogQSBjYW1lcmEgY29uZmlndXJhdGlvbiBmb3IgYSB7QGxpbmsgRmxhdFZpZXd9LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIGltYWdlIHBvaW50IGRpc3BsYXllZFxuICogICAgIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKiAgICAgV2hlbiBgeCA9PT0gMC41YCwgdGhlIGltYWdlIGlzIGNlbnRlcmVkIGhvcml6b250YWxseS5cbiAqICAgICBXaGVuIGB4ID09PSAwYCwgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW1hZ2UgaXMgYXQgdGhlIHZpZXdwb3J0IGNlbnRlci5cbiAqICAgICBXaGVuIGB4ID09PSAxYCwgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgaW1hZ2UgcG9pbnQgZGlzcGxheWVkIGF0XG4gKiAgICAgdGhlIHZpZXdwb3J0IGNlbnRlciwgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAqICAgICBXaGVuIGB5ID09PSAwLjVgLCB0aGUgaW1hZ2UgaXMgY2VudGVyZWQgdmVydGljYWxseS5cbiAqICAgICBXaGVuIGB5ID09PSAwYCwgdGhlIHRvcCBlZGdlIG9mIHRoZSBpbWFnZSBpcyBhdCB0aGUgdmlld3BvcnQgY2VudGVyLlxuICogICAgIFdoZW4gYHkgPT09IDFgLCB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9vbSBUaGUgaG9yaXpvbnRhbCB6b29tLCBpbiB0aGUgWzAsIOKInikgcmFuZ2UuXG4gKiAgICAgV2hlbiBgem9vbSA9PT0gMWAsIHRoZSB2aWV3cG9ydCBpcyBhcyB3aWRlIGFzIHRoZSBpbWFnZS5cbiAqICAgICBXaGVuIGB6b29tIDwgMWAsIHRoZSBpbWFnZSBpcyB6b29tZWQgaW4uXG4gKiAgICAgV2hlbiBgem9vbSA+IDFgLCB0aGUgaW1hZ2UgaXMgem9vbWVkIG91dC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtZWRpYUFzcGVjdFJhdGlvIFRoZSBpbWFnZSBhc3BlY3QgcmF0aW8uXG4gKiAgICAgV2hlbiBgbWVkaWFBc3BlY3RSYXRpbyA9PT0gMWAsIHRoZSBpbWFnZSB3aWR0aCBlcXVhbHMgaXRzIGhlaWdodC5cbiAqICAgICBXaGVuIGBtZWRpYUFzcGVjdFJhdGlvIDwgMWAsIHRoZSBpbWFnZSB3aWR0aCBpcyBsZXNzIHRoYW4gaXRzIGhlaWdodC5cbiAqICAgICBXaGVuIGBtZWRpYUFzcGVjdFJhdGlvID4gMWAsIHRoZSBpbWFnZSBoZWlnaHQgaXMgbGVzcyB0aGFuIGl0cyB3aWR0aC5cbiAqL1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBGbGF0Vmlld0Nvb3Jkc1xuICpcbiAqIFRoZSBwb3NpdGlvbiBvZiBhIHBvaW50IGluIGEgZmxhdCBpbWFnZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLCBpbiB0aGUgWzAsIDFdIHJhbmdlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gRmxhdFZpZXdMaW1pdGVyXG4gKlxuICogVmlldyBsaW1pdGVyIGZvciBhIHtAbGluayBGbGF0Vmlld30uXG4gKlxuICogQSB2aWV3IGxpbWl0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEge0BsaW5rIEZsYXRWaWV3UGFyYW1zfSBvYmplY3QsXG4gKiBvcHRpb25hbGx5IG1vZGlmaWVzIGl0IGluIHBsYWNlLCBhbmQgcmV0dXJucyBpdC4gSXQgY2FuIGJlIHVzZWQgdG8gZW5mb3JjZVxuICogY29uc3RyYWludHMgb24gdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBTZWUge0BsaW5rIEZsYXRWaWV3LmxpbWl0fSBmb3IgY29tbW9ubHkgdXNlZCBsaW1pdGVycy4gVGhleSBtYXkgYmUgY29tcG9zZWRcbiAqIHRvZ2V0aGVyIG9yIHdpdGggdXNlci1kZWZpbmVkIGxpbWl0ZXJzIHdpdGgge0BsaW5rIHV0aWwuY29tcG9zZX0uXG4gKlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtGbGF0Vmlld1BhcmFtc31cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzIEZsYXRWaWV3XG4gKiBAaW1wbGVtZW50cyBWaWV3XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgVmlld30gaW1wbGVtZW50aW5nIGFuIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBmb3IgZmxhdCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtc30gcGFyYW1zIFRoZSBpbml0aWFsIHZpZXcgcGFyYW1ldGVycy4gVGhlXG4gKiAgICAgYG1lZGlhQXNwZWN0UmF0aW9gIHBhcmFtZXRlciBtdXN0IGFsd2F5cyBiZSBzZXQuIFRoZSBvdGhlciBwYXJhbWV0ZXJzXG4gKiAgICAgZGVmYXVsdCB0byBge3g6IDAuNSwgeTogMC41LCB6OiAxIH1gIGlmIHVuc3BlY2lmaWVkLlxuICogQHBhcmFtIHtGbGF0Vmlld0xpbWl0ZXI9fSBsaW1pdGVyIFRoZSB2aWV3IGxpbWl0ZXIuIElmIHVuc3BlY2lmaWVkLCBubyB2aWV3XG4gKiAgICAgbGltaXRpbmcgaXMgYXBwbGllZC4gU2VlIHtAbGluayBGbGF0Vmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWRcbiAqICAgICBsaW1pdGVycy5cbiAqL1xuZnVuY3Rpb24gRmxhdFZpZXcocGFyYW1zLCBsaW1pdGVyKSB7XG4gIC8vIFJlcXVpcmUgYW4gYXNwZWN0IHJhdGlvIHRvIGJlIHNwZWNpZmllZC5cbiAgaWYgKCEocGFyYW1zICYmIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvICE9IG51bGwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZWRpYUFzcGVjdFJhdGlvIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG5cbiAgLy8gVGhlIGluaXRpYWwgdmFsdWVzIGZvciB0aGUgdmlldyBwYXJhbWV0ZXJzLlxuICB0aGlzLl94ID0gcGFyYW1zICYmIHBhcmFtcy54ICE9IG51bGwgPyBwYXJhbXMueCA6IGRlZmF1bHRYO1xuICB0aGlzLl95ID0gcGFyYW1zICYmIHBhcmFtcy55ICE9IG51bGwgPyBwYXJhbXMueSA6IGRlZmF1bHRZO1xuICB0aGlzLl96b29tID0gcGFyYW1zICYmIHBhcmFtcy56b29tICE9IG51bGwgPyBwYXJhbXMuem9vbSA6IGRlZmF1bHRab29tO1xuICB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3dpZHRoID0gcGFyYW1zICYmIHBhcmFtcy53aWR0aCAhPSBudWxsID9cbiAgICBwYXJhbXMud2lkdGggOiBkZWZhdWx0V2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHBhcmFtcyAmJiBwYXJhbXMuaGVpZ2h0ICE9IG51bGwgP1xuICAgIHBhcmFtcy5oZWlnaHQgOiBkZWZhdWx0SGVpZ2h0O1xuXG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgdmlldyBsaW1pdGVyLlxuICB0aGlzLl9saW1pdGVyID0gbGltaXRlciB8fCBudWxsO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgcHJvamVjdGlvbiBtYXRyaXggYW5kIGl0cyBpbnZlcnNlLlxuICB0aGlzLl9wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgdGhpcy5faW52UHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIGxhc3QgY2FsY3VsYXRlZCB2aWV3IGZydXN0dW0uXG4gIHRoaXMuX2ZydXN0dW0gPSBbXG4gICAgMCwgLy8gdG9wXG4gICAgMCwgLy8gcmlnaHRcbiAgICAwLCAvLyBib3R0b21cbiAgICAwICAvLyBsZWZ0XG4gIF07XG5cbiAgLy8gV2hldGhlciB0aGUgcHJvamVjdGlvbiBtYXRyaWNlcyBhbmQgdmlldyBmcnVzdHVtIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gIC8vIFRlbXBvcmFyeSB2YXJpYWJsZXMgdXNlZCBmb3IgY2FsY3VsYXRpb25zLlxuICB0aGlzLl9wYXJhbXMgPSB7fTtcbiAgdGhpcy5fdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAvLyBGb3JjZSB2aWV3IGxpbWl0aW5nIG9uIGluaXRpYWwgcGFyYW1ldGVycy5cbiAgdGhpcy5fdXBkYXRlKCk7XG59XG5cbmV2ZW50RW1pdHRlcihGbGF0Vmlldyk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB4IHBhcmFtZXRlci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3g7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB5IHBhcmFtZXRlci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3k7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB6b29tIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fem9vbTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1lZGlhIGFzcGVjdCByYXRpby5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLm1lZGlhQXNwZWN0UmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCB3aWR0aC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoXG4gKiB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtTaXplPX0gc2l6ZVxuICogQHJldHVybiB7U2l6ZX1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHNpemUgPSBzaXplIHx8IHt9O1xuICBzaXplLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICByZXR1cm4gc2l6ZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZVxuICogcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtcz19IHBhcmFtc1xuICogQHJldHVybiB7RmxhdFZpZXdQYXJhbXN9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLnggPSB0aGlzLl94O1xuICBwYXJhbXMueSA9IHRoaXMuX3k7XG4gIHBhcmFtcy56b29tID0gdGhpcy5fem9vbTtcbiAgcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPSB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvO1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBsaW1pdGVyLCBvciBudWxsIGlmIHVuc2V0LlxuICogQHJldHVybiB7P0ZsYXRWaWV3TGltaXRlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmxpbWl0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbWl0ZXI7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB4IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMueCA9IHg7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uKHkpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnkgPSB5O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHpvb20gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnpvb20gPSB6b29tO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBBZGQgeE9mZnNldCB0byB0aGUgeCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geE9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0WCA9IGZ1bmN0aW9uKHhPZmZzZXQpIHtcbiAgdGhpcy5zZXRYKHRoaXMuX3ggKyB4T2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBBZGQgeU9mZnNldCB0byB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geU9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0WSA9IGZ1bmN0aW9uKHlPZmZzZXQpXG57XG4gIHRoaXMuc2V0WSh0aGlzLl95ICsgeU9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHpvb21PZmZzZXQgdG8gdGhlIHpvb20gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbU9mZnNldFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUub2Zmc2V0Wm9vbSA9IGZ1bmN0aW9uKHpvb21PZmZzZXQpIHtcbiAgdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyB6b29tT2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIG1lZGlhIGFzcGVjdCByYXRpby5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtZWRpYUFzcGVjdFJhdGlvXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRNZWRpYUFzcGVjdFJhdGlvID0gZnVuY3Rpb24obWVkaWFBc3BlY3RSYXRpbykge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA9IG1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgdGhpcy5fcGFyYW1zLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zcGVjaWZpZWQgcGFyYW1ldGVycyBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge0ZsYXRWaWV3UGFyYW1ldGVyc30gcGFyYW1zXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy54ID0gcGFyYW1zLng7XG4gIHRoaXMuX3BhcmFtcy55ID0gcGFyYW1zLnk7XG4gIHRoaXMuX3BhcmFtcy56b29tID0gcGFyYW1zLnpvb207XG4gIHRoaXMuX3BhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlldyBsaW1pdGVyLlxuICogQHBhcmFtIHs/RmxhdFZpZXdMaW1pdGVyfSBsaW1pdGVyIFRoZSBuZXcgbGltaXRlciwgb3IgbnVsbCB0byB1bnNldC5cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNldExpbWl0ZXIgPSBmdW5jdGlvbihsaW1pdGVyKSB7XG4gIHRoaXMuX2xpbWl0ZXIgPSBsaW1pdGVyIHx8IG51bGw7XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3Jlc2V0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIHBhcmFtcy54ID0gbnVsbDtcbiAgcGFyYW1zLnkgPSBudWxsO1xuICBwYXJhbXMuem9vbSA9IG51bGw7XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gbnVsbDtcbiAgcGFyYW1zLndpZHRoID0gbnVsbDtcbiAgcGFyYW1zLmhlaWdodCA9IG51bGw7XG59O1xuXG5cbkZsYXRWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgLy8gQXZvaWQgb2JqZWN0IGFsbG9jYXRpb24gd2hlbiBubyBwYXJhbWV0ZXJzIGFyZSBzdXBwbGllZC5cbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgICBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvLyBTYXZlIG9sZCBwYXJhbWV0ZXJzIGZvciBsYXRlciBjb21wYXJpc29uLlxuICB2YXIgb2xkWCA9IHRoaXMuX3g7XG4gIHZhciBvbGRZID0gdGhpcy5feTtcbiAgdmFyIG9sZFpvb20gPSB0aGlzLl96b29tO1xuICB2YXIgb2xkTWVkaWFBc3BlY3RSYXRpbyA9IHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG4gIHZhciBvbGRXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIEZpbGwgaW4gb2JqZWN0IHdpdGggdGhlIG5ldyBzZXQgb2YgcGFyYW1ldGVycyB0byBwYXNzIGludG8gdGhlIGxpbWl0ZXIuXG4gIHBhcmFtcy54ID0gcGFyYW1zLnggIT0gbnVsbCA/IHBhcmFtcy54IDogb2xkWDtcbiAgcGFyYW1zLnkgPSBwYXJhbXMueSAhPSBudWxsID8gcGFyYW1zLnkgOiBvbGRZO1xuICBwYXJhbXMuem9vbSA9IHBhcmFtcy56b29tICE9IG51bGwgPyBwYXJhbXMuem9vbSA6IG9sZFpvb207XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gIT0gbnVsbCA/XG4gICAgcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gOiBvbGRNZWRpYUFzcGVjdFJhdGlvO1xuICBwYXJhbXMud2lkdGggPSBwYXJhbXMud2lkdGggIT0gbnVsbCA/IHBhcmFtcy53aWR0aCA6IG9sZFdpZHRoO1xuICBwYXJhbXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCAhPSBudWxsID8gcGFyYW1zLmhlaWdodCA6IG9sZEhlaWdodDtcblxuICAvLyBBcHBseSB2aWV3IGxpbWl0aW5nIHdoZW4gZGVmaW5lZC5cbiAgaWYgKHRoaXMuX2xpbWl0ZXIpIHtcbiAgICBwYXJhbXMgPSB0aGlzLl9saW1pdGVyKHBhcmFtcyk7XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgbGltaXRlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdyYWIgdGhlIGxpbWl0ZWQgcGFyYW1ldGVycy5cbiAgdmFyIG5ld1ggPSBwYXJhbXMueDtcbiAgdmFyIG5ld1kgPSBwYXJhbXMueTtcbiAgdmFyIG5ld1pvb20gPSBwYXJhbXMuem9vbTtcbiAgdmFyIG5ld01lZGlhQXNwZWN0UmF0aW8gPSBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbztcbiAgdmFyIG5ld1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICB2YXIgbmV3SGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcblxuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKCFyZWFsKG5ld1gpIHx8ICFyZWFsKG5ld1kpIHx8ICFyZWFsKG5ld1pvb20pIHx8XG4gICAgICAhcmVhbChuZXdNZWRpYUFzcGVjdFJhdGlvKSB8fCAhcmVhbChuZXdXaWR0aCkgfHwgIXJlYWwobmV3SGVpZ2h0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIHZpZXcgLSBzdXNwZWN0IGEgYnJva2VuIGxpbWl0ZXInKTtcbiAgfVxuXG4gIC8vIENvbnN0cmFpbiB6b29tLlxuICBuZXdab29tID0gY2xhbXAobmV3Wm9vbSwgem9vbUxpbWl0RXBzaWxvbiwgSW5maW5pdHkpO1xuXG4gIC8vIFVwZGF0ZSBwYXJhbWV0ZXJzLlxuICB0aGlzLl94ID0gbmV3WDtcbiAgdGhpcy5feSA9IG5ld1k7XG4gIHRoaXMuX3pvb20gPSBuZXdab29tO1xuICB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvID0gbmV3TWVkaWFBc3BlY3RSYXRpbztcbiAgdGhpcy5fd2lkdGggPSBuZXdXaWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHBhcmFtZXRlcnMgY2hhbmdlZCBhbmQgZW1pdCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMuXG4gIGlmIChuZXdYICE9PSBvbGRYIHx8IG5ld1kgIT09IG9sZFkgfHwgbmV3Wm9vbSAhPT0gb2xkWm9vbSB8fFxuICAgICAgbmV3TWVkaWFBc3BlY3RSYXRpbyAhPT0gb2xkTWVkaWFBc3BlY3RSYXRpbyB8fFxuICAgICAgbmV3V2lkdGggIT09IG9sZFdpZHRoIHx8IG5ld0hlaWdodCAhPT0gb2xkSGVpZ2h0KSB7XG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbiAgaWYgKG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG4gIH1cblxufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3pvb21YID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl96b29tO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3pvb21ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtZWRpYUFzcGVjdFJhdGlvID0gdGhpcy5fbWVkaWFBc3BlY3RSYXRpbztcbiAgdmFyIGFzcGVjdCA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuICB2YXIgem9vbVggPSB0aGlzLl96b29tO1xuICB2YXIgem9vbVkgPSB6b29tWCAqIG1lZGlhQXNwZWN0UmF0aW8gLyBhc3BlY3Q7XG4gIGlmIChpc05hTih6b29tWSkpIHtcbiAgICB6b29tWSA9IHpvb21YO1xuICB9XG4gIHJldHVybiB6b29tWTtcbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLnVwZGF0ZVdpdGhDb250cm9sUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgdmFyIHNjYWxlID0gdGhpcy56b29tKCk7XG4gIHZhciB6b29tWCA9IHRoaXMuX3pvb21YKCk7XG4gIHZhciB6b29tWSA9IHRoaXMuX3pvb21ZKCk7XG5cbiAgLy8gVE9ETzogc2hvdWxkIHRoZSBzY2FsZSBiZSB0aGUgc2FtZSBmb3IgYm90aCBheGVzP1xuICB0aGlzLm9mZnNldFgocGFyYW1ldGVycy5heGlzU2NhbGVkWCAqIHpvb21YICsgcGFyYW1ldGVycy54ICogc2NhbGUpO1xuICB0aGlzLm9mZnNldFkocGFyYW1ldGVycy5heGlzU2NhbGVkWSAqIHpvb21ZICsgcGFyYW1ldGVycy55ICogc2NhbGUpO1xuICB0aGlzLm9mZnNldFpvb20ocGFyYW1ldGVycy56b29tICogc2NhbGUpO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3VwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByb2pNYXRyaXggPSB0aGlzLl9wcm9qTWF0cml4O1xuICB2YXIgaW52UHJvak1hdHJpeCA9IHRoaXMuX2ludlByb2pNYXRyaXg7XG4gIHZhciBmcnVzdHVtID0gdGhpcy5fZnJ1c3R1bTtcblxuICAvLyBSZWNhbGN1bGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aGVuIHJlcXVpcmVkLlxuICBpZiAodGhpcy5fcHJvamVjdGlvbkNoYW5nZWQpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3g7XG4gICAgdmFyIHkgPSB0aGlzLl95O1xuICAgIHZhciB6b29tWCA9IHRoaXMuX3pvb21YKCk7XG4gICAgdmFyIHpvb21ZID0gdGhpcy5fem9vbVkoKTtcblxuICAgIC8vIFJlY2FsY3VsYXRlIHZpZXcgZnJ1c3R1bS5cbiAgICB2YXIgdG9wICAgICA9IGZydXN0dW1bMF0gPSAoMC41IC0geSkgKyAwLjUgKiB6b29tWTtcbiAgICB2YXIgcmlnaHQgICA9IGZydXN0dW1bMV0gPSAoeCAtIDAuNSkgKyAwLjUgKiB6b29tWDtcbiAgICB2YXIgYm90dG9tICA9IGZydXN0dW1bMl0gPSAoMC41IC0geSkgLSAwLjUgKiB6b29tWTtcbiAgICB2YXIgbGVmdCAgICA9IGZydXN0dW1bM10gPSAoeCAtIDAuNSkgLSAwLjUgKiB6b29tWDtcblxuICAgIC8vIFJlY2FsY3VsYXRlIHByb2plY3Rpb24gbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgICBtYXQ0Lm9ydGhvKHByb2pNYXRyaXgsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgLTEsIDEpO1xuICAgIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIHByb2pNYXRyaXgpO1xuXG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZVByb2plY3Rpb24oKTtcbiAgcmV0dXJuIHRoaXMuX3Byb2pNYXRyaXg7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEByZXR1cm5zIHttYXQ0fVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuaW52ZXJzZVByb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdXBkYXRlUHJvamVjdGlvbigpO1xuICByZXR1cm4gdGhpcy5faW52UHJvak1hdHJpeDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgdmlldyBmcnVzdHVtIGludGVyc2VjdHMgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1heSByZXR1cm4gZmFsc2UgcG9zaXRpdmVzLCBidXQgbmV2ZXIgZmFsc2UgbmVnYXRpdmVzLlxuICogSXQgaXMgdXNlZCBmb3IgZnJ1c3R1bSBjdWxsaW5nLCBpLmUuLCBleGNsdWRpbmcgaW52aXNpYmxlIHRpbGVzIGZyb20gdGhlXG4gKiByZW5kZXJpbmcgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzNbXX0gcmVjdGFuZ2xlIFRoZSB2ZXJ0aWNlcyBvZiB0aGUgcmVjdGFuZ2xlLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG5cbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiBhbnkgb2YgdGhlIGZydXN0dW1cbiAgLy8gcGxhbmVzLiBUaGlzIGlzIGEgc3VmZmljaWVudCBjb25kaXRpb24sIHRob3VnaCBub3QgbmVjZXNzYXJ5LCBmb3IgdGhlXG4gIC8vIHJlY3RhbmdsZSB0byBiZSBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIGZydW91dGVyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJ1c3R1bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW1pdCA9IGZydXN0dW1baV07XG4gICAgdmFyIGF4aXMgPSBwbGFuZUF4ZXNbaV07XG4gICAgdmFyIGNtcCA9IHBsYW5lQ21wW2ldO1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY3RhbmdsZS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHZlcnRleCA9IHJlY3RhbmdsZVtqXTtcbiAgICAgIGlmIChjbXAgPCAwICYmIHZlcnRleFtheGlzXSA8IGxpbWl0IHx8IGNtcCA+IDAgJiYgdmVydGV4W2F4aXNdID4gbGltaXQpIHtcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdCB0aGUgbGV2ZWwgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge0xldmVsW119IGxldmVsTGlzdCB0aGUgbGlzdCBvZiBsZXZlbHMgZnJvbSB3aGljaCB0byBzZWxlY3QuXG4gKiBAcmV0dXJuIHtMZXZlbH0gdGhlIHNlbGVjdGVkIGxldmVsLlxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2VsZWN0TGV2ZWwgPSBmdW5jdGlvbihsZXZlbHMpIHtcblxuICAvLyBNdWx0aXBseSB0aGUgdmlld3BvcnQgd2lkdGggYnkgdGhlIGRldmljZSBwaXhlbCByYXRpbyB0byBnZXQgdGhlIHJlcXVpcmVkXG4gIC8vIGhvcml6b250YWwgcmVzb2x1dGlvbiBpbiBwaXhlbHMuXG4gIC8vXG4gIC8vIENhbGN1bGF0ZSB0aGUgZnJhY3Rpb24gb2YgdGhlIGltYWdlIHRoYXQgd291bGQgYmUgdmlzaWJsZSBhdCB0aGUgY3VycmVudFxuICAvLyB6b29tIHZhbHVlLiBUaGVuLCBmb3IgZWFjaCBsZXZlbCwgbXVsdGlwbHkgYnkgdGhlIGxldmVsIHdpZHRoIHRvIGdldCB0aGVcbiAgLy8gd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBwb3J0aW9uIHRoYXQgd291bGQgYmUgdmlzaWJsZS5cbiAgLy9cbiAgLy8gU2VhcmNoIGZvciB0aGUgc21hbGxlc3QgbGV2ZWwgdGhhdCBzYXRpZmllcyB0aGUgdGhlIHJlcXVpcmVkIHdpZHRoLFxuICAvLyBmYWxsaW5nIGJhY2sgb24gdGhlIGxhcmdlc3QgbGV2ZWwgaWYgbm9uZSBkby5cblxuICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiB0aGlzLndpZHRoKCk7XG4gIHZhciB6b29tRmFjdG9yID0gdGhpcy5fem9vbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICBpZiAoem9vbUZhY3RvciAqIGxldmVsLndpZHRoKCkgPj0gcmVxdWlyZWRQaXhlbHMpIHtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV2ZWxzW2xldmVscy5sZW5ndGggLSAxXTtcblxufTtcblxuXG4vKipcbiAqIENvbnZlcnQgdmlldyBjb29yZGluYXRlcyBpbnRvIHNjcmVlbiBjb29yZGluYXRlcy4gSWYgYSByZXN1bHQgYXJndW1lbnQgaXNcbiAqIHByb3ZpZGVkLCBpdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZFxuICogaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7RmxhdFZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Q29vcmRzPX0gcmVzdWx0IFRoZSByZXN1bHQgYXJndW1lbnQgZm9yIHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtDb29yZHN9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlc1RvU2NyZWVuID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3ZlYztcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9XG5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgLy8gVW5kZWZpbmVkIG9uIGEgbnVsbCB2aWV3cG9ydC5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXN1bHQueCA9IG51bGw7XG4gICAgcmVzdWx0LnkgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRXh0cmFjdCBjb29yZGluYXRlcyBmcm9tIGFyZ3VtZW50LCBmaWxsaW5nIGluIGRlZmF1bHQgdmFsdWVzLlxuICB2YXIgeCA9IGNvb3JkcyAmJiBjb29yZHMueCAhPSBudWxsID8gY29vcmRzLnggOiBkZWZhdWx0WDtcbiAgdmFyIHkgPSBjb29yZHMgJiYgY29vcmRzLnkgIT0gbnVsbCA/IGNvb3Jkcy55IDogZGVmYXVsdFk7XG5cbiAgLy8gUHJvamVjdCB2aWV3IHJheSBvbnRvIGNsaXAgc3BhY2UuXG4gIHZlYzQuc2V0KHJheSwgeCAtIDAuNSwgMC41IC0geSwgLTEsIDEpO1xuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMucHJvamVjdGlvbigpKTtcblxuICAvLyBDYWxjdWxhdGUgcGVyc3BlY3RpdmUgZGl2aWRlLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJheVtpXSAvPSByYXlbM107XG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGFuZCByZXR1cm4uXG4gIHJlc3VsdC54ID0gd2lkdGggKiAocmF5WzBdICsgMSkgLyAyO1xuICByZXN1bHQueSA9IGhlaWdodCAqICgxIC0gcmF5WzFdKSAvIDI7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHNjcmVlbiBjb29yZGluYXRlcyBpbnRvIHZpZXcgY29vcmRpbmF0ZXMuIElmIGEgcmVzdWx0IGFyZ3VtZW50IGlzXG4gKiBwcm92aWRlZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaFxuICogb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtDb29yZHN9IGNvb3JkcyBUaGUgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtGbGF0Vmlld0Nvb3Jkcz19IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0ZsYXRWaWV3Q29vcmRzfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2NyZWVuVG9Db29yZGluYXRlcyA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIENvbnZlcnQgdmlld3BvcnQgY29vcmRpbmF0ZXMgdG8gY2xpcCBzcGFjZS5cbiAgdmFyIHZlY3ggPSAyICogY29vcmRzLnggLyB3aWR0aCAtIDE7XG4gIHZhciB2ZWN5ID0gMSAtIDIgKiBjb29yZHMueSAvIGhlaWdodDtcbiAgdmVjNC5zZXQocmF5LCB2ZWN4LCB2ZWN5LCAxLCAxKTtcblxuICAvLyBQcm9qZWN0IGJhY2sgdG8gd29ybGQgc3BhY2UuXG4gIHZlYzQudHJhbnNmb3JtTWF0NChyYXksIHJheSwgdGhpcy5pbnZlcnNlUHJvamVjdGlvbigpKTtcblxuICAvLyBDb252ZXJ0IHRvIGZsYXQgY29vcmRpbmF0ZXMuXG4gIHJlc3VsdC54ID0gMC41ICsgcmF5WzBdO1xuICByZXN1bHQueSA9IDAuNSAtIHJheVsxXTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb25zIGZvciB2aWV3IGxpbWl0ZXJzLiBTZWUge0BsaW5rIEZsYXRWaWV3TGltaXRlcn0uXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkZsYXRWaWV3LmxpbWl0ID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgeCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0geCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB5IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB4OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFgocGFyYW1zKSB7XG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHkgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgeTogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRZKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnkgPSBjbGFtcChwYXJhbXMueSwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYW4gY29uc3RyYWlucyB0aGUgem9vbSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gem9vbSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB6b29tIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB6b29tOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFpvb20ocGFyYW1zKSB7XG4gICAgICBwYXJhbXMuem9vbSA9IGNsYW1wKHBhcmFtcy56b29tLCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBwcmV2ZW50cyB6b29taW5nIGluIGJleW9uZCB0aGUgZ2l2ZW5cbiAgICogcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIGltYWdlIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcmVzb2x1dGlvbjogZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFJlc29sdXRpb24ocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zLndpZHRoIDw9IDAgfHwgcGFyYW1zLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICB9XG4gICAgICB2YXIgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICB2YXIgbWluWm9vbSA9IHBpeGVsUmF0aW8oKSAqIHdpZHRoIC8gc2l6ZTtcbiAgICAgIHBhcmFtcy56b29tID0gY2xhbXAocGFyYW1zLnpvb20sIG1pblpvb20sIEluZmluaXR5KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHZhbHVlcyBvZiB0aGUgeCBwYXJhbWV0ZXIgdGhhdFxuICAgKiBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB4IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHggdmFsdWUuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIHZpc2libGVYOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFZpc2libGVYKHBhcmFtcykge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB6b29tIHZhbHVlIHRoYXQgbWFrZXMgdGhlIHNwZWNpZmllZCByYW5nZSBmdWxseSB2aXNpYmxlLlxuICAgICAgdmFyIG1heFpvb20gPSBtYXggLSBtaW47XG5cbiAgICAgIC8vIENsYW1wIHpvb20gdG8gdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICBpZiAocGFyYW1zLnpvb20gPiBtYXhab29tKSB7XG4gICAgICAgIHBhcmFtcy56b29tID0gbWF4Wm9vbTtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgWCBzdWNoIHRoYXQgdGhlIGltYWdlIGlzIHZpc2libGUgdXAgdG8gdGhlIHJhbmdlIGVkZ2VzLlxuICAgICAgdmFyIG1pblggPSBtaW4gKyAwLjUgKiBwYXJhbXMuem9vbTtcbiAgICAgIHZhciBtYXhYID0gbWF4IC0gMC41ICogcGFyYW1zLnpvb207XG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW5YLCBtYXhYKTtcblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgdmFsdWVzIG9mIHRoZSB5IHBhcmFtZXRlciB0aGF0XG4gICAqIGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgdmlzaWJsZVk6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0VmlzaWJsZVkocGFyYW1zKSB7XG5cbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGEgbnVsbCB2aWV3cG9ydC5cbiAgICAgIGlmIChwYXJhbXMud2lkdGggPD0gMCB8fCBwYXJhbXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBYIHRvIFkgY29udmVyc2lvbiBmYWN0b3IuXG4gICAgICB2YXIgdmlld3BvcnRBc3BlY3RSYXRpbyA9IHBhcmFtcy53aWR0aCAvIHBhcmFtcy5oZWlnaHQ7XG4gICAgICB2YXIgZmFjdG9yID0gdmlld3BvcnRBc3BlY3RSYXRpbyAvIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHpvb20gdmFsdWUgdGhhdCBtYWtlcyB0aGUgc3BlY2lmaWVkIHJhbmdlIGZ1bGx5IHZpc2libGUuXG4gICAgICB2YXIgbWF4Wm9vbSA9IChtYXggLSBtaW4pICogZmFjdG9yO1xuXG4gICAgICAvLyBDbGFtcCB6b29tIHRvIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAgaWYgKHBhcmFtcy56b29tID4gbWF4Wm9vbSkge1xuICAgICAgICBwYXJhbXMuem9vbSA9IG1heFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIFkgc3VjaCB0aGF0IHRoZSBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSByYW5nZSBlZGdlcy5cbiAgICAgIHZhciBtaW5ZID0gbWluICsgMC41ICogcGFyYW1zLnpvb20gLyBmYWN0b3I7XG4gICAgICB2YXIgbWF4WSA9IG1heCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZmFjdG9yO1xuICAgICAgcGFyYW1zLnkgPSBjbGFtcChwYXJhbXMueSwgbWluWSwgbWF4WSk7XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgem9vbSBwYXJhbWV0ZXIgc3VjaCB0aGF0XG4gICAqIHpvb21pbmcgb3V0IGlzIHByZXZlbnRlZCBiZXlvbmQgdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBpbWFnZSBpcyBmdWxseVxuICAgKiB2aXNpYmxlLiBVbmxlc3MgdGhlIGltYWdlIGFuZCB0aGUgdmlld3BvcnQgaGF2ZSB0aGUgc2FtZSBhc3BlY3QgcmF0aW8sXG4gICAqIHRoaXMgd2lsbCBjYXVzZSBiYW5kcyB0byBhcHBlYXIgYXJvdW5kIHRoZSBpbWFnZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgbGV0dGVyYm94OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRMZXR0ZXJib3gocGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMud2lkdGggPD0gMCB8fCBwYXJhbXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3cG9ydEFzcGVjdFJhdGlvID0gcGFyYW1zLndpZHRoIC8gcGFyYW1zLmhlaWdodDtcblxuICAgICAgdmFyIGZ1bGxXaWR0aFpvb20gPSAxLjA7XG4gICAgICB2YXIgZnVsbEhlaWdodFpvb20gPSB2aWV3cG9ydEFzcGVjdFJhdGlvIC8gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG5cbiAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyB3aWRlciB0aGFuIHRoZSB2aWV3cG9ydCwgbGltaXQgdGhlIGhvcml6b250YWwgem9vbSB0b1xuICAgICAgLy8gdGhlIGltYWdlIHdpZHRoLlxuICAgICAgaWYgKHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID49IHZpZXdwb3J0QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgcGFyYW1zLnpvb20gPSBNYXRoLm1pbihwYXJhbXMuem9vbSwgZnVsbFdpZHRoWm9vbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyBuYXJyb3dlciB0aGFuIHRoZSB2aWV3cG9ydCwgbGltaXQgdGhlIHZlcnRpY2FsIHpvb20gdG9cbiAgICAgIC8vIHRoZSBpbWFnZSBoZWlnaHQuXG4gICAgICBpZiAocGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPD0gdmlld3BvcnRBc3BlY3RSYXRpbykge1xuICAgICAgICBwYXJhbXMuem9vbSA9IE1hdGgubWluKHBhcmFtcy56b29tLCBmdWxsSGVpZ2h0Wm9vbSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmdWxsIGltYWdlIHdpZHRoIGlzIHZpc2libGUsIGxpbWl0IHggdG8gdGhlIGNlbnRyYWwgcG9pbnQuXG4gICAgICAvLyBFbHNlLCBib3VuZCB4IHN1Y2ggdGhhdCBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSBob3Jpem9udGFsIGVkZ2VzLlxuICAgICAgdmFyIG1pblgsIG1heFg7XG4gICAgICBpZiAocGFyYW1zLnpvb20gPiBmdWxsV2lkdGhab29tKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluWCA9IDAuMCArIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbFdpZHRoWm9vbTtcbiAgICAgICAgbWF4WCA9IDEuMCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbFdpZHRoWm9vbTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZ1bGwgaW1hZ2UgaGVpZ2h0IGlzIHZpc2libGUsIGxpbWl0IHkgdG8gdGhlIGNlbnRyYWwgcG9pbnQuXG4gICAgICAvLyBFbHNlLCBib3VuZCB5IHN1Y2ggdGhhdCBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSB2ZXJ0aWNhbCBlZGdlcy5cbiAgICAgIHZhciBtaW5ZLCBtYXhZO1xuICAgICAgaWYgKHBhcmFtcy56b29tID4gZnVsbEhlaWdodFpvb20pIHtcbiAgICAgICAgbWluWSA9IG1heFkgPSAwLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5ZID0gMC4wICsgMC41ICogcGFyYW1zLnpvb20gLyBmdWxsSGVpZ2h0Wm9vbTtcbiAgICAgICAgbWF4WSA9IDEuMCAtIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbEhlaWdodFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIENsYW1wIHggYW5kIHkgaW50byB0aGUgY2FsY3VsYXRlZCBib3VuZHMuXG4gICAgICBwYXJhbXMueCA9IGNsYW1wKHBhcmFtcy54LCBtaW5YLCBtYXhYKTtcbiAgICAgIHBhcmFtcy55ID0gY2xhbXAocGFyYW1zLnksIG1pblksIG1heFkpO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH1cblxufTtcblxuXG5GbGF0Vmlldy50eXBlID0gRmxhdFZpZXcucHJvdG90eXBlLnR5cGUgPSAnZmxhdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGbGF0VmlldztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0O1xudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcbnZhciBjb252ZXJ0Rm92ID0gcmVxdWlyZSgnLi4vdXRpbC9jb252ZXJ0Rm92Jyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcbnZhciByZWFsID0gcmVxdWlyZSgnLi4vdXRpbC9yZWFsJyk7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgZGVjaW1hbCA9IHJlcXVpcmUoJy4uL3V0aWwvZGVjaW1hbCcpO1xudmFyIGNvbXBvc2UgPSByZXF1aXJlKCcuLi91dGlsL2NvbXBvc2UnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBEZWZhdWx0IHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4vLyBTdGFydCB3aXRoIHplcm8gdG8gZW5zdXJlIHRoYXQgdGhvc2UgdmFsdWVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbnZhciBkZWZhdWx0V2lkdGggPSAwO1xudmFyIGRlZmF1bHRIZWlnaHQgPSAwO1xuXG4vLyBEZWZhdWx0IHZpZXcgcGFyYW1ldGVycy5cbnZhciBkZWZhdWx0WWF3ID0gMDtcbnZhciBkZWZhdWx0UGl0Y2ggPSAwO1xudmFyIGRlZmF1bHRSb2xsID0gMDtcbnZhciBkZWZhdWx0Rm92ID0gTWF0aC5QSS80O1xudmFyIGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWCA9IDA7XG52YXIgZGVmYXVsdFByb2plY3Rpb25DZW50ZXJZID0gMDtcblxuLy8gQSBmb3Ygb2YgZXhhY3RseSAwIG9yIM+AIGJyZWFrcyBzb21lIGNvbXB1dGF0aW9ucywgc28gd2UgY29uc3RyYWluIGl0IHRvIHRoZVxuLy8gW2ZvdkxpbWl0RXBzaWxvbiwgz4AgLSBmb3ZMaW1pdEVwc2lsb25dIGludGVydmFsLiBXZSB1c2UgNiBkZWNpbWFsIHBsYWNlcyBmb3Jcbi8vIHRoZSBlcHNpbG9uIHZhbHVlIHRvIGF2b2lkIGJyb2tlbiByZW5kZXJpbmcgZHVlIHRvIGxvc3Mgb2YgcHJlY2lzaW9uIGluXG4vLyBmbG9hdGluZyBwb2ludCBjb21wdXRhdGlvbnMuXG52YXIgZm92TGltaXRFcHNpbG9uID0gMC4wMDAwMDE7XG5cblxuLyoqXG4gKiBAaW50ZXJmYWNlIFJlY3RpbGluZWFyVmlld1BhcmFtc1xuICpcbiAqIEEgY2FtZXJhIGNvbmZpZ3VyYXRpb24gZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHlhdyBUaGUgeWF3IGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICogICAgIFdoZW4gYHlhdyA8IDBgLCB0aGUgdmlldyByb3RhdGVzIHRvIHRoZSBsZWZ0LlxuICogICAgIFdoZW4gYHlhdyA+IDBgLCB0aGUgdmlldyByb3RhdGVzIHRvIHRoZSByaWdodC5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl0Y2ggVGhlIHBpdGNoIGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICogICAgIFdoZW4gYHBpdGNoIDwgMGAsIHRoZSB2aWV3IHJvdGF0ZXMgZG93bndhcmRzLlxuICogICAgIFdoZW4gYHBpdGNoID4gMGAsIHRoZSB2aWV3IHJvdGF0ZXMgdXB3YXJkcy5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm9sbCBUaGUgcm9sbCBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqICAgICBXaGVuIGByb2xsIDwgMGAsIHRoZSB2aWV3IHJvdGF0ZXMgY2xvY2t3aXNlLlxuICogICAgIFdoZW4gYHJvbGwgPiAwYCwgdGhlIHZpZXcgcm90YXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqXG4gKiBAcHJvcGVydHkge2Zvdn0gZm92IFRoZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LCBpbiB0aGUgWzAsIM+AXSByYW5nZS5cbiAqL1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBSZWN0aWxpbmVhclZpZXdDb29yZHNcbiAqXG4gKiBUaGUgcG9zaXRpb24gb2YgYSBwb2ludCBpbiBhIDM2MMKwIGltYWdlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5YXcgVGhlIHlhdyBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXRjaCBUaGUgcGl0Y2ggYW5nbGUsIGluIHRoZSBbLc+ALCDPgF0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gUmVjdGlsaW5lYXJWaWV3TGltaXRlclxuICpcbiAqIFZpZXcgbGltaXRlciBmb3IgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3fS5cbiAqXG4gKiBBIHZpZXcgbGltaXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3UGFyYW1zfVxuICogb2JqZWN0LCBvcHRpb25hbGx5IG1vZGlmaWVzIGl0IGluIHBsYWNlLCBhbmQgcmV0dXJucyBpdC4gSXQgY2FuIGJlIHVzZWQgdG9cbiAqIGVuZm9yY2UgY29uc3RyYWludHMgb24gdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBTZWUge0BsaW5rIFJlY3RpbGluZWFyVmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWQgbGltaXRlcnMuIFRoZXkgbWF5IGJlXG4gKiBjb21wb3NlZCB0b2dldGhlciBvciB3aXRoIHVzZXItZGVmaW5lZCBsaW1pdGVycyB3aXRoIHtAbGluayB1dGlsLmNvbXBvc2V9LlxuICpcbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zfSBwYXJhbXNcbiAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld1BhcmFtc31cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBSZWN0aWxpbmVhclZpZXdcbiAqIEBpbXBsZW1lbnRzIFZpZXdcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBWaWV3fSBpbXBsZW1lbnRpbmcgYSByZWN0aWxpbmVhciBwcm9qZWN0aW9uIGZvciAzNjDCsCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdQYXJhbXM9fSBwYXJhbXMgVGhlIGluaXRpYWwgdmlldyBwYXJhbWV0ZXJzLiBJZlxuICogICAgIHVuc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBge3lhdzogMCwgcGl0Y2g6IDAsIHJvbGw6IDAsIGZvdjogTWF0aC5QSS80IH1gLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyPX0gbGltaXRlciBUaGUgdmlldyBsaW1pdGVyLiBJZiB1bnNwZWNpZmllZCxcbiAqICAgICBubyB2aWV3IGxpbWl0aW5nIGlzIGFwcGxpZWQuIFNlZSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3LmxpbWl0fSBmb3JcbiAqICAgICBjb21tb25seSB1c2VkIGxpbWl0ZXJzLlxuICovXG5mdW5jdGlvbiBSZWN0aWxpbmVhclZpZXcocGFyYW1zLCBsaW1pdGVyKSB7XG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAgdGhpcy5feWF3ID0gcGFyYW1zICYmIHBhcmFtcy55YXcgIT0gbnVsbCA/IHBhcmFtcy55YXcgOiBkZWZhdWx0WWF3O1xuICB0aGlzLl9waXRjaCA9IHBhcmFtcyAmJiBwYXJhbXMucGl0Y2ggIT0gbnVsbCA/IHBhcmFtcy5waXRjaCA6IGRlZmF1bHRQaXRjaDtcbiAgdGhpcy5fcm9sbCA9IHBhcmFtcyAmJiBwYXJhbXMucm9sbCAhPSBudWxsID8gcGFyYW1zLnJvbGwgOiBkZWZhdWx0Um9sbDtcbiAgdGhpcy5fZm92ID0gcGFyYW1zICYmIHBhcmFtcy5mb3YgIT0gbnVsbCA/IHBhcmFtcy5mb3YgOiBkZWZhdWx0Rm92O1xuICB0aGlzLl93aWR0aCA9IHBhcmFtcyAmJiBwYXJhbXMud2lkdGggIT0gbnVsbCA/XG4gICAgcGFyYW1zLndpZHRoIDogZGVmYXVsdFdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBwYXJhbXMgJiYgcGFyYW1zLmhlaWdodCAhPSBudWxsID9cbiAgICBwYXJhbXMuaGVpZ2h0IDogZGVmYXVsdEhlaWdodDtcbiAgdGhpcy5fcHJvamVjdGlvbkNlbnRlclggPSBwYXJhbXMgJiYgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA6IGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fcHJvamVjdGlvbkNlbnRlclkgPSBwYXJhbXMgJiYgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA6IGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWTtcblxuICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHZpZXcgbGltaXRlci5cbiAgdGhpcy5fbGltaXRlciA9IGxpbWl0ZXIgfHwgbnVsbDtcblxuICAvLyBUaGUgbGFzdCBjYWxjdWxhdGVkIHByb2plY3Rpb24gbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgdGhpcy5fcHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIHRoaXMuX2ludlByb2pNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgdmlldyBmcnVzdHVtLlxuICB0aGlzLl9mcnVzdHVtID0gW1xuICAgIHZlYzQuY3JlYXRlKCksIC8vIGxlZnRcbiAgICB2ZWM0LmNyZWF0ZSgpLCAvLyByaWdodFxuICAgIHZlYzQuY3JlYXRlKCksIC8vIGJvdHRvbVxuICAgIHZlYzQuY3JlYXRlKCksIC8vIHRvcFxuICAgIHZlYzQuY3JlYXRlKCkgIC8vIGNhbWVyYVxuICBdO1xuXG4gIC8vIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gbWF0cmljZXMgYW5kIHRoZSB2aWV3IGZydXN0dW0gbmVlZCB0byBiZSB1cGRhdGVkLlxuICB0aGlzLl9wcm9qZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG5cbiAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlcyB1c2VkIGZvciBjYWxjdWxhdGlvbnMuXG4gIHRoaXMuX3BhcmFtcyA9IHt9O1xuICB0aGlzLl9mb3ZzID0ge307XG4gIHRoaXMuX3RtcFZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgLy8gRm9yY2UgdmlldyBsaW1pdGluZyBvbiBpbml0aWFsIHBhcmFtZXRlcnMuXG4gIHRoaXMuX3VwZGF0ZSgpO1xufVxuXG5ldmVudEVtaXR0ZXIoUmVjdGlsaW5lYXJWaWV3KTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB5YXcgYW5nbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUueWF3ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl95YXc7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBwaXRjaCBhbmdsZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5waXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGl0Y2g7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSByb2xsIGFuZ2xlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnJvbGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JvbGw7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbkNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnByb2plY3Rpb25DZW50ZXJZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGZvdiB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5mb3YgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Zvdjtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IHdpZHRoLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U2l6ZT19IHNpemVcbiAqIEByZXR1cm4ge1NpemV9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgc2l6ZSA9IHNpemUgfHwge307XG4gIHNpemUud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgc2l6ZS5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gIHJldHVybiBzaXplO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBwYXJhbWV0ZXJzLiBJZiBhbiBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlXG4gKiByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld1BhcmFtcz19IG9ialxuICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMueWF3ID0gdGhpcy5feWF3O1xuICBwYXJhbXMucGl0Y2ggPSB0aGlzLl9waXRjaDtcbiAgcGFyYW1zLnJvbGwgPSB0aGlzLl9yb2xsO1xuICBwYXJhbXMuZm92ID0gdGhpcy5fZm92O1xuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlldyBsaW1pdGVyLCBvciBudWxsIGlmIHVuc2V0LlxuICogQHJldHVybiB7P1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUubGltaXRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGltaXRlcjtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHlhdyBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5YXdcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRZYXcgPSBmdW5jdGlvbih5YXcpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnlhdyA9IHlhdztcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBwaXRjaCBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFBpdGNoID0gZnVuY3Rpb24ocGl0Y2gpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnBpdGNoID0gcGl0Y2g7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcm9sbCBhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb2xsXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0Um9sbCA9IGZ1bmN0aW9uKHJvbGwpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnJvbGwgPSByb2xsO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGZvdiB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRGb3YgPSBmdW5jdGlvbihmb3YpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLmZvdiA9IGZvdjtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UHJvamVjdGlvbkNlbnRlclggPSBmdW5jdGlvbihwcm9qZWN0aW9uQ2VudGVyWCkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclggPSBwcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UHJvamVjdGlvbkNlbnRlclkgPSBmdW5jdGlvbihwcm9qZWN0aW9uQ2VudGVyWSkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclkgPSBwcm9qZWN0aW9uQ2VudGVyWTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogQWRkIHlhd09mZnNldCB0byB0aGUgY3VycmVudCB5YXcgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0geWF3T2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0WWF3ID0gZnVuY3Rpb24oeWF3T2Zmc2V0KSB7XG4gIHRoaXMuc2V0WWF3KHRoaXMuX3lhdyArIHlhd09mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHBpdGNoT2Zmc2V0IHRvIHRoZSBjdXJyZW50IHBpdGNoIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoT2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0UGl0Y2ggPSBmdW5jdGlvbihwaXRjaE9mZnNldCkge1xuICB0aGlzLnNldFBpdGNoKHRoaXMuX3BpdGNoICsgcGl0Y2hPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZCByb2xsT2Zmc2V0IHRvIHRoZSBjdXJyZW50IHJvbGwgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gcm9sbE9mZnNldFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm9mZnNldFJvbGwgPSBmdW5jdGlvbihyb2xsT2Zmc2V0KSB7XG4gIHRoaXMuc2V0Um9sbCh0aGlzLl9yb2xsICsgcm9sbE9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIGZvdk9mZnNldCB0byB0aGUgY3VycmVudCBmb3YgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZm92T2Zmc2V0XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub2Zmc2V0Rm92ID0gZnVuY3Rpb24oZm92T2Zmc2V0KSB7XG4gIHRoaXMuc2V0Rm92KHRoaXMuX2ZvdiArIGZvdk9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtTaXplfSBzaXplXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgdGhpcy5fcGFyYW1zLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gVW5zcGVjaWZpZWQgcGFyYW1ldGVycyBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld1BhcmFtZXRlcnN9IHBhcmFtc1xuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnlhdyA9IHBhcmFtcy55YXc7XG4gIHRoaXMuX3BhcmFtcy5waXRjaCA9IHBhcmFtcy5waXRjaDtcbiAgdGhpcy5fcGFyYW1zLnJvbGwgPSBwYXJhbXMucm9sbDtcbiAgdGhpcy5fcGFyYW1zLmZvdiA9IHBhcmFtcy5mb3Y7XG4gIHRoaXMuX3BhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWDtcbiAgdGhpcy5fcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgbGltaXRlci5cbiAqIEBwYXJhbSB7P1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9IGxpbWl0ZXIgVGhlIG5ldyBsaW1pdGVyLCBvciBudWxsIHRvIHVuc2V0LlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldExpbWl0ZXIgPSBmdW5jdGlvbihsaW1pdGVyKSB7XG4gIHRoaXMuX2xpbWl0ZXIgPSBsaW1pdGVyIHx8IG51bGw7XG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9yZXNldFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICBwYXJhbXMueWF3ID0gbnVsbDtcbiAgcGFyYW1zLnBpdGNoID0gbnVsbDtcbiAgcGFyYW1zLnJvbGwgPSBudWxsO1xuICBwYXJhbXMuZm92ID0gbnVsbDtcbiAgcGFyYW1zLndpZHRoID0gbnVsbDtcbiAgcGFyYW1zLmhlaWdodCA9IG51bGw7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gIC8vIEF2b2lkIG9iamVjdCBhbGxvY2F0aW9uIHdoZW4gbm8gcGFyYW1ldGVycyBhcmUgc3VwcGxpZWQuXG4gIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gICAgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICB9XG5cbiAgLy8gU2F2ZSBvbGQgcGFyYW1ldGVycyBmb3IgbGF0ZXIgY29tcGFyaXNvbi5cbiAgdmFyIG9sZFlhdyA9IHRoaXMuX3lhdztcbiAgdmFyIG9sZFBpdGNoID0gdGhpcy5fcGl0Y2g7XG4gIHZhciBvbGRSb2xsID0gdGhpcy5fcm9sbDtcbiAgdmFyIG9sZEZvdiA9IHRoaXMuX2ZvdjtcbiAgdmFyIG9sZFByb2plY3Rpb25DZW50ZXJYID0gdGhpcy5fcHJvamVjdGlvbkNlbnRlclg7XG4gIHZhciBvbGRQcm9qZWN0aW9uQ2VudGVyWSA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZO1xuICB2YXIgb2xkV2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIG9sZEhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBGaWxsIGluIG9iamVjdCB3aXRoIHRoZSBuZXcgc2V0IG9mIHBhcmFtZXRlcnMgdG8gcGFzcyBpbnRvIHRoZSBsaW1pdGVyLlxuICBwYXJhbXMueWF3ID0gcGFyYW1zLnlhdyAhPSBudWxsID8gcGFyYW1zLnlhdyA6IG9sZFlhdztcbiAgcGFyYW1zLnBpdGNoID0gcGFyYW1zLnBpdGNoICE9IG51bGwgPyBwYXJhbXMucGl0Y2ggOiBvbGRQaXRjaDtcbiAgcGFyYW1zLnJvbGwgPSBwYXJhbXMucm9sbCAhPSBudWxsID8gcGFyYW1zLnJvbGwgOiBvbGRSb2xsO1xuICBwYXJhbXMuZm92ID0gcGFyYW1zLmZvdiAhPSBudWxsID8gcGFyYW1zLmZvdiA6IG9sZEZvdjtcbiAgcGFyYW1zLndpZHRoID0gcGFyYW1zLndpZHRoICE9IG51bGwgPyBwYXJhbXMud2lkdGggOiBvbGRXaWR0aDtcbiAgcGFyYW1zLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgIT0gbnVsbCA/IHBhcmFtcy5oZWlnaHQgOiBvbGRIZWlnaHQ7XG4gIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCAhPSBudWxsID9cbiAgICBwYXJhbXMucHJvamVjdGlvbkNlbnRlclggOiBvbGRQcm9qZWN0aW9uQ2VudGVyWDtcbiAgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA6IG9sZFByb2plY3Rpb25DZW50ZXJZO1xuXG4gIC8vIEFwcGx5IHZpZXcgbGltaXRpbmcgd2hlbiBkZWZpbmVkLlxuICBpZiAodGhpcy5fbGltaXRlcikge1xuICAgIHBhcmFtcyA9IHRoaXMuX2xpbWl0ZXIocGFyYW1zKTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgdmlldyBsaW1pdGVyJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gIHBhcmFtcyA9IHRoaXMuX25vcm1hbGl6ZShwYXJhbXMpO1xuXG4gIC8vIEdyYWIgdGhlIGxpbWl0ZWQgcGFyYW1ldGVycy5cbiAgdmFyIG5ld1lhdyA9IHBhcmFtcy55YXc7XG4gIHZhciBuZXdQaXRjaCA9IHBhcmFtcy5waXRjaDtcbiAgdmFyIG5ld1JvbGwgPSBwYXJhbXMucm9sbDtcbiAgdmFyIG5ld0ZvdiA9IHBhcmFtcy5mb3Y7XG4gIHZhciBuZXdXaWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgdmFyIG5ld0hlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gIHZhciBuZXdQcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWDtcbiAgdmFyIG5ld1Byb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZO1xuXG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrLlxuICBpZiAoIXJlYWwobmV3WWF3KSB8fCAhcmVhbChuZXdQaXRjaCkgfHwgIXJlYWwobmV3Um9sbCkgfHxcbiAgICAgICFyZWFsKG5ld0ZvdikgfHwgIXJlYWwobmV3V2lkdGgpIHx8ICFyZWFsKG5ld0hlaWdodCkgfHxcbiAgICAgICFyZWFsKG5ld1Byb2plY3Rpb25DZW50ZXJYKSB8fCAhcmVhbChuZXdQcm9qZWN0aW9uQ2VudGVyWSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB2aWV3IC0gc3VzcGVjdCBhIGJyb2tlbiBsaW1pdGVyJyk7XG4gIH1cblxuICAvLyBVcGRhdGUgcGFyYW1ldGVycy5cbiAgdGhpcy5feWF3ID0gbmV3WWF3O1xuICB0aGlzLl9waXRjaCA9IG5ld1BpdGNoO1xuICB0aGlzLl9yb2xsID0gbmV3Um9sbDtcbiAgdGhpcy5fZm92ID0gbmV3Rm92O1xuICB0aGlzLl93aWR0aCA9IG5ld1dpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYID0gbmV3UHJvamVjdGlvbkNlbnRlclg7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZID0gbmV3UHJvamVjdGlvbkNlbnRlclk7XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcGFyYW1ldGVycyBjaGFuZ2VkIGFuZCBlbWl0IHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cbiAgaWYgKG5ld1lhdyAhPT0gb2xkWWF3IHx8IG5ld1BpdGNoICE9PSBvbGRQaXRjaCB8fCBuZXdSb2xsICE9PSBvbGRSb2xsIHx8XG4gICAgICBuZXdGb3YgIT09IG9sZEZvdiB8fCBuZXdXaWR0aCAhPT0gb2xkV2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBvbGRIZWlnaHQgfHxcbiAgICAgIG5ld1Byb2plY3Rpb25DZW50ZXJYICE9PSBvbGRQcm9qZWN0aW9uQ2VudGVyWCB8fFxuICAgICAgbmV3UHJvamVjdGlvbkNlbnRlclkgIT09IG9sZFByb2plY3Rpb25DZW50ZXJZKSB7XG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbiAgaWYgKG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG4gIH1cblxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9ub3JtYWxpemUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuICB0aGlzLl9ub3JtYWxpemVDb29yZGluYXRlcyhwYXJhbXMpO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IG5laXRoZXIgdGhlIGhvcml6b250YWwgbm9yIHRoZSB2ZXJ0aWNhbCBmaWVsZHMgb2Ygdmlld1xuICAvLyBleGNlZWQgz4AgLSBmb3ZMaW1pdEVwc2lsb24uXG4gIHZhciBoZm92UGkgPSBjb252ZXJ0Rm92Lmh0b3YoTWF0aC5QSSwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgdmFyIG1heEZvdiA9IGlzTmFOKGhmb3ZQaSkgPyBNYXRoLlBJIDogTWF0aC5taW4oTWF0aC5QSSwgaGZvdlBpKTtcbiAgcGFyYW1zLmZvdiA9IGNsYW1wKHBhcmFtcy5mb3YsIGZvdkxpbWl0RXBzaWxvbiwgbWF4Rm92IC0gZm92TGltaXRFcHNpbG9uKTtcblxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9ub3JtYWxpemVDb29yZGluYXRlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAvLyBDb25zdHJhaW4geWF3LCBwaXRjaCBhbmQgcm9sbCB0byB0aGUgWy3PgCwgz4BdIGludGVydmFsLlxuICBpZiAoJ3lhdycgaW4gcGFyYW1zKSB7XG4gICAgcGFyYW1zLnlhdyA9IG1vZChwYXJhbXMueWF3IC0gTWF0aC5QSSwgLTIqTWF0aC5QSSkgKyBNYXRoLlBJO1xuICB9XG4gIGlmICgncGl0Y2gnIGluIHBhcmFtcykge1xuICAgIHBhcmFtcy5waXRjaCA9IG1vZChwYXJhbXMucGl0Y2ggLSBNYXRoLlBJLCAtMipNYXRoLlBJKSArIE1hdGguUEk7XG4gIH1cbiAgaWYgKCdyb2xsJyBpbiBwYXJhbXMpIHtcbiAgICBwYXJhbXMucm9sbCA9IG1vZChwYXJhbXMucm9sbCAtIE1hdGguUEksIC0yKk1hdGguUEkpICsgTWF0aC5QSTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuXG4vKipcbiAqIE5vcm1hbGl6ZSB2aWV3IGNvb3JkaW5hdGVzIHNvIHRoYXQgdGhleSBhcmUgdGhlIGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnQgdmlldy5cbiAqIFVzZWZ1bCBmb3IgdHdlZW5pbmcgdGhlIHZpZXcgdGhyb3VnaCB0aGUgc2hvcnRlc3QgcGF0aC4gSWYgYSByZXN1bHQgYXJndW1lbnRcbiAqIGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aCB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoXG4gKiBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc30gY29vcmRzIFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgbm9ybWFsaXplZFxuICogICAgIHZpZXcgY29vcmRpbmF0ZXMuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUubm9ybWFsaXplVG9DbG9zZXN0ID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcblxuICB2YXIgdmlld1lhdyA9IHRoaXMuX3lhdztcbiAgdmFyIHZpZXdQaXRjaCA9IHRoaXMuX3BpdGNoO1xuXG4gIHZhciBjb29yZFlhdyA9IGNvb3Jkcy55YXc7XG4gIHZhciBjb29yZFBpdGNoID0gY29vcmRzLnBpdGNoO1xuXG4gIC8vIENoZWNrIGlmIHRoZSB5YXcgaXMgY2xvc2VyIGFmdGVyIHN1YnRyYWN0aW5nIG9yIGFkZGluZyBhIGZ1bGwgY2lyY2xlLlxuICB2YXIgcHJldllhdyA9IGNvb3JkWWF3IC0gMipNYXRoLlBJO1xuICB2YXIgbmV4dFlhdyA9IGNvb3JkWWF3ICsgMipNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMocHJldllhdyAtIHZpZXdZYXcpIDwgTWF0aC5hYnMoY29vcmRZYXcgLSB2aWV3WWF3KSkge1xuICAgIGNvb3JkWWF3ID0gcHJldllhdztcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyhuZXh0WWF3IC0gdmlld1lhdykgPCBNYXRoLmFicyhjb29yZFlhdyAtIHZpZXdZYXcpKSB7XG4gICAgY29vcmRZYXcgPSBuZXh0WWF3O1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHBpdGNoIGlzIGNsb3NlciBhZnRlciBzdWJ0cmFjdGluZyBvciBhZGRpbmcgYSBmdWxsIGNpcmNsZS5cbiAgdmFyIHByZXZQaXRjaCA9IGNvb3JkUGl0Y2ggLSAyKk1hdGguUEk7XG4gIHZhciBuZXh0UGl0Y2ggPSBjb29yZFBpdGNoICsgMipNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMocHJldlBpdGNoIC0gdmlld1BpdGNoKSA8IE1hdGguYWJzKGNvb3JkUGl0Y2ggLSB2aWV3UGl0Y2gpKSB7XG4gICAgY29vcmRQaXRjaCA9IHByZXZQaXRjaDtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyhwcmV2UGl0Y2ggLSB2aWV3UGl0Y2gpIDwgTWF0aC5hYnMoY29vcmRQaXRjaCAtIHZpZXdQaXRjaCkpIHtcbiAgICBjb29yZFBpdGNoID0gbmV4dFBpdGNoO1xuICB9XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IHt9O1xuICByZXN1bHQueWF3ID0gY29vcmRZYXc7XG4gIHJlc3VsdC5waXRjaCA9IGNvb3JkUGl0Y2g7XG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS51cGRhdGVXaXRoQ29udHJvbFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gIC8vIGF4aXNTY2FsZWRYIGFuZCBheGlzU2NhbGVkWSBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBvd24gYXhpc1xuICAvLyB4IGFuZCB5IGFyZSBzY2FsZWQgYnkgdGhlIHNhbWUgdmFsdWVcblxuICAvLyBJZiB0aGUgdmlld3BvcnQgZGltZW5zaW9ucyBhcmUgemVybywgYXNzdW1lIGEgc3F1YXJlIHZpZXdwb3J0XG4gIC8vIHdoZW4gY29udmVydGluZyBmcm9tIGhmb3YgdG8gdmZvdi5cbiAgdmFyIHZmb3YgPSB0aGlzLl9mb3Y7XG4gIHZhciBoZm92ID0gY29udmVydEZvdi52dG9oKHZmb3YsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICBpZiAoaXNOYU4oaGZvdikpIHtcbiAgICBoZm92ID0gdmZvdjtcbiAgfVxuXG4gIC8vIFRPRE86IHJldmlzaXQgdGhpcyBhZnRlciB3ZSByZXRoaW5rIHRoZSBjb250cm9sIHBhcmFtZXRlcnMuXG4gIHRoaXMub2Zmc2V0WWF3KHBhcmFtZXRlcnMuYXhpc1NjYWxlZFggKiBoZm92ICsgcGFyYW1ldGVycy54ICogMiAqIGhmb3YgKyBwYXJhbWV0ZXJzLnlhdyk7XG4gIHRoaXMub2Zmc2V0UGl0Y2gocGFyYW1ldGVycy5heGlzU2NhbGVkWSAqIHZmb3YgKyBwYXJhbWV0ZXJzLnkgKiAyICogaGZvdiArIHBhcmFtZXRlcnMucGl0Y2gpO1xuICB0aGlzLm9mZnNldFJvbGwoLXBhcmFtZXRlcnMucm9sbCk7XG4gIHRoaXMub2Zmc2V0Rm92KHBhcmFtZXRlcnMuem9vbSAqIHZmb3YpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl91cGRhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcm9qTWF0cml4ID0gdGhpcy5fcHJvak1hdHJpeDtcbiAgdmFyIGludlByb2pNYXRyaXggPSB0aGlzLl9pbnZQcm9qTWF0cml4O1xuICB2YXIgZnJ1c3R1bSA9IHRoaXMuX2ZydXN0dW07XG5cbiAgaWYgKHRoaXMuX3Byb2plY3Rpb25DaGFuZ2VkKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAgIHZhciB2Zm92ID0gdGhpcy5fZm92O1xuICAgIHZhciBoZm92ID0gY29udmVydEZvdi52dG9oKHZmb3YsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcblxuICAgIHZhciBwcm9qZWN0aW9uQ2VudGVyWCA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xuICAgIHZhciBwcm9qZWN0aW9uQ2VudGVyWSA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZO1xuXG4gICAgaWYgKHByb2plY3Rpb25DZW50ZXJYICE9PSAwIHx8IHByb2plY3Rpb25DZW50ZXJZICE9PSAwKSB7XG4gICAgICB2YXIgb2Zmc2V0QW5nbGVYID0gTWF0aC5hdGFuKHByb2plY3Rpb25DZW50ZXJYICogMiAqIE1hdGgudGFuKGhmb3YvMikpO1xuICAgICAgdmFyIG9mZnNldEFuZ2xlWSA9IE1hdGguYXRhbihwcm9qZWN0aW9uQ2VudGVyWSAqIDIgKiBNYXRoLnRhbih2Zm92LzIpKTtcbiAgICAgIHZhciBmb3ZzID0gdGhpcy5fZm92cztcbiAgICAgIGZvdnMubGVmdERlZ3JlZXMgPSAoaGZvdi8yICsgb2Zmc2V0QW5nbGVYKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy5yaWdodERlZ3JlZXMgPSAoaGZvdi8yIC0gb2Zmc2V0QW5nbGVYKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy51cERlZ3JlZXMgPSAodmZvdi8yICsgb2Zmc2V0QW5nbGVZKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy5kb3duRGVncmVlcyA9ICh2Zm92LzIgLSBvZmZzZXRBbmdsZVkpICogMTgwL01hdGguUEk7XG4gICAgICBtYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KHByb2pNYXRyaXgsIGZvdnMsIC0xLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0NC5wZXJzcGVjdGl2ZShwcm9qTWF0cml4LCB2Zm92LCBhc3BlY3QsIC0xLCAxKTtcbiAgICB9XG5cbiAgICBtYXQ0LnJvdGF0ZVoocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGhpcy5fcm9sbCk7XG4gICAgbWF0NC5yb3RhdGVYKHByb2pNYXRyaXgsIHByb2pNYXRyaXgsIHRoaXMuX3BpdGNoKTtcbiAgICBtYXQ0LnJvdGF0ZVkocHJvak1hdHJpeCwgcHJvak1hdHJpeCwgdGhpcy5feWF3KTtcblxuICAgIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIHByb2pNYXRyaXgpO1xuXG4gICAgdGhpcy5fbWF0cml4VG9GcnVzdHVtKHByb2pNYXRyaXgsIGZydXN0dW0pO1xuXG4gICAgdGhpcy5fcHJvamVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9tYXRyaXhUb0ZydXN0dW0gPSBmdW5jdGlvbihwLCBmKSB7XG4gIC8vIEV4dHJhY3QgZnJ1c3R1bSBwbGFuZXMgZnJvbSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgLy8gaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTEvSFQxMi9sYWIvcGxhbmVfZXh0cmFjdGlvbi5wZGZcbiAgdmVjNC5zZXQoZlswXSwgcFszXSArIHBbMF0sIHBbN10gKyBwWzRdLCBwWzExXSArIHBbOF0sICAwKTsgLy8gbGVmdFxuICB2ZWM0LnNldChmWzFdLCBwWzNdIC0gcFswXSwgcFs3XSAtIHBbNF0sIHBbMTFdIC0gcFs4XSwgIDApOyAvLyByaWdodFxuICB2ZWM0LnNldChmWzJdLCBwWzNdICsgcFsxXSwgcFs3XSArIHBbNV0sIHBbMTFdICsgcFs5XSwgIDApOyAvLyB0b3BcbiAgdmVjNC5zZXQoZlszXSwgcFszXSAtIHBbMV0sIHBbN10gLSBwWzVdLCBwWzExXSAtIHBbOV0sICAwKTsgLy8gYm90dG9tXG4gIHZlYzQuc2V0KGZbNF0sIHBbM10gKyBwWzJdLCBwWzddICsgcFs2XSwgcFsxMV0gKyBwWzEwXSwgMCk7IC8vIGNhbWVyYVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG4gIHJldHVybiB0aGlzLl9wcm9qTWF0cml4O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcmV0dXJucyB7bWF0NH1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5pbnZlcnNlUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG4gIHJldHVybiB0aGlzLl9pbnZQcm9qTWF0cml4O1xufTtcblxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSB2aWV3IGZydXN0dW0gaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF5IHJldHVybiBmYWxzZSBwb3NpdGl2ZXMsIGJ1dCBuZXZlciBmYWxzZSBuZWdhdGl2ZXMuXG4gKiBJdCBpcyB1c2VkIGZvciBmcnVzdHVtIGN1bGxpbmcsIGkuZS4sIGV4Y2x1ZGluZyBpbnZpc2libGUgdGlsZXMgZnJvbSB0aGVcbiAqIHJlbmRlcmluZyBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7dmVjMltdfSByZWN0YW5nbGUgVGhlIHZlcnRpY2VzIG9mIHRoZSByZWN0YW5nbGUuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG5cbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuICB2YXIgdmVydGV4ID0gdGhpcy5fdG1wVmVjO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiBhbnkgb2YgdGhlIGZydXN0dW1cbiAgLy8gcGxhbmVzLiBUaGlzIGlzIGEgc3VmZmljaWVudCBjb25kaXRpb24sIHRob3VnaCBub3QgbmVjZXNzYXJ5LCBmb3IgdGhlXG4gIC8vIHJlY3RhbmdsZSB0byBiZSBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIGZydXN0dW0uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJ1c3R1bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFuZSA9IGZydXN0dW1baV07XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVjdGFuZ2xlLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY29ybmVyID0gcmVjdGFuZ2xlW2pdO1xuICAgICAgdmVjNC5zZXQodmVydGV4LCBjb3JuZXJbMF0sIGNvcm5lclsxXSwgY29ybmVyWzJdLCAwKTtcbiAgICAgIGlmICh2ZWM0LmRvdChwbGFuZSwgdmVydGV4KSA+PSAwKSB7XG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdCB0aGUgbGV2ZWwgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIHZpZXcuXG4gKiBAcGFyYW0ge0xldmVsW119IGxldmVsTGlzdCB0aGUgbGlzdCBvZiBsZXZlbHMgZnJvbSB3aGljaCB0byBzZWxlY3QuXG4gKiBAcmV0dXJuIHtMZXZlbH0gdGhlIHNlbGVjdGVkIGxldmVsLlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNlbGVjdExldmVsID0gZnVuY3Rpb24obGV2ZWxMaXN0KSB7XG5cbiAgLy8gTXVsdGlwbHkgdGhlIHZpZXdwb3J0IHdpZHRoIGJ5IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8gdG8gZ2V0IHRoZSByZXF1aXJlZFxuICAvLyBob3Jpem9udGFsIHJlc29sdXRpb24gaW4gcGl4ZWxzLlxuICAvL1xuICAvLyBDYWxjdWxhdGUgdGhlIGZyYWN0aW9uIG9mIGEgY3ViZSBmYWNlIHRoYXQgd291bGQgYmUgdmlzaWJsZSBnaXZlbiB0aGVcbiAgLy8gY3VycmVudCB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LiBUaGVuLCBmb3IgZWFjaCBsZXZlbCwgbXVsdGlwbHkgYnkgdGhlXG4gIC8vIGxldmVsIGhlaWdodCB0byBnZXQgdGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIHBvcnRpb24gdGhhdCB3b3VsZCBiZVxuICAvLyB2aXNpYmxlLlxuICAvL1xuICAvLyBTZWFyY2ggZm9yIHRoZSBzbWFsbGVzdCBsZXZlbCB0aGF0IHNhdGlmaWVzIHRoZSB0aGUgcmVxdWlyZWQgaGVpZ2h0LFxuICAvLyBmYWxsaW5nIGJhY2sgb24gdGhlIGxhcmdlc3QgbGV2ZWwgaWYgbm9uZSBkby5cblxuICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiB0aGlzLl9oZWlnaHQ7XG4gIHZhciBjb3ZlckZhY3RvciA9IE1hdGgudGFuKDAuNSAqIHRoaXMuX2Zvdik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbExpc3RbaV07XG4gICAgaWYgKGNvdmVyRmFjdG9yICogbGV2ZWwuaGVpZ2h0KCkgPj0gcmVxdWlyZWRQaXhlbHMpIHtcbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV2ZWxMaXN0W2xldmVsTGlzdC5sZW5ndGggLSAxXTtcblxufTtcblxuXG4vKipcbiAqIENvbnZlcnQgdmlldyBwYXJhbWV0ZXJzIGludG8gc2NyZWVuIHBvc2l0aW9uLiBJZiBhIHJlc3VsdCBhcmd1bWVudCBpc1xuICogcHJvdmlkZWQsIGl0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkXG4gKiBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Q29vcmRzPX0gcmVzdWx0IFRoZSByZXN1bHQgYXJndW1lbnQgZm9yIHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtDb29yZHN9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZXNUb1NjcmVlbiA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl90bXBWZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIFVuZGVmaW5lZCBvbiBhIG51bGwgdmlld3BvcnQuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgcmVzdWx0LnggPSBudWxsO1xuICAgIHJlc3VsdC55ID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdmlldyByYXkgcG9pbnRpbmcgaW50byB0aGUgKHlhdywgcGl0Y2gpIGRpcmVjdGlvbi5cbiAgdmFyIHlhdyA9IGNvb3Jkcy55YXc7XG4gIHZhciBwaXRjaCA9IGNvb3Jkcy5waXRjaDtcbiAgdmFyIHggPSBNYXRoLnNpbih5YXcpICogTWF0aC5jb3MocGl0Y2gpO1xuICB2YXIgeSA9IC1NYXRoLnNpbihjb29yZHMucGl0Y2gpO1xuICB2YXIgeiA9IC1NYXRoLmNvcyh5YXcpICogTWF0aC5jb3MocGl0Y2gpO1xuICB2ZWM0LnNldChyYXksIHgsIHksIHosIDEpO1xuXG4gIC8vIFByb2plY3QgdmlldyByYXkgb250byBjbGlwIHNwYWNlLlxuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMucHJvamVjdGlvbigpKTtcblxuICAvLyB3IGluIGNsaXAgc3BhY2UgZXF1YWxzIC16IGluIGNhbWVyYSBzcGFjZS5cbiAgaWYgKHJheVszXSA+PSAwKSB7XG4gICAgLy8gUG9pbnQgaXMgaW4gZnJvbnQgb2YgY2FtZXJhLlxuICAgIC8vIENvbnZlcnQgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMuXG4gICAgcmVzdWx0LnggPSB3aWR0aCAqIChyYXlbMF0gLyByYXlbM10gKyAxKSAvIDI7XG4gICAgcmVzdWx0LnkgPSBoZWlnaHQgKiAoMSAtIHJheVsxXSAvIHJheVszXSkgLyAyO1xuICB9IGVsc2Uge1xuICAgIC8vIFBvaW50IGlzIGJlaGluZCBjYW1lcmEuXG4gICAgcmVzdWx0LnggPSBudWxsO1xuICAgIHJlc3VsdC55ID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQ29udmVydCBzY3JlZW4gY29vcmRpbmF0ZXMgaW50byB2aWV3IGNvb3JkaW5hdGVzLiBJZiBhIHJlc3VsdCBhcmd1bWVudCBpc1xuICogcHJvdmlkZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZSByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2hcbiAqIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7Q29vcmRzfSBjb29yZHMgVGhlIHNjcmVlbiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzPX0gcmVzdWx0IFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNjcmVlblRvQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihjb29yZHMsIHJlc3VsdCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdG1wVmVjO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH1cblxuICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBDb252ZXJ0IHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIGNsaXAgc3BhY2UuXG4gIHZhciB2ZWN4ID0gMiAqIGNvb3Jkcy54IC8gd2lkdGggLSAxO1xuICB2YXIgdmVjeSA9IDEgLSAyICogY29vcmRzLnkgLyBoZWlnaHQ7XG4gIHZlYzQuc2V0KHJheSwgdmVjeCwgdmVjeSwgMSwgMSk7XG5cbiAgLy8gUHJvamVjdCBiYWNrIHRvIHdvcmxkIHNwYWNlLlxuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMuaW52ZXJzZVByb2plY3Rpb24oKSk7XG5cbiAgLy8gQ29udmVydCB0byBzcGhlcmljYWwgY29vcmRpbmF0ZXMuXG4gIHZhciByID0gTWF0aC5zcXJ0KHJheVswXSAqIHJheVswXSArIHJheVsxXSAqIHJheVsxXSArIHJheVsyXSAqIHJheVsyXSk7XG4gIHJlc3VsdC55YXcgPSBNYXRoLmF0YW4yKHJheVswXSwgLXJheVsyXSk7XG4gIHJlc3VsdC5waXRjaCA9IE1hdGguYWNvcyhyYXlbMV0gLyByKSAtIE1hdGguUEkvMjtcblxuICB0aGlzLl9ub3JtYWxpemVDb29yZGluYXRlcyhyZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gcmVxdWlyZWQgdG8gcG9zaXRpb24gYW4gZWxlbWVudCB3aXRoXG4gKiBwZXJzcGVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc30gY29vcmRzIFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHNwaGVyZSBlbWJlZGRpbmcgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXh0cmFUcmFuc2Zvcm1zIEV4dHJhIHRyYW5zZm9ybWF0aW9ucyB0byBiZSBhcHBsaWVkIGFmdGVyXG4gKiAgICAgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZC4gVGhpcyBtYXkgYmUgdXNlZCB0byByb3RhdGUgdGhlIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBDU1MgM0QgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZXNUb1BlcnNwZWN0aXZlVHJhbnNmb3JtID0gZnVuY3Rpb24oXG4gICAgY29vcmRzLCByYWRpdXMsIGV4dHJhVHJhbnNmb3Jtcykge1xuICBleHRyYVRyYW5zZm9ybXMgPSBleHRyYVRyYW5zZm9ybXMgfHwgXCJcIjtcblxuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIGZvdiA9IHRoaXMuX2ZvdjtcbiAgdmFyIHBlcnNwZWN0aXZlID0gMC41ICogaGVpZ2h0IC8gTWF0aC50YW4oZm92IC8gMik7XG5cbiAgdmFyIHRyYW5zZm9ybSA9ICcnO1xuXG4gIC8vIENlbnRlciBob3RzcG90IGluIHNjcmVlbi5cbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVYKCcgKyBkZWNpbWFsKHdpZHRoLzIpICsgJ3B4KSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVkoJyArIGRlY2ltYWwoaGVpZ2h0LzIpICsgJ3B4KSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSAnO1xuXG4gIC8vIFNldCB0aGUgcGVyc3BlY3RpdmUgZGVwdGguXG4gIHRyYW5zZm9ybSArPSAncGVyc3BlY3RpdmUoJyArIGRlY2ltYWwocGVyc3BlY3RpdmUpICsgJ3B4KSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVooJyArIGRlY2ltYWwocGVyc3BlY3RpdmUpICsgJ3B4KSAnO1xuXG4gIC8vIFNldCB0aGUgY2FtZXJhIHJvdGF0aW9uLlxuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVooJyArIGRlY2ltYWwoLXRoaXMuX3JvbGwpICsgJ3JhZCkgJztcbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVYKCcgKyBkZWNpbWFsKC10aGlzLl9waXRjaCkgKyAncmFkKSAnO1xuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVkoJyArIGRlY2ltYWwodGhpcy5feWF3KSArICdyYWQpICc7XG5cbiAgLy8gU2V0IHRoZSBob3RzcG90IHJvdGF0aW9uLlxuICB0cmFuc2Zvcm0gKz0gJ3JvdGF0ZVkoJyArIGRlY2ltYWwoLWNvb3Jkcy55YXcpICsgJ3JhZCkgJztcbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVYKCcgKyBkZWNpbWFsKGNvb3Jkcy5waXRjaCkgKyAncmFkKSAnO1xuXG4gIC8vIE1vdmUgYmFjayB0byBzcGhlcmUuXG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWignICsgZGVjaW1hbCgtcmFkaXVzKSArICdweCkgJztcblxuICAvLyBBcHBseSB0aGUgZXh0cmEgdHJhbnNmb3JtYXRpb25zXG4gIHRyYW5zZm9ybSArPSBleHRyYVRyYW5zZm9ybXMgKyAnICc7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn07XG5cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9ucyBmb3IgdmlldyBsaW1pdGVycy4gU2VlIHtAbGluayBSZWN0aWxpbmVhclZpZXdMaW1pdGVyfS5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LmxpbWl0ID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgeWF3IGFuZ2xlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHlhdyB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB5YXcgdmFsdWUuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICB5YXc6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0WWF3KHBhcmFtcykge1xuICAgICAgcGFyYW1zLnlhdyA9IGNsYW1wKHBhcmFtcy55YXcsIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHBpdGNoIGFuZ2xlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBpdGNoIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBpdGNoIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcGl0Y2g6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0UGl0Y2gocGFyYW1zKSB7XG4gICAgICBwYXJhbXMucGl0Y2ggPSBjbGFtcChwYXJhbXMucGl0Y2gsIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHJvbGwgYW5nbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcm9sbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSByb2xsIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcm9sbDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRSb2xsKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnJvbGwgPSBjbGFtcChwYXJhbXMucm9sbCwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIGhvcml6b250YWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICBoZm92OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdEhmb3YocGFyYW1zKSB7XG4gICAgICB2YXIgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgICB2YXIgdm1pbiA9IGNvbnZlcnRGb3YuaHRvdihtaW4sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgdm1heCA9IGNvbnZlcnRGb3YuaHRvdihtYXgsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwYXJhbXMuZm92ID0gY2xhbXAocGFyYW1zLmZvdiwgdm1pbiwgdm1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmVydGljYWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHZmb3Y6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0VmZvdihwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5mb3YgPSBjbGFtcChwYXJhbXMuZm92LCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBwcmV2ZW50cyB6b29taW5nIGluIGJleW9uZCB0aGUgZ2l2ZW5cbiAgICogcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIGN1YmUgZmFjZSB3aWR0aCBpbiBwaXhlbHMgb3IsIGVxdWl2YWxlbnRseSwgb25lXG4gICAqICAgICBmb3VydGggb2YgdGhlIGVxdWlyZWN0YW5ndWxhciB3aWR0aCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICByZXNvbHV0aW9uOiBmdW5jdGlvbihzaXplKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0UmVzb2x1dGlvbihwYXJhbXMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICB2YXIgcmVxdWlyZWRQaXhlbHMgPSBwaXhlbFJhdGlvKCkgKiBoZWlnaHQ7XG4gICAgICAgIHZhciBtaW5Gb3YgPSAyICogTWF0aC5hdGFuKHJlcXVpcmVkUGl4ZWxzIC8gc2l6ZSk7XG4gICAgICAgIHBhcmFtcy5mb3YgPSBjbGFtcChwYXJhbXMuZm92LCBtaW5Gb3YsIEluZmluaXR5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGxpbWl0cyB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZmllbGQgb2ZcbiAgICogdmlldywgcHJldmVudHMgem9vbWluZyBpbiBwYXN0IHRoZSBpbWFnZSByZXNvbHV0aW9uLCBhbmQgbGltaXRzIHRoZSBwaXRjaFxuICAgKiByYW5nZSB0byBwcmV2ZW50IHRoZSBjYW1lcmEgd3JhcHBpbmcgYXJvdW5kIGF0IHRoZSBwb2xlcy4gVGhlc2UgYXJlIHRoZVxuICAgKiBtb3N0IGNvbW1vbiB2aWV3IGNvbnN0cmFpbnRzIGZvciBhIDM2MMKwIHBhbm9yYW1hLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBUaGUgY3ViZSBmYWNlIHdpZHRoIGluIHBpeGVscyBvcixcbiAgICogICAgIGVxdWl2YWxlbnRseSwgb25lIGZvdXJ0aCBvZiB0aGUgZXF1aXJlY3Rhbmd1bGFyIHdpZHRoIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFZGb3YgVGhlIG1heGltdW0gdmVydGljYWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhIRm92PW1heFZGb3ZdIFRoZSBtYXhpbXVtIGhvcml6b250YWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHRyYWRpdGlvbmFsOiBmdW5jdGlvbihtYXhSZXNvbHV0aW9uLCBtYXhWRm92LCBtYXhIRm92KSB7XG4gICAgbWF4SEZvdiA9IG1heEhGb3YgIT0gbnVsbCA/IG1heEhGb3YgOiBtYXhWRm92O1xuXG4gICAgcmV0dXJuIGNvbXBvc2UoXG4gICAgICBSZWN0aWxpbmVhclZpZXcubGltaXQucmVzb2x1dGlvbihtYXhSZXNvbHV0aW9uKSxcbiAgICAgIFJlY3RpbGluZWFyVmlldy5saW1pdC52Zm92KDAsIG1heFZGb3YpLFxuICAgICAgUmVjdGlsaW5lYXJWaWV3LmxpbWl0Lmhmb3YoMCwgbWF4SEZvdiksXG4gICAgICBSZWN0aWxpbmVhclZpZXcubGltaXQucGl0Y2goLU1hdGguUEkvMiwgTWF0aC5QSS8yKSk7XG4gIH1cblxufTtcblxuXG5SZWN0aWxpbmVhclZpZXcudHlwZSA9IFJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUudHlwZSA9ICdyZWN0aWxpbmVhcic7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0aWxpbmVhclZpZXc7XG4iXX0=
